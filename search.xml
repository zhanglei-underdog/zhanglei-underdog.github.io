<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>同步、异步FIFO设计与仿真</title>
      <link href="/2022/09/08/%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5FIFO%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%BF%E7%9C%9F/"/>
      <url>/2022/09/08/%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5FIFO%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BB%BF%E7%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="同步FIFO设计与仿真"><a href="#同步FIFO设计与仿真" class="headerlink" title="同步FIFO设计与仿真"></a>同步FIFO设计与仿真</h1><h2 id="双端口RAM-设计"><a href="#双端口RAM-设计" class="headerlink" title="双端口RAM 设计"></a>双端口RAM 设计</h2><p>思路总结：先定义一个双端口RAM模块用于存储数据和写入数据。</p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220907222834289.png" alt="image-20220907222834289"></p><p>大型RAM需要调用相关IP。小项目中的双端口RAM的实现是基于<code>reg[RAM_WIDTH-1:0] memory[RAM_DEPTH-1:0]</code>进行操作，主要思路是通过读写指针，这里的地址指针其实是循环指针，因为到了最高位之后，它会溢出返回到起始位置。在这个过程当中我们有两种方式进行判断RAM是否已满。方法一：通常都计数器<code>fcount</code>进行计数，执行写操作是<code>fcount</code>加1，执行读操作时<code>fcount</code>减1。 方法二：地址位扩展一位，用最高位来判断空满。这里采用的是方法一。具体RTL编码如下：</p><p>其实如果真正在笔试中，从新定义一个RAM module确实很浪费时间，可以之间再fifo中利用<code>reg[RAM_WIDTH-1:0] memory[RAM_DEPTH-1:0]</code>进行形象替代。</p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220907223724952.png" alt="image-20220907223724952"></p><h2 id="基于双端口RAM，定义同步FIFO"><a href="#基于双端口RAM，定义同步FIFO" class="headerlink" title="基于双端口RAM，定义同步FIFO"></a>基于双端口RAM，定义同步FIFO</h2><p>然后再写一个同步FIFO模块，包住RAM，FIFO所有的存数据、取数据均在RAM中进行。FIFO需要满足的主要条件是 <code>满不能写，空不能读</code>，根据这个原则，来产生我们<code>empty</code>信号和<code>full</code>信号。</p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220907230056584.png" alt="image-20220907230056584"></p><p> 具体的RTL编码如下</p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220907225427890.png" alt="image-20220907225427890"></p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220907225441519.png" alt="image-20220907225441519"></p><h2 id="testbench编写"><a href="#testbench编写" class="headerlink" title="testbench编写"></a>testbench编写</h2><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220907230441717.png" alt="image-20220907230441717"></p><h2 id="仿真波形"><a href="#仿真波形" class="headerlink" title="仿真波形"></a>仿真波形</h2><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220907230530110.png" alt="image-20220907230530110"></p><p>波形分析，由于write_enable和read_enable持续时间较长，会导致在这两个信号有效期间多次进行读写。波形产出结果符合预期。</p><h1 id="异步FIFO设计仿真"><a href="#异步FIFO设计仿真" class="headerlink" title="异步FIFO设计仿真"></a>异步FIFO设计仿真</h1><ul><li>异步FIFO指的时读时钟域和写时钟域的时钟频率不一样</li><li>判满条件选取的是扩展地址位的方法</li><li>与同步FIFO拓展地址位的不同有两点：1：使用格雷码，作为实际数据存取地址。 2：在读时钟有效时，采样写时钟域的写地址、在写时钟有效时，采样读时钟域的读地址，这样主要是为了后续进行判空和判满。</li><li>格雷码求取方式 <code>gray = (in&gt;&gt;1)^in</code></li></ul><h2 id="深度2048-宽度-16bit的异步FIFO-RTL编码"><a href="#深度2048-宽度-16bit的异步FIFO-RTL编码" class="headerlink" title="深度2048 宽度 16bit的异步FIFO RTL编码"></a>深度2048 宽度 16bit的异步FIFO RTL编码</h2><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220908115053188.png" alt="image-20220908115053188"></p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220908115116763.png" alt="image-20220908115116763"></p><h2 id="testbench-编写"><a href="#testbench-编写" class="headerlink" title="testbench 编写"></a>testbench 编写</h2><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220908115312144.png" alt="image-20220908115312144"></p><h2 id="仿真波形-1"><a href="#仿真波形-1" class="headerlink" title="仿真波形"></a>仿真波形</h2><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220908114245036.png" alt="image-20220908114245036"></p>]]></content>
      
      
      <categories>
          
          <category> Verilog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FIFO设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态机设计及仿真</title>
      <link href="/2022/09/06/%E7%8A%B6%E6%80%81%E6%9C%BA%E8%AE%BE%E8%AE%A1%E5%8F%8A%E4%BB%BF%E7%9C%9F/"/>
      <url>/2022/09/06/%E7%8A%B6%E6%80%81%E6%9C%BA%E8%AE%BE%E8%AE%A1%E5%8F%8A%E4%BB%BF%E7%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="状态机设计及仿真"><a href="#状态机设计及仿真" class="headerlink" title="状态机设计及仿真"></a>状态机设计及仿真</h1><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220906090339479.png" alt="image-20220906090339479"></p><h1 id="编码仿真1"><a href="#编码仿真1" class="headerlink" title="编码仿真1:"></a><strong>编码仿真1:</strong></h1><p>编写一个自动售货机，功能如下：</p><p>共有三种纸币入口，分别支持10元，20元，50元。货物售价为80元。需要支持找钱功能（注意，找钱有两种情况， 90元和100元；而110元和120元的情况不符合实际应用场景，所以不存在找钱的情况）。</p><p>参照今天讲的自动售饮料机。</p><p>完成RTL编码，完成testbench编码。</p><h2 id="状态转换图"><a href="#状态转换图" class="headerlink" title="状态转换图"></a>状态转换图</h2><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220905235115349.png" alt="image-20220905235115349"></p><h2 id="RTL编码如下"><a href="#RTL编码如下" class="headerlink" title="RTL编码如下"></a>RTL编码如下</h2><p>设计的是<code>moore</code>型状态机，即输出状态与输入状态无关，next的状态转移完全由状态转移图决定。</p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220905235833245.png" alt="image-20220905235833245"></p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220905235901559.png" alt="image-20220905235901559"></p><h2 id="testbench编写如下"><a href="#testbench编写如下" class="headerlink" title="testbench编写如下"></a>testbench编写如下</h2><p>test中只测试了三种情况：</p><p>情况1：连续给8个10元</p><p>情况2： 连续給4个20元</p><p>情况3：连续给两个50元</p><p>经vcs分析后，三种情况的结果均符合预期。</p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220905235439327.png" alt="image-20220905235439327"></p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220905235539217.png" alt="image-20220905235539217"></p><h2 id="仿真测试"><a href="#仿真测试" class="headerlink" title="仿真测试"></a>仿真测试</h2><p> 符合预期<img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220905235251860.png" alt="image-20220905235251860"></p><h1 id="编码仿真2："><a href="#编码仿真2：" class="headerlink" title="编码仿真2："></a>编码仿真2：</h1><p>完成一个序列检测器101011011的序列检测，完成RTL编程，完成testbench的编写，并利用VCS进行仿真。(说明：注意最后一个状态S9的跳转)</p><h2 id="状态编码"><a href="#状态编码" class="headerlink" title="状态编码"></a>状态编码</h2><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220906104801142.png" alt="image-20220906104801142"></p><h2 id="RTL编码"><a href="#RTL编码" class="headerlink" title="RTL编码"></a>RTL编码</h2><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220906111443068.png" alt="image-20220906111443068"></p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220906111515456.png" alt="image-20220906111515456"></p><h2 id="testbench-编写"><a href="#testbench-编写" class="headerlink" title="testbench 编写"></a>testbench 编写</h2><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220906111612098.png" alt="image-20220906111612098"></p><h2 id="仿真测试-1"><a href="#仿真测试-1" class="headerlink" title="仿真测试"></a>仿真测试</h2><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220906104051431.png" alt="image-20220906104051431"></p>]]></content>
      
      
      <categories>
          
          <category> Verilog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状态机设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周赛子数组子序列计数题目</title>
      <link href="/2022/08/07/%E5%91%A8%E8%B5%9B%E5%AD%90%E6%95%B0%E7%BB%84%E5%AD%90%E5%BA%8F%E5%88%97%E8%AE%A1%E6%95%B0%E9%A2%98%E7%9B%AE/"/>
      <url>/2022/08/07/%E5%91%A8%E8%B5%9B%E5%AD%90%E6%95%B0%E7%BB%84%E5%AD%90%E5%BA%8F%E5%88%97%E8%AE%A1%E6%95%B0%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="周赛子数组子序列计数题目记录"><a href="#周赛子数组子序列计数题目记录" class="headerlink" title="周赛子数组子序列计数题目记录"></a>周赛子数组子序列计数题目记录</h1><p>首先求解排列组合的公式，然后再给出两道最近遇到的相关题目，以加深印象。</p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220807083920253.png" alt="image-20220807083920253"></p><h1 id="题目一-统计指定区间内的所有组合数"><a href="#题目一-统计指定区间内的所有组合数" class="headerlink" title="题目一  统计指定区间内的所有组合数"></a>题目一  统计指定区间内的所有组合数</h1><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220807084334275.png" alt="image-20220807084334275"></p><p>根据题意，我们可以分析得出，一个区间<code>[left,right]</code>如果满足统计得分小于 K ,则其所有子数组都满足要求。又因为元素大于零，所以其前缀和单调增，因此我们可以根据滑动窗口，判断窗口区间内是否满足题意。然后进行统计即可。</p><p><span style="color:red;background:white;font-size:20px;font-family:宋体;">这题需要学习的地方是，<code>[left,right]</code>区间内，以right结尾的子数组数组为<code>left ~ right - 1</code>，所以我们在统计<code>[left,right]</code>区间内所有子数组个数时，其实是一个不断累加的过程。</span></p><p>coding如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">countSubarrays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">long</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> ans = <span class="number">0L</span>, sum = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="keyword">while</span> (sum * (right - left + <span class="number">1</span>) &gt;= k) <span class="comment">//找出满足条件的区间</span></span><br><span class="line">                sum -= nums[left++];</span><br><span class="line">            ans += right - left + <span class="number">1</span>; <span class="comment">//不断累加， right之前的子数组个数，已在之前加入了ans,所以这里只用算以right结尾的子数组数组个数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题目二-2元素数组子序列"><a href="#题目二-2元素数组子序列" class="headerlink" title="题目二  2元素数组子序列"></a>题目二  2元素数组子序列</h1><p>该题目的主要思想是：用整个数组所有2元素组合数目 — 不符合题意的题意的2元素组合数目。 该题两个元素之间可以不连续，上题是子数组，元素之间需要连续。</p><p>所以该题，我们统计不符合  <span style="color:red;background:white;font-size:20px;font-family:宋体;"><code>i &lt; j</code> 且 <code>j - i != nums[j] - nums[i]</code></span>的元素个数，然后计算不符合条件的组合总数，最后相减即可。</p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220807090228042.png" alt="image-20220807090228042"></p><p>条件改写：</p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220807090904973.png" alt="image-20220807090904973"></p><p>coding如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">countBadPairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt;map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> count = map.getOrDefault(nums[i]-i,<span class="number">0</span>);</span><br><span class="line">            count+=<span class="number">1</span>;</span><br><span class="line">            map.put(nums[i]-i,count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> len = (<span class="keyword">long</span>)nums.length;</span><br><span class="line">        Long total = len*(len-<span class="number">1</span>)/<span class="number">2</span>; <span class="comment">//整个数组的二元素子序列总数</span></span><br><span class="line">        Set&lt;Integer&gt; set = map.keySet();</span><br><span class="line">        <span class="keyword">long</span> inconformity = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Integer key : set)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">long</span> value = (<span class="keyword">long</span>)map.get(key);</span><br><span class="line">           <span class="comment">// System.out.println(value);</span></span><br><span class="line">            inconformity += value*(value-<span class="number">1</span>)/<span class="number">2</span>; <span class="comment">//不符合条件的二元素子序列总数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total-inconformity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 周赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题复习总结</title>
      <link href="/2022/08/06/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2022/08/06/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="背包问题复习总结"><a href="#背包问题复习总结" class="headerlink" title="背包问题复习总结"></a>背包问题复习总结</h1><p>关于背包一词，也仅仅只是个代名词，没有什么可怕的。它仅仅是表示着某种动态规划状态转移方程的写法，由于该类问题，就像是往一个背包里放东西，寻找放东西的最大价值，所以称其为背包问题。背包问题，同样可以被改写为自顶向下的写法。</p><p>完全背包和0 1背包只是一种形式，在该种形式下会有很多种变型的方式，如</p><ul><li>把背包装满的方式总数，这时候背包必须装满</li><li>背包可以放的最大价值，这时候不一定装满</li></ul><h1 id="0-1-背包"><a href="#0-1-背包" class="headerlink" title="0 1 背包"></a>0 1 背包</h1><p>能装在重量为W的背包、N个物品只能用一次，N个物品分别有着不同的<code>价值</code>和<code>重量</code>。<strong>状态有两个，就是「背包的容量」和「可选择的物品」</strong>，<strong>选择就是「装进背包」或者「不装进背包」</strong></p><p><code>dp</code> 数组的定义：</p><p><span style="color:red;background:white;font-size:20px;font-family:宋体;"><code>dp[i][w]</code> 表示：对于前 <code>i</code> 个物品（从 1 开始计数），当前背包的容量为 <code>w</code> 时，这种情况下可以装下的最大价值是 <code>dp[i][w]</code>。</span></p><p><span style="color:red;background:white;font-size:20px;font-family:宋体;">  <strong>每个物品的数量只能用一次</strong>。 <code>dp[i][j]</code>的状态与<code>dp[i-1][j]</code>和<code>dp[i-1][j-coins[i-1]]</code>有关，体现出0 1 背包思想的是<code>dp[i-1][j-coins[i-1]]</code>，大概意思就是说，如果第i个物品如果想要放进背包，那么他的前任状态就必须去<code>i-1</code>中找，因为 0 1 背包中，<code>i</code>物品只可以放入一次</span></p><p>coding如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> W, <span class="keyword">int</span> N, <span class="keyword">int</span>[] wt, <span class="keyword">int</span>[] val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case 已初始化</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][W + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">1</span>; w &lt;= W; w++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w - wt[i - <span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 这种情况下只能选择不装入背包</span></span><br><span class="line">                dp[i][w] = dp[i - <span class="number">1</span>][w];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 装入或者不装入背包，择优</span></span><br><span class="line">                dp[i][w] = Math.max(</span><br><span class="line">                    dp[i - <span class="number">1</span>][w - wt[i-<span class="number">1</span>]] + val[i-<span class="number">1</span>], </span><br><span class="line">                    dp[i - <span class="number">1</span>][w]</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当然这个0 1 背包问题也是可以改写成 自顶向下的模型</span></span><br></pre></td></tr></table></figure><h1 id="01背包举例"><a href="#01背包举例" class="headerlink" title="01背包举例"></a>01背包举例</h1><p>该题目dp数组的内容做了小小改动，但是总体框架并没变。</p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220806154405036.png" alt="image-20220806154405036"></p><p>当然该题也可以使用自顶向下的动态规划。大事化小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可以使用回溯，也可以使用0 1 背包，</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">2</span>!=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> amount = sum/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> len1 = nums.length;</span><br><span class="line">        <span class="keyword">boolean</span> [][]dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len1+<span class="number">1</span>][amount+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len1+<span class="number">1</span>;i++)</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len1+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;amount+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-nums[i-<span class="number">1</span>]&lt;<span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j] || dp[i-<span class="number">1</span>][j-nums[i-<span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len1][amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h1><p>再次强调背包<code>dp</code>数组的定义：<code>dp[i][w]</code> 表示：对于前 <code>i</code> 个物品（从 1 开始计数），当前背包的容量为 <code>w</code> 时，这种情况下可以装下的最大价值是 <code>dp[i][w]</code>。当然该定义的细节，在实际题目中会发生变化，但是，总体框架就是这样。</p><p><span style="color:red;background:white;font-size:20px;font-family:宋体;">  <strong>每个物品的数量无限</strong>。 <code>dp[i][j]</code>的状态与<code>dp[i-1][j]</code>和<code>dp[i][j-coins[i-1]]</code>有关，体现出完全背包思想的是<code>dp[i][j-coins[i-1]]</code>,大概意思就是说，如果第<code>i</code>个物品如果想要放进背包，那么他的前任状态就可以去i中找，因为完全背包中，<code>i</code>物品只可以放入多次</span></p><h1 id="完全背包举例"><a href="#完全背包举例" class="headerlink" title="完全背包举例"></a>完全背包举例</h1><p>问题转化：有一个背包，最大容量为 <code>amount</code>，有一系列物品 <code>coins</code>，每个物品的重量为 <code>coins[i]</code>，请问有多少种方法，能够把背包恰好装满？</p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220806143803827.png" alt="image-20220806143803827"></p><p>「<strong>完全背包问题</strong>」每个物品的数量是无限的，但是不管什么背包，只需记住<code>dp[i][w]</code> 表示：对于前 <code>i</code> 个物品（从 1 开始计数），当前背包的容量为 <code>w</code> 时，这种情况下可以装下的最大价值是 <code>dp[i][w]</code>。</p><p>如此以来我们的状态转移方程可以写为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= amount; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j - coins[i-<span class="number">1</span>] &gt;= <span class="number">0</span>)</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j] </span><br><span class="line">                     + dp[i][j-coins[i-<span class="number">1</span>]];</span><br><span class="line"><span class="keyword">return</span> dp[N][W]</span><br></pre></td></tr></table></figure><p>最终可以<code>coding</code>如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][]dp = <span class="keyword">new</span> <span class="keyword">int</span>[coins.length+<span class="number">1</span>][amount+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> len1 = dp.length;</span><br><span class="line">        <span class="keyword">int</span> len2 = dp[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len1;i++)</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len1;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;len2;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-coins[i-<span class="number">1</span>]&lt;<span class="number">0</span>) <span class="comment">//状态转移方程</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-coins[i-<span class="number">1</span>]];  <span class="comment">//状态转移方程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len1-<span class="number">1</span>][len2-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="当然零钱兑换Ⅱ也可以用自顶向下的动态规划"><a href="#当然零钱兑换Ⅱ也可以用自顶向下的动态规划" class="headerlink" title="当然零钱兑换Ⅱ也可以用自顶向下的动态规划"></a>当然零钱兑换Ⅱ也可以用自顶向下的动态规划</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> [][]memo;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span></span>&#123;</span><br><span class="line">    memo = <span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>][coins.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;memo.length;i++)</span><br><span class="line">        Arrays.fill(memo[i],-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> dp(coins,amount,coins.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//dp函数的定义为： 在amount的容量限制下，使用前N的硬币能够凑出amount的最大组合数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> []coins,<span class="keyword">int</span> amount,<span class="keyword">int</span> N)</span></span>&#123; <span class="comment">//amount 代表可以需要装的总量   N代表可以用的硬币种类数</span></span><br><span class="line">    <span class="keyword">if</span>(amount == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(N&lt;<span class="number">0</span>) <span class="comment">//无可用硬币</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(memo[amount][N]!=-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> memo[amount][N];</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(amount&lt;coins[N]) <span class="comment">//放不下</span></span><br><span class="line">        temp = dp(coins,amount,N-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        temp = dp(coins,amount,N-<span class="number">1</span>) +  dp(coins,amount - coins[N],N);  <span class="comment">//放入背包和不放入背包的方法不同，故相加</span></span><br><span class="line">    memo[amount][N] = temp;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="零钱兑换Ⅱ回溯做法"><a href="#零钱兑换Ⅱ回溯做法" class="headerlink" title="零钱兑换Ⅱ回溯做法"></a>零钱兑换Ⅱ回溯做法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> [][]memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = coins.length;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[len][amount+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            Arrays.fill(memo[i],-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = dp(amount,coins,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> amount,<span class="keyword">int</span> []coins,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(amount&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(amount == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>( memo[start][amount]!=-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>  memo[start][amount];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;coins.length;i++)</span><br><span class="line">            temp += dp(amount-coins[i],coins,i);</span><br><span class="line">        </span><br><span class="line">        memo[start][amount] = temp;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划之子序列问题总结</title>
      <link href="/2022/08/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2022/08/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="子序列问题总结"><a href="#子序列问题总结" class="headerlink" title="子序列问题总结"></a>子序列问题总结</h1><p>本质上都是大事化小，小事化了的宗旨。</p><h1 id="一维的-dp-数组："><a href="#一维的-dp-数组：" class="headerlink" title="一维的 dp 数组："></a><strong>一维的 <code>dp</code> 数组</strong>：</h1><p>这类题目，在前面的博客中，我有很细心的总结思考。适用 <strong>最长递增子序列</strong>和 <strong>最大子数组和</strong>等题目它的模板是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = arr.length;</span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        dp[i] = 最值(dp[i], dp[j] + ...) <span class="comment">//dp[j]就是子问题</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二维的-dp-数组："><a href="#二维的-dp-数组：" class="headerlink" title="二维的 dp 数组："></a><strong>二维的 <code>dp</code> 数组</strong>：</h1><p>比如最长公共子序列、编辑距离,一般需要初始化的为<code>dp[i][i]</code>，模板<code>coding</code>如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从上至下遍历</span></span><br><span class="line"><span class="keyword">int</span> n = arr.length;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> dp[n][n];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == arr[j]) </span><br><span class="line">            dp[i][j] = dp[i][j] + ...  <span class="comment">//dp[i-1][j-1],dp[i][j-1] dp[i-1][j]就是子问题  </span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[i][j] = 最值(...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从下往上遍历</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = s.length();</span><br><span class="line"><span class="keyword">int</span>[][]dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i) == s.charAt(j))</span><br><span class="line">            dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>];  <span class="comment">//dp[i+1][j-1]、dp[i+1][j]、dp[i][j-1]就是子问题</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[i][j] = Math.min(dp[i+<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>])+<span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][len-<span class="number">1</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当然二维<code>dp</code>也可以使用带备忘录的从顶向下求解方式。</p><p>说到底，动态规划，就是通过子问题的求解，最终解决原问题。</p><h1 id="二维dp求解示例"><a href="#二维dp求解示例" class="headerlink" title="二维dp求解示例"></a>二维dp求解示例</h1><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220806093311222.png" alt="image-20220806093311222"></p><h1 id="二维DP函数-自顶向下的解法，大事化小"><a href="#二维DP函数-自顶向下的解法，大事化小" class="headerlink" title="二维DP函数  自顶向下的解法，大事化小"></a>二维DP函数  自顶向下的解法，大事化小</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> [][]memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            Arrays.fill(memo[i],-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> dp(s,<span class="number">0</span>,s.length()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(String s,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == j) <span class="comment">//i == j 时已返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;j) <span class="comment">// dp[i+1][j-1]可能会出现 i&gt;j情况</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(memo[i][j]!=-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span>(s.charAt(i) == s.charAt(j))</span><br><span class="line">            temp = <span class="number">2</span>+dp(s,i+<span class="number">1</span>,j-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp =  Math.max(dp(s,i+<span class="number">1</span>,j),dp(s,i,j-<span class="number">1</span>));</span><br><span class="line">        memo[i][j] = temp;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二维DP数组-自底向上解法"><a href="#二维DP数组-自底向上解法" class="headerlink" title="二维DP数组  自底向上解法"></a>二维DP数组  自底向上解法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span>[][]dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == s.charAt(j))</span><br><span class="line">                    dp[i][j] = <span class="number">2</span>+dp[i+<span class="number">1</span>][j-<span class="number">1</span>]; <span class="comment">//出现相等情况是，最长回文子序列长度加2</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i+<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][len-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结-："><a href="#总结-：" class="headerlink" title="总结 ："></a>总结 ：</h1><p>只要是<code>dp</code>，就肯定可以用自顶向下和自底向上两种方式进行求解。但也需要注意两种方式，在不同情况下，各有优劣，如在最长递增子序列适合用一维<code>dp</code>数组进行求解，在正则表达式求解中，适合<code>dp</code>函数自顶向下求解。</p><p>目前来说，个人对<code>dp</code>函数的使用还是挺有见解的，当然<code>dp</code>数组的使用方式也较为熟练，针对于常见题目。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 子序列问题总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring为什么不推荐使用@Autowired注解</title>
      <link href="/2022/08/05/Spring%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8-Autowired%E6%B3%A8%E8%A7%A3/"/>
      <url>/2022/08/05/Spring%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8-Autowired%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring为什么不推荐使用-Autowired-注解"><a href="#Spring为什么不推荐使用-Autowired-注解" class="headerlink" title="Spring为什么不推荐使用@Autowired 注解"></a>Spring为什么不推荐使用@Autowired 注解</h1><ul><li>因为<code>@Autowired</code> 注解在Bean 注入的时候是基于<code>ByType</code>, <span style="color:white;background:red;font-size:20px;font-family:宋体;">因此会由于注入两个相同类型的Bean导致装配失败</span></li><li><code>@Resource</code> :作用相当于<code>@Autowired</code>，只不过 <code>@Resource</code> 默认按照<code>byName</code>方式装配, 如果没有匹配, 则退回到 <code>byType</code> 方式进行装配</li><li><code>@Qualifier</code>: 如果想让<code>@Autowired</code> 注入的Bean进行 <code>byName</code>装配, 可以使用 <code>@Qualifier</code> 进行指定</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*@Resource装配顺序：</span></span><br><span class="line"><span class="comment">①如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。</span></span><br><span class="line"><span class="comment">②如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。</span></span><br><span class="line"><span class="comment">③如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。</span></span><br><span class="line"><span class="comment">④如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。*/</span></span><br><span class="line"></span><br><span class="line">总体来说：在属性注入方式中，<span class="meta">@Resource</span>要比<span class="meta">@Autowired</span>效果好，因此, 如果一定要使用属性注入, 可以使用 <span class="meta">@Resource</span> 代替 <span class="meta">@Autowired</span> 注解</span><br></pre></td></tr></table></figure><h2 id="Spirng三种常见注入方式：属性注入-构造方法注入-set-方法注入"><a href="#Spirng三种常见注入方式：属性注入-构造方法注入-set-方法注入" class="headerlink" title="Spirng三种常见注入方式：属性注入, 构造方法注入, set 方法注入"></a><strong>Spirng三种常见注入方式：属性注入, 构造方法注入, set 方法注入</strong></h2><p><strong>属性注入</strong><br>可以看到, 我们<strong>开发最常用的就是属性注入</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppointmentNumberConfigurationController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AppointmentNumberConfigurationService numberConfigurationService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>set 方法注入</strong><br>set 方法注入也会用到<code>@Autowired</code>注解，但使用方式与属性注入有所不同，<br><strong>属性注入是用在成员变量上，而set 方法的时候，是用在成员变量的Setter函数上。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppointmentNumberConfigurationController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AppointmentNumberConfigurationService numberConfigurationService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumberConfigurationService</span><span class="params">(AppointmentNumberConfigurationService numberConfigurationService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.numberConfigurationService = numberConfigurationService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>构造方法注入</strong><br>Constructor Injection是构造器注入，是我们最为推荐的一种使用方式。<br>但是, <strong>每次注入都按照这样的流程去构造注入的话, 会显得比较麻烦</strong>.<br>至于如何去简化这一步骤, 我们可以继续往下看.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppointmentNumberConfigurationController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> AppointmentNumberConfigurationService numberConfigurationService;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AppointmentNumberConfigurationController</span><span class="params">(AppointmentNumberConfigurationService numberConfigurationService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.numberConfigurationService = numberConfigurationService;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>三种注入方式对比</strong></p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220805154733053.png" alt="image-20220805154733053"></p>]]></content>
      
      
      <categories>
          
          <category> Spring系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AutoWired </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长公共子序列问题</title>
      <link href="/2022/08/04/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/"/>
      <url>/2022/08/04/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="公共子序列问题"><a href="#公共子序列问题" class="headerlink" title="公共子序列问题"></a>公共子序列问题</h1><p><code>dp</code>数组与<code>dp</code>函数的定义其实很有意义，所有的代码逻辑都是围绕着它开启的。<code>dp</code>数组和函数的定义往往与题目求解的答案是关联的。</p><p>在<code>dp</code>数组或函数一定被自己设定好之后，我就要考虑如果将大问题转化为小问题（如零钱兑换），或则通过小问题的求解推导出大问题的答案（如斐波那契数列）</p><h1 id="题目一-最长公共子序列"><a href="#题目一-最长公共子序列" class="headerlink" title="题目一 最长公共子序列"></a>题目一 最长公共子序列</h1><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220804201224363.png" alt="image-20220804201224363"></p><h2 id="题目一自底向上"><a href="#题目一自底向上" class="headerlink" title="题目一自底向上"></a>题目一自底向上</h2><p><code>dp</code>数组的定义就是，<code>dp[i][j]</code> 为 <code>text1 0~i</code>位置字符与<code>text2 0~j</code>位置字符的最长公共子序列长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//思考如何大事化小呢？ </span></span><br><span class="line">    <span class="comment">//dp[i][j]代表 text1 0-i 与 text2 0-j的最长公共子序列</span></span><br><span class="line">    <span class="comment">//如果charAt(i) == charAt(j)  dp[i][j] = dp[i-1][j-1]+1</span></span><br><span class="line">    <span class="comment">//如果不相等  dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1])</span></span><br><span class="line">    <span class="comment">//这种类型的题更适合用dp数组来做</span></span><br><span class="line">    <span class="keyword">int</span> len1 = text1.length();</span><br><span class="line">    <span class="keyword">int</span> len2 = text2.length();</span><br><span class="line">    <span class="keyword">int</span>[][]dp = <span class="keyword">new</span> <span class="keyword">int</span>[len1+<span class="number">1</span>][len2+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len1+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;len2+<span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(text1.charAt(i-<span class="number">1</span>) == text2.charAt(j-<span class="number">1</span>))</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目二自顶向下"><a href="#题目二自顶向下" class="headerlink" title="题目二自顶向下"></a>题目二自顶向下</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用自顶向下的写法</span></span><br><span class="line"><span class="keyword">int</span>[][]memo;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//思考如何大事化小呢？ </span></span><br><span class="line">    <span class="comment">//dp[i][j]代表 text1 0-i 与 text2 0-j的最长公共子序列</span></span><br><span class="line">    <span class="comment">//如果charAt(i) == charAt(j)  dp[i][j] = dp[i-1][j-1]+1</span></span><br><span class="line">    <span class="comment">//如果不相等  dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1])</span></span><br><span class="line">    <span class="comment">//这种类型的题更适合用dp数组来做</span></span><br><span class="line">    <span class="keyword">int</span> len1 = text1.length();</span><br><span class="line">    <span class="keyword">int</span> len2 = text2.length();</span><br><span class="line">    memo = <span class="keyword">new</span> <span class="keyword">int</span>[len1][len2];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len1;i++)</span><br><span class="line">        Arrays.fill(memo[i],-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//很明显通过自顶向上的写法存在重叠子问题，加入备忘录！</span></span><br><span class="line">    <span class="keyword">return</span> dp(text1,text2,len1-<span class="number">1</span>,len2-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(String text1,String text2,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(j&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(memo[i][j]!=-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(text1.charAt(i) == text2.charAt(j))</span><br><span class="line">        temp = <span class="number">1</span>+dp(text1,text2,i-<span class="number">1</span>,j-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        temp =  Math.max(dp(text1,text2,i-<span class="number">1</span>,j),dp(text1,text2,i,j-<span class="number">1</span>));</span><br><span class="line">    memo[i][j] = temp;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题目二两个字符串的最小ASCII删除和"><a href="#题目二两个字符串的最小ASCII删除和" class="headerlink" title="题目二两个字符串的最小ASCII删除和"></a>题目二两个字符串的最小ASCII删除和</h1><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220804201607611.png" alt="image-20220804201607611"></p><h2 id="题目二自底向上"><a href="#题目二自底向上" class="headerlink" title="题目二自底向上"></a>题目二自底向上</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumDeleteSum</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//大事化小  </span></span><br><span class="line">    <span class="comment">//dp[i][j]为s1 0-i 与 s2 0-j变为相等字符串所需要删除的最小ASCII</span></span><br><span class="line">    <span class="comment">//当 charAt(i)与charAt(j)相等时,dp[i-1][j-1]可以推导出dp[i][j]</span></span><br><span class="line">    <span class="comment">//不相等时, dp[i-1][j]与dp[i][j-1]可以推导出dp[i][j]</span></span><br><span class="line">    <span class="keyword">int</span> len1 = s1.length();</span><br><span class="line">    <span class="keyword">int</span> len2 = s2.length();</span><br><span class="line">    <span class="keyword">int</span> [][]dp = <span class="keyword">new</span> <span class="keyword">int</span>[len1+<span class="number">1</span>][len2+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len1+<span class="number">1</span>;i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = s1.charAt(i-<span class="number">1</span>)+dp[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len2+<span class="number">1</span>;i++)</span><br><span class="line">        dp[<span class="number">0</span>][i] = s2.charAt(i-<span class="number">1</span>)+dp[<span class="number">0</span>][i-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len1+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;len2+<span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.charAt(i-<span class="number">1</span>) == s2.charAt(j-<span class="number">1</span>))</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = Math.min(dp[i][j-<span class="number">1</span>]+s2.charAt(j-<span class="number">1</span>),dp[i-<span class="number">1</span>][j]+s1.charAt(i-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目二自顶向下-1"><a href="#题目二自顶向下-1" class="headerlink" title="题目二自顶向下"></a>题目二自顶向下</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自顶向下解法  大事化小</span></span><br><span class="line"><span class="keyword">int</span> [][]memo;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumDeleteSum</span><span class="params">(String s1,String s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = s1.length();</span><br><span class="line">    <span class="keyword">int</span> len2 = s2.length();</span><br><span class="line">    memo = <span class="keyword">new</span> <span class="keyword">int</span>[len1][len2];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len1;i++)</span><br><span class="line">        Arrays.fill(memo[i],-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> dp(s1,s2,len1-<span class="number">1</span>,len2-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(String s1,String s2,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=j;k++)</span><br><span class="line">            temp += s2.charAt(k);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j == -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=i;k++)</span><br><span class="line">            temp += s1.charAt(k);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(memo[i][j]!=-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    <span class="keyword">int</span> temp2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(s1.charAt(i)==s2.charAt(j))</span><br><span class="line">        temp2 = dp(s1,s2,i-<span class="number">1</span>,j-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        temp2 = Math.min(dp(s1,s2,i-<span class="number">1</span>,j)+s1.charAt(i),dp(s1,s2,i,j-<span class="number">1</span>)+s2.charAt(j));</span><br><span class="line"></span><br><span class="line">    memo[i][j] = temp2;</span><br><span class="line">    <span class="keyword">return</span> temp2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最长公共子序列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大子数组和</title>
      <link href="/2022/08/04/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"/>
      <url>/2022/08/04/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h1><p>这两天在复习动态规划的相关题目，根据自己总结的口诀”大事化小，小事化了”，在遇到一个大问题时，我们要思考如何通过子问题的求解去推到主问题。如何将大问题分解为一个小问题，是根据题目的要求去设定的。</p><p>在大事已经化小的基础之上，我们要考虑什么时候截止。比如递归基，比如<code>dp</code>数组遍历终点。看如下题目</p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220804195038019.png" alt="image-20220804195038019"></p><h1 id="自底向上解答分析"><a href="#自底向上解答分析" class="headerlink" title="自底向上解答分析"></a>自底向上解答分析</h1><ul><li>大事化小，如何化解呢？</li><li><code>dp[i]</code> 定义为<code> 0-i</code>下标数字，以<code>i</code>下标结尾最大和的连续子数组</li><li><code>dp[i] </code>与什么有关呢 : 要么加上前一个数，要么不加！什么时候不加呢，就是当<code>nums[i]</code>比<code> 0~ i-1</code>下标的连续子数组最大和都要大</li></ul><p>coding如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//大事化小，如何化解呢？</span></span><br><span class="line">        <span class="comment">//dp[i] 定义为 0-i下标数字，以i下标结尾最大和的连续子数组</span></span><br><span class="line">        <span class="comment">//dp[i] 与什么有关呢 : 要么加上前一个数，要么不加！什么时候不加呢，就是当nums[i]比 0- i-1下标的连续子数组最大和都要大</span></span><br><span class="line">        <span class="keyword">int</span> []dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;dp[i-<span class="number">1</span>]+nums[i])</span><br><span class="line">                dp[i] = nums[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i] = nums[i] + dp[i-<span class="number">1</span>];</span><br><span class="line">            max = Math.max(max,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(max,dp[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    preSum[i+<span class="number">1</span>] - min(preSum[<span class="number">0.</span>.i])。</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解决方案二，通过前缀和，以 nums[i] 为结尾的最大子数组之和是多少？其实就是 preSum[i+1] - min(preSum[0..i])。</span></span><br></pre></td></tr></table></figure><h1 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h1><p>这题如果从数组末尾进行递归的话，递归基不好写的，如果从前往后递归的话，递归基可以统一为数组的最后一个元素。</p><p>记忆化的这一步其实是识别一个问题：在纯递归中哪些子问题被重复计算了？<br>我们看一下上面的代码，发现被重复计算的是<code>int next = getSum(nums, index + 1, mem); </code>这一部分。<br>所以我们需要一个数组把它存起来，这样下次访问的时候如果发现已经计算过就直接读，如果没有就计算一次，然后把它写回去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从前至后</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ans = Integer.MIN_VALUE;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Integer[] mem = <span class="keyword">new</span> Integer[nums.length];</span><br><span class="line">        <span class="comment">//最大子数组和 开始的位置不确定，所以这里需要利用for循环遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            ans = Math.max(ans, getSum(nums, i, mem));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index, Integer[] mem)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == nums.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读值</span></span><br><span class="line">        <span class="keyword">if</span> (mem[index] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mem[index];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//计算下一个位置的最大子数组和</span></span><br><span class="line">        <span class="keyword">int</span> next = getSum(nums, index + <span class="number">1</span>, mem);</span><br><span class="line">        <span class="comment">// 若index+1位置开始的最大子数组和大于0，则可以与index位置的num[index]进行相加，进而mem[index]也就确定了</span></span><br><span class="line">        <span class="keyword">return</span> mem[index] = nums[index] + (next &gt; <span class="number">0</span> ? next : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再也不怕编辑距离!</title>
      <link href="/2022/08/04/%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%80%95%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
      <url>/2022/08/04/%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%80%95%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="破解编辑距离"><a href="#破解编辑距离" class="headerlink" title="破解编辑距离"></a>破解编辑距离</h1><p>闭上眼睛，吸口气。想一下，这道题难吗？”刚开始做挺难的，想不懂啊，为什么要这样子搞呢，哦，原来是递归，哦，原来是动态规划”，然后自己就照着题解，再敲了一遍，实在是卑微~</p><p>看看自己的记录，事不过三，第三次写这个题目，我终于醒悟了！</p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220804083504239.png" alt="image-20220804083504239"></p><p>昨晚自己通过凑零钱问题，总结了一个做递归和动态规划的诀窍，那就是<span style="color:white;background:red;font-size:20px;font-family:宋体;">  “大事化小，小事化了”，大事化小的意思，就是如果将大的问题分解为子问题，小事化了就是确定递归基，找出问题化解的尽头！</span></p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220804085307359.png" alt="image-20220804085307359"></p><h1 id="大事化小，小事化了-—-带备忘录的递归"><a href="#大事化小，小事化了-—-带备忘录的递归" class="headerlink" title="大事化小，小事化了 — 带备忘录的递归"></a>大事化小，小事化了 — 带备忘录的递归</h1><p>​        <strong>大事化小</strong>：<code>dp(word1,word2,i,j)</code>,表示<code>word1 0-i</code>位置 与<code> word2 0-j</code>位置的最小编辑距离,其中<code> i，j</code>从两个单词的末尾处开始, 那么我们如果将这个大问题分解为小问题呢，那么也就是通过题目中提到的可以对<code>word1</code>单词进行插入、删除、替换操作，那就很简单啦，大问题不就是由这三个子问题的<code>ans</code>再加上1,<code>dp(word1,word2,i,j)=Math.min(dp(word1,word2,i,j-1),Math.min(dp(word1,word2,i-1,j),dp(word1,word2,i-1,j-1)))+1;</code>，但是这也要注意哈，如果<code>i,j</code>位置的字符相等的化，我们是不需要进行插入删除替换操作的，即<code>dp(word1,word2,i,j) = dp(word1,word2,i-1,j-1);</code>.</p><p>​        <strong>小事化了</strong>：递归基为<code> i=-1 || j=-1</code>,也就是<code>word1 或 word2</code>某个单词的下标已经走到了-1位置，也就是走完了。</p><p>根据上述思路，<code>coding</code>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自顶向下，大事化小，小事化了</span></span><br><span class="line"><span class="keyword">int</span>[][]memo;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = word1.length();</span><br><span class="line">    <span class="keyword">int</span> len2 = word2.length();</span><br><span class="line">    memo = <span class="keyword">new</span> <span class="keyword">int</span>[len1][len2];</span><br><span class="line">    <span class="keyword">return</span> dp(word1,word2,word1.length()-<span class="number">1</span>,word2.length()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dp(word1,word2,i,j),表示word1 0-i位置 与 word2 0-j位置的最小编辑距离</span></span><br><span class="line"><span class="comment">//其中 i，j从两个单词的末尾处开始，递归基为 i=-1  || j=-1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(String word1,String word2,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 注：是将word1 转化为word2的最小操作数</span></span><br><span class="line">    <span class="keyword">if</span>(i == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> j+<span class="number">1</span>; <span class="comment">//在头部插入 j+1个元素</span></span><br><span class="line">    <span class="keyword">if</span>(j == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>; <span class="comment">//删除头部的i+1个元素</span></span><br><span class="line">    <span class="keyword">if</span>(memo[i][j]!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(word1.charAt(i) == word2.charAt(j))</span><br><span class="line">        temp =  dp(word1,word2,i-<span class="number">1</span>,j-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//i j所在位置的字符如果不相等的话，我们有三种操作方式：插入、删除、替换</span></span><br><span class="line">        temp =  Math.min(dp(word1,word2,i,j-<span class="number">1</span>),Math.min(dp(word1,word2,i-<span class="number">1</span>,j),dp(word1,word2,i-<span class="number">1</span>,j-<span class="number">1</span>)))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    memo[i][j] = temp;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自底向上-—-标准的动态规划"><a href="#自底向上-—-标准的动态规划" class="headerlink" title="自底向上 — 标准的动态规划"></a>自底向上 — 标准的动态规划</h1><p>自底向上的动态规划解法，有两个问题需要解决，</p><p>一是确定状态转移方程，这一点可以直接猜测推导，或者可以通过自顶向下的解法中延伸出来，二者都有难度哈，需要靠经验吃饭。</p><p>二是确定初始条件，如果没有把初始条件进行初始化，我们是无法通过迭代递推得到最终的动态规划结果。</p><p>回归本题。</p><p>我们的状态转移方程受自顶向下的解法启发。  初始条件即为，① <code>word2</code>长度为<code>0</code>时，<code>word1</code>的最小编辑距离，与它本身的字符长度有关，② <code>word1</code>长度为0时，<code>word1</code>的最小编辑距离，与<code>word2</code>的字符长度有关。</p><p>根据如上思路，<code>coding</code>如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//自底向上的动态规划，这里需要借鉴自顶向下的化解方案，不然我们事很难直接写出状态转移方程的</span></span><br><span class="line">    <span class="comment">//另外，一般的自底向上的动态规划，都会考虑dp数组要不要多申请一个维度，这样就可以避免很多边界情况的讨论，这就如同单链表的虚拟头节点</span></span><br><span class="line">    <span class="keyword">int</span> len1 = word1.length();</span><br><span class="line">    <span class="keyword">int</span> len2 = word2.length();</span><br><span class="line">    <span class="keyword">int</span>[][]dp = <span class="keyword">new</span> <span class="keyword">int</span>[len1+<span class="number">1</span>][len2+<span class="number">1</span>]; <span class="comment">//dp[len1][len2] 代表 word1 0-len1 与 word2 0-len2 的最小编辑距离</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dp[<span class="number">0</span>].length;i++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;dp.length;j++)&#123;</span><br><span class="line">        dp[j][<span class="number">0</span>] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始遍历，这里的遍历方向需要有状态转移方程来决定</span></span><br><span class="line">    <span class="comment">//if(word1.charAt(i) == word2.charAt(j)) dp[i][j] = dp[i-1][j-1];</span></span><br><span class="line">    <span class="comment">//else dp[i][j] = Math.min(dp[i][j-1],Math.min(dp[i-1][j],dp[i-1][j-1]))+1;   //所以遍历方向由上至下，由左向右</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len1;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=len2;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(word1.charAt(i-<span class="number">1</span>) == word2.charAt(j-<span class="number">1</span>)) </span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = Math.min(dp[i][j-<span class="number">1</span>],Math.min(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-<span class="number">1</span>]))+<span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过零钱兑换浅析动态规划</title>
      <link href="/2022/08/03/%E9%80%9A%E8%BF%87%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%E6%B5%85%E6%9E%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2022/08/03/%E9%80%9A%E8%BF%87%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%E6%B5%85%E6%9E%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="今天总结一下零钱兑换问题"><a href="#今天总结一下零钱兑换问题" class="headerlink" title="今天总结一下零钱兑换问题"></a>今天总结一下零钱兑换问题</h1><p>​        试想一下，如果题目给我们总金额<code>amount</code>很大，硬币的种类有很多，我们怎么解决这样一个<code>big problem</code>呢。仔细分析一下，不难的！<strong>”大事化小，小事化了“</strong>,这句话正是解决这类问题的关键。</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220803222552524.png" alt="image-20220803222552524"></p><h1 id="方案一：从顶向下，对应大事化小、小事化了"><a href="#方案一：从顶向下，对应大事化小、小事化了" class="headerlink" title="方案一：从顶向下，对应大事化小、小事化了"></a>方案一：从顶向下，对应大事化小、小事化了</h1><p>仅仅针对这道题的示例<code>1</code>来说，我们如何凑出<code>amount</code>=11的最少硬币数量呢。</p><p>一句话：11的最小凑出数由下面的如下条件决定：即（11- 1)、（11-2）、（11-5）这三个的最小凑出数 再加1。</p><p>根据这样的思路，我们便可以写出自顶向下的递归代码，这里注意递归基的写法。 在这个过程中还需要加上备忘录，很明显这里存在重叠子问题，和斐波那契数列的重叠子问题很像。<code>coding</code>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带备忘录的递归，属于动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> []memo = <span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> dp(coins,amount,memo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[]coins,<span class="keyword">int</span> amount,<span class="keyword">int</span> []memo)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(amount&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(amount == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(memo[amount]!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> memo[amount];</span><br><span class="line">    <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> coin:coins)&#123;</span><br><span class="line">        <span class="keyword">int</span> subProblem = dp(coins,amount-coin,memo);</span><br><span class="line">        <span class="keyword">if</span>(subProblem&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        res = Math.min(res,<span class="number">1</span>+subProblem);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res!=Integer.MAX_VALUE)</span><br><span class="line">        memo[amount] = res;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        memo[amount] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res == Integer.MAX_VALUE?-<span class="number">1</span>:res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方案二：从底向上，进行迭代求取"><a href="#方案二：从底向上，进行迭代求取" class="headerlink" title="方案二：从底向上，进行迭代求取"></a>方案二：从底向上，进行迭代求取</h1><p>这种方式就是典型的<span style="color:white;background:red;font-size:20px;font-family:宋体;"> 动态规划</span>，这种方式下，最后的ans依赖于子问题的求解。这样你是需要知道迭代方程的！并且你还需要确定子问题独立，也就是每个子问题互不相关。</p><p>整个步骤如下所示：</p><p><strong>明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 <code>dp</code> 数组/函数的含义</strong>。</p><p>本道题DP数组的含义：<code>dp[i]</code>表示<code>amount=i</code>时，所求出的最小凑出数。</p><p>状态转移方程：本题的状态转移方程是一类题的代表，比如最长递增子序列。 本题中<code>dp[i]</code>与<code>dp[i-coin]</code>有关。 最长递增子序列中<code>dp[i]</code>与<code>dp[j]  0=&lt;j&lt;i</code>有关。</p><p>按照自底向上的方案coding如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> []dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">     Arrays.fill(dp,amount+<span class="number">1</span>);</span><br><span class="line">     dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=amount;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> coin:coins)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i-coin&lt;<span class="number">0</span>||dp[i-coin]==amount+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            dp[i] = Math.min(dp[i],<span class="number">1</span>+dp[i-coin]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount]==amount+<span class="number">1</span>?-<span class="number">1</span>:dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈实现队列、队列实现栈</title>
      <link href="/2022/08/02/%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E3%80%81%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
      <url>/2022/08/02/%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E3%80%81%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="回顾两个设计题目"><a href="#回顾两个设计题目" class="headerlink" title="回顾两个设计题目"></a>回顾两个设计题目</h1><p>栈是先进后出，队列是先进先出，如果需要用栈实现队列，就需要两个栈相互倒；如果需要用队列实现栈，用一个栈两个队列都可以。</p><h1 id="队列实现栈"><a href="#队列实现栈" class="headerlink" title="队列实现栈"></a>队列实现栈</h1><p>​    用队列模拟栈的话，我们的栈顶元素就在队尾。但是队尾我们是无法做<code>get</code>操作的，所以我们需要定义一个变量记录队尾元素。该变量的更新操作有两个时刻，一是模拟栈<code>push</code>元素时，二是模拟栈<code>pop</code>元素时。</p><p>​    那么我们如何实现pop()操作呢，想法也很常见，我们将队头元素进行删除，再将删除后的元素加入队尾。<span style="color:white;background:red;font-size:20px;font-family:宋体;">当还剩2个元素没有删除时，倒数第二个就是我们需要记录的模拟栈顶元素，这里我们需要更新栈顶变量的值，删除后再加入队列。倒数第一个元素删除后，不需要再加入队列。这样整个逻辑就通了。</span></p><p>具体题目如下</p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220802155733076.png" alt="image-20220802155733076"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    LinkedList&lt;Integer&gt; list1;</span><br><span class="line">    <span class="keyword">int</span> stackHead;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stackHead = x;</span><br><span class="line">        list1.offer(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = list1.size();</span><br><span class="line">        <span class="keyword">while</span>(size&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            list1.offer(list1.poll());</span><br><span class="line">            size--; <span class="comment">//记录删了多少个元素了</span></span><br><span class="line">        &#125;</span><br><span class="line">        stackHead = list1.poll(); <span class="comment">//注意在这里更新stackHead的值</span></span><br><span class="line">        list1.offer(stackHead);</span><br><span class="line">        <span class="keyword">return</span> list1.poll(); <span class="comment">//倒数第一个元素无需再加入队列</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stackHead;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="栈实现队列"><a href="#栈实现队列" class="headerlink" title="栈实现队列"></a>栈实现队列</h1><p>只点评一句吧，根据这个思路所有的代码也就呼之欲出。</p><p><span style="color:white;background:red;font-size:20px;font-family:宋体;"> 声明两个栈，stack1,stack2,其中stack1永远作为插入元素栈，在模拟poll元素时，我们将stack1中的元素全部压栈到stack2中，这样倒了一下，元素的顺序也就符合了队列的先进先出特性</span></p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220802160638137.png" alt="image-20220802160638137">、</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; stack1;</span><br><span class="line">    Stack&lt;Integer&gt; stack2;</span><br><span class="line">    <span class="keyword">boolean</span> master;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> Stack&lt;&gt;(); <span class="comment">//stack1永远作为插入元素的那一个</span></span><br><span class="line">        stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack1.push(x);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(!stack2.isEmpty()) <span class="comment">//stack2没有元素时，我们将stack1中的元素倒过来</span></span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> stack2.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack2.isEmpty()&amp;&amp;stack1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈与队列的相互转化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调队列</title>
      <link href="/2022/08/02/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
      <url>/2022/08/02/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="题目是这样的"><a href="#题目是这样的" class="headerlink" title="题目是这样的"></a>题目是这样的</h1><p>复习完单调栈之后，再看思考单调队列的设计，你会发现这不就是同一种思路的东西吗。<span style="color:white;background:red;font-size:20px;font-family:宋体;">也就是在添加数据那里做了些文章，通过while循环保证了队列元素的单调性，单调队列需要保证的是队头元素是最大值</span>，单调栈需要保证的是栈底是最大值，唯一不一样的是单调队列从队头出队元素，也就刚好满足239题的意思，求解滑动窗口的最大值，当左侧<code>left</code>移出的元素为单调队列最大值时，单调队列就要将队头元素删除。</p><p>反之单调栈是在栈顶出栈元素，栈顶是单调栈中最小的元素，当然这里是单调递减栈，单调递增栈则反之。</p><p>239题的具体代码实现和需要注意的细节问题，已在注释中写清楚了。希望自己能把这类结构转化为长期记忆。</p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220802144548404.png" alt="image-20220802144548404"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> []ans = <span class="keyword">new</span> <span class="keyword">int</span>[len-k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        monotonous monoQueue = <span class="keyword">new</span> monotonous();</span><br><span class="line">        <span class="comment">//滑动窗口，进行区间更替，通过单调队列的过滤，我们即可拿到题目需要的ans</span></span><br><span class="line">        <span class="keyword">while</span>(right&lt;len)&#123;</span><br><span class="line">            monoQueue.offer(nums[right++]);</span><br><span class="line">            <span class="keyword">if</span>(right-left&gt;=k)&#123;</span><br><span class="line">                ans[index++] = monoQueue.max();</span><br><span class="line">                monoQueue.poll(nums[left++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">monotonous</span></span>&#123;</span><br><span class="line">    LinkedList &lt;Integer&gt; queue; <span class="comment">//使用LinkedList 来模拟我们的单调队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">monotonous</span><span class="params">()</span></span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">offer</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="comment">//通过while循环，确保队列单调，在指定区间内，队头为最大值，然后依次递减</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()&amp;&amp;queue.getLast()&lt;x)&#123; </span><br><span class="line">             <span class="comment">//这里的remove操作和单调栈的很像。当队尾元素小于要插入的元素时，我们将这种不满足条件的队尾元素进行删除</span></span><br><span class="line">            queue.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到合适位置，将该元素插入</span></span><br><span class="line">        queue.addLast(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//单调队列保证了队头元素是最大值，所以直接返回队头元素即可</span></span><br><span class="line">        <span class="keyword">return</span> queue.getFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">poll</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果要删除的元素，是队头元素，才真正执行出队操作</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="keyword">this</span>.max();</span><br><span class="line">        <span class="keyword">if</span>(n == max)</span><br><span class="line">            queue.removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调栈</title>
      <link href="/2022/08/01/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
      <url>/2022/08/01/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="今天来复习单调栈"><a href="#今天来复习单调栈" class="headerlink" title="今天来复习单调栈"></a>今天来复习单调栈</h1><p>​    闭上眼睛想一下，单调栈确实没什么复杂的。闭上眼睛想一想，就是一组数，通过一定的条件添加进栈中。为什么叫单调呢？主要是在元素加入栈，条件判断时使用的时<code>while</code>, 而我们需要的ans就在这个单调的添加元素的过程中产生，比如我们需要知道每个元素的下一个最大元素、比如我们需要知道环形数组的下一个最大元素。抑或是我想在这个单调添加元素的过程中获取一些其他的信息，比如下一个最大元素的位置？这就需要我们往栈里不仅存上元素的值，还需要存上元素的下标。</p><p>​    一般来说下一个最大元素的求解方法，是从数组的末尾进行单调添加，因为倒着入栈便是正着出栈。但我们需要注意单调栈在其他题目中，变形、存储数据的变化、添加数据的方向的变化等。</p><h1 id="单调栈的模板程序"><a href="#单调栈的模板程序" class="headerlink" title="单调栈的模板程序"></a>单调栈的模板程序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="comment">// 存放答案的数组</span></span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;&gt;(); </span><br><span class="line">    <span class="comment">// 倒着往栈里放</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 判定个子高矮</span></span><br><span class="line">        <span class="keyword">while</span> (!s.isEmpty() &amp;&amp; s.peek() &lt;= nums[i]) &#123;</span><br><span class="line">            <span class="comment">// 矮个起开，反正也被挡着了。。。</span></span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// nums[i] 身后的更大元素</span></span><br><span class="line">        res[i] = s.isEmpty() ? -<span class="number">1</span> : s.peek();</span><br><span class="line">        s.push(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="这里放三道自己刷过好几遍的leetcode题目"><a href="#这里放三道自己刷过好几遍的leetcode题目" class="headerlink" title="这里放三道自己刷过好几遍的leetcode题目"></a>这里放三道自己刷过好几遍的leetcode题目</h1><p>希望自己别再忘了。。。时常巩固吧。</p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220801162451036.png" alt="image-20220801162451036"></p><p><strong>单调栈+HashMap</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt;map = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//用于存放nums1对应元素在nums2中下一个更大元素</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums2.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty()&amp;&amp;stack.peek()&lt;nums2[i])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty())</span><br><span class="line">                map.put(nums2[i],-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                map.put(nums2[i],stack.peek());</span><br><span class="line">            stack.push(nums2[i]);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> []ans = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums1.length;i++)&#123;</span><br><span class="line">            ans[i] = map.get(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220801162541800.png" alt="image-20220801162541800"></p><p><strong>单调栈+自定义栈中元素类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] temperatures) &#123;</span><br><span class="line">        <span class="keyword">return</span> sigleStack(temperatures);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sigleStack(<span class="keyword">int</span> []num)&#123;</span><br><span class="line">        LinkedList&lt;<span class="keyword">int</span>[]&gt;stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> []ans = <span class="keyword">new</span> <span class="keyword">int</span>[num.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=num.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty()&amp;&amp;stack.peek()[<span class="number">0</span>]&lt;=num[i])&#123;</span><br><span class="line">               stack.pop();</span><br><span class="line">            &#125; </span><br><span class="line">            ans[i] = stack.isEmpty()?<span class="number">0</span>:stack.peek()[<span class="number">1</span>]-i;</span><br><span class="line">            stack.push(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;num[i],i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220801162626407.png" alt="image-20220801162626407"></p><p><strong>单调栈+利用数组长度的两倍模拟环形数组+取模运算</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> []ans = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        Stack&lt;Integer&gt;stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.length*<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty()&amp;&amp;nums[i%len]&gt;=stack.peek())&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty())</span><br><span class="line">                ans[i%len] = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans[i%len] = stack.peek();</span><br><span class="line">            stack.push(nums[i%len]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8新特性</title>
      <link href="/2022/07/31/java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2022/07/31/java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>Lambda表达式的基本语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Lambda表达式的写法</span></span><br><span class="line">   Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; Integer.compare(o1,o2);</span><br></pre></td></tr></table></figure><p>1.举例： (o1,o2) -&gt; Integer.compare(o1,o2);</p><p>2.格式：</p><ul><li><p>-&gt; :  lambda操作符 或 箭头操作符</p></li><li><p>-&gt;左边：lambda形参列表 （其实就是接口中的抽象方法的形参列表)</p></li><li><p>-&gt;右边：lambda体 （其实就是重写的抽象方法的方法体</p></li><li><p>函数式接口的使用说明,只有函数式接口才可以用lambda表达式</p><blockquote><p>如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。<br>我们可以在一个接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口。<br>Lambda表达式的本质：作为函数式接口的实例</p></blockquote></li></ul><h2 id="使用：分为六种情况"><a href="#使用：分为六种情况" class="headerlink" title="使用：分为六种情况"></a>使用：分为六种情况</h2><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220731223822748.png" alt="image-20220731223822748"></p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220731223905524.png" alt="image-20220731223905524"></p><p><strong>总结六种情况：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">-&gt;左边：lambda形参列表的参数类型可以省略(类型推断)；如果lambda形参列表只一个参数，其一对()也可以省略</span></span><br><span class="line"><span class="comment">-&gt;右边：lambda体应该使用一对&#123;&#125;包裹；如果lambda体只一条执行语句（可能是return语句，省略这一对&#123;&#125;和return关键字</span></span><br><span class="line"><span class="comment">所以以前用匿名实现类表示的现在都可以用Lambda表达式来写</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="Java8中关于Lambda表达式提供的4个基本的函数式接口"><a href="#Java8中关于Lambda表达式提供的4个基本的函数式接口" class="headerlink" title="Java8中关于Lambda表达式提供的4个基本的函数式接口"></a>Java8中关于Lambda表达式提供的4个基本的函数式接口</h2><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220731225853803.png" alt="image-20220731225853803"></p><p>源码foreach方法定义，就是使用的Consumer消费型接口</p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220801102731381.png" alt="image-20220801102731381"></p><h2 id="lambda表达式总结"><a href="#lambda表达式总结" class="headerlink" title="lambda表达式总结"></a>lambda表达式总结</h2><h3 id="何时使用lambda表达式？"><a href="#何时使用lambda表达式？" class="headerlink" title="何时使用lambda表达式？"></a>何时使用lambda表达式？</h3><p>当需要对一个函数式接口实例化的时候，可以使用lambda表达式。</p><h3 id="何时使用给定的函数式接口？"><a href="#何时使用给定的函数式接口？" class="headerlink" title="何时使用给定的函数式接口？"></a>何时使用给定的函数式接口？</h3><p>如果我们开发中需要定义一个函数式接口，首先看看在已有的jdk提供的函数式接口是否提供了<br>能满足需求的函数式接口。如果有，则直接调用即可，不需要自己再自定义了。</p><h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><p>1.理解：<br>方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法。</p><p>2.使用情境：<br>当要传递给Lambda体的操作，已经实现的方法了，可以使用方法引用！</p><p>3.格式：<br>类(或对象) :: 方法名</p><p>4.分为如下的三种情况：</p><ul><li><p>   情况1     对象 :: 非静态方法</p></li><li><p>   情况2     类 :: 静态方法</p></li><li><p>   情况3     类 :: 非静态方法</p></li></ul><p>5.要求：</p><blockquote><p>要求接口中的抽象方法的形参列表和返回值类型与方法引用的方法的形参列表和返回值类型相同！（针对于情况1和情况2）<br>当函数式接口方法的第一个参数是需要引用方法的调用者，并且第二个参数是需要引用方法的参数(或无参数)时：ClassName::methodName（针对于情况3）</p></blockquote><p>举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一：对象 :: 实例方法</span></span><br><span class="line"><span class="comment">//Consumer中的void accept(T t)</span></span><br><span class="line"><span class="comment">//PrintStream中的void println(T t)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Consumer&lt;String&gt; con1 = str -&gt; System.out.println(str);</span><br><span class="line">con1.accept(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line">PrintStream ps = System.out;</span><br><span class="line">Consumer&lt;String&gt; con2 = ps::println;</span><br><span class="line">con2.accept(<span class="string">&quot;beijing&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Supplier中的T get()</span></span><br><span class="line"><span class="comment">//Employee中的String getName()</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Employee emp = <span class="keyword">new</span> Employee(<span class="number">1001</span>,<span class="string">&quot;Tom&quot;</span>,<span class="number">23</span>,<span class="number">5600</span>);</span><br><span class="line"></span><br><span class="line">Supplier&lt;String&gt; sup1 = () -&gt; emp.getName();</span><br><span class="line">System.out.println(sup1.get());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line">Supplier&lt;String&gt; sup2 = emp::getName;</span><br><span class="line">System.out.println(sup2.get());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二：类 :: 静态方法</span></span><br><span class="line"><span class="comment">//Comparator中的int compare(T t1,T t2)</span></span><br><span class="line"><span class="comment">//Integer中的int compare(T t1,T t2)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Comparator&lt;Integer&gt; com1 = (t1,t2) -&gt; Integer.compare(t1,t2);</span><br><span class="line">System.out.println(com1.compare(<span class="number">12</span>,<span class="number">21</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">Comparator&lt;Integer&gt; com2 = Integer::compare;</span><br><span class="line">System.out.println(com2.compare(<span class="number">12</span>,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Function中的R apply(T t)</span></span><br><span class="line"><span class="comment">//Math中的Long round(Double d)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Function&lt;Double,Long&gt; func = <span class="keyword">new</span> Function&lt;Double, Long&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">apply</span><span class="params">(Double d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Math.round(d);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">Function&lt;Double,Long&gt; func1 = d -&gt; Math.round(d);</span><br><span class="line">System.out.println(func1.apply(<span class="number">12.3</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">Function&lt;Double,Long&gt; func2 = Math::round;</span><br><span class="line">System.out.println(func2.apply(<span class="number">12.6</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况3：类 :: 实例方法  (有难度)</span></span><br><span class="line"><span class="comment">// Comparator中的int comapre(T t1,T t2)</span></span><br><span class="line"><span class="comment">// String中的int t1.compareTo(t2)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Comparator&lt;String&gt; com1 = (s1,s2) -&gt; s1.compareTo(s2);</span><br><span class="line">System.out.println(com1.compare(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;abd&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">Comparator&lt;String&gt; com2 = String :: compareTo;</span><br><span class="line">System.out.println(com2.compare(<span class="string">&quot;abd&quot;</span>,<span class="string">&quot;abm&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BiPredicate中的boolean test(T t1, T t2);</span></span><br><span class="line"><span class="comment">//String中的boolean t1.equals(t2)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">BiPredicate&lt;String,String&gt; pre1 = (s1,s2) -&gt; s1.equals(s2);</span><br><span class="line">System.out.println(pre1.test(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;abc&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line">BiPredicate&lt;String,String&gt; pre2 = String :: equals;</span><br><span class="line">System.out.println(pre2.test(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;abd&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function中的R apply(T t)</span></span><br><span class="line"><span class="comment">// Employee中的String getName();</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Employee employee = <span class="keyword">new</span> Employee(<span class="number">1001</span>, <span class="string">&quot;Jerry&quot;</span>, <span class="number">23</span>, <span class="number">6000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Function&lt;Employee,String&gt; func1 = e -&gt; e.getName();</span><br><span class="line">System.out.println(func1.apply(employee));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">Function&lt;Employee,String&gt; func2 = Employee::getName;</span><br><span class="line">System.out.println(func2.apply(employee));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="构造器引用与数组引用"><a href="#构造器引用与数组引用" class="headerlink" title="构造器引用与数组引用"></a>构造器引用与数组引用</h1><p>1.构造器引用格式：类名::new</p><p>2.构造器引用使用要求：和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。抽象方法的返回值类型即为构造器所属的类的类型</p><p>3.构造器引用举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Supplier中的T get()</span></span><br><span class="line">   <span class="comment">//Employee的空参构造器：Employee()</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       Supplier&lt;Employee&gt; sup = <span class="keyword">new</span> Supplier&lt;Employee&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> Employee <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> Employee();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">       System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">       Supplier&lt;Employee&gt;  sup1 = () -&gt; <span class="keyword">new</span> Employee();</span><br><span class="line">       System.out.println(sup1.get());</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">       Supplier&lt;Employee&gt;  sup2 = Employee :: <span class="keyword">new</span>;</span><br><span class="line">       System.out.println(sup2.get());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Function中的R apply(T t)</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Function&lt;Integer,Employee&gt; func1 = id -&gt; <span class="keyword">new</span> Employee(id);</span><br><span class="line">       Employee employee = func1.apply(<span class="number">1001</span>);</span><br><span class="line">       System.out.println(employee);</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">       Function&lt;Integer,Employee&gt; func2 = Employee :: <span class="keyword">new</span>;</span><br><span class="line">       Employee employee1 = func2.apply(<span class="number">1002</span>);</span><br><span class="line">       System.out.println(employee1);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BiFunction中的R apply(T t,U u)</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">       BiFunction&lt;Integer,String,Employee&gt; func1 = (id,name) -&gt; <span class="keyword">new</span> Employee(id,name);</span><br><span class="line">       System.out.println(func1.apply(<span class="number">1001</span>,<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">       BiFunction&lt;Integer,String,Employee&gt; func2 = Employee :: <span class="keyword">new</span>;</span><br><span class="line">       System.out.println(func2.apply(<span class="number">1002</span>,<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>4.数组引用格式：数组类型[] :: new</p><p>5.数组引用举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Function中的R apply(T t)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Function&lt;Integer,String[]&gt; func1 = length -&gt; <span class="keyword">new</span> String[length];</span><br><span class="line">    String[] arr1 = func1.apply(<span class="number">5</span>);</span><br><span class="line">    System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Function&lt;Integer,String[]&gt; func2 = String[] :: <span class="keyword">new</span>;</span><br><span class="line">    String[] arr2 = func2.apply(<span class="number">10</span>);</span><br><span class="line">    System.out.println(Arrays.toString(arr2));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="重点：Stream-API"><a href="#重点：Stream-API" class="headerlink" title="重点：Stream API"></a>重点：Stream API</h1><h2 id="1-Stream-API的理解："><a href="#1-Stream-API的理解：" class="headerlink" title="1.Stream API的理解："></a>1.Stream API的理解：</h2><p>1.1 Stream关注的是对数据的运算，与CPU打交道<br>集合关注的是数据的存储，与内存打交道</p><p>1.2 java8提供了一套api,使用这套api可以对内存中的数据进行过滤、排序、映射、归约等操作。类似于sql对数据库中表的相关操作。</p><h2 id="2-注意点："><a href="#2-注意点：" class="headerlink" title="2.注意点："></a>2.注意点：</h2><ul><li>①Stream 自己不会存储元素。</li><li>②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</li><li>③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</li></ul><h2 id="3-Stream的使用流程："><a href="#3-Stream的使用流程：" class="headerlink" title="3.Stream的使用流程："></a>3.Stream的使用流程：</h2><ul><li>① Stream的实例化</li><li>② 一系列的中间操作（过滤、映射、…)</li><li>③ 终止操作</li></ul><h2 id="4-使用流程的注意点："><a href="#4-使用流程的注意点：" class="headerlink" title="4.使用流程的注意点："></a>4.使用流程的注意点：</h2><ul><li>4.1 一个中间操作链，对数据源的数据进行处理</li><li>4.2 一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用</li></ul><h2 id="5-步骤一：Stream实例化"><a href="#5-步骤一：Stream实例化" class="headerlink" title="5.步骤一：Stream实例化"></a>5.步骤一：Stream实例化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建 Stream方式一：通过集合</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        default Stream&lt;E&gt; stream() : 返回一个顺序流(数据顺序可以得到保证)</span></span><br><span class="line">        Stream&lt;Employee&gt; stream = employees.stream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        default Stream&lt;E&gt; parallelStream() : 返回一个并行流(数据顺序得不到保证)</span></span><br><span class="line">        Stream&lt;Employee&gt; parallelStream = employees.parallelStream();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 Stream方式二：通过数组</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="comment">//调用Arrays类的static &lt;T&gt; Stream&lt;T&gt; stream(T[] array): 返回一个流</span></span><br><span class="line">        IntStream stream = Arrays.stream(arr);</span><br><span class="line"></span><br><span class="line">        Employee e1 = <span class="keyword">new</span> Employee(<span class="number">1001</span>,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        Employee e2 = <span class="keyword">new</span> Employee(<span class="number">1002</span>,<span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">        Employee[] arr1 = <span class="keyword">new</span> Employee[]&#123;e1,e2&#125;;</span><br><span class="line">        Stream&lt;Employee&gt; stream1 = Arrays.stream(arr1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建 Stream方式三：通过Stream的of()</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 Stream方式四：创建无限流</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//      迭代</span></span><br><span class="line"><span class="comment">//      public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)</span></span><br><span class="line">        <span class="comment">//遍历前10个偶数</span></span><br><span class="line">        Stream.iterate(<span class="number">0</span>, t -&gt; t + <span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println); <span class="comment">//foreach里面用的是函数式接口Consumer</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//      生成</span></span><br><span class="line"><span class="comment">//      public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</span></span><br><span class="line">        Stream.generate(Math::random).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-步骤二：中间操作"><a href="#6-步骤二：中间操作" class="headerlink" title="6.步骤二：中间操作"></a>6.步骤二：中间操作</h2><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220801101831599.png" alt="image-20220801101831599"></p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220801101848504.png" alt="image-20220801101848504"></p><h2 id="7-步骤三：终止操作"><a href="#7-步骤三：终止操作" class="headerlink" title="7.步骤三：终止操作"></a>7.步骤三：终止操作</h2><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220801101949286.png" alt="image-20220801101949286"></p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220801102041093.png" alt="image-20220801102041093"></p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220801102118432.png" alt="image-20220801102118432"></p><h2 id="Stream中间操作举例"><a href="#Stream中间操作举例" class="headerlink" title="Stream中间操作举例"></a>Stream中间操作举例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 测试Stream的中间操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamAPITest1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1-筛选与切片</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class="line">        <span class="comment">//filter(Predicate p)-接收 Lambda，从流中排除某些元素</span></span><br><span class="line">        Stream&lt;Employee&gt; stream = list.stream();</span><br><span class="line">        <span class="comment">//查询员工表中薪资大于7000的员工信息</span></span><br><span class="line">        stream.filter(e -&gt; e.getSalary() &gt; <span class="number">7000</span>).forEach(System.out::println);</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//limit(n)- 截断流，使其元素不超过给定数量</span></span><br><span class="line">        <span class="comment">//截取前三条数据</span></span><br><span class="line">        list.stream().limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//skip(n) - 跳过元素，返回一个扔掉了前n个元素的流 若流中元素不足n个，则返回一个空流 与limit(n)互补</span></span><br><span class="line">        list.stream().skip(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//distinct() - 筛选，通过流所生成元素的hashCode()和equals()去除重复元素</span></span><br><span class="line">        list.add(<span class="keyword">new</span> Employee(<span class="number">1010</span>,<span class="string">&quot;刘强东&quot;</span>,<span class="number">40</span>,<span class="number">8000</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Employee(<span class="number">1010</span>,<span class="string">&quot;刘强东&quot;</span>,<span class="number">40</span>,<span class="number">8000</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Employee(<span class="number">1010</span>,<span class="string">&quot;刘强东&quot;</span>,<span class="number">40</span>,<span class="number">8000</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Employee(<span class="number">1010</span>,<span class="string">&quot;刘强东&quot;</span>,<span class="number">40</span>,<span class="number">8000</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Employee(<span class="number">1010</span>,<span class="string">&quot;刘强东&quot;</span>,<span class="number">40</span>,<span class="number">8000</span>));</span><br><span class="line"> </span><br><span class="line">        System.out.println(list);</span><br><span class="line">        System.out.println();</span><br><span class="line"> </span><br><span class="line">        list.stream().distinct().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//2-映射</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//map(Function f)-接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应用到每个元素上，并将其映射成一个新的元素</span></span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;dd&quot;</span>);</span><br><span class="line">        list.stream().map(str -&gt; str.toUpperCase()).forEach(System.out::println);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//练习1：获取员工姓名长度大于3的员工的姓名</span></span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">        Stream&lt;String&gt; namesStream = employees.stream().map(Employee::getName);</span><br><span class="line">        namesStream.filter(name -&gt; name.length() &gt; <span class="number">3</span>).forEach(System.out::println);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//练习2：</span></span><br><span class="line">        Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream().map(StreamAPITest1::fromStringToStream);</span><br><span class="line">        streamStream.forEach(s -&gt; &#123;</span><br><span class="line">            s.forEach(System.out::println);</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//flatMap(Function f)-接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</span></span><br><span class="line">        Stream&lt;Character&gt; characterStream = list.stream().flatMap(StreamAPITest1::fromStringToStream);</span><br><span class="line">        characterStream.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//将字符串中的多个字符构成的集合转换为对应的Stream的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Character&gt; <span class="title">fromStringToStream</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Character&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Character c : str.toCharArray())&#123;</span><br><span class="line">            list.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.stream();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ArrayList list1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list1.add(<span class="number">1</span>);</span><br><span class="line">        list1.add(<span class="number">2</span>);</span><br><span class="line">        list1.add(<span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line">        ArrayList list2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list2.add(<span class="number">4</span>);</span><br><span class="line">        list2.add(<span class="number">5</span>);</span><br><span class="line">        list2.add(<span class="number">6</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//        list1.add(list2);</span></span><br><span class="line">        list1.addAll(list2);</span><br><span class="line">        System.out.println(list1);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//3-排序</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//sorted()-自然排序</span></span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">12</span>, <span class="number">43</span>, <span class="number">65</span>, <span class="number">34</span>, <span class="number">87</span>, <span class="number">0</span>, -<span class="number">98</span>, <span class="number">7</span>);</span><br><span class="line">        list.stream().sorted().forEach(System.out::println);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//抛异常，原因：Employee没有实现Comparable接口</span></span><br><span class="line"><span class="comment">//        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span></span><br><span class="line"><span class="comment">//        employees.stream().sorted().forEach(System.out::println);</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//sorted(Comparator com)-定制排序</span></span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">        employees.stream().sorted((e1,e2) -&gt; Integer.compare(e1.getAge(), e2.getAge()))</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Stream的终止操作举例：匹配与查找、归约、收集"><a href="#Stream的终止操作举例：匹配与查找、归约、收集" class="headerlink" title="Stream的终止操作举例：匹配与查找、归约、收集"></a>Stream的终止操作举例：匹配与查找、归约、收集</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 测试Stream的终止操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1-匹配与查找</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">        <span class="comment">//allMatch(Predicate p)-检查是否匹配所有元素</span></span><br><span class="line">        <span class="comment">//练习：是否所有的员工的年龄都大于18</span></span><br><span class="line">        <span class="keyword">boolean</span> allMatch = employees.stream().allMatch(e -&gt; e.getAge() &gt; <span class="number">18</span>);</span><br><span class="line">        System.out.println(allMatch);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//anyMatch(Predicate p)-检查是否至少匹配一个元素。</span></span><br><span class="line">        <span class="comment">//练习：是否存在员工的工资大于10000</span></span><br><span class="line">        <span class="keyword">boolean</span> anyMatch = employees.stream().anyMatch(e -&gt; e.getSalary() &gt; <span class="number">10000</span>);</span><br><span class="line">        System.out.println(anyMatch);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment">//noneMatch(Predicate p)-检查是否没有匹配的元素</span></span><br><span class="line">        <span class="comment">//练习：是否存在员工姓&quot;雷&quot;</span></span><br><span class="line">        <span class="keyword">boolean</span> noneMatch = employees.stream().noneMatch(e -&gt; e.getName().startsWith(<span class="string">&quot;雷&quot;</span>));</span><br><span class="line">        System.out.println(noneMatch);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//findFirst-返回第一个元素</span></span><br><span class="line">        Optional&lt;Employee&gt; employee = employees.stream().findFirst();</span><br><span class="line">        System.out.println(employee);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//findAny-返回当前流中的任意元素</span></span><br><span class="line">        Optional&lt;Employee&gt; employee1 = employees.parallelStream().findAny();</span><br><span class="line">        System.out.println(employee1);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">        <span class="comment">//count-返回流中元素的总个数</span></span><br><span class="line">        <span class="keyword">long</span> count = employees.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">5000</span>).count();</span><br><span class="line">        System.out.println(count);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//max(Comparator c)-返回流中最大值</span></span><br><span class="line">        <span class="comment">//练习：返回最高的工资</span></span><br><span class="line">        Stream&lt;Double&gt; salaryStream = employees.stream().map(e -&gt; e.getSalary());</span><br><span class="line">        Optional&lt;Double&gt; maxSalary = salaryStream.max(Double::compare);</span><br><span class="line">        System.out.println(maxSalary);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment">//min(Comparator c)-返回流中最小值</span></span><br><span class="line">        <span class="comment">//练习：返回最低工资的员工</span></span><br><span class="line">        Optional&lt;Employee&gt; employee = employees.stream().min((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()));</span><br><span class="line">        System.out.println(employee);</span><br><span class="line">        System.out.println();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment">//forEach(Consumer c)-内部迭代</span></span><br><span class="line">        employees.stream().forEach(System.out::println);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//使用集合的遍历操作</span></span><br><span class="line">        employees.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//2-归约</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//reduce(T identity, BinaryOperator)-可以将流中元素反复结合起来，得到一个值 返回T</span></span><br><span class="line">        <span class="comment">//练习1：计算1-10的自然数的和</span></span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">        Integer sum = list.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//reduce(BinaryOperator)-可以将流中元素反复结合起来，得到一个值 返回Optional&lt;T&gt;</span></span><br><span class="line">        <span class="comment">//练习2：计算公司所有员工工资的总和</span></span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">        Stream&lt;Double&gt; salaryStream = employees.stream().map(Employee::getSalary);</span><br><span class="line"><span class="comment">//        Optional&lt;Double&gt; sumMoney = salaryStream.reduce(Double::sum);</span></span><br><span class="line">        Optional&lt;Double&gt; sumMoney = salaryStream.reduce((d1,d2) -&gt; d1 + d2);</span><br><span class="line">        System.out.println(sumMoney);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//3-收集</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//collect(Collector c)-将流转换为其他形式 接收一个Collector接口的实现，用于给Stream中元素做汇总的方法</span></span><br><span class="line">        <span class="comment">//练习1：查找工资大于6000的员工，结果返回为一个List或Set</span></span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">        List&lt;Employee&gt; employeeList = employees.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">6000</span>).collect(Collectors.toList());</span><br><span class="line">        employeeList.forEach(System.out::println);</span><br><span class="line"> </span><br><span class="line">        System.out.println();</span><br><span class="line"> </span><br><span class="line">        Set&lt;Employee&gt; employeeSet = employees.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">6000</span>).collect(Collectors.toSet());</span><br><span class="line">        employeeSet.forEach(System.out::println);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="java-util-Optional类"><a href="#java-util-Optional类" class="headerlink" title="java.util.Optional类"></a>java.util.Optional类</h1><h2 id="1-理解：为了解决java中的空指针问题而生！"><a href="#1-理解：为了解决java中的空指针问题而生！" class="headerlink" title="1.理解：为了解决java中的空指针问题而生！"></a>1.理解：为了解决java中的空指针问题而生！</h2><p>Optional<T> 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null<br>，表示这个值不存在。原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避<br>免空指针异常。</p><h2 id="2-常用方法："><a href="#2-常用方法：" class="headerlink" title="2.常用方法："></a>2.常用方法：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//empty():创建的Optional对象内部的value = null</span></span><br><span class="line">        Optional&lt;Object&gt; op1 = Optional.empty();</span><br><span class="line">        <span class="keyword">if</span>(!op1.isPresent())&#123;<span class="comment">//Optional封装的数据是否包含数据</span></span><br><span class="line">            System.out.println(<span class="string">&quot;数据为空&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(op1);</span><br><span class="line">        System.out.println(op1.isPresent());</span><br><span class="line">        <span class="comment">//如果Optional封装的数据value为空，则get()报错。否则，value不为空时，返回value.</span></span><br><span class="line"><span class="comment">//        System.out.println(op1.get());</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">//        str = null;</span></span><br><span class="line">        <span class="comment">//of(T t):封装数据t生成Optional对象。要求t非空，否则报错。</span></span><br><span class="line">        Optional&lt;String&gt; op1 = Optional.of(str);</span><br><span class="line">        <span class="comment">//get()通常与of()方法搭配使用。用于获取内部的封装的数据value</span></span><br><span class="line">        String str1 = op1.get();</span><br><span class="line">        System.out.println(str1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;beijing&quot;</span>;</span><br><span class="line">        str = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//ofNullable(T t) ：封装数据t赋给Optional内部的value。不要求t非空</span></span><br><span class="line">        Optional&lt;String&gt; op1 = Optional.ofNullable(str);</span><br><span class="line">        <span class="comment">//orElse(T t1):如果Optional内部的value非空，则返回此value值。如果</span></span><br><span class="line">        <span class="comment">//value为空，则返回t1.</span></span><br><span class="line">        String str2 = op1.orElse(<span class="string">&quot;shanghai&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(str2);<span class="comment">//</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3-典型练习："><a href="#3-典型练习：" class="headerlink" title="3.典型练习："></a>3.典型练习：</h2><p>能保证如下的方法执行中不会出现空指针的异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Optional类的getGirlName():</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getGirlName2</span><span class="params">(Boy boy)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Optional&lt;Boy&gt; boyOptional = Optional.ofNullable(boy);</span><br><span class="line">    <span class="comment">//此时的boy1一定非空</span></span><br><span class="line">    Boy boy1 = boyOptional.orElse(<span class="keyword">new</span> Boy(<span class="keyword">new</span> Girl(<span class="string">&quot;迪丽热巴&quot;</span>)));</span><br><span class="line"></span><br><span class="line">    Girl girl = boy1.getGirl();</span><br><span class="line"></span><br><span class="line">    Optional&lt;Girl&gt; girlOptional = Optional.ofNullable(girl);</span><br><span class="line">    <span class="comment">//girl1一定非空</span></span><br><span class="line">    Girl girl1 = girlOptional.orElse(<span class="keyword">new</span> Girl(<span class="string">&quot;古力娜扎&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> girl1.getName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Boy boy = <span class="keyword">null</span>;</span><br><span class="line">    boy = <span class="keyword">new</span> Boy();</span><br><span class="line">    boy = <span class="keyword">new</span> Boy(<span class="keyword">new</span> Girl(<span class="string">&quot;苍老师&quot;</span>));</span><br><span class="line">    String girlName = getGirlName2(boy);</span><br><span class="line">    System.out.println(girlName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lambada、方法引用、stream流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/07/30/hello-world/"/>
      <url>/2022/07/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>groupBy用法和原理</title>
      <link href="/2022/06/10/groupBy%E7%94%A8%E6%B3%95%E5%92%8C%E5%8E%9F%E7%90%86/"/>
      <url>/2022/06/10/groupBy%E7%94%A8%E6%B3%95%E5%92%8C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="关于group-by的用法-原理"><a href="#关于group-by的用法-原理" class="headerlink" title="关于group by的用法 原理"></a>关于group by的用法 原理</h1><p>摘自 —<a href="https://blog.csdn.net/u014717572">燕山八音</a></p><p>先来看下表1，表名为test：</p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/mysql1.jpg" alt="mysql1"></p><p>执行如下SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  name  <span class="keyword">FROM</span>  test</span><br><span class="line"><span class="keyword">GROUP</span>  <span class="keyword">BY</span>  name</span><br></pre></td></tr></table></figure><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/mysql2.jpg" alt="mysql2"></p><p>可是为了能够更好的理解<strong>“group by”多个列“</strong>和<strong>”聚合函数“</strong>的应用，我建议在思考的过程中，由表1到表2的过程中，增加一个虚构的中间表：<strong>虚拟表3</strong>。下面说说如何来思考上面SQL语句执行情况：</p><p>1.FROM test：该句执行后，应该结果和表1一样，就是原来的表。</p><p>2.FROM test Group BY name：该句执行后，我们想象生成了<strong>虚拟表3，</strong>如下所图所示，生成过程是这样的：group by name，那么找name那一列，具有相同name值的行，合并成一行，如对于name值为aa的，那么&lt;1 aa 2&gt;与&lt;2 aa 3&gt;两行合并成1行，所有的id值和number值写到一个单元格里面。</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/mysql3.jpg" alt="mysql3"></p><p>3.接下来就要针对<strong>虚拟表3</strong>执行Select语句了：</p><p>（1）如果执行select *的话，那么返回的结果应该是虚拟表3，可是id和number中有的单元格里面的内容是多个值的，而关系数据库就是基于关系的，单元格中是不允许有多个值的，所以你看，执行select * 语句就报错了。</p><p>（2）我们再看name列，每个单元格只有一个数据，所以我们select name的话，就没有问题了。为什么name列每个单元格只有一个值呢，因为我们就是用name列来group by的。</p><p>（3）那么对于id和number里面的单元格有多个数据的情况怎么办呢？答案就是用<strong>聚合函数，聚合函数就用来输入多个数据，输出一个数据的。</strong>如cout(id)，sum(number)，而每个聚合函数的输入就是每一个多数据的单元格。</p><p>（4）例如我们执行select name,sum(number) from test group by name，那么sum就对虚拟表3的number列的每个单元格进行sum操作，例如对name为aa的那一行的number列执行sum操作，即2+3，返回5，最后执行结果如下：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/mysql4.jpg" alt="mysql4"></p><p> （5）group by 多个字段该怎么理解呢：如group by name,number，我们可以把name和number 看成一个<strong>整体字段</strong>，</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> group by用法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内连接与子查询的区别</title>
      <link href="/2022/06/06/%E5%86%85%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/06/06/%E5%86%85%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="内连接和子查询的区别"><a href="#内连接和子查询的区别" class="headerlink" title="内连接和子查询的区别"></a>内连接和子查询的区别</h1><h3 id="一-子查询"><a href="#一-子查询" class="headerlink" title="一 子查询"></a><strong>一 子查询</strong></h3><p>1 MySQL从4.1版本开始支持子查询，使用子查询进行SELECT语句嵌套查询，可以一次完成很多逻辑上需要多个步骤才能完成的SQL操作</p><p>2 子查询虽然很灵活，但是执行效率并不高</p><p>3 执行子查询时，SQL语句中进行嵌套了SQL语句, 这就类似于循环了</p><p>4 例如有两张表, 我先查一张表,查一次, 然后拿这个结果去筛选查另一张表,查两次<strong>（增加了回表操作!!!）</strong></p><h3 id="二-连接查询-join"><a href="#二-连接查询-join" class="headerlink" title="二 连接查询(join)"></a>二 连接查询(join)</h3><p>1 可以使用连接查询(JOIN)代替子查询，连接查询需要建立临时表，,但因为联表操作不需要查询数据, 只需要在联表成新表之后查询一次, 因此其速度比子查询快</p><p>2 表关联是可以利用两个表的索引的，如果是用子查询，至少第二次查询是没有办法使用索引的</p><p>3 例如两张表, 我先把两张表拼在一起, 不查, 再查拼起来的新表, 查一次</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>​    两者不存在谁优于谁的说法，只是那种更适应某种环境。一般要看你是什么用途，如果数据量少的话可以子查询，或者经常用的数据就使用子查询，不经常用的就连接查询，适习惯而定，当然是指数据量少的情况下。</p><p> 一般来讲连接查询效率更高，因为子查询会多次遍历数据，而连接查询只遍历一次，但是如果数据量较少的话子查询更加容易控制。但如果数据量大的话两者的区别就会很明显，对于数据量多的肯定是用连接查询快些，原因：因为子查询会多次遍历所有的数据（视你的子查询的层次而定），如果你的子查询是在无限套娃，且每张表数据量不大，使用子查询效率高。</p><p> 连接查询只会遍历一次，但是数据量少的话也就无所谓是连接查询还是子查询，多表数据量大建议采用连接查询。</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内连接与子查询 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据流中位数</title>
      <link href="/2022/06/01/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
      <url>/2022/06/01/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="数据流的中位数"><a href="#数据流的中位数" class="headerlink" title="数据流的中位数"></a>数据流的中位数</h1><p>题目如下，是一道困难题，但是只要思路掌握了还是比较好做的。</p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220801150420421.png" alt="image-20220801150420421"></p><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>数据流可以随意增加，那我们如何在O（1）的时间复杂度内获取到中位数呢。肯定是要借助于构建相关的数据结构。</p><h2 id="构建想法："><a href="#构建想法：" class="headerlink" title="构建想法："></a>构建想法：</h2><p>将数据流分为两半，前一半和后一半，前一半保存在大顶堆里，这样它最大数就暴露的出来；后一半保存在小顶堆里这样它的最小数就暴露了出来；我们需要的中位数，就是在这两个数之间产生。在添加数据的时候<strong>要保证小数(small)的所有数都比大数的要大，且两个堆的数字个数差值不超过1</strong></p><h2 id="重要代码结构"><a href="#重要代码结构" class="headerlink" title="重要代码结构"></a>重要代码结构</h2><p>获取中位数的代码<code>findMedian</code>比较好些，而添加数据流的<code>addNum</code>则颇具技巧，需要自己掌握！</p><p>当我们需要往大顶堆里添加数据时，我们像将其添加到小顶堆里，在将小顶堆中最小的数取出来，放在大顶堆中；</p><p>当我们需要往小顶堆里添加数据时，我们像将其添加到大顶堆里，在将大顶堆中最小的数取出来，放在小顶堆中；</p><p>这样以来就满足了我们的题目设定 <strong>要保证小数(small)的所有数都比大数的要大，且两个堆的数字个数差值不超过1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(smallHeap.size()&gt;largeHeap.size())&#123;</span><br><span class="line">           smallHeap.offer(num);</span><br><span class="line">           largeHeap.offer(smallHeap.poll());</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           largeHeap.offer(num);</span><br><span class="line">           smallHeap.offer(largeHeap.poll());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt;largeHeap;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt;smallHeap;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        largeHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b)-&gt; &#123;<span class="keyword">return</span> b-a;&#125;); <span class="comment">//大数在堆顶</span></span><br><span class="line">        smallHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(); <span class="comment">//小数在堆顶</span></span><br><span class="line">        <span class="comment">//要保证小数(small)的所有数都比大数的要大，且两个堆的数字个数差值不超过1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(smallHeap.size()&gt;largeHeap.size())&#123;</span><br><span class="line">            smallHeap.offer(num);</span><br><span class="line">            largeHeap.offer(smallHeap.poll());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            largeHeap.offer(num);</span><br><span class="line">            smallHeap.offer(largeHeap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(largeHeap.size()&gt;smallHeap.size())</span><br><span class="line">            <span class="keyword">return</span> largeHeap.peek();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(smallHeap.size()&gt;largeHeap.size())</span><br><span class="line">            <span class="keyword">return</span> smallHeap.peek();</span><br><span class="line">        <span class="keyword">return</span> (largeHeap.peek()+smallHeap.peek())/<span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优先队列的使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内连接与子查询区别</title>
      <link href="/2022/06/01/%E5%86%85%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%AD%90%E6%9F%A5%E8%AF%A2%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/06/01/%E5%86%85%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%AD%90%E6%9F%A5%E8%AF%A2%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="内连接和子查询的区别"><a href="#内连接和子查询的区别" class="headerlink" title="内连接和子查询的区别"></a>内连接和子查询的区别</h1><h3 id="一-子查询"><a href="#一-子查询" class="headerlink" title="一 子查询"></a><strong>一 子查询</strong></h3><p>1 MySQL从4.1版本开始支持子查询，使用子查询进行SELECT语句嵌套查询，可以一次完成很多逻辑上需要多个步骤才能完成的SQL操作</p><p>2 子查询虽然很灵活，但是执行效率并不高</p><p>3 执行子查询时，SQL语句中进行嵌套了SQL语句, 这就类似于循环了</p><p>4 例如有两张表, 我先查一张表,查一次, 然后拿这个结果去筛选查另一张表,查两次<strong>（增加了回表操作!!!）</strong></p><h3 id="二-连接查询-join"><a href="#二-连接查询-join" class="headerlink" title="二 连接查询(join)"></a>二 连接查询(join)</h3><p>1 可以使用连接查询(JOIN)代替子查询，连接查询需要建立临时表，,但因为联表操作不需要查询数据, 只需要在联表成新表之后查询一次, 因此其速度比子查询快</p><p>2 表关联是可以利用两个表的索引的，如果是用子查询，至少第二次查询是没有办法使用索引的</p><p>3 例如两张表, 我先把两张表拼在一起, 不查, 再查拼起来的新表, 查一次</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>​    两者不存在谁优于谁的说法，只是那种更适应某种环境。一般要看你是什么用途，如果数据量少的话可以子查询，或者经常用的数据就使用子查询，不经常用的就连接查询，适习惯而定，当然是指数据量少的情况下。</p><p> 一般来讲连接查询效率更高，因为子查询会多次遍历数据，而连接查询只遍历一次，但是如果数据量较少的话子查询更加容易控制。但如果数据量大的话两者的区别就会很明显，对于数据量多的肯定是用连接查询快些，原因：因为子查询会多次遍历所有的数据（视你的子查询的层次而定），如果你的子查询是在无限套娃，且每张表数据量不大，使用子查询效率高。</p><p> 连接查询只会遍历一次，但是数据量少的话也就无所谓是连接查询还是子查询，多表数据量大建议采用连接查询。</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内连接与子查询区别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java反射</title>
      <link href="/2022/05/30/java%E5%8F%8D%E5%B0%84/"/>
      <url>/2022/05/30/java%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="java反射"><a href="#java反射" class="headerlink" title="java反射"></a>java反射</h1><p>反射主要用于当程序编译时，无法确定创建一个什么样的对象，需要在运行期间确定！</p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220731153220891.png" alt="image-20220731153220891"></p><p><strong>Java反射机制提供的功能</strong></p><ul><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时判断任意一个类所具有的成员变量和方法</li><li>在运行时获取泛型信息</li><li>在运行时调用任意一个对象的成员变量和方法</li><li>在运行时处理注解</li><li>生成动态代理  </li></ul><h2 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> 哪些类型可以有Class对象？ </span><br><span class="line">（<span class="number">1</span>）外部类， 成员(成员内部类， 静态内部类)， 局部内部类， 匿名内部类</span><br><span class="line">（<span class="number">2</span>） <span class="class"><span class="keyword">interface</span>： 接口</span></span><br><span class="line"><span class="class">（3） []：数组</span></span><br><span class="line"><span class="class">（4） <span class="title">enum</span>：枚举</span></span><br><span class="line"><span class="class">（5） <span class="title">annotation</span>：注解@<span class="title">interface</span></span></span><br><span class="line"><span class="class">（6） <span class="title">primitive</span> <span class="title">type</span>：基本数据类型</span></span><br><span class="line"><span class="class">（7） <span class="title">void</span></span></span><br><span class="line"><span class="class">/*<span class="title">Class</span>类的理解</span></span><br><span class="line"><span class="class">1.类的加载过程：程序经过<span class="title">javac</span>.<span class="title">exe</span>命令以后，会生成一个或多个字节码文件(.<span class="title">class</span>结尾)。接着我们使用<span class="title">java</span>.<span class="title">exe</span>命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。此过程就称为类的加载。加载到内存中的类，我们就称为运行时类，此运行时类，就作为<span class="title">Class</span>的一个实例。</span></span><br><span class="line"><span class="class">2.换句话说，<span class="title">Class</span>的实例就对应着一个运行时类。</span></span><br><span class="line"><span class="class">3.加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式来获取此运行时类。*/</span></span><br></pre></td></tr></table></figure><ul><li>对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口，对于每个类而言， JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个结构(class/interface/enum/annotation/primitive type/void/[])的有关信息。</li><li> Class本身也是一个类</li><li> Class 对象只能由系统建立对象</li><li>一个加载的类在 JVM 中只会有一个Class实例</li><li> 一个Class对象对应的是一个加载到JVM中的一个.class文件</li><li>每个类的实例都会记得自己是由哪个 Class 实例所生成</li><li>通过Class可以完整地得到一个类中的所有被加载的结构</li><li>Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象  </li></ul><h3 id="class-类的常用方法"><a href="#class-类的常用方法" class="headerlink" title="class 类的常用方法"></a>class 类的常用方法</h3><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220731154538876.png" alt="image-20220731154538876"></p><h3 id="获取Class实例的几种方式"><a href="#获取Class实例的几种方式" class="headerlink" title="获取Class实例的几种方式"></a>获取Class实例的几种方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取Class实例的几种方式</span></span><br><span class="line"><span class="comment">//方式一：调用运行时类的属性：.class</span></span><br><span class="line">Class clazz1 = Person.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：通过运行时类的对象,调用getClass()</span></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">Class clazz2 = p1.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式三：调用Class的静态方法：forName(String classPath)</span></span><br><span class="line">Class clazz3 = Class.forName(<span class="string">&quot;com.atguigu.java.Person&quot;</span>);</span><br><span class="line">clazz3 = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式四：使用类的加载器：ClassLoader  (了解)</span></span><br><span class="line">ClassLoader classLoader = ReflectionTest.class.getClassLoader();</span><br><span class="line">Class clazz4 = classLoader.loadClass(<span class="string">&quot;com.atguigu.java.Person&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建一个指定类的对象。</span></span><br><span class="line"><span class="comment">classPath:指定类的全类名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(String classPath)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   Class clazz =  Class.forName(classPath);</span><br><span class="line">   <span class="keyword">return</span> clazz.newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="classloader"><a href="#classloader" class="headerlink" title="classloader"></a>classloader</h2><h3 id="1、类加载过程"><a href="#1、类加载过程" class="headerlink" title="1、类加载过程"></a>1、类加载过程</h3><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220731160852917.png" alt="image-20220731160852917"></p><h3 id="2、类加载器作用"><a href="#2、类加载器作用" class="headerlink" title="2、类加载器作用"></a>2、类加载器作用</h3><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220731160929702.png" alt="image-20220731160929702"></p><h3 id="3、类加载器分类"><a href="#3、类加载器分类" class="headerlink" title="3、类加载器分类"></a>3、类加载器分类</h3><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220731161002326.png" alt="image-20220731161002326"></p><h3 id="4、java类编译运行的执行流程"><a href="#4、java类编译运行的执行流程" class="headerlink" title="4、java类编译运行的执行流程"></a>4、java类编译运行的执行流程</h3><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220731161103004.png" alt="image-20220731161103004"></p><h3 id="5、使用Classloader加载src目录下的配置文件"><a href="#5、使用Classloader加载src目录下的配置文件" class="headerlink" title="5、使用Classloader加载src目录下的配置文件"></a>5、使用Classloader加载src目录下的配置文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Properties pros =  <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//此时的文件默认在当前的module下。</span></span><br><span class="line">        <span class="comment">//读取配置文件的方式一：</span></span><br><span class="line"><span class="comment">//        FileInputStream fis = new FileInputStream(&quot;jdbc.properties&quot;);</span></span><br><span class="line"><span class="comment">//        FileInputStream fis = new FileInputStream(&quot;src\\jdbc1.properties&quot;);</span></span><br><span class="line"><span class="comment">//        pros.load(fis);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取配置文件的方式二：使用ClassLoader</span></span><br><span class="line">        <span class="comment">//配置文件默认识别为：当前module的src下</span></span><br><span class="line">        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();</span><br><span class="line">        InputStream is = classLoader.getResourceAsStream(<span class="string">&quot;jdbc1.properties&quot;</span>);</span><br><span class="line">        pros.load(is);</span><br><span class="line"></span><br><span class="line">        String user = pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        String password = pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user = &quot;</span> + user + <span class="string">&quot;,password = &quot;</span> + password);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="反射应用举例"><a href="#反射应用举例" class="headerlink" title="反射应用举例"></a>反射应用举例</h2><h3 id="应用一：创建运行时类的对象"><a href="#应用一：创建运行时类的对象" class="headerlink" title="应用一：创建运行时类的对象"></a>应用一：创建运行时类的对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>代码举例</span><br><span class="line">Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line"></span><br><span class="line">Person obj = clazz.newInstance();</span><br><span class="line">System.out.println(obj);</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>说明</span><br><span class="line">newInstance():调用此方法，创建对应的运行时类的对象。内部调用了运行时类的空参的构造器。</span><br><span class="line"></span><br><span class="line">要想此方法正常的创建运行时类的对象，要求：</span><br><span class="line"><span class="number">1.</span>运行时类必须提供空参的构造器</span><br><span class="line"><span class="number">2.</span>空参的构造器的访问权限得够。通常，设置为<span class="keyword">public</span>。</span><br><span class="line"></span><br><span class="line">在javabean中要求提供一个<span class="keyword">public</span>的空参构造器。原因：</span><br><span class="line"><span class="number">1.</span>便于通过反射，创建运行时类的对象</span><br><span class="line"><span class="number">2.</span>便于子类继承此运行时类时，默认调用<span class="keyword">super</span>()时，保证父类此构造器</span><br></pre></td></tr></table></figure><h3 id="应用二：获取运行时类的指定结构"><a href="#应用二：获取运行时类的指定结构" class="headerlink" title="应用二：获取运行时类的指定结构"></a>应用二：获取运行时类的指定结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">调用指定的属性：</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testField1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建运行时类的对象</span></span><br><span class="line">    Person p = (Person) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. getDeclaredField(String fieldName):获取运行时类中指定变量名的属性</span></span><br><span class="line">    Field name = clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.保证当前属性是可访问的</span></span><br><span class="line">    name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//3.获取、设置指定对象的此属性值</span></span><br><span class="line">    name.set(p,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(name.get(p));</span><br><span class="line">&#125;</span><br><span class="line">调用指定的方法：</span><br><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class clazz = Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建运行时类的对象</span></span><br><span class="line">        Person p = (Person) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.获取指定的某个方法</span></span><br><span class="line"><span class="comment">        getDeclaredMethod():参数1 ：指明获取的方法的名称  参数2：指明获取的方法的形参列表</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Method show = clazz.getDeclaredMethod(<span class="string">&quot;show&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">//2.保证当前方法是可访问的</span></span><br><span class="line">        show.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        3. 调用方法的invoke():参数1：方法的调用者  参数2：给方法形参赋值的实参</span></span><br><span class="line"><span class="comment">        invoke()的返回值即为对应类中调用的方法的返回值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Object returnValue = show.invoke(p,<span class="string">&quot;CHN&quot;</span>); <span class="comment">//String nation = p.show(&quot;CHN&quot;);</span></span><br><span class="line">        System.out.println(returnValue);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*************如何调用静态方法*****************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// private static void showDesc()</span></span><br><span class="line"></span><br><span class="line">        Method showDesc = clazz.getDeclaredMethod(<span class="string">&quot;showDesc&quot;</span>);</span><br><span class="line">        showDesc.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//如果调用的运行时类中的方法没返回值，则此invoke()返回null</span></span><br><span class="line"><span class="comment">//        Object returnVal = showDesc.invoke(null);</span></span><br><span class="line">        Object returnVal = showDesc.invoke(Person.class);</span><br><span class="line">        System.out.println(returnVal);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">调用指定的构造器：</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConstructor</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//private Person(String name)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.获取指定的构造器</span></span><br><span class="line"><span class="comment">    getDeclaredConstructor():参数：指明构造器的参数列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    Constructor constructor = clazz.getDeclaredConstructor(String.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.保证此构造器是可访问的</span></span><br><span class="line">    constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.调用此构造器创建运行时类的对象</span></span><br><span class="line">    Person per = (Person) constructor.newInstance(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    System.out.println(per);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用三：获取运行时类的完整结构"><a href="#应用三：获取运行时类的完整结构" class="headerlink" title="应用三：获取运行时类的完整结构"></a>应用三：获取运行时类的完整结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">我们可以通过反射，获取对应的运行时类中所有的属性、方法、构造器、父类、接口、父类的泛型、包、注解、异常等。。。。</span><br><span class="line">典型代码：</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line">    <span class="comment">//获取属性结构</span></span><br><span class="line">    <span class="comment">//getFields():获取当前运行时类及其父类中声明为public访问权限的属性</span></span><br><span class="line">    Field[] fields = clazz.getFields();</span><br><span class="line">    <span class="keyword">for</span>(Field f : fields)&#123;</span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getDeclaredFields():获取当前运行时类中声明的所属性。（不包含父类中声明的属性</span></span><br><span class="line">    Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span>(Field f : declaredFields)&#123;</span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getMethods():获取当前运行时类及其所父类中声明为public权限的方法</span></span><br><span class="line">    Method[] methods = clazz.getMethods();</span><br><span class="line">    <span class="keyword">for</span>(Method m : methods)&#123;</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">//getDeclaredMethods():获取当前运行时类中声明的所方法。（不包含父类中声明的方法</span></span><br><span class="line">    Method[] declaredMethods = clazz.getDeclaredMethods();</span><br><span class="line">    <span class="keyword">for</span>(Method m : declaredMethods)&#123;</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取构造器结构</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Class clazz = Person.class;</span><br><span class="line">        <span class="comment">//getConstructors():获取当前运行时类中声明为public的构造器</span></span><br><span class="line">        Constructor[] constructors = clazz.getConstructors();</span><br><span class="line">        <span class="keyword">for</span>(Constructor c : constructors)&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//getDeclaredConstructors():获取当前运行时类中声明的所的构造器</span></span><br><span class="line">        Constructor[] declaredConstructors = clazz.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span>(Constructor c : declaredConstructors)&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取运行时类的父类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Class clazz = Person.class;</span><br><span class="line"></span><br><span class="line">        Class superclass = clazz.getSuperclass();</span><br><span class="line">        System.out.println(superclass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取运行时类的带泛型的父类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Class clazz = Person.class;</span><br><span class="line"></span><br><span class="line">        Type genericSuperclass = clazz.getGenericSuperclass();</span><br><span class="line">        System.out.println(genericSuperclass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取运行时类的带泛型的父类的泛型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    代码：逻辑性代码  vs 功能性代码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Class clazz = Person.class;</span><br><span class="line"></span><br><span class="line">        Type genericSuperclass = clazz.getGenericSuperclass();</span><br><span class="line">        ParameterizedType paramType = (ParameterizedType) genericSuperclass;</span><br><span class="line">        <span class="comment">//获取泛型类型</span></span><br><span class="line">        Type[] actualTypeArguments = paramType.getActualTypeArguments();</span><br><span class="line"><span class="comment">//        System.out.println(actualTypeArguments[0].getTypeName());</span></span><br><span class="line">        System.out.println(((Class)actualTypeArguments[<span class="number">0</span>]).getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取运行时类实现的接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Class clazz = Person.class;</span><br><span class="line"></span><br><span class="line">        Class[] interfaces = clazz.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span>(Class c : interfaces)&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//获取运行时类的父类实现的接口</span></span><br><span class="line">        Class[] interfaces1 = clazz.getSuperclass().getInterfaces();</span><br><span class="line">        <span class="keyword">for</span>(Class c : interfaces1)&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        获取运行时类所在的包</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Class clazz = Person.class;</span><br><span class="line"></span><br><span class="line">        Package pack = clazz.getPackage();</span><br><span class="line">        System.out.println(pack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        获取运行时类声明的注解</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Class clazz = Person.class;</span><br><span class="line"></span><br><span class="line">        Annotation[] annotations = clazz.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span>(Annotation annos : annotations)&#123;</span><br><span class="line">            System.out.println(annos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="应用四：动态代理"><a href="#应用四：动态代理" class="headerlink" title="应用四：动态代理"></a>应用四：动态代理</h3><h4 id="代理类与被代理类需要实现同一接口，主要是为了调用方法时统一方法名）"><a href="#代理类与被代理类需要实现同一接口，主要是为了调用方法时统一方法名）" class="headerlink" title="(代理类与被代理类需要实现同一接口，主要是为了调用方法时统一方法名）"></a>(代理类与被代理类需要实现同一接口，主要是为了调用方法时统一方法名）</h4><p>1.代理模式的原理：<br>使用一个代理将对象包装起来, 然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。</p><p><strong>2.静态代理</strong><br><strong>2.1 举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">静态代理举例</span></span><br><span class="line"><span class="comment">特点：代理类和被代理类在编译期间，就确定下来了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ClothFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">produceCloth</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyClothFactory</span> <span class="keyword">implements</span> <span class="title">ClothFactory</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> ClothFactory factory;<span class="comment">//用被代理类对象进行实例化</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyClothFactory</span><span class="params">(ClothFactory factory)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produceCloth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理工厂的准备工作&quot;</span>);</span><br><span class="line">        factory.produceCloth();</span><br><span class="line">        System.out.println(<span class="string">&quot;代理工厂后续的收尾工作&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LiningClothFactory</span> <span class="keyword">implements</span> <span class="title">ClothFactory</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produceCloth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Lining工厂生产一批运动服&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建被代理类的对象</span></span><br><span class="line">        LiningClothFactory Lining = <span class="keyword">new</span> LiningClothFactory();</span><br><span class="line">        <span class="comment">//创建代理类的对象</span></span><br><span class="line">        ProxyClothFactory proxyClothFactory = <span class="keyword">new</span> ProxyClothFactory(Lining);</span><br><span class="line"> </span><br><span class="line">        proxyClothFactory.produceCloth();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.2 <strong>静态代理的缺点：</strong><br>① 代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。<br>② 每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。</p><p>3.动态代理的特点：<br>动态代理是指客户通过代理类来调用其它对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对<br>象。</p><p><strong>4.动态代理的实现</strong></p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220731165308862.png" alt="image-20220731165308862"></p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220731165340878.png" alt="image-20220731165340878"></p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220731165403824.png" alt="image-20220731165403824"></p><p><strong>4.1 需要解决的两个主要问题：</strong><br>问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象。<br>（通过<code>Proxy.newProxyInstance()</code>实现）<br>问题二：当通过代理类的对象调用方法a时，如何动态的去调用被代理类中的同名方法a。<br>(通过<code>InvocationHandler</code>接口的实现类及其方法<code>invoke()</code>) </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*动态代理实现步骤：首先通过Proxy.newProxyInstance()创建接口代理，里面的参数需要传对应的classloader、interfaces、InvocationHandler。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">其中实现接口InvocationHandler，必须实现invoke方法。在这里加入如要代理的逻辑。原被代理对象的方法调用通过method.invoke(targetObj, params)*/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">动态代理的举例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getBelief</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span> <span class="keyword">implements</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBelief</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I believe I can fly!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我喜欢吃&quot;</span> + food);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">要想实现动态代理，需要解决的问题：</span></span><br><span class="line"><span class="comment">1.如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象</span></span><br><span class="line"><span class="comment">2.当通过代理类的对象调用方法时，如何动态的去调用被代理类中的同名方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span></span>&#123;</span><br><span class="line">    <span class="comment">//调用此方法，返回一个代理类的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxyInstance</span><span class="params">(Object obj)</span></span>&#123;<span class="comment">//被代理类的对象</span></span><br><span class="line">        MyInvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler();</span><br><span class="line">        handler.bind(obj);</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(),handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Object obj;<span class="comment">//需要使用被代理类的对象进行赋值</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke()</span></span><br><span class="line">    <span class="comment">//将被代理类要执行的方法a的功能就声明在invoke()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//method:即为代理类对象调用的方法，此方法也就作为了被代理类对象要调用的方法</span></span><br><span class="line">        <span class="comment">//obj:被代理类的对象</span></span><br><span class="line">        Object returnValue = method.invoke(obj, args);</span><br><span class="line">        <span class="comment">//上述方法的返回值就作为当前类中的invoke()的返回值</span></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SuperMan superMan = <span class="keyword">new</span> SuperMan();</span><br><span class="line">        <span class="comment">//proxyInstance:代理类的对象</span></span><br><span class="line">        Human proxyInstance = (Human) ProxyFactory.getProxyInstance(superMan);</span><br><span class="line">        <span class="comment">//当通过代理类对象调用方法时，会自动的调用被代理类中同名的方法</span></span><br><span class="line">        String belief = proxyInstance.getBelief();</span><br><span class="line">        System.out.println(belief);</span><br><span class="line">        proxyInstance.eat(<span class="string">&quot;火锅&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;******************************&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        LiningClothFactory liningClothFactory = <span class="keyword">new</span> LiningClothFactory();</span><br><span class="line"> </span><br><span class="line">        ClothFactory proxyClothFactory = (ClothFactory) ProxyFactory.getProxyInstance(liningClothFactory);</span><br><span class="line"> </span><br><span class="line">        proxyClothFactory.produceCloth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序与快速排序再理解</title>
      <link href="/2022/05/15/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%86%8D%E7%90%86%E8%A7%A3/"/>
      <url>/2022/05/15/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%86%8D%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="归并排序与快速排序"><a href="#归并排序与快速排序" class="headerlink" title="归并排序与快速排序"></a>归并排序与快速排序</h1><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序就是先把左半边数组排好序，再把右半边数组排好序，然后把两半数组合并，和二叉树的后序遍历很像。</p><p>借用大佬的示例图片</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/1.jpg" alt="1"></p><p>附上这个思路的代码</p><p>这里要注意temp数组的使用！</p><p><strong>temp 数组的作用，是一次归并排序的辅助数组，原数组根据temp数组的本次记录值，来进行本次的归并排序，归并排序的起始点是lo 与 mid+1。排序分为四段：1 左半段已走完    2右半段走完      3 temp[i]&gt;temp[j]    4 else</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[]temp;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        temp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        sort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[]nums,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lo == hi)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = lo+(hi-lo)/<span class="number">2</span>;</span><br><span class="line">        sort(nums,lo,mid);  <span class="comment">//后序遍历</span></span><br><span class="line">        sort(nums,mid+<span class="number">1</span>,hi);</span><br><span class="line">        merge(nums,lo,mid,hi); <span class="comment">//按序合并</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> lo,<span class="keyword">int</span> mid,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=lo;i&lt;=hi;i++)&#123;</span><br><span class="line">            temp[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=lo,j=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p=lo;p&lt;=hi;p++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==mid+<span class="number">1</span>)&#123;</span><br><span class="line">                nums[p] = temp[j++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j == hi+<span class="number">1</span>)&#123;</span><br><span class="line">                nums[p] = temp[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(temp[i]&gt;temp[j])</span><br><span class="line">                nums[p] = temp[j++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nums[p] = temp[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><strong>快速排序是先将一个元素排好序，然后再将剩下的元素排好序</strong>。</p><p>快速排序的核心无疑是 <code>partition</code> 函数， <code>partition</code> 函数的作用是在 <code>nums[lo..hi]</code> 中寻找一个分界点 <code>p</code>，通过交换元素使得 <code>nums[lo..p-1]</code> 都小于等于 <code>nums[p]</code>，且 <code>nums[p+1..hi]</code> 都大于 <code>nums[p]</code>：</p><p>剩下的元素有哪些？左边一坨，右边一坨，去吧，对子数组进行递归，用 <code>partition</code> 函数把剩下的元素也排好序。</p><p>这里借用labuladong的作图，非常感谢这位大佬的知识付出。</p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/2.jpg" alt="2"></p><p>这里在实现partition函数过程中，很多人用的是双指针的做法，这里我采用<strong>剑指offer</strong>中的partition函数的书写方法。主要思想就是，通过small慢指针变量的移动，使得lo~small之间的元素都是小于mid。具体实现见下面的函数实现。</p><p>关于partition需要注意的点，都已注释在代码中标注了出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        sort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[]nums,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lo&gt;=hi)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> p = partition(nums,lo,hi);</span><br><span class="line">        sort(nums,lo,p-<span class="number">1</span>);</span><br><span class="line">        sort(nums,p+<span class="number">1</span>,hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[]nums,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[lo];</span><br><span class="line">        <span class="keyword">int</span> small = lo-<span class="number">1</span>; <span class="comment">//small指向当先可以确定的小于privot的位置</span></span><br><span class="line">        <span class="keyword">int</span> index = rand.nextInt(lo,hi+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> privot = nums[index];</span><br><span class="line">        swap(nums,index,hi); <span class="comment">//先将privot元素放到hi位置，所以后面的for循环遍历结束条件时i&lt;hi</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=lo;i&lt;hi;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;privot)&#123; </span><br><span class="line">                ++small; <span class="comment">//进行自加，判断该位置是否可以将i位置的元素换过来，其实这句话，就算不加也不会影响最后的结果。</span></span><br><span class="line">                <span class="keyword">if</span>(small != i)&#123;<span class="comment">// 只有当发现small 与 i位置不相等时，small与i之前才存在大于privot的的数，</span></span><br><span class="line">                    swap(nums,small,i);<span class="comment">//才能进行交换</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++small; <span class="comment">//最后再加一次的主要作用，是为了将先前放到hi位置的privot元素放到分界线处</span></span><br><span class="line">        swap(nums,small,hi);</span><br><span class="line">        <span class="keyword">return</span> small;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[]nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑马docker复习</title>
      <link href="/2022/05/12/%E9%BB%91%E9%A9%ACdocker%E5%A4%8D%E4%B9%A0/"/>
      <url>/2022/05/12/%E9%BB%91%E9%A9%ACdocker%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker实用篇"><a href="#Docker实用篇" class="headerlink" title="Docker实用篇"></a>Docker实用篇</h1><h1 id="1-初识Docker"><a href="#1-初识Docker" class="headerlink" title="1.初识Docker"></a>1.初识Docker</h1><h2 id="1-1-什么是Docker"><a href="#1-1-什么是Docker" class="headerlink" title="1.1.什么是Docker"></a>1.1.什么是Docker</h2><p>微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。</p><ul><li>分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。</li><li>在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题</li></ul><h3 id="1-1-1-应用部署的环境问题"><a href="#1-1-1-应用部署的环境问题" class="headerlink" title="1.1.1.应用部署的环境问题"></a>1.1.1.应用部署的环境问题</h3><p>大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题：</p><ul><li><p>依赖关系复杂，容易出现兼容性问题</p></li><li><p>开发、测试、生产环境有差异</p></li></ul><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210731141907366.png" alt="image-20210731141907366"></p><p>例如一个项目中，部署时需要依赖于node.js、Redis、RabbitMQ、MySQL等，这些服务部署时所需要的函数库、依赖项各不相同，甚至会有冲突。给部署带来了极大的困难。</p><h3 id="1-1-2-Docker解决依赖兼容问题"><a href="#1-1-2-Docker解决依赖兼容问题" class="headerlink" title="1.1.2.Docker解决依赖兼容问题"></a>1.1.2.Docker解决依赖兼容问题</h3><p>而Docker确巧妙的解决了这些问题，Docker是如何实现的呢？</p><p>Docker为了解决依赖的兼容问题的，采用了两个手段：</p><ul><li><p>将应用的Libs（函数库）、Deps（依赖）、配置与应用一起打包</p></li><li><p>将每个应用放到一个隔离<strong>容器</strong>去运行，避免互相干扰</p></li></ul><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210731142219735.png" alt="image-20210731142219735"></p><p>这样打包好的应用包中，既包含应用本身，也保护应用所需要的Libs、Deps，无需再操作系统上安装这些，自然就不存在不同应用之间的兼容问题了。</p><p>虽然解决了不同应用的兼容问题，但是开发、测试等环境会存在差异，操作系统版本也会有差异，怎么解决这些问题呢？</p><h3 id="1-1-3-Docker解决操作系统环境差异"><a href="#1-1-3-Docker解决操作系统环境差异" class="headerlink" title="1.1.3.Docker解决操作系统环境差异"></a>1.1.3.Docker解决操作系统环境差异</h3><p>要解决不同操作系统环境差异问题，必须先了解操作系统结构。以一个Ubuntu操作系统为例，结构如下：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210731143401460.png" alt="image-20210731143401460"></p><p>结构包括：</p><ul><li>计算机硬件：例如CPU、内存、磁盘等</li><li>系统内核：所有Linux发行版的内核都是Linux，例如CentOS、Ubuntu、Fedora等。内核可以与计算机硬件交互，对外提供<strong>内核指令</strong>，用于操作计算机硬件。</li><li>系统应用：操作系统本身提供的应用、函数库。这些函数库是对内核指令的封装，使用更加方便。</li></ul><p>应用于计算机交互的流程如下：</p><p>1）应用调用操作系统应用（函数库），实现各种功能</p><p>2）系统函数库是对内核指令集的封装，会调用内核指令</p><p>3）内核指令操作计算机硬件</p><p>Ubuntu和CentOSpringBoot都是基于Linux内核，无非是系统应用不同，提供的函数库有差异：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210731144304990.png" alt="image-20210731144304990"></p><p>此时，如果将一个Ubuntu版本的MySQL应用安装到CentOS系统，MySQL在调用Ubuntu函数库时，会发现找不到或者不匹配，就会报错了：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210731144458680.png" alt="image-20210731144458680"></p><p>Docker如何解决不同系统环境的问题？</p><ul><li>Docker将用户程序与所需要调用的系统(比如Ubuntu)函数库一起打包</li><li>Docker运行到不同操作系统时，直接基于打包的函数库，借助于操作系统的Linux内核来运行</li></ul><p>如图：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210731144820638.png" alt="image-20210731144820638"></p><h3 id="1-1-4-小结"><a href="#1-1-4-小结" class="headerlink" title="1.1.4.小结"></a>1.1.4.小结</h3><p>Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？</p><ul><li>Docker允许开发中将应用、依赖、函数库、配置一起<strong>打包</strong>，形成可移植镜像</li><li>Docker应用运行在容器中，使用沙箱机制，相互<strong>隔离</strong></li></ul><p>Docker如何解决开发、测试、生产环境有差异的问题？</p><ul><li>Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行</li></ul><p>Docker是一个快速交付应用、运行应用的技术，具备下列优势：</p><ul><li>可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统</li><li>运行时利用沙箱机制形成隔离容器，各个应用互不干扰</li><li>启动、移除都可以通过一行命令完成，方便快捷</li></ul><h2 id="1-2-Docker和虚拟机的区别"><a href="#1-2-Docker和虚拟机的区别" class="headerlink" title="1.2.Docker和虚拟机的区别"></a>1.2.Docker和虚拟机的区别</h2><p>Docker可以让一个应用在任何操作系统中非常方便的运行。而以前我们接触的虚拟机，也能在一个操作系统中，运行另外一个操作系统，保护系统中的任何应用。</p><p>两者有什么差异呢？</p><p><strong>虚拟机</strong>（virtual machine）是在操作系统中<strong>模拟</strong>硬件设备，然后运行另一个操作系统，比如在 Windows 系统里面运行 Ubuntu 系统，这样就可以运行任意的Ubuntu应用了。</p><p><strong>Docker</strong>仅仅是封装函数库，并没有模拟完整的操作系统，如图：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210731145914960.png" alt="image-20210731145914960"></p><p>对比来看：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210731152243765.png" alt="image-20210731152243765"></p><p>小结：</p><p>Docker和虚拟机的差异：</p><ul><li><p>docker是一个系统进程；虚拟机是在操作系统中的操作系统</p></li><li><p>docker体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般</p></li></ul><h2 id="1-3-Docker架构"><a href="#1-3-Docker架构" class="headerlink" title="1.3.Docker架构"></a>1.3.Docker架构</h2><h3 id="1-3-1-镜像和容器"><a href="#1-3-1-镜像和容器" class="headerlink" title="1.3.1.镜像和容器"></a>1.3.1.镜像和容器</h3><p>Docker中有几个重要的概念：</p><p><strong>镜像（Image）</strong>：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。</p><p><strong>容器（Container）</strong>：镜像中的应用程序运行后形成的进程就是<strong>容器</strong>，只是Docker会给容器进程做隔离，对外不可见。</p><p>一切应用最终都是代码组成，都是硬盘中的一个个的字节形成的<strong>文件</strong>。只有运行时，才会加载到内存，形成进程。</p><p>而<strong>镜像</strong>，就是把一个应用在硬盘上的文件、及其运行环境、部分系统函数库文件一起打包形成的文件包。这个文件包是只读的。</p><p><strong>容器</strong>呢，就是将这些文件中编写的程序、函数加载到内存中允许，形成进程，只不过要隔离起来。因此一个镜像可以启动多次，形成多个容器进程。</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210731153059464.png" alt="image-20210731153059464"></p><p>例如你下载了一个QQ，如果我们将QQ在磁盘上的运行<strong>文件</strong>及其运行的操作系统依赖打包，形成QQ镜像。然后你可以启动多次，双开、甚至三开QQ</p><h3 id="1-3-2-DockerHub"><a href="#1-3-2-DockerHub" class="headerlink" title="1.3.2.DockerHub"></a>1.3.2.DockerHub</h3><p>开源应用程序非常多，打包这些应用往往是重复的劳动。为了避免这些重复劳动，人们就会将自己打包的应用镜像，例如Redis、MySQL镜像放到网络上，共享使用，就像GitHub的代码共享一样。</p><ul><li><p>DockerHub：DockerHub是一个官方的Docker镜像的托管平台。这样的平台称为Docker Registry。</p></li><li><p>国内也有类似于DockerHub 的公开服务，比如 <a href="https://c.163yun.com/hub">网易云镜像服务</a>、<a href="https://cr.console.aliyun.com/">阿里云镜像库</a>等。</p></li></ul><p>我们一方面可以将自己的镜像共享到DockerHub，另一方面也可以从DockerHub拉取镜像：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210731153743354.png" alt="image-20210731153743354"></p><h3 id="1-3-3-Docker架构"><a href="#1-3-3-Docker架构" class="headerlink" title="1.3.3.Docker架构"></a>1.3.3.Docker架构</h3><p>我们要使用Docker来操作镜像、容器，就必须要安装Docker。</p><p>Docker是一个<span style="color:red;background:white;font-size:20px;font-family:宋体;">CS架构</span>的程序，由两部分组成：</p><ul><li><p>服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等</p></li><li><p>客户端(client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。</p></li></ul><p>如图：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210731154257653.png" alt="image-20210731154257653"></p><h3 id="1-3-4-小结"><a href="#1-3-4-小结" class="headerlink" title="1.3.4.小结"></a>1.3.4.小结</h3><p>镜像：</p><ul><li>将应用程序及其依赖、环境、配置打包在一起</li></ul><p>容器：</p><ul><li>镜像运行起来就是容器，一个镜像可以运行多个容器</li></ul><p>Docker结构：</p><ul><li><p>服务端：接收命令或远程请求，操作镜像或容器</p></li><li><p>客户端：发送命令或者请求到Docker服务端</p></li></ul><p>DockerHub：</p><ul><li>一个镜像托管的服务器，类似的还有阿里云镜像服务，统称为DockerRegistry</li></ul><h2 id="1-4-安装Docker"><a href="#1-4-安装Docker" class="headerlink" title="1.4.安装Docker"></a>1.4.安装Docker</h2><p>Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。</p><p>Docker CE 分为 <code>stable</code> <code>test</code> 和 <code>nightly</code> 三个更新频道。</p><p>官方网站上有各种环境下的 <a href="https://docs.docker.com/install/">安装指南</a>，这里主要介绍 Docker CE 在 CentOS上的安装。</p><h3 id="CentOS安装Docker"><a href="#CentOS安装Docker" class="headerlink" title="CentOS安装Docker"></a>CentOS安装Docker</h3><p>Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求，所以我们在CentOS 7安装Docker。</p><h3 id="1-1-1卸载（可选）"><a href="#1-1-1卸载（可选）" class="headerlink" title="1.1.1卸载（可选）"></a>1.1.1卸载（可选）</h3><p>如果之前安装过旧版本的Docker，可以使用下面命令卸载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine \</span><br><span class="line">                  docker-ce</span><br></pre></td></tr></table></figure><h3 id="1-1-2-安装docker"><a href="#1-1-2-安装docker" class="headerlink" title="1.1.2.安装docker"></a>1.1.2.安装docker</h3><p>首先需要大家虚拟机联网，安装yum工具</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils \</span><br><span class="line">           device-mapper-persistent-data \</span><br><span class="line">           lvm2 --skip-broken</span><br></pre></td></tr></table></figure><p>然后更新本地镜像源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置docker镜像源</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">    </span><br><span class="line">sed -i &#x27;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#x27; /etc/yum.repos.d/docker-ce.repo</span><br><span class="line"></span><br><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure><p>然后输入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker-ce</span><br></pre></td></tr></table></figure><p>docker-ce为社区免费版本。稍等片刻，docker即可安装成功。</p><h3 id="1-1-3-启动docker"><a href="#1-1-3-启动docker" class="headerlink" title="1.1.3.启动docker"></a>1.1.3.启动docker</h3><p>Docker应用需要用到各种端口，逐一去修改防火墙设置。非常麻烦，因此建议大家直接关闭防火墙！(在企业中肯定不能这么干)</p><p>启动docker前，一定要关闭防火墙后！！</p><p>启动docker前，一定要关闭防火墙后！！</p><p>启动docker前，一定要关闭防火墙后！！</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="comment"># 禁止开机启动防火墙</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure><p>通过命令启动docker：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker  <span class="comment"># 启动docker服务</span></span><br><span class="line"></span><br><span class="line">systemctl stop docker  <span class="comment"># 停止docker服务</span></span><br><span class="line"></span><br><span class="line">systemctl restart docker  <span class="comment"># 重启docker服务</span></span><br></pre></td></tr></table></figure><p>然后输入命令，可以查看docker版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure><p>如图：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220802084213341.png" alt="image-20220802084213341"> </p><h3 id="1-1-4-配置镜像加速"><a href="#1-1-4-配置镜像加速" class="headerlink" title="1.1.4.配置镜像加速"></a>1.1.4.配置镜像加速</h3><p>docker官方镜像仓库网速较差，我们需要设置国内镜像服务：</p><p>参考阿里云的镜像加速文档：<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a></p><h1 id="2-Docker的基本操作"><a href="#2-Docker的基本操作" class="headerlink" title="2.Docker的基本操作"></a>2.Docker的基本操作</h1><h2 id="2-1-镜像操作"><a href="#2-1-镜像操作" class="headerlink" title="2.1.镜像操作"></a>2.1.镜像操作</h2><h3 id="2-1-1-镜像名称"><a href="#2-1-1-镜像名称" class="headerlink" title="2.1.1.镜像名称"></a>2.1.1.镜像名称</h3><p>首先来看下镜像的名称组成：</p><ul><li>镜名称一般分两部分组成：[repository]:[tag]。</li><li>在没有指定tag时，默认是latest，代表最新版本的镜像</li></ul><p>如图：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210731155141362.png" alt="image-20210731155141362"></p><p>这里的mysql就是repository，5.7就是tag，合一起就是镜像名称，代表5.7版本的MySQL镜像。</p><h3 id="2-1-2-镜像命令（常见命令）"><a href="#2-1-2-镜像命令（常见命令）" class="headerlink" title="2.1.2.镜像命令（常见命令）"></a>2.1.2.镜像命令（常见命令）</h3><p>常见的镜像操作命令如图：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210731155649535.png" alt="image-20210731155649535"></p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220802090038607.png" alt="image-20220802090038607"></p><p>查看帮助的命令为  eg  docker image –help  😜</p><h3 id="2-1-3-案例1-拉取、查看镜像"><a href="#2-1-3-案例1-拉取、查看镜像" class="headerlink" title="2.1.3.案例1-拉取、查看镜像"></a>2.1.3.案例1-拉取、查看镜像</h3><p>需求：从DockerHub中拉取一个nginx镜像并查看</p><p>1）首先去镜像仓库搜索nginx镜像，比如<a href="https://hub.docker.com/">DockerHub</a>:</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210731155844368.png" alt="image-20210731155844368"></p><p>2）根据查看到的镜像名称，拉取自己需要的镜像，通过命令：docker pull nginx</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210731155856199.png" alt="image-20210731155856199"></p><p>3）通过命令：docker images 查看拉取到的镜像</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210731155903037.png" alt="image-20210731155903037"></p><h3 id="2-1-4-案例2-保存、导入镜像"><a href="#2-1-4-案例2-保存、导入镜像" class="headerlink" title="2.1.4.案例2-保存、导入镜像"></a>2.1.4.案例2-保存、导入镜像</h3><p>需求：利用docker save将nginx镜像导出磁盘，然后再通过load加载回来</p><p>1）利用docker xx –help命令查看docker save和docker load的语法</p><p>例如，查看save命令用法，可以输入命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210731161104732.png" alt="image-20210731161104732"></p><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o [保存的目标文件名称] [镜像名称]</span><br></pre></td></tr></table></figure><p>2）使用docker save导出镜像到磁盘 </p><p>运行命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o nginx.tar nginx:latest</span><br></pre></td></tr></table></figure><p>结果如图：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210731161354344.png" alt="image-20210731161354344"></p><p>3）使用docker load加载镜像</p><p>先删除本地的nginx镜像：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi nginx:latest</span><br></pre></td></tr></table></figure><p>然后运行命令，加载本地文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i nginx.tar</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210731161746245.png" alt="image-20210731161746245"></p><h3 id="2-1-5-练习"><a href="#2-1-5-练习" class="headerlink" title="2.1.5.练习"></a>2.1.5.练习</h3><p>需求：去DockerHub搜索并拉取一个Redis镜像</p><p>目标：</p><p>1）去DockerHub搜索Redis镜像</p><p>2）查看Redis镜像的名称和版本</p><p>3）利用docker pull命令拉取镜像</p><p>4）利用docker save命令将 redis:latest打包为一个redis.tar包</p><p>5）利用docker rmi 删除本地的redis:latest</p><p>6）利用docker load 重新加载 redis.tar文件</p><h2 id="2-2-容器操作"><a href="#2-2-容器操作" class="headerlink" title="2.2.容器操作"></a>2.2.容器操作</h2><h3 id="2-2-1-容器相关命令"><a href="#2-2-1-容器相关命令" class="headerlink" title="2.2.1.容器相关命令"></a>2.2.1.容器相关命令</h3><p>容器操作的命令如图：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210731161950495.png" alt="image-20210731161950495"></p><p>容器保护三个状态：</p><ul><li>运行：进程正常运行</li><li>暂停：进程暂停，CPU不再运行，并不释放内存</li><li>停止：进程终止，回收进程占用的内存、CPU等资源</li></ul><p>其中：</p><ul><li><p>docker run：创建并运行一个容器，处于运行状态</p></li><li><p>docker pause：让一个运行的容器暂停</p></li><li><p>docker unpause：让一个容器从暂停状态恢复运行</p></li><li><p>docker stop：停止一个运行的容器</p></li><li><p>docker start：让一个停止的容器再次运行</p></li><li><p>docker rm：删除一个容器</p></li></ul><h3 id="2-2-2-案例-创建并运行一个容器"><a href="#2-2-2-案例-创建并运行一个容器" class="headerlink" title="2.2.2.案例-创建并运行一个容器"></a>2.2.2.案例-创建并运行一个容器</h3><p>创建并运行nginx容器的命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name containerName -p 80:80 -d nginx</span><br></pre></td></tr></table></figure><p>命令解读：</p><ul><li>docker run ：创建并运行一个容器</li><li>–name : 给容器起一个名字，比如叫做mn</li><li>-p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口</li><li>-d：后台运行容器</li><li>nginx：镜像名称，例如nginx</li></ul><p>这里的<code>-p</code>参数，是将容器端口映射到宿主机端口。</p><p>默认情况下，容器是隔离环境，我们直接访问宿主机的80端口，肯定访问不到容器中的nginx。</p><p>现在，将容器的80与宿主机的80关联起来，当我们访问宿主机的80端口时，就会被映射到容器的80，这样就能访问到nginx了：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210731163255863.png" alt="image-20210731163255863"></p><h3 id="2-2-3-案例-进入容器，修改文件"><a href="#2-2-3-案例-进入容器，修改文件" class="headerlink" title="2.2.3.案例-进入容器，修改文件"></a>2.2.3.案例-进入容器，修改文件</h3><p><strong>需求</strong>：进入Nginx容器，修改HTML文件内容，添加“传智教育欢迎您”</p><p><strong>提示</strong>：进入容器要用到docker exec命令。</p><p><strong>步骤</strong>：</p><p>1）进入容器。进入我们刚刚创建的nginx容器的命令为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mn bash</span><br></pre></td></tr></table></figure><p>命令解读：</p><ul><li><p>docker exec ：进入容器内部，执行一个命令</p></li><li><p>-it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</p></li><li><p>mn ：要进入的容器的名称</p></li><li><p>bash：进入容器后执行的命令，bash是一个linux终端交互命令</p></li></ul><p>2）进入nginx的HTML所在目录 /usr/share/nginx/html</p><p>容器内部会模拟一个独立的Linux文件系统，看起来如同一个linux服务器一样：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210731164159811.png" alt="image-20210731164159811"></p><p>nginx的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的html文件。</p><p>查看DockerHub网站中的nginx页面，可以知道nginx的html目录位置在<code>/usr/share/nginx/html</code></p><p>我们执行命令，进入该目录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/share/nginx/html</span><br></pre></td></tr></table></figure><p> 查看目录下文件：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210731164455818.png" alt="image-20210731164455818"></p><p>3）修改index.html的内容</p><p>容器内没有vi命令，无法直接修改，我们用下面的命令来修改：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i -e <span class="string">&#x27;s#Welcome to nginx#欢迎您#g&#x27;</span> -e <span class="string">&#x27;s#&lt;head&gt;#&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;#g&#x27;</span> index.html</span><br></pre></td></tr></table></figure><p>在浏览器访问自己的虚拟机地址，例如我的是：<a href="http://192.168.150.101，即可看到结果：">http://192.168.150.101，即可看到结果：</a></p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210731164717604.png" alt="image-20210731164717604"></p><h3 id="2-2-4-小结"><a href="#2-2-4-小结" class="headerlink" title="2.2.4.小结"></a>2.2.4.小结</h3><p>docker run命令的常见参数有哪些？</p><ul><li>–name：指定容器名称</li><li>-p：指定端口映射</li><li>-d：让容器后台运行</li></ul><p>查看容器日志的命令：</p><ul><li>docker logs</li><li>添加 -f 参数可以持续查看日志</li></ul><p>查看容器状态：</p><ul><li>docker ps</li><li>docker ps -a 查看所有容器，包括已经停止的</li></ul><h2 id="2-3-数据卷（容器数据管理-重要）"><a href="#2-3-数据卷（容器数据管理-重要）" class="headerlink" title="2.3.数据卷（容器数据管理, 重要）"></a>2.3.数据卷（容器数据管理, 重要）</h2><p>在之前的nginx案例中，修改nginx的html页面时，需要进入nginx内部。并且因为没有编辑器，修改文件也很麻烦。</p><p>这就是因为容器与数据（容器内文件）耦合带来的后果。</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210731172440275.png" alt="image-20210731172440275"></p><p>要解决这个问题，必须将数据与容器解耦，这就要用到数据卷了。</p><h3 id="2-3-1-什么是数据卷"><a href="#2-3-1-什么是数据卷" class="headerlink" title="2.3.1.什么是数据卷"></a>2.3.1.什么是数据卷</h3><p><strong>数据卷（volume）</strong>是一个虚拟目录，指向宿主机文件系统中的某个目录。</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210731173541846.png" alt="image-20210731173541846"></p><p>Docker是一个<span style="color:white;background:red;font-size:20px;font-family:宋体;">一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。</span></p><p>这样，我们操作宿主机的/var/lib/docker/volumes/html目录，就等于操作容器内的/usr/share/nginx/html目录了</p><h3 id="2-3-2-数据集操作命令"><a href="#2-3-2-数据集操作命令" class="headerlink" title="2.3.2.数据集操作命令"></a>2.3.2.数据集操作命令</h3><p>数据卷操作的基本语法如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume [COMMAND]</span><br></pre></td></tr></table></figure><p>docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作：</p><ul><li>create 创建一个volume</li><li>inspect 显示一个或多个volume的信息</li><li>ls 列出所有的volume</li><li>prune 删除未使用的volume</li><li>rm 删除一个或多个指定的volume</li></ul><h3 id="2-3-3-创建和查看数据卷"><a href="#2-3-3-创建和查看数据卷" class="headerlink" title="2.3.3.创建和查看数据卷"></a>2.3.3.创建和查看数据卷</h3><p><strong>需求</strong>：创建一个数据卷，并查看数据卷在宿主机的目录位置</p><p>① 创建数据卷</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create html</span><br></pre></td></tr></table></figure><p>② 查看所有数据</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume ls</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210731173746910.png" alt="image-20210731173746910"></p><p>③ 查看数据卷详细信息卷</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect html</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210731173809877.png" alt="image-20210731173809877"></p><p>可以看到，我们创建的html这个数据卷关联的宿主机目录为<code>/var/lib/docker/volumes/html/_data</code>目录。</p><p><strong>小结</strong>：</p><p>数据卷的作用：</p><ul><li>将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全</li></ul><p>数据卷操作：</p><ul><li>docker volume create：创建数据卷</li><li>docker volume ls：查看所有数据卷</li><li>docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置</li><li>docker volume rm：删除指定数据卷</li><li>docker volume prune：删除所有未使用的数据卷</li></ul><h3 id="2-3-4-挂载数据卷"><a href="#2-3-4-挂载数据卷" class="headerlink" title="2.3.4.挂载数据卷"></a>2.3.4.挂载数据卷</h3><p>我们在创建容器时，可以通过 -v 参数来挂载一个数据卷到某个容器内目录，命令格式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  --name mn \</span><br><span class="line">  -v html:/root/html \</span><br><span class="line">  -p 8080:80</span><br><span class="line">  nginx \</span><br></pre></td></tr></table></figure><p>这里的-v就是挂载数据卷的命令：</p><ul><li><code>-v html:/root/htm</code> ：把html数据卷挂载到容器内的/root/html这个目录中</li></ul><h3 id="2-3-5-案例-给nginx挂载数据卷"><a href="#2-3-5-案例-给nginx挂载数据卷" class="headerlink" title="2.3.5.案例-给nginx挂载数据卷"></a>2.3.5.案例-给nginx挂载数据卷</h3><p><strong>需求</strong>：创建一个nginx容器，修改容器内的html目录内的index.html内容</p><p><strong>分析</strong>：上个案例中，我们进入nginx容器内部，已经知道nginx的html目录所在位置/usr/share/nginx/html ，我们需要把这个目录挂载到html这个数据卷上，方便操作其中的内容。</p><p><strong>提示</strong>：运行容器时使用 -v 参数挂载数据卷</p><p>步骤：</p><p>① 创建容器并挂载数据卷到容器内的HTML目录（）</p><p><span style="color:white;background:red;font-size:20px;font-family:宋体;">这里的-v html 可以自动在host的 /var/lib/docker/volumes/目录下自动创建一个名为html的数据卷，冒号后面的内容：/usr/share/nginx/html ，意思式将html数据卷挂载到容器内的这个目录上。实现数据的共享修改</span></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mn -v html:/usr/share/nginx/html -p 80:80 -d nginx</span><br></pre></td></tr></table></figure><p>使用 docker volume inspect 数 据卷，找如下内容</p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220802102326348.png" alt="image-20220802102326348"></p><p>② 进入html数据卷所在位置，并修改HTML内容</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看html数据卷的位置</span></span><br><span class="line">docker volume inspect html</span><br><span class="line"><span class="comment"># 进入该目录</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/docker/volumes/html/_data</span><br><span class="line"><span class="comment"># 修改文件</span></span><br><span class="line">vi index.html</span><br></pre></td></tr></table></figure><p>通过vim修改后可以在浏览器直接访问到修改后的内容，这便是数据卷挂载的效果，在host内修改，容器内的内容也跟着被修改了。</p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220802102455223.png" alt="image-20220802102455223"></p><h3 id="2-3-6-案例-给MySQL挂载本地目录"><a href="#2-3-6-案例-给MySQL挂载本地目录" class="headerlink" title="2.3.6.案例-给MySQL挂载本地目录"></a>2.3.6.案例-给MySQL挂载本地目录</h3><p>容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下：</p><ul><li>带数据卷模式：宿主机目录 –&gt; 数据卷 —&gt; 容器内目录</li><li>直接挂载模式：宿主机目录 —&gt; 容器内目录</li></ul><p>如图：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210731175155453.png" alt="image-20210731175155453"></p><p><strong>语法</strong>：</p><p>目录挂载与数据卷挂载的语法是类似的：</p><ul><li>-v [宿主机目录]:[容器内目录]</li><li>-v [宿主机文件]:[容器内文件]</li></ul><p><strong>需求</strong>：创建并运行一个MySQL容器，将宿主机目录直接挂载到容器</p><p>实现思路如下：</p><p>1）在将课前资料中的mysql.tar文件上传到虚拟机，通过load命令加载为镜像</p><p>2）创建目录/tmp/mysql/data</p><p>3）创建目录/tmp/mysql/conf，将课前资料提供的hmy.cnf文件上传到/tmp/mysql/conf</p><p>4）去DockerHub查阅资料，创建并运行MySQL容器，要求：</p><p>① 挂载/tmp/mysql/data到mysql容器内数据存储目录</p><p>② 挂载/tmp/mysql/conf/hmy.cnf到mysql容器的配置文件</p><p>③ 设置MySQL密码</p><h3 id="2-3-7-小结"><a href="#2-3-7-小结" class="headerlink" title="2.3.7.小结"></a>2.3.7.小结</h3><p>docker run的命令中通过 -v 参数挂载文件或目录到容器中：</p><ul><li>-v volume名称:容器内目录</li><li>-v 宿主机文件:容器内文</li><li>-v 宿主机目录:容器内目录</li></ul><p>数据卷挂载与目录直接挂载的</p><ul><li><span style="color:white;background:red;font-size:20px;font-family:宋体;">数据卷挂载耦合度低，由docker来管理目录，但是目录较深，不好找</span></li><li><span style="color:white;background:red;font-size:20px;font-family:宋体;">目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看</span></li></ul><h1 id="3-Dockerfile自定义镜像"><a href="#3-Dockerfile自定义镜像" class="headerlink" title="3.Dockerfile自定义镜像"></a>3.Dockerfile自定义镜像</h1><p>常见的镜像在DockerHub就能找到，但是我们自己写的项目就必须自己构建镜像了。</p><p>而要自定义镜像，就必须先了解镜像的结构才行。</p><h2 id="3-1-镜像结构"><a href="#3-1-镜像结构" class="headerlink" title="3.1.镜像结构"></a>3.1.镜像结构</h2><p>镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。</p><p>我们以MySQL为例，来看看镜像的组成结构：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210731175806273.png" alt="image-20210731175806273"></p><p>简单来说，镜像就是在系统函数库、运行环境基础上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。</p><p>我们要构建镜像，其实就是实现上述打包的过程。</p><h2 id="3-2-Dockerfile语法"><a href="#3-2-Dockerfile语法" class="headerlink" title="3.2.Dockerfile语法"></a>3.2.Dockerfile语法</h2><p>构建自定义的镜像时，并不需要一个个文件去拷贝，打包。</p><p>我们只需要告诉Docker，我们的镜像的组成，需要哪些BaseImage、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来Docker会帮助我们构建镜像。</p><p>而描述上述信息的文件就是Dockerfile文件。</p><p><strong>Dockerfile</strong>就是一个文本文件，其中包含一个个的**指令(Instruction)**，用指令来说明要执行什么操作来构建镜像。<span style="color:white;background:red;font-size:20px;font-family:宋体;">每一个指令都会形成一层Layer。</span></p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210731180321133.png" alt="image-20210731180321133"></p><p>更新详细语法说明，请参考官网文档： <a href="https://docs.docker.com/engine/reference/builder">https://docs.docker.com/engine/reference/builder</a></p><h2 id="3-3-构建Java项目"><a href="#3-3-构建Java项目" class="headerlink" title="3.3.构建Java项目"></a>3.3.构建Java项目</h2><h3 id="3-3-1-基于Ubuntu构建Java项目"><a href="#3-3-1-基于Ubuntu构建Java项目" class="headerlink" title="3.3.1.基于Ubuntu构建Java项目"></a>3.3.1.基于Ubuntu构建Java项目</h3><p>需求：基于Ubuntu镜像构建一个新镜像，运行一个java项目</p><ul><li><p>步骤1：新建一个空文件夹docker-demo</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210801101207444.png" alt="image-20210801101207444"></p></li><li><p>步骤2：拷贝课前资料中的docker-demo.jar文件到docker-demo这个目录</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210801101314816.png" alt="image-20210801101314816"></p></li><li><p>步骤3：拷贝课前资料中的jdk8.tar.gz文件到docker-demo这个目录</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210801101410200.png" alt="image-20210801101410200"></p></li><li><p>步骤4：拷贝课前资料提供的Dockerfile到docker-demo这个目录</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210801101455590.png" alt="image-20210801101455590"></p><p>其中的内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="comment"># 配置环境变量，JDK的安装目录</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_DIR=/usr/local</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝jdk和java项目的包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./jdk8.tar.gz <span class="variable">$JAVA_DIR</span>/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./docker-demo.jar /tmp/app.jar</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装JDK</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$JAVA_DIR</span> \</span></span><br><span class="line"><span class="bash"> &amp;&amp; tar -xf ./jdk8.tar.gz \</span></span><br><span class="line"><span class="bash"> &amp;&amp; mv ./jdk1.8.0_144 ./java8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME=$JAVA_DIR/java8</span><br><span class="line"><span class="keyword">ENV</span> PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8090</span></span><br><span class="line"><span class="comment"># 入口，java项目的启动命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> java -jar /tmp/app.jar</span></span><br></pre></td></tr></table></figure></li><li><p>步骤5：进入docker-demo</p><p>将准备好的docker-demo上传到虚拟机任意目录，然后进入docker-demo目录下</p></li><li><p>步骤6：运行命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t javaweb:1.0 .</span><br></pre></td></tr></table></figure></li></ul><p>最后访问 <a href="http://192.168.150.101:8090/hello/count%EF%BC%8C%E5%85%B6%E4%B8%AD%E7%9A%84ip%E6%94%B9%E6%88%90%E4%BD%A0%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BAip">http://192.168.150.101:8090/hello/count，其中的ip改成你的虚拟机ip</a></p><h3 id="3-3-2-基于java8构建Java项目"><a href="#3-3-2-基于java8构建Java项目" class="headerlink" title="3.3.2.基于java8构建Java项目"></a>3.3.2.基于java8构建Java项目</h3><p>虽然我们可以基于Ubuntu基础镜像，添加任意自己需要的安装包，构建镜像，但是却比较麻烦。所以大多数情况下，我们都可以在一些安装了部分软件的基础镜像上做改造。</p><p>例如，构建java项目的镜像，可以在已经准备了JDK的基础镜像基础上构建。</p><p>需求：基于java:8-alpine镜像，将一个Java项目构建为镜像</p><p>实现思路如下：</p><ul><li><p>① 新建一个空的目录，然后在目录中新建一个文件，命名为Dockerfile</p></li><li><p>② 拷贝课前资料提供的docker-demo.jar到这个目录中</p></li><li><p>③ 编写Dockerfile文件：</p><ul><li><p>a ）基于java:8-alpine作为基础镜像</p></li><li><p>b ）将app.jar拷贝到镜像中</p></li><li><p>c ）暴露端口</p></li><li><p>d ）编写入口ENTRYPOINT</p><p>内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span>-alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./app.jar /tmp/app.jar</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8090</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> java -jar /tmp/app.jar</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>④ 使用docker build命令构建镜像</p></li><li><p>⑤ 使用docker run创建容器并运行</p></li></ul><h2 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4.小结"></a>3.4.小结</h2><p>小结：</p><ol><li><p>Dockerfile的本质是一个文件，通过指令描述镜像的构建过程</p></li><li><p>Dockerfile的第一行必须是FROM，从一个基础镜像来构建</p></li><li><p>基础镜像可以是基本操作系统，如Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine</p></li></ol><h1 id="4-Docker-Compose"><a href="#4-Docker-Compose" class="headerlink" title="4.Docker-Compose"></a>4.Docker-Compose</h1><p>Docker Compose可以基于Compose文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器！</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210731180921742.png" alt="image-20210731180921742"></p><h2 id="4-1-初识DockerCompose"><a href="#4-1-初识DockerCompose" class="headerlink" title="4.1.初识DockerCompose"></a>4.1.初识DockerCompose</h2><p>Compose文件是一个文本文件，通过指令定义集群中的每个容器如何运行。格式如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&quot;3.8&quot;</span></span><br><span class="line"> services:</span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql:<span class="number">5.7</span><span class="number">.25</span></span><br><span class="line">    environment:</span><br><span class="line">     MYSQL_ROOT_PASSWORD: <span class="number">123</span> </span><br><span class="line">    volumes:</span><br><span class="line">     - <span class="string">&quot;/tmp/mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">     - <span class="string">&quot;/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf&quot;</span></span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">     - <span class="string">&quot;8090:8090&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的Compose文件就描述一个项目，其中包含两个容器：</p><ul><li>mysql：一个基于<code>mysql:5.7.25</code>镜像构建的容器，并且挂载了两个目录</li><li>web：一个基于<code>docker build</code>临时构建的镜像容器，映射端口时8090</li></ul><p>DockerCompose的详细语法参考官网：<a href="https://docs.docker.com/compose/compose-file/">https://docs.docker.com/compose/compose-file/</a></p><p>其实DockerCompose文件可以看做是将多个docker run命令写到一个文件，只是语法稍有差异。</p><h2 id="4-2-安装DockerCompose"><a href="#4-2-安装DockerCompose" class="headerlink" title="4.2.安装DockerCompose"></a>4.2.安装DockerCompose</h2><p>dockerCompose就是将 docker build  run等命令集成到一起。</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>Linux下需要通过命令下载：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">curl -L https://github.com/docker/compose/releases/download/1.23.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure><p>如果下载速度较慢，或者下载失败，可以使用课前资料提供的docker-compose文件：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220802110414610.png" alt="image-20220802110414610"></p><h3 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h3><p>修改文件权限：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改权限</span></span><br><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure><h3 id="Base自动补全命令："><a href="#Base自动补全命令：" class="headerlink" title="Base自动补全命令："></a>Base自动补全命令：</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 补全命令</span></span><br><span class="line">curl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</span><br></pre></td></tr></table></figure><p>如果这里出现错误，需要修改自己的hosts文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;199.232.68.133 raw.githubusercontent.com&quot;</span> &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure><h2 id="4-3-部署微服务集群"><a href="#4-3-部署微服务集群" class="headerlink" title="4.3.部署微服务集群"></a>4.3.部署微服务集群</h2><p><strong>需求</strong>：将之前学习的cloud-demo微服务集群利用DockerCompose部署</p><p><strong>实现思路</strong>：</p><p>① 查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件</p><p>② 修改自己的cloud-demo项目，将数据库、nacos地址都命名为docker-compose中的服务名</p><p>③ 使用maven打包工具，将项目中的每个微服务都打包为app.jar</p><p>④ 将打包好的app.jar拷贝到cloud-demo中的每一个对应的子目录中</p><p>⑤ 将cloud-demo上传至虚拟机，利用 docker-compose up -d 来部署</p><h3 id="4-3-1-compose文件"><a href="#4-3-1-compose文件" class="headerlink" title="4.3.1.compose文件"></a>4.3.1.compose文件</h3><p>查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件，而且每个微服务都准备了一个独立的目录：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210731181341330.png" alt="image-20210731181341330"></p><p>内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nacos:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nacos/nacos-server</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MODE:</span> <span class="string">standalone</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8848:8848&quot;</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7.25</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;$PWD/mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;$PWD/mysql/conf:/etc/mysql/conf.d/&quot;</span></span><br><span class="line">  <span class="attr">userservice:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./user-service</span></span><br><span class="line">  <span class="attr">orderservice:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./order-service</span></span><br><span class="line">  <span class="attr">gateway:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./gateway</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;10010:10010&quot;</span></span><br></pre></td></tr></table></figure><p>可以看到，其中包含5个service服务：</p><ul><li><code>nacos</code>：作为注册中心和配置中心<ul><li><code>image: nacos/nacos-server</code>： 基于nacos/nacos-server镜像构建</li><li><code>environment</code>：环境变量<ul><li><code>MODE: standalone</code>：单点模式启动</li></ul></li><li><code>ports</code>：端口映射，这里暴露了8848端口</li></ul></li><li><code>mysql</code>：数据库<ul><li><code>image: mysql:5.7.25</code>：镜像版本是mysql:5.7.25</li><li><code>environment</code>：环境变量<ul><li><code>MYSQL_ROOT_PASSWORD: 123</code>：设置数据库root账户的密码为123</li></ul></li><li><code>volumes</code>：数据卷挂载，这里挂载了mysql的data、conf目录，其中有我提前准备好的数据</li></ul></li><li><code>userservice</code>、<code>orderservice</code>、<code>gateway</code>：都是基于Dockerfile临时构建的</li></ul><p>查看mysql目录，可以看到其中已经准备好了cloud_order、cloud_user表：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210801095205034.png" alt="image-20210801095205034"></p><p>查看微服务目录，可以看到都包含Dockerfile文件：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210801095320586.png" alt="image-20210801095320586"></p><p>内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span>-alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./app.jar /tmp/app.jar</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> java -jar /tmp/app.jar</span></span><br></pre></td></tr></table></figure><h3 id="4-3-2-修改微服务配置"><a href="#4-3-2-修改微服务配置" class="headerlink" title="4.3.2.修改微服务配置"></a>4.3.2.修改微服务配置</h3><p>因为微服务将来要部署为docker容器，而容器之间互联不是通过IP地址，而是通过容器名。这里我们将order-service、user-service、gateway服务的mysql、nacos地址都修改为基于容器名的访问。</p><p>如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://mysql:3306/cloud_order?useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">orderservice</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">nacos:8848</span> <span class="comment"># nacos服务地址</span></span><br></pre></td></tr></table></figure><h3 id="4-3-3-打包"><a href="#4-3-3-打包" class="headerlink" title="4.3.3.打包"></a>4.3.3.打包</h3><p>接下来需要将我们的每个微服务都打包。因为之前查看到Dockerfile中的jar包名称都是app.jar，因此我们的每个微服务都需要用这个名称。</p><p>可以通过修改pom.xml中的打包名称来实现，每个微服务都需要修改：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 服务打包的最终名称 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>app<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打包后：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210801095951030.png" alt="image-20210801095951030"></p><h3 id="4-3-4-拷贝jar包到部署目录"><a href="#4-3-4-拷贝jar包到部署目录" class="headerlink" title="4.3.4.拷贝jar包到部署目录"></a>4.3.4.拷贝jar包到部署目录</h3><p>编译打包好的app.jar文件，需要放到Dockerfile的同级目录中。注意：每个微服务的app.jar放到与服务名称对应的目录，别搞错了。</p><p>user-service：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210801100201253.png" alt="image-20210801100201253"></p><p>order-service：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210801100231495.png" alt="image-20210801100231495"></p><p>gateway：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210801100308102.png" alt="image-20210801100308102"></p><h3 id="4-3-5-部署"><a href="#4-3-5-部署" class="headerlink" title="4.3.5.部署"></a>4.3.5.部署</h3><p>最后，我们需要将文件整个cloud-demo文件夹上传到虚拟机中，理由DockerCompose部署。</p><p>上传到任意目录：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210801100955653.png" alt="image-20210801100955653"></p><p>部署：</p><p>进入cloud-demo目录，然后运行下面的命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h1 id="5-Docker镜像仓库"><a href="#5-Docker镜像仓库" class="headerlink" title="5.Docker镜像仓库"></a>5.Docker镜像仓库</h1><h2 id="5-1-搭建私有镜像仓库"><a href="#5-1-搭建私有镜像仓库" class="headerlink" title="5.1.搭建私有镜像仓库"></a>5.1.搭建私有镜像仓库</h2><p>参考课前资料《CentOS7安装Docker.md》</p><h2 id="5-2-推送、拉取镜像"><a href="#5-2-推送、拉取镜像" class="headerlink" title="5.2.推送、拉取镜像"></a>5.2.推送、拉取镜像</h2><p>推送镜像到私有镜像服务必须先tag，步骤如下：</p><p>① 重新tag本地镜像，名称前缀为私有仓库的地址：192.168.150.101:8080/</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag nginx:latest 192.168.150.101:8080/nginx:1.0 </span><br></pre></td></tr></table></figure><p>② 推送镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 192.168.150.101:8080/nginx:1.0 </span><br></pre></td></tr></table></figure><p>③ 拉取镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 192.168.150.101:8080/nginx:1.0 </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 黑马docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21天刷题计划（17）归并排序</title>
      <link href="/2022/05/05/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%8817%EF%BC%89%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/05/05/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%8817%EF%BC%89%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p><strong>所有递归的算法，你甭管它是干什么的，本质上都是在遍历一棵（递归）树，然后在节点（前中后序位置）上执行代码</strong></p><p>归并排序实质上可以说是二叉树的后序遍历。</p><p> <img src="/articleImg/65_article/1.gif" alt="1"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Merge.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Merge</span></span>&#123;</span><br><span class="line">     <span class="comment">// 用于辅助合并有序数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] temp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先给辅助数组开辟内存空间</span></span><br><span class="line">        temp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="comment">// 排序整个数组（原地修改）</span></span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lo &gt;= hi)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo+hi)/<span class="number">2</span>;</span><br><span class="line">        sort(nums,lo,mid);</span><br><span class="line">        sort(nums,mid+<span class="number">1</span>,hi);</span><br><span class="line">        merge(nums,lo,hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[]nums,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=lo;i&lt;=hi;i++)&#123;</span><br><span class="line">            temp[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j=lo,mid=(lo+hi)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> k=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p = lo;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=lo;i&lt;=hi;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j == mid+<span class="number">1</span>)&#123;</span><br><span class="line">                nums[p++] = temp[k++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k == hi+<span class="number">1</span>)&#123;</span><br><span class="line">                nums[p++] = temp[j++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp[j]&lt;temp[k])&#123;</span><br><span class="line">                nums[p++] = temp[j++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[p++] = temp[k++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其他应用"><a href="#其他应用" class="headerlink" title="其他应用"></a>其他应用</h1><p> <img src="/articleImg/65_article/2.jpg" alt="2"></p><p>应用归并排序解决其他问题，主要是体现在merge函数执行之前。这里要注意，在执行merge函数时[lo,mid] [mid+1, hi]这两个区间的数，已经是有序的数组了。</p><p>我们一般可以在这里进行计数。计数时充分利用了两个子数组的有序性，通过维护一个区间，进而可以进行快速计数。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> end = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= mid; i++) &#123;</span><br><span class="line">    <span class="comment">// nums 中的元素可能较大，乘 2 可能溢出，所以转化成 long</span></span><br><span class="line">    <span class="keyword">while</span> (end &lt;= hi &amp;&amp; (<span class="keyword">long</span>)nums[i] &gt; (<span class="keyword">long</span>)nums[end] * <span class="number">2</span>) &#123;</span><br><span class="line">        end++;</span><br><span class="line">    &#125;</span><br><span class="line">    count += end - (mid + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用到该题目中，在归并之前夹带私货，通过维护一个区间，来计算[lo，mid]中有多少元素，大于右侧区间2倍元素<br>如果要在归并j时进行操作，就需要每次通过for循环遍历[mid+1,k]。最终得解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Merge.sort(nums);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Merge</span></span>&#123;</span><br><span class="line">     <span class="comment">// 用于辅助合并有序数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] temp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先给辅助数组开辟内存空间</span></span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        temp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="comment">// 排序整个数组（原地修改）</span></span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lo &gt;= hi)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo+hi)/<span class="number">2</span>;</span><br><span class="line">        sort(nums,lo,mid);</span><br><span class="line">        sort(nums,mid+<span class="number">1</span>,hi);</span><br><span class="line">        merge(nums,lo,hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[]nums,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=lo;i&lt;=hi;i++)&#123;</span><br><span class="line">            temp[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j=lo,mid=(lo+hi)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> k=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p = lo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行效率优化，维护左闭右开区间 [mid+1, end) 中的元素乘 2 小于 nums[i]</span></span><br><span class="line">        <span class="comment">// 为什么 end 是开区间？因为这样的话可以保证初始区间 [mid+1, mid+1) 是一个空区间</span></span><br><span class="line">        <span class="keyword">int</span> end = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= mid; i++) &#123;</span><br><span class="line">            <span class="comment">// nums 中的元素可能较大，乘 2 可能溢出，所以转化成 long</span></span><br><span class="line">            <span class="keyword">while</span> (end &lt;= hi &amp;&amp; (<span class="keyword">long</span>)nums[i] &gt; (<span class="keyword">long</span>)nums[end] * <span class="number">2</span>) &#123;</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">            count += end - (mid + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=lo;i&lt;=hi;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j == mid+<span class="number">1</span>)&#123;</span><br><span class="line">                nums[p++] = temp[k++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k == hi+<span class="number">1</span>)&#123;</span><br><span class="line">                nums[p++] = temp[j++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp[j]&lt;temp[k])&#123;</span><br><span class="line">                nums[p++] = temp[j++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[p++] = temp[k++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 21天刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21天刷题计划（21）动态规划地下城游戏</title>
      <link href="/2022/05/05/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%8821%EF%BC%89%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F/"/>
      <url>/2022/05/05/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%8821%EF%BC%89%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="地下城游戏"><a href="#地下城游戏" class="headerlink" title="地下城游戏"></a>地下城游戏</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/53.jpg" alt="53"></p><p><strong>思路整理</strong></p><ul><li>从 grid[i][j] 到达终点（右下角）所需的最少生命值是 dp(grid, i, j)</li><li>子问题也是独立的</li><li>本题dp数组的更新方向，是从右下角逐步网上进行更新，由于骑士每次只向右或向下移动一步。所以我们的dp数组的更新 <strong>从下往上，从右往左</strong></li><li>本题的base case有两个小技巧，第一 ：dp数组的维度要多申请一维，都初始化为max 第二：mem[m-1][n] = 1; mem[m][n-1] = 1;为了求右下角dp[i][j]的初始值。不然都是Integer.max 会导致最终结果错误</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="keyword">int</span>[][] dungeon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = dungeon.length;</span><br><span class="line">        <span class="keyword">int</span> n = dungeon[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> [][]mem = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mem.length;i++)</span><br><span class="line">            Arrays.fill(mem[i],Integer.MAX_VALUE);</span><br><span class="line">        mem[m-<span class="number">1</span>][n] = <span class="number">1</span>;</span><br><span class="line">        mem[m][n-<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=n-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = Math.min(mem[i+<span class="number">1</span>][j],mem[i][j+<span class="number">1</span>]);</span><br><span class="line">                mem[i][j] = temp - dungeon[i][j] &gt;<span class="number">0</span>?temp - dungeon[i][j]:<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mem[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用带备忘录的递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> [][]dungeon,<span class="keyword">int</span>[][]mem,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = dungeon.length;</span><br><span class="line">    <span class="keyword">int</span> n = dungeon[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span>(i==m-<span class="number">1</span>&amp;&amp;j==n-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dungeon[i][j]&gt;=<span class="number">0</span>?<span class="number">1</span>:-dungeon[i][j]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(i==m||j==n)</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mem[i][j] != -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> mem[i][j];</span><br><span class="line">    <span class="keyword">int</span> res = Math.min(dp(dungeon,mem,i+<span class="number">1</span>,j),dp(dungeon,mem,i,j+<span class="number">1</span>)) - dungeon[i][j];</span><br><span class="line">    mem[i][j] = res&gt;<span class="number">0</span>?res:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> mem[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 21天刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21天刷题计划（20）动态规划编辑距离</title>
      <link href="/2022/05/05/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%8820%EF%BC%89%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
      <url>/2022/05/05/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%8820%EF%BC%89%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划编辑距离"><a href="#动态规划编辑距离" class="headerlink" title="动态规划编辑距离"></a>动态规划编辑距离</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/52.jpg" alt="52"></p><p>思路总结：</p><ul><li>本题有两种解法，第一种：带备忘录的递归、第二种、动态规划</li><li>采用动态规划的话要注意dp数组要多申请一维，方便遍历。</li><li>定义：dp(i, j) 返回 s1[0..i] 和 s2[0..j] 的最小编辑距离</li><li>当word1.charAt(i-1) == word2.charAt(j-1)时dp[i][j] = dp[i-1][j-1]; 当其不相等时，p[i][j] = MIN(dp[i-1][j]+1,dp[i-1][j-1]+1,dp[i][j-1]+1);</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length();</span><br><span class="line">        <span class="keyword">int</span> n = word2.length();</span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化base case</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i-<span class="number">1</span>) == word2.charAt(j-<span class="number">1</span>))</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]; <span class="comment">//什么都不用做，跳过即可</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = MIN(dp[i-<span class="number">1</span>][j]+<span class="number">1</span>,dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>,dp[i][j-<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MIN</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.min(a,Math.min(b,c));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 21天刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21天刷题计划（19）动态规划入门LIS</title>
      <link href="/2022/05/05/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%8819%EF%BC%89%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8LIS/"/>
      <url>/2022/05/05/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%8819%EF%BC%89%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8LIS/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划入门LIS"><a href="#动态规划入门LIS" class="headerlink" title="动态规划入门LIS"></a>动态规划入门LIS</h1><p><img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/55.jpg" alt="55"></p><ul><li>满足具备「最优子结构」，nums数组的每一个数，应该都可以找到对应自己的最长子序列，最终的结果，也正好可以根据之前的结果推理出来。</li><li>状态转移方程推导：basecase dp[]数组初始化为1，每个数把自己首先当作子序列。状态就是还有多少数没找最长递增子序列。选择就是选择之前的哪个数为基准，作为衔接自己的最长递增子序列。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;dp.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&gt;nums[j])</span><br><span class="line">                    dp[i] = Math.max(dp[j]+<span class="number">1</span>,dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dp.length;i++)</span><br><span class="line">            ans = Math.max(ans,dp[i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 21天刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21天刷题计划（18）动态规划入门零钱兑换</title>
      <link href="/2022/05/05/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%8818%EF%BC%89%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/"/>
      <url>/2022/05/05/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%8818%EF%BC%89%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h1><p>算法小抄的动态规划，我做了两边，也算入了门。后面继续加油吧。</p><ul><li>动态规划问题的一般形式就是求最值</li><li>重叠子问题、最优子结构、状态转移方程就是动态规划三要素</li><li>动态规划问题一定会具备「最优子结构」</li><li>写出状态转移方程是最困难的</li></ul><ol><li>本题中对应的状态：dp[]数组的下标代表金额，数组中的数代表该金额最少能用多少枚硬币凑出。</li><li>本提的最优子结构：1-amount金额，每一个可凑金额都可以被最少的硬币数凑出，才可以最后导致amount被最少硬币数凑出！</li><li>辅助你思考状态转移方程：明确 <strong>base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 dp 数组/函数的含义</strong>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划，自底向上</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> []dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp,amount+<span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dp.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> coin : coins)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i-coin&lt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            dp[i] = Math.min(dp[i-coin]+<span class="number">1</span>,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] == amount+<span class="number">1</span> ? -<span class="number">1</span>:dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 21天刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21天刷题计划（16）子集组合排列问题</title>
      <link href="/2022/05/05/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%8816%EF%BC%89%E5%AD%90%E9%9B%86%E7%BB%84%E5%90%88%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/"/>
      <url>/2022/05/05/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%8816%EF%BC%89%E5%AD%90%E9%9B%86%E7%BB%84%E5%90%88%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/42.jpg" alt="42"></p><h1 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h1><ul><li><strong>本题的元素唯一，且不能复选</strong>。属于常规的DFS框架</li><li>需要注意的是，我们需要给DFS函数的参数列表加一个<strong>start参数</strong>，表示从数组的哪个元素开始遍历。用** track 记录根节点到每个节点的路径的值**。同时在前序位置把每个节点的路径值收集起来，完成回溯树的遍历就收集了所有子集。</li><li>通过 start 参数控制树枝的遍历，避免产生重复的子集的主要原因是：<strong>使用 start 变量保证元素 nums[start] 之后只会出现 nums[start+1..] 中的元素</strong></li><li>我们在for循环外，如果提前发现不满足题目需要的路径，就不用再往下再继续遍历了，直接return，进行剪枝操作。</li></ul><p>求子集的模板代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 组合/子集问题回溯算法框架 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 回溯算法标准框架</span></span><br><span class="line">    <span class="comment">//1.在for循环外进行子集组合的保存</span></span><br><span class="line">    <span class="comment">//2.如果提前发现不满足题目需要的路径，进行剪枝操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.length; i++) &#123;  <span class="comment">//注意这里是从start开始的</span></span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.addLast(nums[i]);</span><br><span class="line">        </span><br><span class="line">        backtrack(nums, i + <span class="number">1</span>); <span class="comment">// 注意参数</span></span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans;</span><br><span class="line">    LinkedList&lt;Integer&gt; tracked;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        ans =<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        tracked = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        DFS(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> LinkedList&lt;&gt;(tracked)); <span class="comment">//回溯树的遍历就收集了所有子集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=step;i&lt;nums.length;i++)&#123;</span><br><span class="line">            tracked.addLast(nums[i]);</span><br><span class="line">            DFS(nums,i+<span class="number">1</span>);</span><br><span class="line">            tracked.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="子集Ⅱ"><a href="#子集Ⅱ" class="headerlink" title="子集Ⅱ"></a>子集Ⅱ</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/44.jpg" alt="44"></p><h1 id="思路整理-1"><a href="#思路整理-1" class="headerlink" title="思路整理"></a>思路整理</h1><ul><li>数组元素有重复，切不可复用，这种情况下，需要先对数组排序和再进行剪枝。<br>剪枝的示意图如下：</li></ul><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/43.jpg" alt="43"></p><ul><li>体现在代码上，需要先进行排序，让相同的元素靠在一起，如果发现 nums[i] == nums[i-1]，则跳过，这里我们也需要注意i值的合法性。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">数组有重复元素，不可复用情况下的模板框架为：</span><br><span class="line">Arrays.sort(nums);</span><br><span class="line">/* 组合/子集问题回溯算法框架 */</span><br><span class="line">void backtrack(int[] nums, int start) &#123;</span><br><span class="line">    // 回溯算法标准框架</span><br><span class="line">    for (int i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">        // 剪枝逻辑，跳过值相同的相邻树枝</span><br><span class="line">        if (i &gt; start &amp;&amp; nums[i] == nums[i - 1]) &#123;  //这一句是关键</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        // 做选择</span><br><span class="line">        track.addLast(nums[i]);</span><br><span class="line">        // 注意参数</span><br><span class="line">        backtrack(nums, i + 1);</span><br><span class="line">        // 撤销选择</span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; tracked = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        DFS(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(tracked));</span><br><span class="line">        <span class="keyword">if</span>(step == nums.length)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=step;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;step&amp;&amp;nums[i]==nums[i-<span class="number">1</span>]) <span class="comment">//这一句是关键</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            tracked.addLast(nums[i]);</span><br><span class="line">            DFS(nums,i+<span class="number">1</span>);</span><br><span class="line">            tracked.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/54.jpg" alt="54"></p><h1 id="思路整理-2"><a href="#思路整理-2" class="headerlink" title="思路整理"></a>思路整理</h1><ul><li>k个数和为n，我们只需要在for循环外（产生子集），进行条件判断即可</li><li>元素没有重复，且不会复用，这就是常规的DFS求子集/组合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        DFS(n,k,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(track.size() == k)&#123; <span class="comment">// 搜集回溯树时，进行判断个数即可</span></span><br><span class="line">            res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(track));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=step;i&lt;=n;i++)&#123;</span><br><span class="line">            track.addLast(i);</span><br><span class="line">            DFS(n,k,i+<span class="number">1</span>);</span><br><span class="line">            track.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/46.jpg" alt="46"></p><h1 id="思路总结"><a href="#思路总结" class="headerlink" title="思路总结"></a>思路总结</h1><ul><li>这种情况属于无重复元素，但元素可以复用。</li><li>我们需要对传统的DFS求子集进行小小调整即可。<strong>我在在进行下一步遍历时传入DFS（nums,i）</strong>,取代常规的DFS（nums,i+1）,这样保证了在求子集时，自己的父元素仍然可以使用。具体示意图如下：<br><strong>这相当于给之前的回溯树添加了一条树枝，在遍历这棵树的过程中，一个元素可以被无限次使用</strong></li></ul><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/45.jpg" alt="45"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">无重复元素，但元素可以复用</span><br><span class="line"><span class="comment">/* 组合/子集问题回溯算法框架 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 回溯算法标准框架</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.length; i++) &#123; <span class="comment">//注意这里从start开始</span></span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.addLast(nums[i]);</span><br><span class="line">        <span class="comment">// 注意参数</span></span><br><span class="line">        backtrack(nums, i);  <span class="comment">//注意这里传入的是 i</span></span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题解法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> trackSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt;trackList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; ansList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        DFS(candidates,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ansList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> []candidates,<span class="keyword">int</span> target,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(trackSum == target)&#123;</span><br><span class="line">            ansList.add(<span class="keyword">new</span> LinkedList&lt;&gt;(trackList));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(trackSum&gt;target)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=step;i&lt;candidates.length;i++)&#123;</span><br><span class="line">            trackList.add(candidates[i]);</span><br><span class="line">            trackSum += candidates[i];</span><br><span class="line">            DFS(candidates,target,i);</span><br><span class="line">            trackList.removeLast();</span><br><span class="line">            trackSum -= candidates[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="组合总和Ⅱ"><a href="#组合总和Ⅱ" class="headerlink" title="组合总和Ⅱ"></a>组合总和Ⅱ</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/47.jpg" alt="47"></p><p>该种情况属于元素重复，但是不可复选。</p><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/48.jpg" alt="48"></p><ol><li>处理方法就是先排序</li><li>在根据前后元素nums[i],nums[i-1]是否相等，在for循环内进行剪枝</li><li>最后在for循环外保存相关子集，并进行剪枝操作</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> trackSum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt;ansList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; trackList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        DFS(candidates,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ansList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> []candidates,<span class="keyword">int</span> target,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(trackSum == target)&#123;</span><br><span class="line">            ansList.add(<span class="keyword">new</span> LinkedList&lt;&gt;(trackList));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(trackSum &gt; target)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=step;i&lt;candidates.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;step&amp;&amp;candidates[i]==candidates[i-<span class="number">1</span>]) <span class="comment">//如果一个节点有多条值相同的树枝相邻，则只遍历第一条，剩下的都剪掉，不要去遍历：</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            trackList.add(candidates[i]);</span><br><span class="line">            trackSum += candidates[i];</span><br><span class="line">            DFS(candidates,target,i+<span class="number">1</span>);</span><br><span class="line">            trackList.removeLast();</span><br><span class="line">            trackSum -= candidates[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="组合总和Ⅲ"><a href="#组合总和Ⅲ" class="headerlink" title="组合总和Ⅲ"></a>组合总和Ⅲ</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/49.jpg" alt="49"></p><h1 id="思路整理-3"><a href="#思路整理-3" class="headerlink" title="思路整理"></a>思路整理</h1><p>本题属于无重复元素，且元素无复用</p><ul><li>只要会常规的DFS求子集、组合,也就是DFS子集树，这道题就没啥问题</li><li>注意for循环的收集ans，和剪枝操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> trackSum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt;ansList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; trackList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        DFS(n,k,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ansList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(trackSum == n &amp;&amp; trackList.size() == k)&#123;</span><br><span class="line">            ansList.add(<span class="keyword">new</span> LinkedList&lt;&gt;(trackList));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(trackSum&gt;n || trackList.size()&gt;k)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=step;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">            trackList.addLast(i);</span><br><span class="line">            trackSum += i;</span><br><span class="line">            DFS(n,k,i+<span class="number">1</span>);</span><br><span class="line">            trackList.removeLast();</span><br><span class="line">            trackSum -= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="全排列Ⅱ"><a href="#全排列Ⅱ" class="headerlink" title="全排列Ⅱ"></a>全排列Ⅱ</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/50.jpg" alt="50"></p><h1 id="思路整理-4"><a href="#思路整理-4" class="headerlink" title="思路整理"></a>思路整理</h1><ul><li>全排列一共有三种情况，无重无复，有重无复，无重可复</li><li>有重有复在去重之后，属于无重可复</li><li>本题属于较难的有重无复。我们有两种处理方案<ol><li>用 prevNum 记录前一条树枝的值，就可以避免遍历值相同的树枝，从而避免产生相同的子树，最终避免出现重复的排列。<strong>用该方法，元素可以是无序的</strong></li><li>保证相同元素在排列中的相对位置保持不变。输入 nums = [1,2,2’,2’’]，2’ 只有在 2 已经被使用的情况下才会被选择，2’’ 只有在 2’ 已经被使用的情况下才会被选择，这就保证了相同元素在排列中的相对位置保证固定。<strong>该方法需要使用辅助数组。</strong></li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt;visited = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> []used;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        Arrays.fill(used,<span class="keyword">false</span>);</span><br><span class="line">        DFS(nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span>[]nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited.size() == nums.length)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> LinkedList&lt;&gt;(visited));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> preNum = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(used[i]||preNum == nums[i]) <span class="comment">//使用preNum的主要原因是因为全排列中for循环下标从0开始，preNum记录上一个元素值，避免产生重复分支。</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line">            preNum = nums[i];</span><br><span class="line">            visited.addLast(nums[i]);</span><br><span class="line">            DFS(nums);</span><br><span class="line">            visited.removeLast();</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 21天刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21天刷题计划（15）深入理解DFS</title>
      <link href="/2022/05/05/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%8815%EF%BC%89%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3DFS/"/>
      <url>/2022/05/05/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%8815%EF%BC%89%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3DFS/</url>
      
        <content type="html"><![CDATA[<h1 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h1><p>解决一个回溯问题，实际上就是一个决策树的遍历过程。<br>[1,2,3]的回溯树如下：</p><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/39.jpg" alt="39"></p><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/40.jpg" alt="40"></p><p>我们只要在递归之前做出选择，在递归之后撤销刚才的选择，就能正确得到每个节点的选择列表和路径。<br>回溯核心代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 选择 in 选择列表:</span><br><span class="line">    # 做选择</span><br><span class="line">    将该选择从选择列表移除</span><br><span class="line">    路径.add(选择)</span><br><span class="line">    backtrack(路径, 选择列表)</span><br><span class="line">    # 撤销选择</span><br><span class="line">    路径.remove(选择)</span><br><span class="line">    将该选择再加入选择列表</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt;visited = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        DFS(nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span>[]nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited.size() == nums.length)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> LinkedList(visited));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123; <span class="comment">// 注意这里的下标是从 0开始的</span></span><br><span class="line">            <span class="keyword">if</span>(visited.contains(nums[i]))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            visited.addLast(nums[i]);</span><br><span class="line">            DFS(nums);</span><br><span class="line">            visited.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h1><p>这道题自己做了很多遍了。<br>总结一下思想</p><p>需要注意step参数，也在递归中相当于一个for函数，去遍历矩阵的每一行<br>在每一行的八个格子里，选择合适的格子放置皇后，便是我们的选择<br>isValid判断位置是否合法函数，只需要判断左上，右上，正上。因为下方还没有放置任何皇后。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;String&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">char</span> [][]maze = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">                maze[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        DFS(maze,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">char</span>[][]maze,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(step == maze.length)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> LinkedList(track));</span><br><span class="line">            <span class="keyword">return</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maze.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isValid(maze,step,i))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            maze[step][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            track.addLast(<span class="keyword">new</span> String(maze[step]));</span><br><span class="line">            DFS(maze,step+<span class="number">1</span>);</span><br><span class="line">            track.removeLast();</span><br><span class="line">            maze[step][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][]maze,<span class="keyword">int</span> step,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="comment">//检查左上方</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m=step-<span class="number">1</span>,n=i-<span class="number">1</span>;m&gt;=<span class="number">0</span>&amp;&amp;n&gt;=<span class="number">0</span>;m--,n--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maze[m][n] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查右上方</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m=step-<span class="number">1</span>,n=i+<span class="number">1</span>;m&gt;=<span class="number">0</span>&amp;&amp;n&lt;maze[<span class="number">0</span>].length;m--,n++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maze[m][n] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查正上方</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> m=step-<span class="number">1</span>;m&gt;=<span class="number">0</span>;m--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maze[m][i] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="DFS深入理解"><a href="#DFS深入理解" class="headerlink" title="DFS深入理解"></a>DFS深入理解</h1><h1 id="划分为K个相等的子集"><a href="#划分为K个相等的子集" class="headerlink" title="划分为K个相等的子集"></a>划分为K个相等的子集</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/51.jpg" alt="51"></p><p>本题我<strong>以数字的视角进行进行选桶</strong>,简单点说就是DFS中的for循环遍历的是bucket[i],利用递归遍历的是数字。这里要类比八皇后的两个遍历对象。</p><ul><li>首先创建一个k大小的一维数组，模拟桶。遍历桶的方式采用for循环的方式</li><li>遍历数的话，可以用for，但是在这里用了很巧妙的方式，利用传入参数step，递归遍历nums数组</li><li><strong>利用参数列表step递归遍历nums数组，和八皇后中，利用step递归遍历行的思想是完全一致的！</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> []bucket;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum % k != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> target = sum/k;</span><br><span class="line">        bucket = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,j = nums.length - <span class="number">1</span>; i &lt; j; i++, j--) &#123;</span><br><span class="line">            <span class="comment">// 交换 nums[i] 和 nums[j]</span></span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> DFS(nums,target,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span>[]nums,<span class="keyword">int</span> target,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(step == nums.length)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bucket.length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bucket[i] != target)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bucket.length;i++)&#123;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span>(bucket[i] + nums[step]&gt;target) <span class="comment">//这个if用于剪枝</span></span><br><span class="line">                 <span class="keyword">continue</span>; <span class="comment">//当前桶不能放，去下一个桶放</span></span><br><span class="line"></span><br><span class="line">            bucket[i] += nums[step];</span><br><span class="line">            <span class="keyword">if</span>(DFS(nums,target,step+<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            bucket[i] -= nums[step];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 21天刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义双向链表</title>
      <link href="/2022/04/30/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/04/30/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="双向链表的自定义实现"><a href="#双向链表的自定义实现" class="headerlink" title="双向链表的自定义实现"></a>双向链表的自定义实现</h1><p>在jdk8中的linkedlist底层是采用双向链表进行实现的。</p><p><strong>关于Node</strong></p><ul><li><strong>Node</strong> :  在双向链表中，我们需要自己定义一个节点Node class。这个Node是普通的双向链表类型，只不过value字段有两个，一个是key，一个是val,这个value字段是根据自己实际题目的需要去自定义的。这里使用与LRU的题目求解。LRU里面有个map要根据key找到双向链表中的节点。</li><li><strong>Node</strong> : next和prev和C语言中的指针是一个意思，用于指向双向链表中的上一个节点和下一个节点。由此构建出整条双向链表。</li></ul><p><strong>关于DoubleList</strong></p><ul><li><strong>DoubleList</strong> : 最开始学习数据结构时，我并不是很理解为什么要将双向链表进行包装，为什么要增加head节点和tail节点把整条双向链表包装起来呢。反正不就是遍历解决一切问题咯。类似的单链表在很多应用中也会被包起来。事实证明当时的我并没有理解到位。经过实践学习后，我发现，如果双向链表被head和tail包装起来之后，在头部和尾部操作起来十分方便。例如在LRU中，我们利用双向链表模拟应用使用的先后。一旦LRU满，我们需要头部删除，一旦get应用或则put应用，我们又需要再末尾新增，如果head和tail包装节点，我们再底层实现上回略显糅杂。</li><li><strong>DoubleList</strong> : 一旦我们理解到双向链表的所有节点被包装在head和tail之间时，我们从上至下写程序即可。在写程序时，切记眼疾手快，三思后行，不要害怕代码量，代码就是一点一点的构思出来的。写到哪、构思到哪。没有一蹴而就的东西！ </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> key,val;</span><br><span class="line">    <span class="keyword">public</span> Node next,prev;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = k;</span><br><span class="line">        <span class="keyword">this</span>.val = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleList</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node head,tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//所有的节点都在head与tail之间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">        x.prev = tail.prev;</span><br><span class="line">        tail.prev.next  = x;</span><br><span class="line">        x.next = tail;</span><br><span class="line">        tail.prev = x;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">        x.prev.next = x.next;</span><br><span class="line">        x.next.prev = x.prev;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">removeFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next == tail)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node first = head.next;</span><br><span class="line">        head.next = first.next;</span><br><span class="line">        first.next.prev = head;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="这里重新附上LRU的实现"><a href="#这里重新附上LRU的实现" class="headerlink" title="这里重新附上LRU的实现"></a>这里重新附上LRU的实现</h1><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220731084828655.png" alt="image-20220731084828655"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当然了哈，LRU利用LinkedHashMap进行实现会更为简洁。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">//first节点为最老节点，末节点为recently节点</span></span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line">    HashMap&lt;Integer,Node&gt;map = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">//存储Integer 对应的Node</span></span><br><span class="line">    DoubleList cache = <span class="keyword">new</span> DoubleList(); <span class="comment">//实际存放的Node</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cap = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(key))</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//当前LRU中含有该节点</span></span><br><span class="line">        <span class="comment">//将其提升为最近使用过的</span></span><br><span class="line">        makeRecently(key);</span><br><span class="line">        <span class="keyword">return</span> map.get(key).val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//get相关函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span>  <span class="title">makeRecently</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="comment">//首先需要删除该节点，删除时需要注意同时删除cache 及 map 中的entry</span></span><br><span class="line">        Node node = map.get(key);</span><br><span class="line">        cache.remove(node);</span><br><span class="line">        cache.addLast(node);</span><br><span class="line">        map.put(key,node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">           Node node = map.get(key);</span><br><span class="line">           cache.remove(node);</span><br><span class="line">           node.val = value;</span><br><span class="line">           cache.addLast(node);</span><br><span class="line">           map.put(key,node);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(cache.size()&gt;=<span class="keyword">this</span>.cap)&#123;</span><br><span class="line">           <span class="keyword">this</span>.removeCacheFirst(key);</span><br><span class="line">       &#125;</span><br><span class="line">       addCacheRecently(key,value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addCacheRecently</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(key,val);</span><br><span class="line">        cache.addLast(node);</span><br><span class="line">        map.put(key,node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeCacheFirst</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        Node node = cache.removeFirst();</span><br><span class="line">        map.remove(node.key);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双向链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch01</title>
      <link href="/2022/04/04/Elasticsearch01/"/>
      <url>/2022/04/04/Elasticsearch01/</url>
      
        <content type="html"><![CDATA[<p>– elasticsearch基础</p><h1 id="1-初识elasticsearch"><a href="#1-初识elasticsearch" class="headerlink" title="1.初识elasticsearch"></a>1.初识elasticsearch</h1><h2 id="1-1-了解ES"><a href="#1-1-了解ES" class="headerlink" title="1.1.了解ES"></a>1.1.了解ES</h2><h3 id="1-1-1-elasticsearch的作用"><a href="#1-1-1-elasticsearch的作用" class="headerlink" title="1.1.1.elasticsearch的作用"></a>1.1.1.elasticsearch的作用</h3><p>elasticsearch是一款非常强大的开源搜索引擎，具备非常多强大功能，可以帮助我们从海量数据中快速找到需要的内容</p><p>例如：</p><ul><li><p>在GitHub搜索代码</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210720193623245.png" alt="image-20210720193623245"></p></li><li><p>在电商网站搜索商品</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210720193633483.png" alt="image-20210720193633483"></p></li><li><p>在百度搜索答案</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210720193641907.png" alt="image-20210720193641907"></p></li><li><p>在打车软件搜索附近的车</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210720193648044.png" alt="image-20210720193648044"></p></li></ul><h3 id="1-1-2-ELK技术栈"><a href="#1-1-2-ELK技术栈" class="headerlink" title="1.1.2.ELK技术栈"></a>1.1.2.ELK技术栈</h3><p>elasticsearch结合kibana、Logstash、Beats，也就是elastic stack（ELK）。被广泛应用在日志数据分析、实时监控等领域：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210720194008781.png" alt="image-20210720194008781"></p><p>而elasticsearch是elastic stack的核心，负责存储、搜索、分析数据。</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210720194230265.png" alt="image-20210720194230265"></p><h3 id="1-1-3-elasticsearch和lucene"><a href="#1-1-3-elasticsearch和lucene" class="headerlink" title="1.1.3.elasticsearch和lucene"></a>1.1.3.elasticsearch和lucene</h3><p>elasticsearch底层是基于<strong>lucene</strong>来实现的。</p><p><strong>Lucene</strong>是一个Java语言的搜索引擎类库，是Apache公司的顶级项目，由DougCutting于1999年研发。官网地址：<a href="https://lucene.apache.org/">https://lucene.apache.org/</a> 。</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210720194547780.png" alt="image-20210720194547780"></p><p><strong>elasticsearch</strong>的发展历史：</p><ul><li>2004年Shay Banon基于Lucene开发了Compass</li><li>2010年Shay Banon 重写了Compass，取名为Elasticsearch。</li></ul><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210720195001221.png" alt="image-20210720195001221"></p><h3 id="1-1-4-为什么不是其他搜索技术？"><a href="#1-1-4-为什么不是其他搜索技术？" class="headerlink" title="1.1.4.为什么不是其他搜索技术？"></a>1.1.4.为什么不是其他搜索技术？</h3><p>目前比较知名的搜索引擎技术排名：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210720195142535.png" alt="image-20210720195142535"></p><p>虽然在早期，Apache Solr是最主要的搜索引擎技术，但随着发展elasticsearch已经渐渐超越了Solr，独占鳌头：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210720195306484.png" alt="image-20210720195306484"></p><h3 id="1-1-5-总结"><a href="#1-1-5-总结" class="headerlink" title="1.1.5.总结"></a>1.1.5.总结</h3><p>什么是elasticsearch？</p><ul><li>一个开源的分布式搜索引擎，可以用来实现搜索、日志统计、分析、系统监控等功能</li></ul><p>什么是elastic stack（ELK）？</p><ul><li>是以elasticsearch为核心的技术栈，包括beats、Logstash、kibana、elasticsearch</li></ul><p>什么是Lucene？</p><ul><li>是Apache的开源搜索引擎类库，提供了搜索引擎的核心API</li></ul><h2 id="1-2-倒排索引"><a href="#1-2-倒排索引" class="headerlink" title="1.2.倒排索引"></a>1.2.倒排索引</h2><p>倒排索引的概念是基于MySQL这样的正向索引而言的。</p><h3 id="1-2-1-正向索引"><a href="#1-2-1-正向索引" class="headerlink" title="1.2.1.正向索引"></a>1.2.1.正向索引</h3><p>那么什么是正向索引呢？例如给下表（tb_goods）中的id创建索引：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210720195531539.png" alt="image-20210720195531539"></p><p>如果是根据id查询，那么直接走索引，查询速度非常快。</p><p>但如果是基于title做模糊查询，只能是逐行扫描数据，流程如下：</p><p>1）用户搜索数据，条件是title符合<code>&quot;%手机%&quot;</code></p><p>2）逐行获取数据，比如id为1的数据</p><p>3）判断数据中的title是否符合用户搜索条件</p><p>4）如果符合则放入结果集，不符合则丢弃。回到步骤1</p><p>逐行扫描，也就是全表扫描，随着数据量增加，其查询效率也会越来越低。当数据量达到数百万时，就是一场灾难。</p><h3 id="1-2-2-倒排索引"><a href="#1-2-2-倒排索引" class="headerlink" title="1.2.2.倒排索引"></a>1.2.2.倒排索引</h3><p>倒排索引中有两个非常重要的概念：</p><ul><li>文档（<code>Document</code>）：用来搜索的数据，其中的每一条数据就是一个文档。例如一个网页、一个商品信息</li><li>词条（<code>Term</code>）：对文档数据或用户搜索数据，利用某种算法分词，得到的具备含义的词语就是词条。例如：我是中国人，就可以分为：我、是、中国人、中国、国人这样的几个词条</li></ul><p><strong>创建倒排索引</strong>是对正向索引的一种特殊处理，流程如下：</p><ul><li>将每一个文档的数据利用算法分词，得到一个个词条</li><li>创建表，每行数据包括词条、词条所在文档id、位置等信息</li><li>因为词条唯一性，可以给词条创建索引，例如hash表结构索引</li></ul><p>如图：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210720200457207.png" alt="image-20210720200457207"></p><p>倒排索引的<strong>搜索流程</strong>如下（以搜索”华为手机”为例）：</p><p>1）用户输入条件<code>&quot;华为手机&quot;</code>进行搜索。</p><p>2）对用户输入内容<strong>分词</strong>，得到词条：<code>华为</code>、<code>手机</code>。</p><p>3）拿着词条在倒排索引中查找，可以得到包含词条的文档id：1、2、3。</p><p>4）拿着文档id到正向索引中查找具体文档。</p><p>如图：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210720201115192.png" alt="image-20210720201115192"></p><p>虽然要先查询倒排索引，再查询倒排索引，但是无论是词条、还是文档id都建立了索引，查询速度非常快！无需全表扫描。</p><h3 id="1-2-3-正向和倒排"><a href="#1-2-3-正向和倒排" class="headerlink" title="1.2.3.正向和倒排"></a>1.2.3.正向和倒排</h3><p>那么为什么一个叫做正向索引，一个叫做倒排索引呢？</p><ul><li><p><strong>正向索引</strong>是最传统的，根据id索引的方式。但根据词条查询时，必须先逐条获取每个文档，然后判断文档中是否包含所需要的词条，是<strong>根据文档找词条的过程</strong>。</p></li><li><p>而<strong>倒排索引</strong>则相反，是先找到用户要搜索的词条，根据词条得到保护词条的文档的id，然后根据id获取文档。是<strong>根据词条找文档的过程</strong>。</p></li></ul><p>是不是恰好反过来了？</p><p>那么两者方式的优缺点是什么呢？</p><p><strong>正向索引</strong>：</p><ul><li>优点：<ul><li>可以给多个字段创建索引</li><li>根据索引字段搜索、排序速度非常快</li></ul></li><li>缺点：<ul><li>根据非索引字段，或者索引字段中的部分词条查找时，只能全表扫描。</li></ul></li></ul><p><strong>倒排索引</strong>：</p><ul><li>优点：<ul><li>根据词条搜索、模糊搜索时，速度非常快</li></ul></li><li>缺点：<ul><li>只能给词条创建索引，而不是字段</li><li>无法根据字段做排序</li></ul></li></ul><h2 id="1-3-es的一些概念"><a href="#1-3-es的一些概念" class="headerlink" title="1.3.es的一些概念"></a>1.3.es的一些概念</h2><p>elasticsearch中有很多独有的概念，与mysql中略有差别，但也有相似之处。</p><h3 id="1-3-1-文档和字段"><a href="#1-3-1-文档和字段" class="headerlink" title="1.3.1.文档和字段"></a>1.3.1.文档和字段</h3><p>elasticsearch是面向<strong>文档（Document）</strong>存储的，可以是数据库中的一条商品数据，一个订单信息。文档数据会被序列化为json格式后存储在elasticsearch中：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210720202707797.png" alt="image-20210720202707797"></p><p>而Json文档中往往包含很多的<strong>字段（Field）</strong>，类似于数据库中的列。</p><h3 id="1-3-2-索引和映射"><a href="#1-3-2-索引和映射" class="headerlink" title="1.3.2.索引和映射"></a>1.3.2.索引和映射</h3><p><strong>索引（Index）</strong>，就是相同类型的文档的集合。</p><p>例如：</p><ul><li>所有用户文档，就可以组织在一起，称为用户的索引；</li><li>所有商品的文档，可以组织在一起，称为商品的索引；</li><li>所有订单的文档，可以组织在一起，称为订单的索引；</li></ul><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210720203022172.png" alt="image-20210720203022172"></p><p>因此，我们可以把索引当做是数据库中的表。</p><p>数据库的表会有约束信息，用来定义表的结构、字段的名称、类型等信息。因此，索引库中就有<strong>映射（mapping）</strong>，是索引中文档的字段约束信息，类似表的结构约束。</p><h3 id="1-3-3-mysql与elasticsearch"><a href="#1-3-3-mysql与elasticsearch" class="headerlink" title="1.3.3.mysql与elasticsearch"></a>1.3.3.mysql与elasticsearch</h3><p>我们统一的把mysql与elasticsearch的概念做一下对比：</p><table><thead><tr><th><strong>MySQL</strong></th><th><strong>Elasticsearch</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Table</td><td>Index</td><td>索引(index)，就是文档的集合，类似数据库的表(table)</td></tr><tr><td>Row</td><td>Document</td><td>文档（Document），就是一条条的数据，类似数据库中的行（Row），文档都是JSON格式</td></tr><tr><td>Column</td><td>Field</td><td>字段（Field），就是JSON文档中的字段，类似数据库中的列（Column）</td></tr><tr><td>Schema</td><td>Mapping</td><td>Mapping（映射）是索引中文档的约束，例如字段类型约束。类似数据库的表结构（Schema）</td></tr><tr><td>SQL</td><td>DSL</td><td>DSL是elasticsearch提供的JSON风格的请求语句，用来操作elasticsearch，实现CRUD</td></tr></tbody></table><p>是不是说，我们学习了elasticsearch就不再需要mysql了呢？</p><p>并不是如此，两者各自有自己的擅长支出：</p><ul><li><p>Mysql：擅长事务类型操作，可以确保数据的安全和一致性</p></li><li><p>Elasticsearch：擅长海量数据的搜索、分析、计算</p></li></ul><p>因此在企业中，往往是两者结合使用：</p><ul><li>对安全性要求较高的写操作，使用mysql实现</li><li>对查询性能要求较高的搜索需求，使用elasticsearch实现</li><li>两者再基于某种方式，实现数据的同步，保证一致性</li></ul><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210720203534945.png" alt="image-20210720203534945"></p><h2 id="1-4-安装es、kibana"><a href="#1-4-安装es、kibana" class="headerlink" title="1.4.安装es、kibana"></a>1.4.安装es、kibana</h2><h3 id="1-4-1-安装"><a href="#1-4-1-安装" class="headerlink" title="1.4.1.安装"></a>1.4.1.安装</h3><p>参考课前资料：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210720203805350.png" alt="image-20210720203805350"> </p><h3 id="1-4-2-分词器"><a href="#1-4-2-分词器" class="headerlink" title="1.4.2.分词器"></a>1.4.2.分词器</h3><p>参考课前资料：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210720203805350.png" alt="image-20210720203805350"> </p><h3 id="1-4-3-总结"><a href="#1-4-3-总结" class="headerlink" title="1.4.3.总结"></a>1.4.3.总结</h3><p>分词器的作用是什么？</p><ul><li>创建倒排索引时对文档分词</li><li>用户搜索时，对输入的内容分词</li></ul><p>IK分词器有几种模式？</p><ul><li>ik_smart：智能切分，粗粒度</li><li>ik_max_word：最细切分，细粒度</li></ul><p>IK分词器如何拓展词条？如何停用词条？</p><ul><li>利用config目录的IkAnalyzer.cfg.xml文件添加拓展词典和停用词典</li><li>在词典中添加拓展词条或者停用词条</li></ul><h1 id="2-索引库操作"><a href="#2-索引库操作" class="headerlink" title="2.索引库操作"></a>2.索引库操作</h1><p>索引库就类似数据库表，mapping映射就类似表的结构。</p><p>我们要向es中存储数据，必须先创建“库”和“表”。</p><h2 id="2-1-mapping映射属性"><a href="#2-1-mapping映射属性" class="headerlink" title="2.1.mapping映射属性"></a>2.1.mapping映射属性</h2><p>mapping是对索引库中文档的约束，常见的mapping属性包括：</p><ul><li>type：字段数据类型，常见的简单类型有：<ul><li>字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址）</li><li>数值：long、integer、short、byte、double、float、</li><li>布尔：boolean</li><li>日期：date</li><li>对象：object</li></ul></li><li>index：是否创建索引，默认为true</li><li>analyzer：使用哪种分词器</li><li>properties：该字段的子字段</li></ul><p>例如下面的json文档：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;age&quot;</span>: <span class="number">21</span>,</span><br><span class="line">    <span class="attr">&quot;weight&quot;</span>: <span class="number">52.1</span>,</span><br><span class="line">    <span class="attr">&quot;isMarried&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;info&quot;</span>: <span class="string">&quot;黑马程序员Java讲师&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;email&quot;</span>: <span class="string">&quot;zy@itcast.cn&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;score&quot;</span>: [<span class="number">99.1</span>, <span class="number">99.5</span>, <span class="number">98.9</span>],</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;firstName&quot;</span>: <span class="string">&quot;云&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;lastName&quot;</span>: <span class="string">&quot;赵&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的每个字段映射（mapping）：</p><ul><li>age：类型为 integer；参与搜索，因此需要index为true；无需分词器</li><li>weight：类型为float；参与搜索，因此需要index为true；无需分词器</li><li>isMarried：类型为boolean；参与搜索，因此需要index为true；无需分词器</li><li>info：类型为字符串，需要分词，因此是text；参与搜索，因此需要index为true；分词器可以用ik_smart</li><li>email：类型为字符串，但是不需要分词，因此是keyword；不参与搜索，因此需要index为false；无需分词器</li><li>score：虽然是数组，但是我们只看元素的类型，类型为float；参与搜索，因此需要index为true；无需分词器</li><li>name：类型为object，需要定义多个子属性<ul><li>name.firstName；类型为字符串，但是不需要分词，因此是keyword；参与搜索，因此需要index为true；无需分词器</li><li>name.lastName；类型为字符串，但是不需要分词，因此是keyword；参与搜索，因此需要index为true；无需分词器</li></ul></li></ul><h2 id="2-2-索引库的CRUD"><a href="#2-2-索引库的CRUD" class="headerlink" title="2.2.索引库的CRUD"></a>2.2.索引库的CRUD</h2><p>这里我们统一使用Kibana编写DSL的方式来演示。</p><h3 id="2-2-1-创建索引库和映射"><a href="#2-2-1-创建索引库和映射" class="headerlink" title="2.2.1.创建索引库和映射"></a>2.2.1.创建索引库和映射</h3><h4 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h4><ul><li>请求方式：PUT</li><li>请求路径：/索引库名，可以自定义</li><li>请求参数：mapping映射</li></ul><p>格式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PUT /索引库名称</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;字段名&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;字段名2&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;字段名3&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;子字段&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// ...略</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PUT /heima</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;info&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">        <span class="string">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot;email&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">        <span class="string">&quot;index&quot;</span>: <span class="string">&quot;falsae&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot;name&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;firstName&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      // ... 略</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-2-查询索引库"><a href="#2-2-2-查询索引库" class="headerlink" title="2.2.2.查询索引库"></a>2.2.2.查询索引库</h3><p><strong>基本语法</strong>：</p><ul><li><p>请求方式：GET</p></li><li><p>请求路径：/索引库名</p></li><li><p>请求参数：无</p></li></ul><p><strong>格式</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /索引库名</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210720211019329.png" alt="image-20210720211019329"></p><h3 id="2-2-3-修改索引库"><a href="#2-2-3-修改索引库" class="headerlink" title="2.2.3.修改索引库"></a>2.2.3.修改索引库</h3><p>倒排索引结构虽然不复杂，但是一旦数据结构改变（比如改变了分词器），就需要重新创建倒排索引，这简直是灾难。因此索引库<strong>一旦创建，无法修改mapping</strong>。</p><p>虽然无法修改mapping中已有的字段，但是却允许添加新的字段到mapping中，因为不会对倒排索引产生影响。</p><p><strong>语法说明</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT /索引库名/_mapping</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;新字段名&quot;</span>:&#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210720212357390.png" alt="image-20210720212357390"></p><h3 id="2-2-4-删除索引库"><a href="#2-2-4-删除索引库" class="headerlink" title="2.2.4.删除索引库"></a>2.2.4.删除索引库</h3><p><strong>语法：</strong></p><ul><li><p>请求方式：DELETE</p></li><li><p>请求路径：/索引库名</p></li><li><p>请求参数：无</p></li></ul><p><strong>格式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /索引库名</span><br></pre></td></tr></table></figure><p>在kibana中测试：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210720212123420.png" alt="image-20210720212123420"></p><h3 id="2-2-5-总结"><a href="#2-2-5-总结" class="headerlink" title="2.2.5.总结"></a>2.2.5.总结</h3><p>索引库操作有哪些？</p><ul><li>创建索引库：PUT /索引库名</li><li>查询索引库：GET /索引库名</li><li>删除索引库：DELETE /索引库名</li><li>添加字段：PUT /索引库名/_mapping</li></ul><h1 id="3-文档操作"><a href="#3-文档操作" class="headerlink" title="3.文档操作"></a>3.文档操作</h1><h2 id="3-1-新增文档"><a href="#3-1-新增文档" class="headerlink" title="3.1.新增文档"></a>3.1.新增文档</h2><p><strong>语法：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST /索引库名/_doc/文档id</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;字段1&quot;</span>: <span class="string">&quot;值1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;字段2&quot;</span>: <span class="string">&quot;值2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;字段3&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;子属性1&quot;</span>: <span class="string">&quot;值3&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;子属性2&quot;</span>: <span class="string">&quot;值4&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST /heima/_doc/<span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;info&quot;</span>: <span class="string">&quot;黑马程序员Java讲师&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;email&quot;</span>: <span class="string">&quot;zy@itcast.cn&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;firstName&quot;</span>: <span class="string">&quot;云&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;lastName&quot;</span>: <span class="string">&quot;赵&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>响应：</strong></p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210720212933362.png" alt="image-20210720212933362"></p><h2 id="3-2-查询文档"><a href="#3-2-查询文档" class="headerlink" title="3.2.查询文档"></a>3.2.查询文档</h2><p>根据rest风格，新增是post，查询应该是get，不过查询一般都需要条件，这里我们把文档id带上。</p><p><strong>语法：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /&#123;索引库名称&#125;/_doc/&#123;id&#125;</span><br></pre></td></tr></table></figure><p><strong>通过kibana查看数据：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /heima/_doc/<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>查看结果：</strong></p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210720213345003.png" alt="image-20210720213345003"></p><h2 id="3-3-删除文档"><a href="#3-3-删除文档" class="headerlink" title="3.3.删除文档"></a>3.3.删除文档</h2><p>删除使用DELETE请求，同样，需要根据id进行删除：</p><p><strong>语法：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /&#123;索引库名&#125;/_doc/id值</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 根据id删除数据</span><br><span class="line">DELETE /heima/_doc/<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210720213634918.png" alt="image-20210720213634918"></p><h2 id="3-4-修改文档"><a href="#3-4-修改文档" class="headerlink" title="3.4.修改文档"></a>3.4.修改文档</h2><p>修改有两种方式：</p><ul><li>全量修改：直接覆盖原来的文档</li><li>增量修改：修改文档中的部分字段</li></ul><h3 id="3-4-1-全量修改"><a href="#3-4-1-全量修改" class="headerlink" title="3.4.1.全量修改"></a>3.4.1.全量修改</h3><p>全量修改是覆盖原来的文档，其本质是：</p><ul><li>根据指定的id删除文档</li><li>新增一个相同id的文档</li></ul><p><strong>注意</strong>：如果根据id删除时，id不存在，第二步的新增也会执行，也就从修改变成了新增操作了。</p><p><strong>语法：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT /&#123;索引库名&#125;/_doc/文档id</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;字段1&quot;</span>: <span class="string">&quot;值1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;字段2&quot;</span>: <span class="string">&quot;值2&quot;</span>,</span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PUT /heima/_doc/<span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;info&quot;</span>: <span class="string">&quot;黑马程序员高级Java讲师&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;email&quot;</span>: <span class="string">&quot;zy@itcast.cn&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;firstName&quot;</span>: <span class="string">&quot;云&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;lastName&quot;</span>: <span class="string">&quot;赵&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-2-增量修改"><a href="#3-4-2-增量修改" class="headerlink" title="3.4.2.增量修改"></a>3.4.2.增量修改</h3><p>增量修改是只修改指定id匹配的文档中的部分字段。</p><p><strong>语法：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /&#123;索引库名&#125;/_update/文档id</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;doc&quot;</span>: &#123;</span><br><span class="line">         <span class="attr">&quot;字段名&quot;</span>: <span class="string">&quot;新的值&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /heima/_update/<span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;doc&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;email&quot;</span>: <span class="string">&quot;ZhaoYun@itcast.cn&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-总结"><a href="#3-5-总结" class="headerlink" title="3.5.总结"></a>3.5.总结</h2><p>文档操作有哪些？</p><ul><li>创建文档：POST /{索引库名}/_doc/文档id   { json文档 }</li><li>查询文档：GET /{索引库名}/_doc/文档id</li><li>删除文档：DELETE /{索引库名}/_doc/文档id</li><li>修改文档：<ul><li>全量修改：PUT /{索引库名}/_doc/文档id { json文档 }</li><li>增量修改：POST /{索引库名}/_update/文档id { “doc”: {字段}}</li></ul></li></ul><h1 id="4-RestAPI"><a href="#4-RestAPI" class="headerlink" title="4.RestAPI"></a>4.RestAPI</h1><p>ES官方提供了各种不同语言的客户端，用来操作ES。这些客户端的本质就是组装DSL语句，通过http请求发送给ES。官方文档地址：<a href="https://www.elastic.co/guide/en/elasticsearch/client/index.html">https://www.elastic.co/guide/en/elasticsearch/client/index.html</a></p><p>其中的Java Rest Client又包括两种：</p><ul><li>Java Low Level Rest Client</li><li>Java High Level Rest Client</li></ul><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210720214555863.png" alt="image-20210720214555863"></p><p>我们学习的是Java HighLevel Rest Client客户端API</p><h2 id="4-0-导入Demo工程"><a href="#4-0-导入Demo工程" class="headerlink" title="4.0.导入Demo工程"></a>4.0.导入Demo工程</h2><h3 id="4-0-1-导入数据"><a href="#4-0-1-导入数据" class="headerlink" title="4.0.1.导入数据"></a>4.0.1.导入数据</h3><p>首先导入课前资料提供的数据库数据：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210720220400297.png" alt="image-20210720220400297"> </p><p>数据结构如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_hotel` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;酒店id&#x27;</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;酒店名称；例：7天酒店&#x27;</span>,</span><br><span class="line">  `address` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;酒店地址；例：航头路&#x27;</span>,</span><br><span class="line">  `price` <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;酒店价格；例：329&#x27;</span>,</span><br><span class="line">  `score` <span class="type">int</span>(<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;酒店评分；例：45，就是4.5分&#x27;</span>,</span><br><span class="line">  `brand` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;酒店品牌；例：如家&#x27;</span>,</span><br><span class="line">  `city` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;所在城市；例：上海&#x27;</span>,</span><br><span class="line">  `star_name` <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;酒店星级，从低到高分别是：1星到5星，1钻到5钻&#x27;</span>,</span><br><span class="line">  `business` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商圈；例：虹桥&#x27;</span>,</span><br><span class="line">  `latitude` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;纬度；例：31.2497&#x27;</span>,</span><br><span class="line">  `longitude` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;经度；例：120.3925&#x27;</span>,</span><br><span class="line">  `pic` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;酒店图片；例:/img/1.jpg&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure><h3 id="4-0-2-导入项目"><a href="#4-0-2-导入项目" class="headerlink" title="4.0.2.导入项目"></a>4.0.2.导入项目</h3><p>然后导入课前资料提供的项目:</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210720220503411.png" alt="image-20210720220503411"> </p><p>项目结构如图：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210720220647541.png" alt="image-20210720220647541"></p><h3 id="4-0-3-mapping映射分析"><a href="#4-0-3-mapping映射分析" class="headerlink" title="4.0.3.mapping映射分析"></a>4.0.3.mapping映射分析</h3><p>创建索引库，最关键的是mapping映射，而mapping映射要考虑的信息包括：</p><ul><li>字段名</li><li>字段数据类型</li><li>是否参与搜索</li><li>是否需要分词</li><li>如果分词，分词器是什么？</li></ul><p>其中：</p><ul><li>字段名、字段数据类型，可以参考数据表结构的名称和类型</li><li>是否参与搜索要分析业务来判断，例如图片地址，就无需参与搜索</li><li>是否分词呢要看内容，内容如果是一个整体就无需分词，反之则要分词</li><li>分词器，我们可以统一使用ik_max_word</li></ul><p>来看下酒店数据的索引库结构:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">PUT /hotel</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;copy_to&quot;</span>: <span class="string">&quot;all&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;address&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;index&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;price&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;score&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;brand&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;copy_to&quot;</span>: <span class="string">&quot;all&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;city&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;copy_to&quot;</span>: <span class="string">&quot;all&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;starName&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;business&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;location&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;geo_point&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;pic&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;index&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;all&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几个特殊字段说明：</p><ul><li>location：地理坐标，里面包含精度、纬度</li><li>all：一个组合字段，其目的是将多字段的值 利用copy_to合并，提供给用户搜索</li></ul><p>地理坐标说明：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210720222110126.png" alt="image-20210720222110126"></p><p>copy_to说明：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210720222221516.png" alt="image-20210720222221516"></p><h3 id="4-0-4-初始化RestClient"><a href="#4-0-4-初始化RestClient" class="headerlink" title="4.0.4.初始化RestClient"></a>4.0.4.初始化RestClient</h3><p>在elasticsearch提供的API中，与elasticsearch一切交互都封装在一个名为RestHighLevelClient的类中，必须先完成这个对象的初始化，建立与elasticsearch的连接。</p><p>分为三步：</p><p>1）引入es的RestHighLevelClient依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）因为SpringBoot默认的ES版本是7.6.2，所以我们需要覆盖默认的ES版本：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">elasticsearch.version</span>&gt;</span>7.12.1<span class="tag">&lt;/<span class="name">elasticsearch.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3）初始化RestHighLevelClient：</p><p>初始化的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RestHighLevelClient client = <span class="keyword">new</span> RestHighLevelClient(RestClient.builder(</span><br><span class="line">        HttpHost.create(<span class="string">&quot;http://192.168.150.101:9200&quot;</span>)</span><br><span class="line">));</span><br></pre></td></tr></table></figure><p>这里为了单元测试方便，我们创建一个测试类HotelIndexTest，然后将初始化的代码编写在@BeforeEach方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpHost;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestHighLevelClient;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HotelIndexTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RestHighLevelClient client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = <span class="keyword">new</span> RestHighLevelClient(RestClient.builder(</span><br><span class="line">                HttpHost.create(<span class="string">&quot;http://192.168.150.101:9200&quot;</span>)</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-1-创建索引库"><a href="#4-1-创建索引库" class="headerlink" title="4.1.创建索引库"></a>4.1.创建索引库</h2><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220804145736023.png" alt="image-20220804145736023"></p><h3 id="4-1-1-代码解读"><a href="#4-1-1-代码解读" class="headerlink" title="4.1.1.代码解读"></a>4.1.1.代码解读</h3><p>创建索引库的API如下：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210720223049408.png" alt="image-20210720223049408"></p><p>代码分为三步：</p><ul><li>1）创建Request对象。因为是创建索引库的操作，因此Request是CreateIndexRequest。</li><li>2）添加请求参数，其实就是DSL的JSON参数部分。因为json字符串很长，这里是定义了静态字符串常量MAPPING_TEMPLATE，让代码看起来更加优雅。</li><li>3）发送请求，client.indices()方法的返回值是IndicesClient类型，封装了所有与索引库操作有关的方法。</li></ul><h3 id="4-1-2-完整示例"><a href="#4-1-2-完整示例" class="headerlink" title="4.1.2.完整示例"></a>4.1.2.完整示例</h3><p>在hotel-demo的cn.itcast.hotel.constants包下，创建一个类，定义mapping映射的JSON字符串常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.constants;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HotelConstants</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAPPING_TEMPLATE = <span class="string">&quot;&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  \&quot;mappings\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    \&quot;properties\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;id\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;name\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;text\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;analyzer\&quot;: \&quot;ik_max_word\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;copy_to\&quot;: \&quot;all\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;address\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;index\&quot;: false\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;price\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;score\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;brand\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;copy_to\&quot;: \&quot;all\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;city\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;copy_to\&quot;: \&quot;all\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;starName\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;business\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;location\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;geo_point\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;pic\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;index\&quot;: false\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;all\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;text\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;analyzer\&quot;: \&quot;ik_max_word\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    &#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  &#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在hotel-demo中的HotelIndexTest测试类中，编写单元测试，实现创建索引：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createHotelIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建Request对象</span></span><br><span class="line">    CreateIndexRequest request = <span class="keyword">new</span> CreateIndexRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备请求的参数：DSL语句</span></span><br><span class="line">    request.source(MAPPING_TEMPLATE, XContentType.JSON);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    client.indices().create(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-删除索引库"><a href="#4-2-删除索引库" class="headerlink" title="4.2.删除索引库"></a>4.2.删除索引库</h2><p>删除索引库的DSL语句非常简单：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /hotel</span><br></pre></td></tr></table></figure><p>与创建索引库相比：</p><ul><li>请求方式从PUT变为DELTE</li><li>请求路径不变</li><li>无请求参数</li></ul><p>所以代码的差异，注意体现在Request对象上。依然是三步走：</p><ul><li>1）创建Request对象。这次是DeleteIndexRequest对象</li><li>2）准备参数。这里是无参</li><li>3）发送请求。改用delete方法</li></ul><p>在hotel-demo中的HotelIndexTest测试类中，编写单元测试，实现删除索引：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testDeleteHotelIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建Request对象</span></span><br><span class="line">    DeleteIndexRequest request = <span class="keyword">new</span> DeleteIndexRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    client.indices().delete(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-判断索引库是否存在"><a href="#4-3-判断索引库是否存在" class="headerlink" title="4.3.判断索引库是否存在"></a>4.3.判断索引库是否存在</h2><p>判断索引库是否存在，本质就是查询，对应的DSL是：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel</span><br></pre></td></tr></table></figure><p>因此与删除的Java代码流程是类似的。依然是三步走：</p><ul><li>1）创建Request对象。这次是GetIndexRequest对象</li><li>2）准备参数。这里是无参</li><li>3）发送请求。改用exists方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testExistsHotelIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建Request对象</span></span><br><span class="line">    GetIndexRequest request = <span class="keyword">new</span> GetIndexRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    <span class="keyword">boolean</span> exists = client.indices().exists(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 3.输出</span></span><br><span class="line">    System.err.println(exists ? <span class="string">&quot;索引库已经存在！&quot;</span> : <span class="string">&quot;索引库不存在！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-总结"><a href="#4-4-总结" class="headerlink" title="4.4.总结"></a>4.4.总结</h2><p>JavaRestClient操作elasticsearch的流程基本类似。核心是client.indices()方法来获取索引库的操作对象。</p><p>索引库操作的基本步骤：</p><ul><li>初始化RestHighLevelClient</li><li>创建XxxIndexRequest。XXX是Create、Get、Delete</li><li>准备DSL（ Create时需要，其它是无参）</li><li>发送请求。调用RestHighLevelClient#indices().xxx()方法，xxx是create、exists、delete</li></ul><h1 id="5-RestClient操作文档"><a href="#5-RestClient操作文档" class="headerlink" title="5.RestClient操作文档"></a>5.RestClient操作文档</h1><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220804153001821.png" alt="image-20220804153001821"></p><p>为了与索引库操作分离，我们再次参加一个测试类，做两件事情：</p><ul><li>初始化RestHighLevelClient</li><li>我们的酒店数据在数据库，需要利用IHotelService去查询，所以注入这个接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.hotel.pojo.Hotel;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.hotel.service.IHotelService;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HotelDocumentTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IHotelService hotelService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RestHighLevelClient client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = <span class="keyword">new</span> RestHighLevelClient(RestClient.builder(</span><br><span class="line">                HttpHost.create(<span class="string">&quot;http://192.168.150.101:9200&quot;</span>)</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-1-新增文档"><a href="#5-1-新增文档" class="headerlink" title="5.1.新增文档"></a>5.1.新增文档</h2><p>我们要将数据库的酒店数据查询出来，写入elasticsearch中。</p><h3 id="5-1-1-索引库实体类"><a href="#5-1-1-索引库实体类" class="headerlink" title="5.1.1.索引库实体类"></a>5.1.1.索引库实体类</h3><p>数据库查询后的结果是一个Hotel类型的对象。结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;tb_hotel&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hotel</span> </span>&#123;</span><br><span class="line">    <span class="meta">@TableId(type = IdType.INPUT)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> String business;</span><br><span class="line">    <span class="keyword">private</span> String longitude;</span><br><span class="line">    <span class="keyword">private</span> String latitude;</span><br><span class="line">    <span class="keyword">private</span> String pic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与我们的索引库结构存在差异：</p><ul><li>longitude和latitude需要合并为location</li></ul><p>因此，我们需要定义一个新的类型，与索引库结构吻合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HotelDoc</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> String business;</span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line">    <span class="keyword">private</span> String pic;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HotelDoc</span><span class="params">(Hotel hotel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = hotel.getId();</span><br><span class="line">        <span class="keyword">this</span>.name = hotel.getName();</span><br><span class="line">        <span class="keyword">this</span>.address = hotel.getAddress();</span><br><span class="line">        <span class="keyword">this</span>.price = hotel.getPrice();</span><br><span class="line">        <span class="keyword">this</span>.score = hotel.getScore();</span><br><span class="line">        <span class="keyword">this</span>.brand = hotel.getBrand();</span><br><span class="line">        <span class="keyword">this</span>.city = hotel.getCity();</span><br><span class="line">        <span class="keyword">this</span>.starName = hotel.getStarName();</span><br><span class="line">        <span class="keyword">this</span>.business = hotel.getBusiness();</span><br><span class="line">        <span class="keyword">this</span>.location = hotel.getLatitude() + <span class="string">&quot;, &quot;</span> + hotel.getLongitude();</span><br><span class="line">        <span class="keyword">this</span>.pic = hotel.getPic();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-1-2-语法说明"><a href="#5-1-2-语法说明" class="headerlink" title="5.1.2.语法说明"></a>5.1.2.语法说明</h3><p>新增文档的DSL语句如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /&#123;索引库名&#125;/_doc/<span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;age&quot;</span>: <span class="number">21</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的java代码如图：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210720230027240.png" alt="image-20210720230027240"></p><p>可以看到与创建索引库类似，同样是三步走：</p><ul><li>1）创建Request对象</li><li>2）准备请求参数，也就是DSL中的JSON文档</li><li>3）发送请求</li></ul><p>变化的地方在于，这里直接使用client.xxx()的API，不再需要client.indices()了。</p><h3 id="5-1-3-完整代码"><a href="#5-1-3-完整代码" class="headerlink" title="5.1.3.完整代码"></a>5.1.3.完整代码</h3><p>我们导入酒店数据，基本流程一致，但是需要考虑几点变化：</p><ul><li>酒店数据来自于数据库，我们需要先查询出来，得到hotel对象</li><li>hotel对象需要转为HotelDoc对象</li><li>HotelDoc需要序列化为json格式</li></ul><p>因此，代码整体步骤如下：</p><ul><li>1）根据id查询酒店数据Hotel</li><li>2）将Hotel封装为HotelDoc</li><li>3）将HotelDoc序列化为JSON</li><li>4）创建IndexRequest，指定索引库名和id</li><li>5）准备请求参数，也就是JSON文档</li><li>6）发送请求</li></ul><p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testAddDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.根据id查询酒店数据</span></span><br><span class="line">    Hotel hotel = hotelService.getById(<span class="number">61083L</span>);</span><br><span class="line">    <span class="comment">// 2.转换为文档类型</span></span><br><span class="line">    HotelDoc hotelDoc = <span class="keyword">new</span> HotelDoc(hotel);</span><br><span class="line">    <span class="comment">// 3.将HotelDoc转json，也就是es需要的数据格式，mysql中的数据格式与es中的有些许差别。</span></span><br><span class="line">    String json = JSON.toJSONString(hotelDoc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.准备Request对象</span></span><br><span class="line">    IndexRequest request = <span class="keyword">new</span> IndexRequest(<span class="string">&quot;hotel&quot;</span>).id(hotelDoc.getId().toString());</span><br><span class="line">    <span class="comment">// 2.准备Json文档</span></span><br><span class="line">    request.source(json, XContentType.JSON);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    client.index(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2-查询文档"><a href="#5-2-查询文档" class="headerlink" title="5.2.查询文档"></a>5.2.查询文档</h2><h3 id="5-2-1-语法说明"><a href="#5-2-1-语法说明" class="headerlink" title="5.2.1.语法说明"></a>5.2.1.语法说明</h3><p>查询的DSL语句如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_doc/&#123;id&#125;</span><br></pre></td></tr></table></figure><p>非常简单，因此代码大概分两步：</p><ul><li>准备Request对象</li><li>发送请求</li></ul><p>不过查询的目的是得到结果，解析为HotelDoc，因此难点是结果的解析。完整代码如下：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210720230811674.png" alt="image-20210720230811674"></p><p>可以看到，结果是一个JSON，其中文档放在一个<code>_source</code>属性中，因此解析就是拿到<code>_source</code>，反序列化为Java对象即可。</p><p>与之前类似，也是三步走：</p><ul><li>1）准备Request对象。这次是查询，所以是GetRequest</li><li>2）发送请求，得到结果。因为是查询，这里调用client.get()方法</li><li>3）解析结果，就是对JSON做反序列化</li></ul><h3 id="5-2-2-完整代码"><a href="#5-2-2-完整代码" class="headerlink" title="5.2.2.完整代码"></a>5.2.2.完整代码</h3><p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testGetDocumentById</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    GetRequest request = <span class="keyword">new</span> GetRequest(<span class="string">&quot;hotel&quot;</span>, <span class="string">&quot;61082&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求，得到响应</span></span><br><span class="line">    GetResponse response = client.get(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 3.解析响应结果</span></span><br><span class="line">    String json = response.getSourceAsString();</span><br><span class="line"></span><br><span class="line">    HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class);</span><br><span class="line">    System.out.println(hotelDoc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-3-删除文档"><a href="#5-3-删除文档" class="headerlink" title="5.3.删除文档"></a>5.3.删除文档</h2><p>删除的DSL为是这样的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /hotel/_doc/&#123;id&#125;</span><br></pre></td></tr></table></figure><p>与查询相比，仅仅是请求方式从DELETE变成GET，可以想象Java代码应该依然是三步走：</p><ul><li>1）准备Request对象，因为是删除，这次是DeleteRequest对象。要指定索引库名和id</li><li>2）准备参数，无参</li><li>3）发送请求。因为是删除，所以是client.delete()方法</li></ul><p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testDeleteDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    DeleteRequest request = <span class="keyword">new</span> DeleteRequest(<span class="string">&quot;hotel&quot;</span>, <span class="string">&quot;61083&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    client.delete(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-4-修改文档"><a href="#5-4-修改文档" class="headerlink" title="5.4.修改文档"></a>5.4.修改文档</h2><h3 id="5-4-1-语法说明"><a href="#5-4-1-语法说明" class="headerlink" title="5.4.1.语法说明"></a>5.4.1.语法说明</h3><p>修改我们讲过两种方式：</p><ul><li>全量修改：本质是先根据id删除，再新增</li><li>增量修改：修改文档中的指定字段值</li></ul><p>在RestClient的API中，全量修改与新增的API完全一致，判断依据是ID：</p><ul><li>如果新增时，ID已经存在，则修改</li><li>如果新增时，ID不存在，则新增</li></ul><p>这里不再赘述，我们主要关注增量修改。</p><p>代码示例如图：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210720231040875.png" alt="image-20210720231040875"></p><p>与之前类似，也是三步走：</p><ul><li>1）准备Request对象。这次是修改，所以是UpdateRequest</li><li>2）准备参数。也就是JSON文档，里面包含要修改的字段</li><li>3）更新文档。这里调用client.update()方法</li></ul><h3 id="5-4-2-完整代码"><a href="#5-4-2-完整代码" class="headerlink" title="5.4.2.完整代码"></a>5.4.2.完整代码</h3><p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testUpdateDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    UpdateRequest request = <span class="keyword">new</span> UpdateRequest(<span class="string">&quot;hotel&quot;</span>, <span class="string">&quot;61083&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备请求参数</span></span><br><span class="line">    request.doc(</span><br><span class="line">        <span class="string">&quot;price&quot;</span>, <span class="string">&quot;952&quot;</span>,</span><br><span class="line">        <span class="string">&quot;starName&quot;</span>, <span class="string">&quot;四钻&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    client.update(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-5-批量导入文档"><a href="#5-5-批量导入文档" class="headerlink" title="5.5.批量导入文档"></a>5.5.批量导入文档</h2><p>案例需求：利用BulkRequest批量将数据库数据导入到索引库中。</p><p>步骤如下：</p><ul><li><p>利用mybatis-plus查询酒店数据</p></li><li><p>将查询到的酒店数据（Hotel）转换为文档类型数据（HotelDoc）</p></li><li><p>利用JavaRestClient中的BulkRequest批处理，实现批量新增文档</p></li></ul><h3 id="5-5-1-语法说明"><a href="#5-5-1-语法说明" class="headerlink" title="5.5.1.语法说明"></a>5.5.1.语法说明</h3><p>批量处理BulkRequest，其本质就是将多个普通的CRUD请求组合在一起发送。</p><p>其中提供了一个add方法，用来添加其他请求：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210720232105943.png" alt="image-20210720232105943"></p><p>可以看到，能添加的请求包括：</p><ul><li>IndexRequest，也就是新增</li><li>UpdateRequest，也就是修改</li><li>DeleteRequest，也就是删除</li></ul><p>因此Bulk中添加了多个IndexRequest，就是批量新增功能了。示例：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210720232431383.png" alt="image-20210720232431383"></p><p>其实还是三步走：</p><ul><li>1）创建Request对象。这里是BulkRequest</li><li>2）准备参数。批处理的参数，就是其它Request对象，这里就是多个IndexRequest</li><li>3）发起请求。这里是批处理，调用的方法为client.bulk()方法</li></ul><p>我们在导入酒店数据时，将上述代码改造成for循环处理即可。</p><h3 id="5-5-2-完整代码"><a href="#5-5-2-完整代码" class="headerlink" title="5.5.2.完整代码"></a>5.5.2.完整代码</h3><p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testBulkRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 批量查询酒店数据</span></span><br><span class="line">    List&lt;Hotel&gt; hotels = hotelService.list();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    BulkRequest request = <span class="keyword">new</span> BulkRequest();</span><br><span class="line">    <span class="comment">// 2.准备参数，添加多个新增的Request</span></span><br><span class="line">    <span class="keyword">for</span> (Hotel hotel : hotels) &#123;</span><br><span class="line">        <span class="comment">// 2.1.转换为文档类型HotelDoc</span></span><br><span class="line">        HotelDoc hotelDoc = <span class="keyword">new</span> HotelDoc(hotel);</span><br><span class="line">        <span class="comment">// 2.2.创建新增文档的Request对象</span></span><br><span class="line">        request.add(<span class="keyword">new</span> IndexRequest(<span class="string">&quot;hotel&quot;</span>)</span><br><span class="line">                    .id(hotelDoc.getId().toString())</span><br><span class="line">                    .source(JSON.toJSONString(hotelDoc), XContentType.JSON));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    client.bulk(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新增成功后我们来查询一下"><a href="#新增成功后我们来查询一下" class="headerlink" title="新增成功后我们来查询一下"></a>新增成功后我们来查询一下</h3><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220804153656435.png" alt="image-20220804153656435"></p><p>查询结果如下：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220804153649168.png" alt="image-20220804153649168"></p><p>批量导入成功。</p><h2 id="5-6-小结"><a href="#5-6-小结" class="headerlink" title="5.6.小结"></a>5.6.小结</h2><p>文档操作的基本步骤：</p><ul><li>初始化RestHighLevelClient</li><li>创建XxxRequest。XXX是Index、Get、Update、Delete、Bulk</li><li>准备参数（Index、Update、Bulk时需要）</li><li>发送请求。调用RestHighLevelClient#.xxx()方法，xxx是index、get、update、delete、bulk</li><li>解析结果（Get时需要）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES索引库及文档操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud02</title>
      <link href="/2022/04/03/SpringCloud02/"/>
      <url>/2022/04/03/SpringCloud02/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringCloud实用篇02"><a href="#SpringCloud实用篇02" class="headerlink" title="SpringCloud实用篇02"></a>SpringCloud实用篇02</h1><p>springcloud 2.2.9 reference doc</p><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/">https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/</a></p><h1 id="1-Nacos配置管理"><a href="#1-Nacos配置管理" class="headerlink" title="1.Nacos配置管理"></a>1.Nacos配置管理</h1><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220801211346504.png" alt="image-20220801211346504"></p><p>Nacos除了可以做注册中心，同样可以做配置管理来使用。</p><h2 id="1-1-统一配置管理"><a href="#1-1-统一配置管理" class="headerlink" title="1.1.统一配置管理"></a>1.1.统一配置管理</h2><p>当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。我们需要一种统一配置管理方案，可以集中管理所有实例的配置。</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714164426792.png" alt="image-20210714164426792"></p><p>Nacos一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新。</p><h3 id="1-1-1-在nacos中添加配置文件"><a href="#1-1-1-在nacos中添加配置文件" class="headerlink" title="1.1.1.在nacos中添加配置文件"></a>1.1.1.在nacos中添加配置文件</h3><p>如何在nacos中管理配置呢？</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714164742924.png" alt="image-20210714164742924"></p><p>然后在弹出的表单中，填写配置信息：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714164856664.png" alt="image-20210714164856664"></p><blockquote><p>注意：项目的核心配置，需要热更新的配置才有放到nacos管理的必要。基本不会变更的一些配置还是保存在微服务本地比较好。</p></blockquote><h3 id="1-1-2-从微服务拉取配置"><a href="#1-1-2-从微服务拉取配置" class="headerlink" title="1.1.2.从微服务拉取配置"></a>1.1.2.从微服务拉取配置</h3><p>微服务要拉取nacos中管理的配置，并且与本地的application.yml配置合并，才能完成项目启动。</p><p>但如果尚未读取application.yml，又如何得知nacos地址呢？</p><p>因此spring引入了一种新的配置文件：bootstrap.yaml文件，会在application.yml之前被读取，流程如下：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/L0iFYNF.png" alt="img"></p><p>1）引入nacos-config依赖</p><p>首先，在user-service服务中，引入nacos-config的客户端依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos配置管理依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）添加bootstrap.yaml</p><p>然后，在user-service中添加一个bootstrap.yaml文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userservice</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment">#开发环境，这里是dev </span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># Nacos地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 文件后缀名</span></span><br></pre></td></tr></table></figure><p>这里会根据spring.cloud.nacos.server-addr获取nacos地址，再根据</p><p><code>$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</code>作为文件id，来读取配置。</p><p>本例中，就是去读取<code>userservice-dev.yaml</code>：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714170845901.png" alt="image-20210714170845901"></p><p>3）读取nacos配置</p><p>在user-service中的UserController中添加业务逻辑，读取pattern.dateformat配置：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714170337448.png" alt="image-20210714170337448"></p><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.user.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.user.pojo.User;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.user.service.UserService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;pattern.dateformat&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String dateformat;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;now&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">now</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在页面访问，可以看到效果：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714170449612.png" alt="image-20210714170449612"></p><h2 id="1-2-配置热更新"><a href="#1-2-配置热更新" class="headerlink" title="1.2.配置热更新"></a>1.2.配置热更新</h2><p>我们最终的目的，是修改nacos中的配置后，微服务中无需重启即可让配置生效，也就是<strong>配置热更新</strong>。</p><p>要实现配置热更新，可以使用两种方式：</p><h3 id="1-2-1-方式一"><a href="#1-2-1-方式一" class="headerlink" title="1.2.1.方式一"></a>1.2.1.方式一</h3><p>在@Value注入的变量所在类上添加注解@RefreshScope：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714171036335.png" alt="image-20210714171036335"></p><h3 id="1-2-2-方式二（配置热更新推荐！）"><a href="#1-2-2-方式二（配置热更新推荐！）" class="headerlink" title="1.2.2.方式二（配置热更新推荐！）"></a>1.2.2.方式二（配置热更新推荐！）</h3><p>使用@ConfigurationProperties注解代替@Value注解。</p><p>在user-service服务中，添加一个类，读取patterrn.dateformat属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.user.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;pattern&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PatternProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String dateformat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在UserController中使用这个类代替@Value：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714171316124.png" alt="image-20210714171316124"></p><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.user.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.user.config.PatternProperties;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.user.pojo.User;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.user.service.UserService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PatternProperties patternProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;now&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">now</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(patternProperties.getDateformat()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220801211950690.png" alt="image-20220801211950690"></p><h2 id="1-3-配置共享"><a href="#1-3-配置共享" class="headerlink" title="1.3.配置共享"></a>1.3.配置共享</h2><p>其实微服务启动时，会去nacos读取多个配置文件，例如：</p><ul><li><p><code>[spring.application.name]-[spring.profiles.active].yaml</code>，例如：userservice-dev.yaml</p></li><li><p><code>[spring.application.name].yaml</code>，例如：userservice.yaml（一定会被读取）</p></li></ul><p>而<code>[spring.application.name].yaml</code>不包含环境，因此可以被多个环境共享。</p><p>下面我们通过案例来测试配置共享</p><h3 id="1）添加一个环境共享配置"><a href="#1）添加一个环境共享配置" class="headerlink" title="1）添加一个环境共享配置"></a>1）添加一个环境共享配置</h3><p>我们在nacos中添加一个userservice.yaml文件：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714173233650.png" alt="image-20210714173233650"></p><h3 id="2）在user-service中读取共享配置"><a href="#2）在user-service中读取共享配置" class="headerlink" title="2）在user-service中读取共享配置"></a>2）在user-service中读取共享配置</h3><p>在user-service服务中，修改PatternProperties类，读取新添加的属性：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714173324231.png" alt="image-20210714173324231"></p><p>在user-service服务中，修改UserController，添加一个方法：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714173721309.png" alt="image-20210714173721309"></p><h3 id="3）运行两个UserApplication，使用不同的profile"><a href="#3）运行两个UserApplication，使用不同的profile" class="headerlink" title="3）运行两个UserApplication，使用不同的profile"></a>3）运行两个UserApplication，使用不同的profile</h3><p>修改UserApplication2这个启动项，改变其profile值：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714173538538.png" alt="image-20210714173538538"></p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714173519963.png" alt="image-20210714173519963"></p><p>这样，UserApplication(8081)使用的profile是dev，UserApplication2(8082)使用的profile是test。</p><p>启动UserApplication和UserApplication2</p><p>访问<a href="http://localhost:8081/user/prop%EF%BC%8C%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:8081/user/prop，结果：</a></p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714174313344.png" alt="image-20210714174313344"></p><p>访问<a href="http://localhost:8082/user/prop%EF%BC%8C%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:8082/user/prop，结果：</a></p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714174424818.png" alt="image-20210714174424818"></p><p>可以看出来，不管是dev，还是test环境，都读取到了envSharedValue这个属性的值。</p><h3 id="4）配置共享的优先级"><a href="#4）配置共享的优先级" class="headerlink" title="4）配置共享的优先级"></a>4）配置共享的优先级</h3><p>当nacos、服务本地同时出现相同属性时，优先级有高低之分：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714174623557.png" alt="image-20210714174623557"></p><h2 id="1-4-搭建Nacos集群"><a href="#1-4-搭建Nacos集群" class="headerlink" title="1.4.搭建Nacos集群"></a>1.4.搭建Nacos集群</h2><p>Nacos生产环境下一定要部署为集群状态，部署方式参考课前资料中的文档：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714174728042.png" alt="image-20210714174728042"></p><h1 id="2-Feign远程调用"><a href="#2-Feign远程调用" class="headerlink" title="2.Feign远程调用"></a>2.Feign远程调用</h1><p>先来看我们以前利用RestTemplate发起远程调用的代码：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714174814204.png" alt="image-20210714174814204"></p><p>存在下面的问题：</p><p>•代码可读性差，编程体验不统一</p><p>•参数复杂URL难以维护</p><p>Feign是一个声明式的http客户端，官方地址：<a href="https://github.com/OpenFeign/feign">https://github.com/OpenFeign/feign</a></p><p>其作用就是帮助我们优雅的实现http请求的发送，解决上面提到的问题。</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714174918088.png" alt="image-20210714174918088"></p><h2 id="2-1-Feign替代RestTemplate"><a href="#2-1-Feign替代RestTemplate" class="headerlink" title="2.1.Feign替代RestTemplate"></a>2.1.Feign替代RestTemplate</h2><p>Fegin的使用步骤如下：</p><h3 id="1）引入依赖"><a href="#1）引入依赖" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>我们在order-service服务的pom文件中引入feign的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2）添加注解"><a href="#2）添加注解" class="headerlink" title="2）添加注解"></a>2）添加注解</h3><p>在order-service的启动类添加注解开启Feign的功能：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714175102524.png" alt="image-20210714175102524"></p><h3 id="3）编写Feign的客户端"><a href="#3）编写Feign的客户端" class="headerlink" title="3）编写Feign的客户端"></a>3）编写Feign的客户端</h3><p>在order-service中新建一个接口，内容如下：（相当于就是抄需要被访问服务的对应请求接口）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.order.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.order.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(&quot;userservice&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">User <span class="title">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个客户端主要是基于SpringMVC的注解来声明远程调用的信息，比如：</p><ul><li>服务名称：userservice</li><li>请求方式：GET</li><li>请求路径：/user/{id}</li><li>请求参数：Long id</li><li>返回值类型：User</li></ul><p>这样，Feign就可以帮助我们发送http请求，无需自己使用RestTemplate来发送了。</p><h3 id="4）测试"><a href="#4）测试" class="headerlink" title="4）测试"></a>4）测试</h3><p>修改order-service中的OrderService类中的queryOrderById方法，使用Feign客户端代替RestTemplate：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714175415087.png" alt="image-20210714175415087"></p><p>是不是看起来优雅多了。</p><h3 id="5）总结"><a href="#5）总结" class="headerlink" title="5）总结"></a>5）总结</h3><p>使用Feign的步骤：</p><p>① 引入依赖</p><p>② 添加@EnableFeignClients注解</p><p>③ 编写FeignClient接口</p><p>④ 使用FeignClient中定义的方法代替RestTemplate</p><h2 id="2-2-自定义配置"><a href="#2-2-自定义配置" class="headerlink" title="2.2.自定义配置"></a>2.2.自定义配置</h2><p>Feign可以支持很多的自定义配置，如下表所示：</p><table><thead><tr><th>类型</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td><strong>feign.Logger.Level</strong></td><td>修改日志级别</td><td>包含四种不同的级别：NONE、BASIC、HEADERS、FULL</td></tr><tr><td>feign.codec.Decoder</td><td>响应结果的解析器</td><td>http远程调用的结果做解析，例如解析json字符串为java对象</td></tr><tr><td>feign.codec.Encoder</td><td>请求参数编码</td><td>将请求参数编码，便于通过http请求发送</td></tr><tr><td>feign. Contract</td><td>支持的注解格式</td><td>默认是SpringMVC的注解</td></tr><tr><td>feign. Retryer</td><td>失败重试机制</td><td>请求失败的重试机制，默认是没有，不过会使用Ribbon的重试</td></tr></tbody></table><p>一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的@Bean覆盖默认Bean即可。</p><p>下面以日志为例来演示如何自定义配置。</p><h3 id="2-2-1-配置文件方式"><a href="#2-2-1-配置文件方式" class="headerlink" title="2.2.1.配置文件方式"></a>2.2.1.配置文件方式</h3><p>基于配置文件修改feign的日志级别可以针对单个服务：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span>  </span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span> </span><br><span class="line">      <span class="attr">userservice:</span> <span class="comment"># 针对某个微服务的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">FULL</span> <span class="comment">#  日志级别 </span></span><br></pre></td></tr></table></figure><p>也可以针对所有服务：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span>  </span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span> </span><br><span class="line">      <span class="attr">default:</span> <span class="comment"># 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">FULL</span> <span class="comment">#  日志级别 </span></span><br></pre></td></tr></table></figure><p>而日志的级别分为四种：</p><ul><li>NONE：不记录任何日志信息，这是默认值。</li><li>BASIC：仅记录请求的方法，URL以及响应状态码和执行时间</li><li>HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</li><li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。</li></ul><h3 id="2-2-2-Java代码方式"><a href="#2-2-2-Java代码方式" class="headerlink" title="2.2.2.Java代码方式"></a>2.2.2.Java代码方式</h3><p>也可以基于Java代码来修改日志级别，先声明一个类，然后声明一个Logger.Level的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultFeignConfiguration</span>  </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger.<span class="function">Level <span class="title">feignLogLevel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.BASIC; <span class="comment">// 日志级别为BASIC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要<strong>全局生效</strong>，将其放到启动类的@EnableFeignClients这个注解中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration .class)</span> </span><br></pre></td></tr></table></figure><p>如果是<strong>局部生效</strong>，则把它放到对应的@FeignClient这个注解中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;userservice&quot;, configuration = DefaultFeignConfiguration .class)</span> </span><br></pre></td></tr></table></figure><h2 id="2-3-Feign使用优化"><a href="#2-3-Feign使用优化" class="headerlink" title="2.3.Feign使用优化"></a>2.3.Feign使用优化</h2><p><span style="color:red;background:white;font-size:20px;font-family:宋体;">feign是声明式客户端，它只是把我们的声明变成HTTP请求，最后发Http请求还是会以来其它框架。</span></p><p>Feign底层发起http请求，依赖于其它的框架。其底层客户端实现包括：</p><p>•URLConnection：默认实现，不支持连接池</p><p>•Apache HttpClient ：支持连接池</p><p>•OKHttp：支持连接池</p><p><span style="color:white;background:red;font-size:20px;font-family:宋体;">因此提高Feign的性能主要手段就是使用<strong>连接池</strong>代替默认的URLConnection。</span></p><p>这里我们用Apache的HttpClient来演示。</p><p>1）引入依赖</p><p>在order-service的pom文件中引入Apache的HttpClient依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--httpClient的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）配置连接池</p><p>在order-service的application.yml中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span> <span class="comment"># default全局的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">BASIC</span> <span class="comment"># 日志级别，BASIC就是基本的请求和响应信息</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启feign对HttpClient的支持</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">200</span> <span class="comment"># 最大的连接数</span></span><br><span class="line">    <span class="attr">max-connections-per-route:</span> <span class="number">50</span> <span class="comment"># 每个路径的最大连接数</span></span><br></pre></td></tr></table></figure><p>接下来，在FeignClientFactoryBean中的loadBalance方法中打断点：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714185925910.png" alt="image-20210714185925910"></p><p>Debug方式启动order-service服务，可以看到这里的client，底层就是Apache HttpClient：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714190041542.png" alt="image-20210714190041542"></p><p>总结，Feign的优化：</p><p>1.日志级别尽量用basic</p><p>2.使用HttpClient或OKHttp代替URLConnection</p><p>①  引入feign-httpClient依赖</p><p>②  配置文件开启httpClient功能，设置连接池参数</p><h2 id="2-4-最佳实践"><a href="#2-4-最佳实践" class="headerlink" title="2.4.最佳实践"></a>2.4.最佳实践</h2><p>所谓最近实践，就是使用过程中总结的经验，最好的一种使用方式。</p><p>自习观察可以发现，Feign的客户端与服务提供者的controller代码非常相似：</p><p>feign客户端：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714190542730.png" alt="image-20210714190542730"></p><p>UserController：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714190528450.png" alt="image-20210714190528450"></p><p>有没有一种办法简化这种重复的代码编写呢？</p><h3 id="2-4-1-继承方式"><a href="#2-4-1-继承方式" class="headerlink" title="2.4.1.继承方式"></a>2.4.1.继承方式</h3><p>一样的代码可以通过继承来共享：</p><p>1）定义一个API接口，利用定义方法，并基于SpringMVC注解做声明。</p><p>2）Feign客户端和Controller都集成改接口</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220801222338162.png" alt="image-20220801222338162"></p><p>优点：</p><ul><li>简单</li><li>实现了代码共享</li></ul><p>缺点：</p><ul><li><p>服务提供方、服务消费方紧耦合</p></li><li><p>参数列表中的注解映射并不会继承，因此Controller中必须再次声明方法、参数列表、注解</p></li></ul><h3 id="2-4-2-抽取方式"><a href="#2-4-2-抽取方式" class="headerlink" title="2.4.2.抽取方式"></a>2.4.2.抽取方式</h3><p>将Feign的Client抽取为独立模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用。</p><p>例如，将UserClient、User、Feign的默认配置都抽取到一个feign-api包中，所有微服务引用该依赖包，即可直接使用。</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714214041796.png" alt="image-20210714214041796"></p><h3 id="2-4-3-实现基于抽取的最佳实践"><a href="#2-4-3-实现基于抽取的最佳实践" class="headerlink" title="2.4.3.实现基于抽取的最佳实践"></a>2.4.3.实现基于抽取的最佳实践</h3><h4 id="1）抽取"><a href="#1）抽取" class="headerlink" title="1）抽取"></a>1）抽取</h4><p>首先创建一个module，命名为feign-api：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714204557771.png" alt="image-20210714204557771"></p><p>项目结构：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714204656214.png" alt="image-20210714204656214"></p><p>在feign-api中然后引入feign的starter依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，order-service中编写的UserClient、User、DefaultFeignConfiguration都复制到feign-api项目中</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714205221970.png" alt="image-20210714205221970"></p><h4 id="2）在order-service中使用feign-api"><a href="#2）在order-service中使用feign-api" class="headerlink" title="2）在order-service中使用feign-api"></a>2）在order-service中使用feign-api</h4><p>首先，删除order-service中的UserClient、User、DefaultFeignConfiguration等类或接口。</p><p>在order-service的pom文件中中引入feign-api的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改order-service中的所有与上述三个组件有关的导包部分，改成导入feign-api中的包</p><h4 id="3）重启测试"><a href="#3）重启测试" class="headerlink" title="3）重启测试"></a>3）重启测试</h4><p>重启后，发现服务报错了：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714205623048.png" alt="image-20210714205623048"></p><p><span style="color:white;background:red;font-size:20px;font-family:宋体;">这是因为UserClient现在在cn.itcast.feign.clients包下，而order-service的@EnableFeignClients注解是在cn.itcast.order包下，不在同一个包，无法扫描到UserClient。</span></p><h4 id="4）解决扫描包问题"><a href="#4）解决扫描包问题" class="headerlink" title="4）解决扫描包问题"></a>4）解决扫描包问题</h4><p>方式一：</p><p>指定Feign应该扫描的包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(basePackages = &quot;cn.itcast.feign.clients&quot;)</span></span><br></pre></td></tr></table></figure><p>方式二：</p><p>指定需要加载的Client接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(clients = &#123;UserClient.class&#125;)</span></span><br></pre></td></tr></table></figure><h1 id="3-Gateway服务网关"><a href="#3-Gateway服务网关" class="headerlink" title="3.Gateway服务网关"></a>3.Gateway服务网关</h1><p>Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。</p><p><span style="color:white;background:red;font-size:20px;font-family:宋体;">服务网关是对整个微服务的一种保护</span></p><h2 id="3-1-为什么需要网关"><a href="#3-1-为什么需要网关" class="headerlink" title="3.1.为什么需要网关"></a>3.1.为什么需要网关</h2><p>Gateway网关是我们服务的守门神，所有微服务的统一入口。</p><p>网关的<strong>核心功能特性</strong>：</p><ul><li>请求路由</li><li>权限控制</li><li>限流</li></ul><p>架构图：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714210131152.png" alt="image-20210714210131152"></p><p><strong>权限控制</strong>：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</p><p><strong>路由和负载均衡</strong>：一切请求都必须先经过gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。</p><p><strong>限流</strong>：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</p><p>在SpringCloud中网关的实现包括两种：</p><ul><li>gateway</li><li>zuul</li></ul><p>Zuul是基于Servlet的实现，属于阻塞式编程。而SpringCloudGateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</p><h2 id="3-2-gateway快速入门"><a href="#3-2-gateway快速入门" class="headerlink" title="3.2.gateway快速入门"></a>3.2.gateway快速入门</h2><p>下面，我们就演示下网关的基本路由功能。基本步骤如下：</p><ol><li>创建SpringBoot工程gateway，引入网关依赖</li><li>编写启动类</li><li>编写基础配置和路由规则</li><li>启动网关服务进行测试</li></ol><h3 id="1）创建gateway服务，引入依赖"><a href="#1）创建gateway服务，引入依赖" class="headerlink" title="1）创建gateway服务，引入依赖"></a>1）创建gateway服务，引入依赖</h3><p>创建服务：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714210919458.png" alt="image-20210714210919458"></p><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--网关--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--nacos服务发现依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2）编写启动类"><a href="#2）编写启动类" class="headerlink" title="2）编写启动类"></a>2）编写启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.gateway;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GatewayApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(GatewayApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3）编写基础配置和路由规则"><a href="#3）编写基础配置和路由规则" class="headerlink" title="3）编写基础配置和路由规则"></a>3）编写基础配置和路由规则</h3><p>创建application.yml文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span> <span class="comment"># 网关端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span> <span class="comment"># 网关路由配置</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> <span class="comment"># 路由id，自定义，只要唯一即可</span></span><br><span class="line">          <span class="comment"># uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userservice</span> <span class="comment"># 路由的目标地址 lb就是负载均衡，后面跟服务名称</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment"># 路由断言，也就是判断请求是否符合路由规则的条件</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span> <span class="comment"># 这个是按照路径匹配，只要以/user/开头就符合要求</span></span><br></pre></td></tr></table></figure><p>我们将符合<code>Path</code> 规则的一切请求，都代理到 <code>uri</code>参数指定的地址。</p><p>本例中，我们将 <code>/user/**</code>开头的请求，代理到<code>lb://userservice</code>，lb是负载均衡，根据服务名拉取服务列表，实现负载均衡。</p><h3 id="4）重启测试"><a href="#4）重启测试" class="headerlink" title="4）重启测试"></a>4）重启测试</h3><p>重启网关，访问<a href="http://localhost:10010/user/1%E6%97%B6%EF%BC%8C%E7%AC%A6%E5%90%88%60/user/**%60%E8%A7%84%E5%88%99%EF%BC%8C%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%88%B0uri%EF%BC%9Ahttp://userservice/user/1%EF%BC%8C%E5%BE%97%E5%88%B0%E4%BA%86%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:10010/user/1时，符合`/user/**`规则，请求转发到uri：http://userservice/user/1，得到了结果：</a></p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714211908341.png" alt="image-20210714211908341"></p><h3 id="5）网关路由的流程图"><a href="#5）网关路由的流程图" class="headerlink" title="5）网关路由的流程图"></a>5）网关路由的流程图</h3><p>整个访问的流程如下：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220801230621459.png" alt="image-20220801230621459"></p><p>总结：</p><p>网关搭建步骤：</p><ol><li><p>创建项目，引入nacos服务发现和gateway依赖</p></li><li><p>配置application.yml，包括服务基本信息、nacos地址、路由</p></li></ol><p>路由配置包括：</p><ol><li><p>路由id：路由的唯一标示</p></li><li><p>路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡</p></li><li><p>路由断言（predicates）：判断路由的规则，</p></li><li><p>路由过滤器（filters）：对请求或响应做处理</p></li></ol><p>接下来，就重点来学习路由断言和路由过滤器的详细知识</p><h2 id="3-3-断言工厂"><a href="#3-3-断言工厂" class="headerlink" title="3.3.断言工厂"></a>3.3.断言工厂</h2><p>我们在配置文件中写的断言规则只是字符串，这些字符串会被Predicate Factory读取并处理，转变为路由判断的条件</p><p>例如Path=/user/**是按照路径匹配，这个规则是由</p><p><code>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory</code>类来</p><p>处理的，像这样的断言工厂在SpringCloudGateway还有十几个:</p><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>After</td><td>是某个时间点后的请求</td><td>-  After=2037-01-20T17:42:47.789-07:00[America/Denver]</td></tr><tr><td>Before</td><td>是某个时间点之前的请求</td><td>-  Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</td></tr><tr><td>Between</td><td>是某两个时间点之前的请求</td><td>-  Between=2037-01-20T17:42:47.789-07:00[America/Denver],  2037-01-21T17:42:47.789-07:00[America/Denver]</td></tr><tr><td>Cookie</td><td>请求必须包含某些cookie</td><td>- Cookie=chocolate, ch.p</td></tr><tr><td>Header</td><td>请求必须包含某些header</td><td>- Header=X-Request-Id, \d+</td></tr><tr><td>Host</td><td>请求必须是访问某个host（域名）</td><td>-  Host=<strong>.somehost.org,</strong>.anotherhost.org</td></tr><tr><td>Method</td><td>请求方式必须是指定方式</td><td>- Method=GET,POST</td></tr><tr><td>Path</td><td>请求路径必须符合指定规则</td><td>- Path=/red/{segment},/blue/**</td></tr><tr><td>Query</td><td>请求参数必须包含指定参数</td><td>- Query=name, Jack或者-  Query=name</td></tr><tr><td>RemoteAddr</td><td>请求者的ip必须是指定范围</td><td>- RemoteAddr=192.168.1.1/24</td></tr><tr><td>Weight</td><td>权重处理</td><td></td></tr></tbody></table><p>我们只需要掌握Path这种路由工程就可以了。</p><h2 id="3-4-过滤器工厂"><a href="#3-4-过滤器工厂" class="headerlink" title="3.4.过滤器工厂"></a>3.4.过滤器工厂</h2><p>GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714212312871.png" alt="image-20210714212312871"></p><h3 id="3-4-1-路由过滤器的种类"><a href="#3-4-1-路由过滤器的种类" class="headerlink" title="3.4.1.路由过滤器的种类"></a>3.4.1.路由过滤器的种类</h3><p>Spring提供了31种不同的路由过滤器工厂。例如：</p><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>AddRequestHeader</td><td>给当前请求添加一个请求头</td></tr><tr><td>RemoveRequestHeader</td><td>移除请求中的一个请求头</td></tr><tr><td>AddResponseHeader</td><td>给响应结果中添加一个响应头</td></tr><tr><td>RemoveResponseHeader</td><td>从响应结果中移除有一个响应头</td></tr><tr><td>RequestRateLimiter</td><td>限制请求的流量</td></tr></tbody></table><h3 id="3-4-2-请求头过滤器"><a href="#3-4-2-请求头过滤器" class="headerlink" title="3.4.2.请求头过滤器"></a>3.4.2.请求头过滤器</h3><p>下面我们以AddRequestHeader 为例来讲解。</p><blockquote><p><strong>需求</strong>：给所有进入userservice的请求添加一个请求头：Truth=itcast is freaking awesome!</p></blockquote><p>只需要修改gateway服务的application.yml文件，添加路由过滤即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> </span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://userservice</span> </span><br><span class="line">        <span class="attr">predicates:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/user/**</span> </span><br><span class="line">        <span class="attr">filters:</span> <span class="comment"># 过滤器</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=Truth,</span> <span class="string">Itcast</span> <span class="string">is</span> <span class="string">freaking</span> <span class="string">awesome!</span> <span class="comment"># 添加请求头</span></span><br></pre></td></tr></table></figure><p>当前过滤器写在userservice路由下，因此仅仅对访问userservice的请求有效。</p><h3 id="3-4-3-默认过滤器"><a href="#3-4-3-默认过滤器" class="headerlink" title="3.4.3.默认过滤器"></a>3.4.3.默认过滤器</h3><p>如果要对所有的路由都生效，则可以将过滤器工厂写到default下。格式如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> </span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://userservice</span> </span><br><span class="line">        <span class="attr">predicates:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/user/**</span></span><br><span class="line">      <span class="attr">default-filters:</span> <span class="comment"># 默认过滤项</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">AddRequestHeader=Truth,</span> <span class="string">Itcast</span> <span class="string">is</span> <span class="string">freaking</span> <span class="string">awesome!</span> </span><br></pre></td></tr></table></figure><h3 id="3-4-4-总结"><a href="#3-4-4-总结" class="headerlink" title="3.4.4.总结"></a>3.4.4.总结</h3><p>过滤器的作用是什么？</p><p>① 对路由的请求或响应做加工处理，比如添加请求头</p><p>② 配置在路由下的过滤器只对当前路由的请求生效</p><p>defaultFilters的作用是什么？</p><p>① 对所有路由都生效的过滤器</p><h2 id="3-5-全局过滤器"><a href="#3-5-全局过滤器" class="headerlink" title="3.5.全局过滤器"></a>3.5.全局过滤器</h2><p>上一节学习的过滤器，网关提供了31种，但每一种过滤器的作用都是固定的。如果我们希望拦截请求，做自己的业务逻辑则没办法实现。</p><h3 id="3-5-1-全局过滤器作用"><a href="#3-5-1-全局过滤器作用" class="headerlink" title="3.5.1.全局过滤器作用"></a>3.5.1.全局过滤器作用</h3><p>全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样。区别在于GatewayFilter通过配置定义，处理逻辑是固定的；而GlobalFilter的逻辑需要自己写代码实现。</p><p>定义方式是实现GlobalFilter接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GlobalFilter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  处理当前请求，有必要的话通过&#123;<span class="doctag">@link</span> GatewayFilterChain&#125;将请求交给下一个过滤器处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange 请求上下文，里面可以获取Request、Response等信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chain 用来把请求委托给下一个过滤器 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> Mono&lt;Void&gt;&#125; 返回标示当前过滤器业务结束</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在filter中编写自定义逻辑，可以实现下列功能：</p><ul><li>登录状态判断</li><li>权限校验</li><li>请求限流等</li></ul><h3 id="3-5-2-自定义全局过滤器（适合与过滤操作复杂的场景，自定义一个类）"><a href="#3-5-2-自定义全局过滤器（适合与过滤操作复杂的场景，自定义一个类）" class="headerlink" title="3.5.2.自定义全局过滤器（适合与过滤操作复杂的场景，自定义一个类）"></a>3.5.2.自定义全局过滤器（适合与过滤操作复杂的场景，自定义一个类）</h3><p>需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：</p><ul><li><p>参数中是否有authorization，</p></li><li><p>authorization参数值是否为admin</p></li></ul><p>如果同时满足则放行，否则拦截</p><p>实现：</p><p><span style="color:white;background:red;font-size:20px;font-family:宋体;">在gateway中定义一个过滤器：  定义方式为实现GlobalFilter接口,重写其中的 Mono<Void> filter方法。</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.gateway.filters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Order(-1)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizeFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.获取请求参数</span></span><br><span class="line">        MultiValueMap&lt;String, String&gt; params = exchange.getRequest().getQueryParams();</span><br><span class="line">        <span class="comment">// 2.获取authorization参数</span></span><br><span class="line">        String auth = params.getFirst(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.校验</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(auth)) &#123;</span><br><span class="line">            <span class="comment">// 放行</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.拦截</span></span><br><span class="line">        <span class="comment">// 4.1.禁止访问，设置状态码</span></span><br><span class="line">        exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);</span><br><span class="line">        <span class="comment">// 4.2.结束处理</span></span><br><span class="line">        <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-3-过滤器执行顺序"><a href="#3-5-3-过滤器执行顺序" class="headerlink" title="3.5.3.过滤器执行顺序"></a>3.5.3.过滤器执行顺序</h3><p>请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter</p><p><span style="color:white;background:red;font-size:20px;font-family:宋体;">请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器：</span></p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714214228409.png" alt="image-20210714214228409"></p><p>排序的规则是什么呢？</p><ul><li>每一个过滤器都必须指定一个int类型的order值，<strong>order值越小，优先级越高，执行顺序越靠前</strong>。</li><li>GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定</li><li>路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增。</li><li>当过滤器的order值一样时，会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行。</li></ul><p>详细内容，可以查看源码：</p><p><code>org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator#getFilters()</code>方法是先加载defaultFilters，然后再加载某个route的filters，然后合并。</p><p><code>org.springframework.cloud.gateway.handler.FilteringWebHandler#handle()</code>方法会加载全局过滤器，与前面的过滤器合并后根据order排序，组织过滤器链</p><h2 id="3-6-跨域问题"><a href="#3-6-跨域问题" class="headerlink" title="3.6.跨域问题"></a>3.6.跨域问题</h2><h3 id="3-6-1-什么是跨域问题"><a href="#3-6-1-什么是跨域问题" class="headerlink" title="3.6.1.什么是跨域问题"></a>3.6.1.什么是跨域问题</h3><p>跨域：域名不一致就是跨域，主要包括：</p><ul><li><p>域名不同： <a href="http://www.taobao.com/">www.taobao.com</a> 和 <a href="http://www.taobao.org/">www.taobao.org</a> 和 <a href="http://www.jd.com/">www.jd.com</a> 和 miaosha.jd.com</p></li><li><p>域名相同，端口不同：localhost:8080和localhost8081</p></li></ul><p>跨域问题：浏览器禁止请求的<span style="color:white;background:red;font-size:20px;font-family:宋体;">发起者与服务端</span>发生跨域<span style="color:white;background:red;font-size:20px;font-family:宋体;">ajax请求</span>，请求被浏览器拦截的问题</p><p>解决方案：CORS，这个以前应该学习过，这里不再赘述了。不知道的小伙伴可以查看<a href="https://www.ruanyifeng.com/blog/2016/04/cors.html">https://www.ruanyifeng.com/blog/2016/04/cors.html</a></p><p>以前解决方案就是：浏览器去问服务器，该请求是否可以进行跨域处理，若可以，跨域问题就得以解决。</p><h3 id="3-6-2-模拟跨域问题"><a href="#3-6-2-模拟跨域问题" class="headerlink" title="3.6.2.模拟跨域问题"></a>3.6.2.模拟跨域问题</h3><p>找到课前资料的页面文件：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714215713563.png" alt="image-20210714215713563"></p><p>放入tomcat或者nginx这样的web服务器中，启动并访问。</p><p>可以在浏览器控制台看到下面的错误：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714215832675.png" alt="image-20210714215832675"></p><p>从localhost:8090访问localhost:10010，端口不同，显然是跨域的请求。</p><h3 id="3-6-3-解决跨域问题"><a href="#3-6-3-解决跨域问题" class="headerlink" title="3.6.3.解决跨域问题"></a>3.6.3.解决跨域问题</h3><p>在gateway服务的application.yml文件中，添加下面的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="comment"># 。。。</span></span><br><span class="line">      <span class="attr">globalcors:</span> <span class="comment"># 全局的跨域处理</span></span><br><span class="line">        <span class="attr">add-to-simple-url-handler-mapping:</span> <span class="literal">true</span> <span class="comment"># 解决options请求被拦截问题，options请求不被网关拦截，这样CROS的询问请求就可以正常发出了</span></span><br><span class="line">        <span class="attr">corsConfigurations:</span></span><br><span class="line">          <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span> <span class="comment"># 拦截所有的请求都做跨域处理</span></span><br><span class="line">            <span class="attr">allowedOrigins:</span> <span class="comment"># 允许哪些网站的跨域请求 </span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://localhost:8090&quot;</span></span><br><span class="line">            <span class="attr">allowedMethods:</span> <span class="comment"># 允许的跨域ajax的请求方式</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;GET&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;POST&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;DELETE&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;PUT&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;OPTIONS&quot;</span></span><br><span class="line">            <span class="attr">allowedHeaders:</span> <span class="string">&quot;*&quot;</span> <span class="comment"># 允许在请求中携带的头信息</span></span><br><span class="line">            <span class="attr">allowCredentials:</span> <span class="literal">true</span> <span class="comment"># 是否允许携带cookie</span></span><br><span class="line">            <span class="attr">maxAge:</span> <span class="number">360000</span> <span class="comment"># 这次跨域检测的有效期</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nacos配置管理、Feign远程调用、Gateway服务网关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud01</title>
      <link href="/2022/04/01/SpringCloud01/"/>
      <url>/2022/04/01/SpringCloud01/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringCloud01"><a href="#SpringCloud01" class="headerlink" title="SpringCloud01"></a>SpringCloud01</h1><h1 id="1-认识微服务"><a href="#1-认识微服务" class="headerlink" title="1.认识微服务"></a>1.认识微服务</h1><h2 id="1-1单体架构"><a href="#1-1单体架构" class="headerlink" title="1.1单体架构"></a>1.1单体架构</h2><p><strong>单体架构</strong>：将业务的所有功能集中在一个项目中开发，打成一个包部署。</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713202807818.png" alt="image-20210713202807818"></p><p>单体架构的优缺点如下：</p><p><strong>优点：</strong></p><ul><li>架构简单</li><li>部署成本低</li></ul><p><strong>缺点：</strong></p><ul><li>耦合度高（维护困难、升级困难）</li></ul><h2 id="1-2-分布式架构"><a href="#1-2-分布式架构" class="headerlink" title="1.2.分布式架构"></a>1.2.分布式架构</h2><p><strong>分布式架构</strong>：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713203124797.png" alt="image-20210713203124797"></p><p>分布式架构的优缺点：</p><p><strong>优点：</strong></p><ul><li>降低服务耦合</li><li>有利于服务升级和拓展</li></ul><p><strong>缺点：</strong></p><ul><li>服务调用关系错综复杂</li></ul><p>分布式架构虽然降低了服务耦合，但是服务拆分时也有很多问题需要思考：</p><ul><li>服务拆分的粒度如何界定？</li><li>服务之间如何调用？</li><li>服务的调用关系如何管理？</li></ul><p>人们需要制定一套行之有效的标准来约束分布式架构。</p><h2 id="1-3-微服务"><a href="#1-3-微服务" class="headerlink" title="1.3.微服务"></a>1.3.微服务</h2><p>微服务的架构特征：</p><ul><li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责</li><li>自治：团队独立、技术独立、数据独立，独立部署和交付</li><li>面向服务：服务提供统一标准的接口，与语言和技术无关</li><li>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</li></ul><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713203753373.png" alt="image-20210713203753373"></p><p>微服务的上述特性其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。</p><p>因此，可以认为<strong>微服务</strong>是一种经过良好架构设计的<strong>分布式架构方案</strong> 。</p><p>但方案该怎么落地？选用什么样的技术栈？全球的互联网公司都在积极尝试自己的微服务落地方案。</p><p>其中在Java领域最引人注目的就是SpringCloud提供的方案了。</p><h2 id="1-4-SpringCloud"><a href="#1-4-SpringCloud" class="headerlink" title="1.4.SpringCloud"></a>1.4.SpringCloud</h2><p>SpringCloud是目前国内使用最广泛的微服务框架。官网地址：<a href="https://spring.io/projects/spring-cloud%E3%80%82">https://spring.io/projects/spring-cloud。</a></p><p>SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验。</p><p>其中常见的组件包括：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713204155887.png" alt="image-20210713204155887"></p><p>另外，SpringCloud底层是依赖于SpringBoot的，并且有版本的兼容关系，如下：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713205003790.png" alt="image-20210713205003790"></p><p>我们课堂学习的版本是 Hoxton.SR10，因此对应的SpringBoot版本是2.3.x版本。</p><h2 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5.总结"></a>1.5.总结</h2><ul><li><p>单体架构：简单方便，高度耦合，扩展性差，适合小型项目。例如：学生管理系统</p></li><li><p>分布式架构：松耦合，扩展性好，但架构复杂，难度大。适合大型互联网项目，例如：京东、淘宝</p></li><li><p>微服务：一种良好的分布式架构方案</p><p>①优点：拆分粒度更小、服务更独立、耦合度更低</p><p>②缺点：架构非常复杂，运维、监控、部署难度提高</p></li><li><p>SpringCloud是微服务架构的一站式解决方案，集成了各种优秀微服务功能组件</p></li></ul><h1 id="2-服务拆分和远程调用"><a href="#2-服务拆分和远程调用" class="headerlink" title="2.服务拆分和远程调用"></a>2.服务拆分和远程调用</h1><p>任何分布式架构都离不开服务的拆分，微服务也是一样。</p><h2 id="2-1-服务拆分原则"><a href="#2-1-服务拆分原则" class="headerlink" title="2.1.服务拆分原则"></a>2.1.服务拆分原则</h2><p>这里我总结了微服务拆分时的几个原则：</p><ul><li>不同微服务，不要重复开发相同业务</li><li>微服务数据独立，不要访问其它微服务的数据库</li><li>微服务可以将自己的业务暴露为接口，供其它微服务调用</li></ul><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713210800950.png" alt="image-20210713210800950"></p><h2 id="2-2-服务拆分示例"><a href="#2-2-服务拆分示例" class="headerlink" title="2.2.服务拆分示例"></a>2.2.服务拆分示例</h2><p>以课前资料中的微服务cloud-demo为例，其结构如下：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713211009593.png" alt="image-20210713211009593"></p><p>cloud-demo：父工程，管理依赖</p><ul><li>order-service：订单微服务，负责订单相关业务</li><li>user-service：用户微服务，负责用户相关业务</li></ul><p>要求：</p><ul><li>订单微服务和用户微服务都必须有各自的数据库，相互独立</li><li>订单服务和用户服务都对外暴露Restful的接口</li><li>订单服务如果需要查询用户信息，只能调用用户服务的Restful接口，不能查询用户数据库</li></ul><h3 id="2-2-1-导入Sql语句"><a href="#2-2-1-导入Sql语句" class="headerlink" title="2.2.1.导入Sql语句"></a>2.2.1.导入Sql语句</h3><p>首先，将课前资料提供的<code>cloud-order.sql</code>和<code>cloud-user.sql</code>导入到mysql中：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713211417049.png" alt="image-20210713211417049"></p><p>cloud-user表中初始数据如下：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713211550169.png" alt="image-20210713211550169"></p><p>cloud-order表中初始数据如下：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713211657319.png" alt="image-20210713211657319"></p><p>cloud-order表中持有cloud-user表中的id字段。</p><h3 id="2-2-2-导入demo工程"><a href="#2-2-2-导入demo工程" class="headerlink" title="2.2.2.导入demo工程"></a>2.2.2.导入demo工程</h3><p>用IDEA导入课前资料提供的Demo：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713211814094.png" alt="image-20210713211814094"></p><p>项目结构如下：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713212656887.png" alt="image-20210713212656887"></p><p>导入后，会在IDEA右下角出现弹窗：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713212349272.png" alt="image-20210713212349272"></p><p>点击弹窗，然后按下图选择：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713212336185.png" alt="image-20210713212336185"></p><p>会出现这样的菜单：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713212513324.png" alt="image-20210713212513324"></p><p>配置下项目使用的JDK：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713220736408.png" alt="image-20210713220736408"></p><h2 id="2-3-实现远程调用案例"><a href="#2-3-实现远程调用案例" class="headerlink" title="2.3.实现远程调用案例"></a>2.3.实现远程调用案例</h2><p>在order-service服务中，有一个根据id查询订单的接口：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713212749575.png" alt="image-20210713212749575"></p><p>根据id查询订单，返回值是Order对象，如图：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713212901725.png" alt="image-20210713212901725"></p><p>其中的user为null</p><p>在user-service中有一个根据id查询用户的接口：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713213146089.png" alt="image-20210713213146089"></p><p>查询的结果如图：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713213213075.png" alt="image-20210713213213075"></p><h3 id="2-3-1-案例需求："><a href="#2-3-1-案例需求：" class="headerlink" title="2.3.1.案例需求："></a>2.3.1.案例需求：</h3><p>修改order-service中的根据id查询订单业务，要求在查询订单的同时，根据订单中包含的userId查询出用户信息，一起返回。</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713213312278.png" alt="image-20210713213312278"></p><p>因此，我们需要在order-service中 向user-service发起一个http的请求，调用<a href="http://localhost:8081/user/%7BuserId%7D%E8%BF%99%E4%B8%AA%E6%8E%A5%E5%8F%A3%E3%80%82">http://localhost:8081/user/{userId}这个接口。</a></p><p>大概的步骤是这样的：</p><ul><li>注册一个RestTemplate的实例到Spring容器</li><li>修改order-service服务中的OrderService类中的queryOrderById方法，根据Order对象中的userId查询User</li><li>将查询的User填充到Order对象，一起返回</li></ul><h3 id="2-3-2-注册RestTemplate"><a href="#2-3-2-注册RestTemplate" class="headerlink" title="2.3.2.注册RestTemplate"></a>2.3.2.注册RestTemplate</h3><p>首先，我们在order-service服务中的OrderApplication启动类中，注册RestTemplate实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MapperScan(&quot;cn.itcast.order.mapper&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OrderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-3-实现远程调用"><a href="#2-3-3-实现远程调用" class="headerlink" title="2.3.3.实现远程调用"></a>2.3.3.实现远程调用</h3><p>修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713213959569.png" alt="image-20210713213959569"></p><h2 id="2-4-提供者与消费者"><a href="#2-4-提供者与消费者" class="headerlink" title="2.4.提供者与消费者"></a>2.4.提供者与消费者</h2><p>在服务调用关系中，会有两个不同的角色：</p><p><strong>服务提供者</strong>：一次业务中，被其它微服务调用的服务。（提供接口给其它微服务）</p><p><strong>服务消费者</strong>：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口）</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713214404481.png" alt="image-20210713214404481"></p><p>但是，服务提供者与服务消费者的角色并不是绝对的，而是相对于业务而言。</p><p>如果服务A调用了服务B，而服务B又调用了服务C，服务B的角色是什么？</p><ul><li>对于A调用B的业务而言：A是服务消费者，B是服务提供者</li><li>对于B调用C的业务而言：B是服务消费者，C是服务提供者</li></ul><p>因此，服务B既可以是服务提供者，也可以是服务消费者。</p><h1 id="3-Eureka注册中心"><a href="#3-Eureka注册中心" class="headerlink" title="3.Eureka注册中心"></a>3.Eureka注册中心</h1><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220801172601591.png" alt="image-20220801172601591"></p><p>假如我们的服务提供者user-service部署了多个实例，如图：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713214925388.png" alt="image-20210713214925388"></p><p>大家思考几个问题：</p><ul><li>order-service在发起远程调用的时候，该如何得知user-service实例的ip地址和端口？</li><li>有多个user-service实例地址，order-service调用时该如何选择？</li><li>order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</li></ul><h2 id="3-1-Eureka的结构和作用"><a href="#3-1-Eureka的结构和作用" class="headerlink" title="3.1.Eureka的结构和作用"></a>3.1.Eureka的结构和作用</h2><p>这些问题都需要利用SpringCloud中的注册中心来解决，其中最广为人知的注册中心就是Eureka，其结构如下：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713220104956.png" alt="image-20210713220104956"></p><p>回答之前的各个问题。</p><p>问题1：order-service如何得知user-service实例地址？</p><p>获取地址信息的流程如下：</p><ul><li>user-service服务实例启动后，将自己的信息注册到eureka-server（Eureka服务端）。这个叫服务注册</li><li>eureka-server保存服务名称到服务实例地址列表的映射关系</li><li>order-service根据服务名称，拉取实例地址列表。这个叫服务发现或服务拉取</li></ul><p>问题2：order-service如何从多个user-service实例中选择具体的实例？</p><ul><li>order-service从实例列表中利用负载均衡算法选中一个实例地址</li><li>向该实例地址发起远程调用</li></ul><p>问题3：order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</p><ul><li>user-service会每隔一段时间（默认30秒）向eureka-server发起请求，报告自己状态，称为心跳</li><li>当超过一定时间没有发送心跳时，eureka-server会认为微服务实例故障，将该实例从服务列表中剔除</li><li>order-service拉取服务时，就能将故障实例排除了</li></ul><blockquote><p>注意：一个微服务，既可以是服务提供者，又可以是服务消费者，因此eureka将服务注册、服务发现等功能统一封装到了eureka-client端</p></blockquote><p>因此，接下来我们动手实践的步骤包括：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713220509769.png" alt="image-20210713220509769"></p><h2 id="3-2-搭建eureka-server"><a href="#3-2-搭建eureka-server" class="headerlink" title="3.2.搭建eureka-server"></a>3.2.搭建eureka-server</h2><p>首先大家注册中心服务端：eureka-server，这必须是一个独立的微服务</p><p><strong>搭建步骤</strong></p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220801171327650.png" alt="image-20220801171327650"></p><h3 id="3-2-1-创建eureka-server服务"><a href="#3-2-1-创建eureka-server服务" class="headerlink" title="3.2.1.创建eureka-server服务"></a>3.2.1.创建eureka-server服务</h3><p>在cloud-demo父工程下，创建一个子模块：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713220605881.png" alt="image-20210713220605881"></p><p>填写模块信息：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713220857396.png" alt="image-20210713220857396"></p><p>然后填写服务信息：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713221339022.png" alt="image-20210713221339022"></p><h3 id="3-2-2-引入eureka依赖"><a href="#3-2-2-引入eureka依赖" class="headerlink" title="3.2.2.引入eureka依赖"></a>3.2.2.引入eureka依赖</h3><p>引入SpringCloud为eureka提供的starter依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-3-编写启动类"><a href="#3-2-3-编写启动类" class="headerlink" title="3.2.3.编写启动类"></a>3.2.3.编写启动类</h3><p>给eureka-server服务编写一个启动类，一定要添加一个@EnableEurekaServer注解，开启eureka的注册中心功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.eureka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-4-编写配置文件"><a href="#3-2-4-编写配置文件" class="headerlink" title="3.2.4.编写配置文件"></a>3.2.4.编写配置文件</h3><p>编写一个application.yml文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10086</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> </span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><h3 id="3-2-5-启动服务"><a href="#3-2-5-启动服务" class="headerlink" title="3.2.5.启动服务"></a>3.2.5.启动服务</h3><p>启动微服务，然后在浏览器访问：<a href="http://127.0.0.1:10086/">http://127.0.0.1:10086</a></p><p>看到下面结果应该是成功了：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713222157190.png" alt="image-20210713222157190"></p><h2 id="3-3-服务注册"><a href="#3-3-服务注册" class="headerlink" title="3.3.服务注册"></a>3.3.服务注册</h2><p>下面，我们将user-service注册到eureka-server中去。</p><h3 id="1）引入依赖"><a href="#1）引入依赖" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>在user-service的pom文件中，引入下面的eureka-client依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2）配置文件"><a href="#2）配置文件" class="headerlink" title="2）配置文件"></a>2）配置文件</h3><p>在user-service中，修改application.yml文件，添加服务名称、eureka地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userservice</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><h3 id="3）启动多个user-service实例"><a href="#3）启动多个user-service实例" class="headerlink" title="3）启动多个user-service实例"></a>3）启动多个user-service实例</h3><p>为了演示一个服务有多个实例的场景，我们添加一个SpringBoot的启动配置，再启动一个user-service。</p><p>首先，复制原来的user-service启动配置：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713222656562.png" alt="image-20210713222656562"></p><p>然后，在弹出的窗口中，填写信息：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713222757702.png" alt="image-20210713222757702"></p><p>现在，SpringBoot窗口会出现两个user-service启动配置：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713222841951.png" alt="image-20210713222841951"></p><p>不过，第一个是8081端口，第二个是8082端口。</p><p>启动两个user-service实例：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713223041491.png" alt="image-20210713223041491"></p><p>查看eureka-server管理页面：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713223150650.png" alt="image-20210713223150650"></p><h2 id="3-4-服务发现"><a href="#3-4-服务发现" class="headerlink" title="3.4.服务发现"></a>3.4.服务发现</h2><p>下面，我们将order-service的逻辑修改：向eureka-server拉取user-service的信息，实现服务发现。</p><h3 id="1）引入依赖-1"><a href="#1）引入依赖-1" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>之前说过，服务发现、服务注册统一都封装在eureka-client依赖，因此这一步与服务注册时一致。</p><p>在order-service的pom文件中，引入下面的eureka-client依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2）配置文件-1"><a href="#2）配置文件-1" class="headerlink" title="2）配置文件"></a>2）配置文件</h3><p>服务发现也需要知道eureka地址，因此第二步与服务注册一致，都是配置eureka信息：</p><p>在order-service中，修改application.yml文件，添加服务名称、eureka地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">orderservice</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><h3 id="3）服务拉取和负载均衡"><a href="#3）服务拉取和负载均衡" class="headerlink" title="3）服务拉取和负载均衡"></a>3）服务拉取和负载均衡</h3><p>最后，我们要去eureka-server中拉取user-service服务的实例列表，并且实现负载均衡。</p><p>不过这些动作不用我们去做，只需要添加一些注解即可。</p><p>在order-service的OrderApplication中，给RestTemplate这个Bean添加一个@LoadBalanced注解：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713224049419.png" alt="image-20210713224049419"></p><p>修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法。修改访问的url路径，用服务名代替ip、端口：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713224245731.png" alt="image-20210713224245731"></p><p>spring会自动帮助我们从eureka-server端，根据userservice这个服务名称，获取实例列表，而后完成负载均衡。</p><h1 id="4-Ribbon负载均衡"><a href="#4-Ribbon负载均衡" class="headerlink" title="4.Ribbon负载均衡"></a>4.Ribbon负载均衡</h1><p>上一节中，我们添加了@LoadBalanced注解，即可实现负载均衡功能，这是什么原理呢？</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220801194950356.png" alt="image-20220801194950356"></p><h2 id="4-1-负载均衡原理"><a href="#4-1-负载均衡原理" class="headerlink" title="4.1.负载均衡原理"></a>4.1.负载均衡原理</h2><p>SpringCloud底层其实是利用了一个名为Ribbon的组件，来实现负载均衡功能的。</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713224517686.png" alt="image-20210713224517686"></p><p>那么我们发出的请求明明是<a href="http://userservice/user/1%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8F%98%E6%88%90%E4%BA%86http://localhost:8081%E7%9A%84%E5%91%A2%EF%BC%9F">http://userservice/user/1，怎么变成了http://localhost:8081的呢？</a></p><h2 id="4-2-源码跟踪"><a href="#4-2-源码跟踪" class="headerlink" title="4.2.源码跟踪"></a>4.2.源码跟踪</h2><p>为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。</p><p>显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是<code>LoadBalancerInterceptor</code>，这个类会在对RestTemplate的请求进行拦截，然后从Eureka根据服务id获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务id。</p><p>我们进行源码跟踪：</p><h3 id="1）LoadBalancerIntercepor"><a href="#1）LoadBalancerIntercepor" class="headerlink" title="1）LoadBalancerIntercepor"></a>1）LoadBalancerIntercepor</h3><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/1525620483637.png" alt="1525620483637"></p><p>可以看到这里的intercept方法，拦截了用户的HttpRequest请求，然后做了几件事：</p><ul><li><code>request.getURI()</code>：获取请求uri，本例中就是 <a href="http://user-service/user/8">http://user-service/user/8</a></li><li><code>originalUri.getHost()</code>：获取uri路径的主机名，其实就是服务id，<code>user-service</code></li><li><code>this.loadBalancer.execute()</code>：处理服务id，和用户请求。</li></ul><p>这里的<code>this.loadBalancer</code>是<code>LoadBalancerClient</code>类型，我们继续跟入。</p><h3 id="2）LoadBalancerClient"><a href="#2）LoadBalancerClient" class="headerlink" title="2）LoadBalancerClient"></a>2）LoadBalancerClient</h3><p>继续跟入execute方法：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/1525620787090.png" alt="1525620787090"></p><p>代码是这样的：</p><ul><li>getLoadBalancer(serviceId)：根据服务id获取ILoadBalancer，而ILoadBalancer会拿着服务id去eureka中获取服务列表并保存起来。</li><li>getServer(loadBalancer)：利用内置的负载均衡算法，从服务列表中选择一个。本例中，可以看到获取了8082端口的服务</li></ul><p>放行后，再次访问并跟踪，发现获取的是8081：</p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/1525620835911.png" alt="1525620835911"></p><p>果然实现了负载均衡。</p><h3 id="3）负载均衡策略IRule"><a href="#3）负载均衡策略IRule" class="headerlink" title="3）负载均衡策略IRule"></a>3）负载均衡策略IRule</h3><p>在刚才的代码中，可以看到获取服务使通过一个<code>getServer</code>方法来做负载均衡:</p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/1525620835911.png" alt="1525620835911"></p><p>我们继续跟入：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/1544361421671.png" alt="1544361421671"></p><p>继续跟踪源码chooseServer方法，发现这么一段代码：</p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/1525622652849.png" alt="1525622652849"></p><p>我们看看这个rule是谁：</p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/1525622699666.png" alt="1525622699666"></p><p>这里的rule默认值是一个<code>RoundRobinRule</code>，看类的介绍：</p><p> <img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/1525622754316.png" alt="1525622754316"></p><p>这不就是轮询的意思嘛。</p><p>到这里，整个负载均衡的流程我们就清楚了。</p><h3 id="4）总结"><a href="#4）总结" class="headerlink" title="4）总结"></a>4）总结</h3><p>SpringCloudRibbon的底层采用了一个拦截器，拦截了RestTemplate发出的请求，对地址做了修改。用一幅图来总结一下：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713224724673.png" alt="image-20210713224724673"></p><p>基本流程如下：</p><ul><li>拦截我们的RestTemplate请求<a href="http://userservice/user/1">http://userservice/user/1</a></li><li>RibbonLoadBalancerClient会从请求url中获取服务名称，也就是user-service</li><li>DynamicServerListLoadBalancer根据user-service到eureka拉取服务列表</li><li>eureka返回列表，localhost:8081、localhost:8082</li><li>IRule利用内置负载均衡规则，从列表中选择一个，例如localhost:8081</li><li>RibbonLoadBalancerClient修改请求地址，用localhost:8081替代userservice，得到<a href="http://localhost:8081/user/1%EF%BC%8C%E5%8F%91%E8%B5%B7%E7%9C%9F%E5%AE%9E%E8%AF%B7%E6%B1%82">http://localhost:8081/user/1，发起真实请求</a></li></ul><h2 id="4-3-负载均衡策略"><a href="#4-3-负载均衡策略" class="headerlink" title="4.3.负载均衡策略"></a>4.3.负载均衡策略</h2><h3 id="4-3-1-负载均衡策略"><a href="#4-3-1-负载均衡策略" class="headerlink" title="4.3.1.负载均衡策略"></a>4.3.1.负载均衡策略</h3><p>负载均衡的规则都定义在IRule接口中，而IRule有很多不同的实现类：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713225653000.png" alt="image-20210713225653000"></p><p>不同规则的含义如下：</p><table><thead><tr><th><strong>内置负载均衡规则类</strong></th><th><strong>规则描述</strong></th></tr></thead><tbody><tr><td>RoundRobinRule</td><td>简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td></tr><tr><td>AvailabilityFilteringRule</td><td>对以下两种服务器进行忽略：   （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。  （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的<clientName>.<clientConfigNameSpace>.ActiveConnectionsLimit属性进行配置。</td></tr><tr><td>WeightedResponseTimeRule</td><td>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td></tr><tr><td><strong>ZoneAvoidanceRule</strong></td><td>以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</td></tr><tr><td>BestAvailableRule</td><td>忽略那些短路的服务器，并选择并发数较低的服务器。</td></tr><tr><td>RandomRule</td><td>随机选择一个可用的服务器。</td></tr><tr><td>RetryRule</td><td>重试机制的选择逻辑</td></tr></tbody></table><p>默认的实现就是ZoneAvoidanceRule，是一种轮询方案</p><h3 id="4-3-2-自定义负载均衡策略"><a href="#4-3-2-自定义负载均衡策略" class="headerlink" title="4.3.2.自定义负载均衡策略"></a>4.3.2.自定义负载均衡策略</h3><p>通过定义IRule实现可以修改负载均衡规则，有两种方式：</p><ol><li>代码方式：在order-service中的OrderApplication类中，定义一个新的IRule：</li></ol><p>​    <strong>这种方式会对所有的微服务生效</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IRule <span class="title">randomRule</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RandomRule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则：</li></ol><p>​    <strong>这种方式只会对userservice微服务生效</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">userservice:</span> <span class="comment"># 给某个微服务配置负载均衡规则，这里是userservice服务</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span> <span class="comment"># 负载均衡规则 </span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>，一般用默认的负载均衡规则，不做修改。</p></blockquote><h2 id="4-4-饥饿加载"><a href="#4-4-饥饿加载" class="headerlink" title="4.4.饥饿加载"></a>4.4.饥饿加载</h2><p><strong>Ribbon默认是采用懒加载</strong>，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。</p><p>而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">eager-load:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">clients:</span> <span class="string">userservice</span></span><br></pre></td></tr></table></figure><h1 id="5-Nacos注册中心"><a href="#5-Nacos注册中心" class="headerlink" title="5.Nacos注册中心"></a>5.Nacos注册中心</h1><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220801201330037.png" alt="image-20220801201330037"></p><p>国内公司一般都推崇阿里巴巴的技术，比如注册中心，SpringCloudAlibaba也推出了一个名为Nacos的注册中心。</p><h2 id="5-1-认识和安装Nacos"><a href="#5-1-认识和安装Nacos" class="headerlink" title="5.1.认识和安装Nacos"></a>5.1.认识和安装Nacos</h2><p><a href="https://nacos.io/">Nacos</a>是阿里巴巴的产品，现在是<a href="https://spring.io/projects/spring-cloud">SpringCloud</a>中的一个组件。相比<a href="https://github.com/Netflix/eureka">Eureka</a>功能更加丰富，在国内受欢迎程度较高。</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713230444308.png" alt="image-20210713230444308"></p><h2 id="5-2-服务注册到nacos"><a href="#5-2-服务注册到nacos" class="headerlink" title="5.2.服务注册到nacos"></a>5.2.服务注册到nacos</h2><p>Nacos是SpringCloudAlibaba的组件，而SpringCloudAlibaba也遵循SpringCloud中定义的服务注册、服务发现规范。因此使用Nacos和使用Eureka对于微服务来说，并没有太大区别。</p><p>主要差异在于：</p><ul><li>依赖不同</li><li>服务地址不同</li></ul><h3 id="1）引入依赖-2"><a href="#1）引入依赖-2" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>在cloud-demo父工程的pom文件中的<code>&lt;dependencyManagement&gt;</code>中引入SpringCloudAlibaba的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在user-service和order-service中的pom文件中引入nacos-discovery依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：不要忘了注释掉eureka的依赖。</p></blockquote><h3 id="2）配置nacos地址"><a href="#2）配置nacos地址" class="headerlink" title="2）配置nacos地址"></a>2）配置nacos地址</h3><p>在user-service和order-service的application.yml中添加nacos地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：不要忘了注释掉eureka的地址</p></blockquote><h3 id="3）重启"><a href="#3）重启" class="headerlink" title="3）重启"></a>3）重启</h3><p>重启微服务后，登录nacos管理页面，可以看到微服务信息：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713231439607.png" alt="image-20210713231439607"></p><h2 id="5-3-服务分级存储模型"><a href="#5-3-服务分级存储模型" class="headerlink" title="5.3.服务分级存储模型"></a>5.3.服务分级存储模型</h2><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220801202140680.png" alt="image-20220801202140680"></p><p>一个<strong>服务</strong>可以有多个<strong>实例</strong>，例如我们的user-service，可以有:</p><ul><li>127.0.0.1:8081</li><li>127.0.0.1:8082</li><li>127.0.0.1:8083</li></ul><p>假如这些实例分布于全国各地的不同机房，例如：</p><ul><li>127.0.0.1:8081，在上海机房</li><li>127.0.0.1:8082，在上海机房</li><li>127.0.0.1:8083，在杭州机房</li></ul><p>Nacos就将同一机房内的实例 划分为一个<strong>集群</strong>。</p><p>也就是说，user-service是服务，一个服务可以包含多个集群，如杭州、上海，每个集群下可以有多个实例，形成分级模型，如图：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713232522531.png" alt="image-20210713232522531"></p><p>微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群。例如：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713232658928.png" alt="image-20210713232658928"></p><p>杭州机房内的order-service应该优先访问同机房的user-service。</p><h3 id="5-3-1-给user-service配置集群"><a href="#5-3-1-给user-service配置集群" class="headerlink" title="5.3.1.给user-service配置集群"></a>5.3.1.给user-service配置集群</h3><p>修改user-service的application.yml文件，添加集群配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span> <span class="comment"># 集群名称</span></span><br></pre></td></tr></table></figure><p>重启两个user-service实例后，我们可以在nacos控制台看到下面结果：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713232916215.png" alt="image-20210713232916215"></p><p>我们再次复制一个user-service启动配置，添加属性：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dserver.port=8083 -Dspring.cloud.nacos.discovery.cluster-name=SH</span><br></pre></td></tr></table></figure><p>配置如图所示：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713233528982.png" alt="image-20210713233528982"></p><p>启动UserApplication3后再次查看nacos控制台：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713233727923.png" alt="image-20210713233727923"></p><h3 id="5-3-2-同集群优先的负载均衡"><a href="#5-3-2-同集群优先的负载均衡" class="headerlink" title="5.3.2.同集群优先的负载均衡"></a>5.3.2.同集群优先的负载均衡</h3><p>默认的<code>ZoneAvoidanceRule</code>并不能实现根据同集群优先来实现负载均衡。</p><p>因此Nacos中提供了一个<code>NacosRule</code>的实现，可以优先从同集群中挑选实例。</p><p>1）给order-service配置集群信息</p><p>修改order-service的application.yml文件，添加集群配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: localhost:8848</span><br><span class="line">      discovery:</span><br><span class="line">        cluster-name: HZ <span class="comment"># 集群名称</span></span><br></pre></td></tr></table></figure><p>2）修改负载均衡规则</p><p>修改order-service的application.yml文件，修改负载均衡规则：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">userservice:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class="comment"># 负载均衡规则 </span></span><br></pre></td></tr></table></figure><h2 id="5-4-权重配置"><a href="#5-4-权重配置" class="headerlink" title="5.4.权重配置"></a>5.4.权重配置</h2><p>实际部署中会出现这样的场景：</p><p>服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。</p><p>但默认情况下NacosRule是同集群内随机挑选，不会考虑机器的性能问题。</p><p>因此，Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高。</p><p>在nacos控制台，找到user-service的实例列表，点击编辑，即可修改权重：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713235133225.png" alt="image-20210713235133225"></p><p>在弹出的编辑窗口，修改权重：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210713235235219.png" alt="image-20210713235235219"></p><blockquote><p><strong>注意</strong>：如果权重修改为0，则该实例永远不会被访问</p></blockquote><h2 id="5-5-环境隔离"><a href="#5-5-环境隔离" class="headerlink" title="5.5.环境隔离"></a>5.5.环境隔离</h2><p>Nacos提供了namespace来实现环境隔离功能。</p><ul><li>nacos中可以有多个namespace</li><li>namespace下可以有group、service等</li><li>不同namespace之间相互隔离，例如不同namespace的服务互相不可见</li></ul><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714000101516.png" alt="image-20210714000101516"></p><h3 id="5-5-1-创建namespace"><a href="#5-5-1-创建namespace" class="headerlink" title="5.5.1.创建namespace"></a>5.5.1.创建namespace</h3><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20220801203857103.png" alt="image-20220801203857103"></p><p>微服务之间相互访问必须同时注册在容易namespace下！</p><p>默认情况下，所有service、data、group都在同一个namespace，名为public：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714000414781.png" alt="image-20210714000414781"></p><p>我们可以点击页面新增按钮，添加一个namespace：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714000440143.png" alt="image-20210714000440143"></p><p>然后，填写表单：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714000505928.png" alt="image-20210714000505928"></p><p>就能在页面看到一个新的namespace：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714000522913.png" alt="image-20210714000522913"></p><h3 id="5-5-2-给微服务配置namespace"><a href="#5-5-2-给微服务配置namespace" class="headerlink" title="5.5.2.给微服务配置namespace"></a>5.5.2.给微服务配置namespace</h3><p>给微服务配置namespace只能通过修改配置来实现。</p><p>例如，修改order-service的application.yml文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">492a7d5d-237b-46a1-a99a-fa8e98e4b0f9</span> <span class="comment"># 命名空间，填ID</span></span><br></pre></td></tr></table></figure><p>重启order-service后，访问控制台，可以看到下面的结果：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714000830703.png" alt="image-20210714000830703"></p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714000837140.png" alt="image-20210714000837140"></p><p>此时访问order-service，因为namespace不同，会导致找不到userservice，控制台会报错：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714000941256.png" alt="image-20210714000941256"></p><h2 id="5-6-Nacos与Eureka的区别"><a href="#5-6-Nacos与Eureka的区别" class="headerlink" title="5.6.Nacos与Eureka的区别"></a>5.6.Nacos与Eureka的区别</h2><p>Nacos的服务实例分为两种l类型：</p><ul><li><p>临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。</p></li><li><p>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</p></li></ul><p>配置一个服务实例为永久实例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">ephemeral:</span> <span class="literal">false</span> <span class="comment"># 设置为非临时实例</span></span><br></pre></td></tr></table></figure><p>Nacos和Eureka整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异：</p><p><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/image-20210714001728017.png" alt="image-20210714001728017"></p><ul><li><p>Nacos与eureka的共同点</p><ul><li>都支持服务注册和服务拉取</li><li>都支持服务提供者心跳方式做健康检测</li></ul></li><li><p>Nacos与Eureka的区别</p><ul><li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li><li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除，nacos一致等到非临时实例变正常。但是非临时实例会给服务器造成压力，所以一般都采用非临时实例。</li><li>Nacos支持服务列表变更的消息推送模式，<strong>当服务提供者发生不正常情况，nacos主动推送消息</strong>，保证服务列表更新更及时</li><li>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</li></ul></li></ul><h3 id="AP与CP"><a href="#AP与CP" class="headerlink" title="AP与CP"></a>AP与CP</h3><p>P(partition)，也就是由于网络问题，将系统的成员隔离成了2个区域，互相无法知道对方的状态，这在分布式环境下是非常常见的。因为P是必须的。</p><p>选择可用性 A(Availability)，此时，那个失去联系的节点依然可以向系统提供服务，不过它的数据就不能保证是同步的了（失去了C属性）。</p><p>选择一致性C(Consistency)，为了保证数据库的一致性，我们必须等待失去联系的节点恢复过来，在这个过程中，那个节点是不允许对外提供服务的，这时候系统处于不可用状态(失去了A属性)。</p>]]></content>
      
      
      <categories>
          
          <category> Spring系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Eureka、Ribbon、Nacos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LFU算法小结</title>
      <link href="/2022/03/23/LFU%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93/"/>
      <url>/2022/03/23/LFU%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h1><h2 id="回顾一下LRU"><a href="#回顾一下LRU" class="headerlink" title="回顾一下LRU"></a>回顾一下LRU</h2><p>首先先谈一下LRU，LRU 算法相当于把数据按照时间排序，这个需求借助链表很自然就能实现，你一直从链表尾部部加入元素的话，越靠近尾部的元素就是新的数据，越靠近头部的元素就是旧的数据，我们进行缓存淘汰的时候只要简单地将尾部的元素淘汰掉就行了。</p><p>所以LRU的实现使用双向链表 + HashMap&lt;key,Node&gt;就可以实现我们的功能，当然java也有现成的数据结构供我们使用（LinkedHashMap）</p><h2 id="谈一谈LFU"><a href="#谈一谈LFU" class="headerlink" title="谈一谈LFU"></a>谈一谈LFU</h2><p><strong>LFU 算法相当于是淘汰访问频次最低的数据，如果访问频次最低的数据有多条，需要淘汰最旧的数据。把数据按照访问频次进行排序</strong>，而且频次还会不断变化，这可不容易实现。</p><h2 id="从LFU的需求来设计我们的数据结构"><a href="#从LFU的需求来设计我们的数据结构" class="headerlink" title="从LFU的需求来设计我们的数据结构"></a>从LFU的需求来设计我们的数据结构</h2><h3 id="重要需求1：时序记录key的频率-并能O（1）对FK表进行更新。"><a href="#重要需求1：时序记录key的频率-并能O（1）对FK表进行更新。" class="headerlink" title="重要需求1：时序记录key的频率,并能O（1）对FK表进行更新。"></a>重要需求1：时序记录key的频率,并能O（1）对FK表进行更新。</h3><p>需要统计key的频率，且当具有相同频率的key进行remove时，需要按照时间顺序进行删除。这个需求我们用频率-keymap, 即FK = HashMap&lt;Integer,new LinkedList&lt;&gt;&gt;就可以实现。但是你得考虑当我们某个key进行更新频率时，比如get or put相同key，那么我们如何以O（1）时间在FK中进行先删除后新增呢。</p><p>很显然要用链表+Hashmap，对应我们可以使用java的LinkedHashSet。<strong>LinkedHashSet顾名思义，是链表和哈希集合的结合体</strong>。链表不能快速访问链表节点，但是插入元素具有时序；哈希集合中的元素无序，但是可以对元素进行快速的访问和删除。那么，它俩结合起来就<strong>兼具了哈希集合和链表的特性，既可以在 O(1) 时间内访问或删除其中的元素，又可以保持插入的时序</strong>。</p><h3 id="需求2-辅助结构"><a href="#需求2-辅助结构" class="headerlink" title="需求2 辅助结构"></a>需求2 辅助结构</h3><ol><li>在LFUget 方法中，我们要以O（1）复杂度进行return,这就需要一个KV（key-value）Map</li><li>在put方法中，当遇到key已存在的情况，我们就需要0（1）知道该key对应的频率，因此，我们需要建立一个KF（key - frequency map</li></ol><p>通过对FK，KV, KF三个map的维护，便达到了我们LFU的需求。</p><h1 id="题后总结"><a href="#题后总结" class="headerlink" title="题后总结"></a><strong>题后总结</strong></h1><ol><li>自己要对HashMap的理解和灵活运用要更上一层楼，尤其在涉及新型数据结构时，HashMap 和链表的结合是十分有用的，即HashMap&lt;Integer, new LinkedHashSet&lt;&gt;&gt;</li><li>LinkedHashMap&lt;&gt;,是双链表和HashMap的结合体。可以O（1）时间获取、删除</li><li>LinkedHashSet&lt;&gt;，也是链表和HashMap的结合。可以O（1）时间获取、删除</li></ol><h1 id="画出get方法和put方法的执行流程图"><a href="#画出get方法和put方法的执行流程图" class="headerlink" title="画出get方法和put方法的执行流程图"></a>画出get方法和put方法的执行流程图</h1><p> <img src="/articleImg/63_article/2.jpg" alt="2"></p><p> <img src="/articleImg/63_article/1.jpg" alt="1"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    HashMap&lt;Integer,Integer&gt;KV;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt;KF;</span><br><span class="line">    HashMap&lt;Integer,LinkedHashSet&lt;Integer&gt;&gt;FK;</span><br><span class="line">    <span class="keyword">int</span> minFrequency;</span><br><span class="line">    <span class="keyword">int</span> maxCapacity;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LFUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        KV = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        KF = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        FK = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        minFrequency = <span class="number">0</span>;</span><br><span class="line">        maxCapacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!KV.containsKey(key))</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> val = KV.get(key);</span><br><span class="line">        increaseFre(key);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxCapacity == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(KV.containsKey(key))&#123;</span><br><span class="line">            KV.put(key,value);</span><br><span class="line">            increaseFre(key);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(maxCapacity == KV.size())&#123;</span><br><span class="line">            decreaseFre();</span><br><span class="line">        &#125;</span><br><span class="line">        KV.put(key,value);</span><br><span class="line">        KF.put(key,<span class="number">1</span>);</span><br><span class="line">        minFrequency = <span class="number">1</span>;</span><br><span class="line">        LinkedHashSet&lt;Integer&gt; setOld = FK.getOrDefault(minFrequency,<span class="keyword">new</span> LinkedHashSet&lt;Integer&gt;());</span><br><span class="line">        setOld.add(key);</span><br><span class="line">        FK.put(minFrequency,setOld);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decreaseFre</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//先删除minfre对应的key，并更新三个map</span></span><br><span class="line">        Integer key = FK.get(minFrequency).iterator().next();</span><br><span class="line">        KV.remove(key);</span><br><span class="line">        KF.remove(key);</span><br><span class="line">        LinkedHashSet&lt;Integer&gt;setOld = FK.get(minFrequency);</span><br><span class="line">        setOld.remove(key);</span><br><span class="line">        <span class="keyword">if</span>(setOld.size() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            FK.remove(minFrequency);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increaseFre</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> frequency = KF.get(key);</span><br><span class="line">        KF.put(key,frequency+<span class="number">1</span>);</span><br><span class="line">        LinkedHashSet&lt;Integer&gt;setOld = FK.get(frequency);</span><br><span class="line">        setOld.remove(key);</span><br><span class="line">        <span class="keyword">if</span>(setOld.size() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            FK.remove(frequency);</span><br><span class="line">            <span class="keyword">if</span>(frequency == minFrequency)</span><br><span class="line">                minFrequency++;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        LinkedHashSet&lt;Integer&gt;setNew = FK.getOrDefault(frequency+<span class="number">1</span>,<span class="keyword">new</span> LinkedHashSet&lt;Integer&gt;());</span><br><span class="line">        setNew.add(key);</span><br><span class="line">        FK.put(frequency+<span class="number">1</span>,setNew);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LFU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21天刷题计划（14）深入理解BFS</title>
      <link href="/2022/03/23/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%8814%EF%BC%89%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3BFS/"/>
      <url>/2022/03/23/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%8814%EF%BC%89%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3BFS/</url>
      
        <content type="html"><![CDATA[<h1 id="打开转盘锁"><a href="#打开转盘锁" class="headerlink" title="打开转盘锁"></a>打开转盘锁</h1><p> <img src="E:\zhanglei-Blog\themes\butterfly\source\articleImg\21天刷题计划\38.jpg" alt="38"></p><p>BFS 出现的常见场景：<strong>问题的本质就是让你在一幅「图」中找到从起点 start 到终点 target 的最近距离</strong>！<br>模板<br>问题的实质就是BFS遍历一张图</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">创建一个队列</span><br><span class="line">加入起始节点</span><br><span class="line">step = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(队列不为空)</span><br><span class="line">&#123;</span><br><span class="line">    size = 此时队列大小</span><br><span class="line">    <span class="keyword">for</span>(size)&#123;</span><br><span class="line">        节点出队</span><br><span class="line">        如果节点满足结束条件，结束程序，返回相关信息</span><br><span class="line">        找出该节点合法的子节点，加入队列</span><br><span class="line">    &#125;</span><br><span class="line">    step++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">openLock</span><span class="params">(String[] deadends, String target)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        Set&lt;String&gt;visited = <span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">//用于存放已走过的位置</span></span><br><span class="line">        Set&lt;String&gt;dead = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;deadends.length;i++)&#123;</span><br><span class="line">            dead.add(deadends[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> queueSize = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;queueSize;x++)&#123;</span><br><span class="line">                 String temp = queue.poll();</span><br><span class="line">                 <span class="keyword">int</span> size = queue.size();</span><br><span class="line">                <span class="comment">// if(dead.contains(temp))</span></span><br><span class="line">                <span class="comment">//     continue;</span></span><br><span class="line">                <span class="keyword">if</span>(temp.equals(target))</span><br><span class="line">                    <span class="keyword">return</span> step;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">                    String temp2 = addOne(temp,i);</span><br><span class="line">                    <span class="keyword">if</span>(!visited.contains(temp2)&amp;&amp;(!dead.contains(temp)))</span><br><span class="line">                    &#123;</span><br><span class="line">                        visited.add(temp2);</span><br><span class="line">                        queue.offer(temp2);</span><br><span class="line">                    &#125;</span><br><span class="line">                        </span><br><span class="line">                    String temp3 = minusOne(temp,i);</span><br><span class="line">                    <span class="keyword">if</span>(!visited.contains(temp3)&amp;&amp;(!dead.contains(temp)))</span><br><span class="line">                       &#123;</span><br><span class="line">                        visited.add(temp3);</span><br><span class="line">                        queue.offer(temp3);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addOne</span><span class="params">(String s,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> []ch = s.toCharArray();</span><br><span class="line">        <span class="keyword">if</span>(ch[index] == <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            ch[index] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ch[index] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(ch);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minusOne</span><span class="params">(String s,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> []ch = s.toCharArray();</span><br><span class="line">        <span class="keyword">if</span>(ch[index] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            ch[index] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ch[index] -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(ch);</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h1><p>这种在二叉树、图中需要寻找最小值，用BFS更为合适，直接套用BFS模板框架即可。<br>再次啰嗦BFS就是让你在一幅「图」中找到从起点 start 到终点 target 的最近距离！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minDepth(TreeNode root) &#123;</span><br><span class="line">        if(root == null)</span><br><span class="line">            return 0;</span><br><span class="line">        int minDepth = 1;</span><br><span class="line">        Queue &lt;TreeNode&gt;queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        while(!queue.isEmpty())&#123;</span><br><span class="line">            int size = queue.size();</span><br><span class="line">            for(int i=0;i&lt;size;i++)&#123;</span><br><span class="line">                TreeNode temp = queue.poll();</span><br><span class="line">                if(temp.left == null &amp;&amp; temp.right == null)&#123;</span><br><span class="line">                    return minDepth;</span><br><span class="line">                &#125;</span><br><span class="line">                if(temp.left != null)</span><br><span class="line">                    queue.offer(temp.left);</span><br><span class="line">                if(temp.right != null)</span><br><span class="line">                    queue.offer(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            minDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第2种思路</strong>，<strong>全局遍历所有得叶子节点，得到最少的高度</strong><br><strong>这种想法需要在参数列表中加入额外的step参数</strong>，自己要对参数的引入有清楚的定义这里引入一张东哥的gif<br>根据这张gif，自己也就知道携带参数的作用域了<br> <img src="E:\zhanglei-Blog\themes\butterfly\source\articleImg\21天刷题计划\1.gif" alt="1"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> minDepth = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里要考虑树是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">1</span>;</span><br><span class="line">        check(root,step);</span><br><span class="line">        <span class="keyword">return</span> minDepth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(TreeNode root,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123; <span class="comment">//表明时叶子节点</span></span><br><span class="line">            <span class="keyword">if</span>(minDepth&gt;step) <span class="comment">//注意这里使用大于</span></span><br><span class="line">                minDepth = step;</span><br><span class="line">        &#125;</span><br><span class="line">        check(root.left,step+<span class="number">1</span>);</span><br><span class="line">        check(root.right,step+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 21天刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker基础学习Ⅱ</title>
      <link href="/2022/03/22/docker%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E2%85%A1/"/>
      <url>/2022/03/22/docker%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E2%85%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="UnionFS联合文件系统"><a href="#UnionFS联合文件系统" class="headerlink" title="UnionFS联合文件系统"></a>UnionFS联合文件系统</h1><p>Docker的镜像实际由一层一层的文件系统组成。联合文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。联合文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。<br><img src="/articleImg/61_article/1.jpg" alt="1"></p><h1 id="编辑容器后提交容器成为一个新镜像"><a href="#编辑容器后提交容器成为一个新镜像" class="headerlink" title="编辑容器后提交容器成为一个新镜像"></a>编辑容器后提交容器成为一个新镜像</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -m &quot;描述信息&quot; -a &quot;作者&quot; 容器ID 目标镜像名:[tag]  # -m -a 这些都是可选参数</span><br></pre></td></tr></table></figure><p> <img src="/articleImg/61_article/2.jpg" alt="2"></p><h1 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h1><p>为了实现数据持久化，使容器之间可以共享数据。可以将容器内的目录，挂载到宿主机上或其他容器内，实现同步和共享的操作。即使将容器删除，挂载到本地的数据卷也不会丢失。</p><p><img src="/articleImg/61_article/3.jpg" alt="3"></p><h2 id="使用容器数据卷"><a href="#使用容器数据卷" class="headerlink" title="使用容器数据卷"></a>使用容器数据卷</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v 主机内目录:容器内目录 镜像名/id</span><br><span class="line">docker inspect [容器名或ID] # 查看该容器即可以看到挂载信息</span><br></pre></td></tr></table></figure><p> <img src="/articleImg/61_article/4.jpg" alt="4"></p><h2 id="具名挂载"><a href="#具名挂载" class="headerlink" title="具名挂载"></a>具名挂载</h2><p>由于匿名挂载（挂载文件名为随机值）不经常用，我们这里主要记录具名挂载。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d  -v 卷名：容器内目录  镜像名/id  # 具名挂载</span><br><span class="line">docker volume inspect 卷名                  # 命令找到主机内目录(需要在主机运行该命令)  </span><br></pre></td></tr></table></figure><p>所有docker容器内的卷，在未指定主机内目录时，都在：*/var/lib/docker/volumes/卷名/_data* 下，可通过具名挂载可以方便的找到卷，因此广泛使用这种方式进行挂载。</p><h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p> <img src="/articleImg/61_article/5.jpg" alt="5"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name container02 --volumes from container01 镜像名/id  # 将两个容器进行挂载</span><br></pre></td></tr></table></figure><h1 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h1><p>Dockerfile是用来构建docker镜像的文件</p><h2 id="构建步骤"><a href="#构建步骤" class="headerlink" title="构建步骤"></a>构建步骤</h2><p>在编写玩Dockerfile之后，运行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -f 文件路径 -t 镜像名 .  # 文件名为Dockerfile时可省略且最后的.不要忽略</span><br><span class="line">docker run     # 运行镜像</span><br><span class="line">docker push    # 发布镜像</span><br></pre></td></tr></table></figure><h2 id="Dockerfile相关命令"><a href="#Dockerfile相关命令" class="headerlink" title="Dockerfile相关命令"></a>Dockerfile相关命令</h2><table><thead><tr><th>命令</th><th>效果</th></tr></thead><tbody><tr><td>FROM</td><td>基础镜像：Centos/Ubuntu</td></tr><tr><td>MAINTAINER</td><td>镜像作者+邮箱</td></tr><tr><td>RUN</td><td>镜像构建的时候需要运行的命令</td></tr><tr><td>ADD</td><td>为镜像添加内容（压缩包）</td></tr><tr><td>WORKDIR</td><td>镜像工作目录（进入容器时的目录）</td></tr><tr><td>VOLUME</td><td>挂载的目录</td></tr><tr><td>EXPOSE</td><td>暴露端口配置 （跟-p意思一样）</td></tr><tr><td>CMD/ENTRYPOINT</td><td>指定这个容器启动时要运行的命令（CMD替代先前命令，ENTRYPOINT在先前命令后追加）</td></tr><tr><td>COPY</td><td>类似于ADD，将文件拷贝到镜像中</td></tr><tr><td>ENV</td><td>构建时设置环境变量</td></tr></tbody></table><h2 id="构建过程需要注意的地方"><a href="#构建过程需要注意的地方" class="headerlink" title="构建过程需要注意的地方"></a>构建过程需要注意的地方</h2><ul><li>每个保留关键字（指令）都必须是大写字母</li><li>从上到下顺序执行</li><li>“#” 表示注释</li><li>每一个指令都会创建提交一个新的镜像层并提交</li></ul><h1 id="将spingboot打的jar包发布到自己的docker中"><a href="#将spingboot打的jar包发布到自己的docker中" class="headerlink" title="将spingboot打的jar包发布到自己的docker中"></a>将spingboot打的jar包发布到自己的docker中</h1><ul><li>首先再IDEA中创建一个springboot项目，然后编写一个controller方法如下</li></ul><p> <img src="/articleImg/62_article/1.jpg" alt="1"></p><ul><li>编写如下Dockerfile</li></ul><p> <img src="/articleImg/62_article/2.jpg" alt="2"></p><ul><li>将这两个文件通过ftp传送到自己的服务器，然后进行编译，运行即可得到反馈</li></ul><p> <img src="/articleImg/62_article/3.jpg" alt="3"></p><p> <img src="/articleImg/62_article/4.jpg" alt="4"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker基础命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21天刷题计划（13）二分图判定算法</title>
      <link href="/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%8813%EF%BC%89%E4%BA%8C%E5%88%86%E5%9B%BE%E5%88%A4%E5%AE%9A%E7%AE%97%E6%B3%95/"/>
      <url>/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%8813%EF%BC%89%E4%BA%8C%E5%88%86%E5%9B%BE%E5%88%A4%E5%AE%9A%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="判断二分图"><a href="#判断二分图" class="headerlink" title="判断二分图"></a>判断二分图</h1><p><img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/36.jpg" alt="36"></p><p><strong>思路整理</strong></p><ul><li>判定的主要思路在于traverse 函数一边遍历节点，一边给节点染色，尝试让每对相邻节点的颜色都不一样。</li><li>若在遍历的过程中，发现子节点已经遍历过，且子节点的颜色标记与父节点的颜色标记一致，那么判定不是二分图</li><li><strong>也要注意图是否联通的问题，所以我们在调用traverse函数的时候需要，对每一个未遍历过的节点进行判断操作</strong></li><li>其他就没有要整理的问题了，主要就是图的遍历问题DFS、BFS。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//BFS做这道题更形象，DFS也是可以的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> []visited; <span class="comment">//用于记录已经遍历过的节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> ok;       <span class="comment">//用于返回最后的结果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> []color; <span class="comment">//用于给节点染色</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        ok  = <span class="keyword">true</span>;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[graph.length];</span><br><span class="line">        color = <span class="keyword">new</span> <span class="keyword">boolean</span>[graph.length];</span><br><span class="line">        Arrays.fill(visited,<span class="keyword">false</span>);</span><br><span class="line">        Arrays.fill(color,<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">int</span> n=graph.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;   </span><br><span class="line">            <span class="keyword">if</span>(!visited[i])  <span class="comment">//解决图是否联通的问题</span></span><br><span class="line">                traverse(graph,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ok;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(<span class="keyword">int</span> [][]graph,<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!ok)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        visited[s] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> item : graph[s])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[item])&#123;</span><br><span class="line">                visited[item] = <span class="keyword">true</span>;</span><br><span class="line">                color[item] = !color[s];</span><br><span class="line">                traverse(graph,item);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(color[item] == color[s])</span><br><span class="line">                    ok = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="可能的二分法"><a href="#可能的二分法" class="headerlink" title="可能的二分法"></a>可能的二分法</h1><p><img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/37.jpg" alt="37"></p><p><strong>思路整理</strong></p><ul><li><strong>二分图的判定主要思想还是染色法，巧妙利用visited数组和color数组</strong>，达到染色的操作和判断</li><li>对于图的创建，对于邻接表数据结构的定义我们一定要清楚，下方有我的记录</li><li>图创建完毕后，就是一个图遍历的过程DFS、BFS。</li></ul><p><strong>无权图的邻接表形式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 图节点编号为 1...n</span><br><span class="line">List&lt;Integer&gt;[] graph = new LinkedList[n + 1];</span><br><span class="line">for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">    graph[i] = new LinkedList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>带权图的邻接表形式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt;[]graph;</span><br><span class="line">    <span class="comment">// 记录图中节点的颜色，false 和 true 代表两种不同颜色</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] color;</span><br><span class="line">    <span class="comment">// 记录图中节点是否被访问过</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] visited;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> ok;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">possibleBipartition</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] dislikes)</span> </span>&#123;</span><br><span class="line">        color =  <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">        visited =  <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">        ok = <span class="keyword">true</span>;</span><br><span class="line">        graph = <span class="keyword">new</span> LinkedList[n+<span class="number">1</span>]; <span class="comment">//这里多申请一个节点，为的是与编号数从1开始进行对应</span></span><br><span class="line">        createGraph(graph,dislikes,n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])</span><br><span class="line">                BFS(graph,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ok;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createGraph</span><span class="params">(LinkedList&lt;Integer&gt;[]graph,<span class="keyword">int</span>[][]dislikes,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">//这里就像是在为每一个数组节点进行malloc</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> []edge : dislikes)&#123;</span><br><span class="line">            <span class="keyword">int</span> w = edge[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> v = edge[<span class="number">1</span>];</span><br><span class="line">            graph[w].add(v);</span><br><span class="line">            graph[v].add(w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">(LinkedList&lt;Integer&gt;[]graph,<span class="keyword">int</span> start)</span></span>&#123; <span class="comment">//采用BFS进行图的遍历</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(start);</span><br><span class="line">        visited[start] = <span class="keyword">true</span>; <span class="comment">//在这里将开始节点进行标注visited</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> node = queue.poll();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> temp:graph[node])&#123;</span><br><span class="line">                <span class="keyword">if</span>(!visited[temp])&#123;</span><br><span class="line">                    visited[temp] = <span class="keyword">true</span>; <span class="comment">//在将节点加入队列时，就要同步visited遍历数组</span></span><br><span class="line">                    color[temp] = !color[node];</span><br><span class="line">                    queue.offer(temp);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(color[temp] == color[node])</span><br><span class="line">                    &#123;</span><br><span class="line">                        ok = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 21天刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21天刷题计划（12）图的算法基础</title>
      <link href="/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%8812%EF%BC%89%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%8812%EF%BC%89%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="所有可能的路径"><a href="#所有可能的路径" class="headerlink" title="所有可能的路径"></a>所有可能的路径</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/35.jpg" alt="35"></p><p><strong>思路整理</strong></p><ul><li>对于这道题本身没有什么难度，我们既可以采用深度优先遍历，也可以采用广度优先遍历。我今天主要想总结的是在深度优先遍历中「做选择」和「撤销选择」这两句代码放置的位置。</li></ul><ol><li>常规方法 ： <strong>「做选择」和「撤销选择」都放在for循环内</strong>，这样我们是没有办法将头节点的路径加入到整个path中的，如果我们想要完整的path，必须在调用DFS之前，在path中加入头节点，代码如下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt;path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    path.add(<span class="number">0</span>);                       <span class="comment">//  ★「做选择」和「撤销选择」都放在for循环内的前提，</span></span><br><span class="line">    traverse(graph,<span class="number">0</span>,path,visited);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(<span class="keyword">int</span>[][]graph,<span class="keyword">int</span> s,LinkedList&lt;Integer&gt;path, <span class="keyword">boolean</span> []visited)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(递归基)</span><br><span class="line">        <span class="function">pass</span></span><br><span class="line"><span class="function">    <span class="title">for</span><span class="params">(<span class="keyword">int</span> item:graph[s])</span></span>&#123;  </span><br><span class="line">        path.addLast(item); <span class="comment">//且加入的数据是传入节点s的子节点</span></span><br><span class="line">        traverse(graph,item,path,visited);</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>今天新巩固的方法： <strong>「做选择」和「撤销选择」都放在for循环外</strong>。我们可以直接得到完整的路径，这是因为头节点在传入的时候，就直接被加入到了path中。代码如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt;path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    traverse(graph,<span class="number">0</span>,path,visited);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(<span class="keyword">int</span>[][]graph,<span class="keyword">int</span> s,LinkedList&lt;Integer&gt;path, <span class="keyword">boolean</span> []visited)</span></span>&#123;</span><br><span class="line">    path.addLast(s);  <span class="comment">//  ★「做选择」和「撤销选择」都放在for循环外，加入数据一定要放到递归基之前，且加入的数据是传入节点s</span></span><br><span class="line">    <span class="keyword">if</span>(递归基)</span><br><span class="line">        <span class="function">pass</span></span><br><span class="line"><span class="function">    <span class="title">for</span><span class="params">(<span class="keyword">int</span> item:graph[s])</span></span>&#123;  </span><br><span class="line">        traverse(graph,item,path,visited);</span><br><span class="line">    &#125;</span><br><span class="line">    path.removeLast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>「做选择」和「撤销选择」也可以在for循环的内外进行交叉，但是一定要注意，是对谁进行add操作，和对谁进行remove</li></ol><p><strong>下面的写法本道题目的标准写法，加入了visited数组放置回路，不论是有没有回路都可以解决。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录所有路径</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt;path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> []visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[graph.length]; <span class="comment">//如果图结构中含有环，那么我们需要添加一个visited数组，防止重复遍历</span></span><br><span class="line">        Arrays.fill(visited,<span class="keyword">false</span>);</span><br><span class="line">        traverse(graph,<span class="number">0</span>,path,visited);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(<span class="keyword">int</span>[][]graph,<span class="keyword">int</span> s,LinkedList&lt;Integer&gt;path, <span class="keyword">boolean</span> []visited)</span></span>&#123;</span><br><span class="line">        path.addLast(s); </span><br><span class="line">        visited[s] = <span class="keyword">true</span>;  </span><br><span class="line">        <span class="keyword">if</span>(s == graph.length-<span class="number">1</span>)</span><br><span class="line">         &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(path));   <span class="comment">//return; //如果「做选择」和「撤销选择」放在外面，这里就不能写return</span></span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> item:graph[s])&#123;  </span><br><span class="line">            <span class="keyword">if</span>(visited[item])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            traverse(graph,item,path,visited);</span><br><span class="line">        &#125;</span><br><span class="line">        visited[s] = <span class="keyword">false</span>;</span><br><span class="line">        path.removeLast();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>由于题目中明确说明没有回路，我们就不用加visited数组了</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt;path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    path.addLast(<span class="number">0</span>);</span><br><span class="line">    traverse(graph,<span class="number">0</span>,path);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(<span class="keyword">int</span>[][]graph,<span class="keyword">int</span> s,LinkedList&lt;Integer&gt;path)</span></span>&#123;</span><br><span class="line">    <span class="comment">//添加节点s到路径</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(s == graph.length-<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(path));</span><br><span class="line">        <span class="comment">//return; //如果「做选择」和「撤销选择」放在外面，这里就不能写return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> item:graph[s])&#123;</span><br><span class="line">        path.addLast(item); </span><br><span class="line">        traverse(graph,item,path);</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 21天刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21天刷题计划（11）二叉搜索树的基础操作</title>
      <link href="/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%8811%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%8811%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h1><p><img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/31.jpg" alt="31"></p><p><strong>思路整理</strong></p><ul><li>一旦涉及「改」，函数就要返回 TreeNode 类型，并且对递归调用的返回值进行接收。</li><li>对于二叉搜索树的判断，我们<strong>必须把 root 的约束传递给左右子树</strong>。也就是root节点需要大于哪个数，小于哪个数<strong>。这里我们在参数列表中，增加函数参数列表，在参数中携带额外信息</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root,TreeNode min,TreeNode max)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (min != <span class="keyword">null</span> &amp;&amp; root.val &lt;= min.val) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//不满足root节点的约束</span></span><br><span class="line">        <span class="keyword">if</span> (max != <span class="keyword">null</span> &amp;&amp; root.val &gt;= max.val) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//不满足root节点的约束</span></span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.left,min,root)&amp;&amp;isValidBST(root.right,root,max); <span class="comment">//把 BST 这个「左小右大」的特性用上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉搜索树的插入操作"><a href="#二叉搜索树的插入操作" class="headerlink" title="二叉搜索树的插入操作"></a>二叉搜索树的插入操作</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/32.jpg" alt="32"></p><p><strong>思路整理</strong></p><ul><li>这题涉及插入操作，我们需要将节点进行返回</li><li>我们要在<strong>root等于null的时候进行插入</strong>，这个时候是合适时机，满足二叉搜索树的数据大小的约束</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span>(root.val&gt;val)</span><br><span class="line">            root.left = insertIntoBST(root.left,val);</span><br><span class="line">        <span class="keyword">if</span>(root.val&lt;val)</span><br><span class="line">            root.right = insertIntoBST(root.right,val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉搜索树的搜索"><a href="#二叉搜索树的搜索" class="headerlink" title="二叉搜索树的搜索"></a>二叉搜索树的搜索</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/33.jpg" alt="33"></p><p><strong>思路整理</strong></p><ul><li>搜索的话，根据二叉搜索树的结构特点，我们<strong>通过if判断来进行剪枝操作</strong>，形成二叉搜索树的模板</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; val)</span><br><span class="line">            <span class="keyword">return</span> searchBST(root.left,val);</span><br><span class="line">        <span class="keyword">if</span>(root.val&lt;val)</span><br><span class="line">            <span class="keyword">return</span> searchBST(root.right,val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="删除二叉搜索树中的节点"><a href="#删除二叉搜索树中的节点" class="headerlink" title="删除二叉搜索树中的节点"></a>删除二叉搜索树中的节点</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/34.jpg" alt="34"></p><p><strong>思路整理</strong></p><ul><li><strong>这里涉及删除，所以我们要将节点进行返回</strong></li><li>这道题需要注意的是，<strong>当找到节点进行删除的时候，我们要分三种情况进行讨论</strong></li><li>①当<strong>root.left == null</strong>时，我们返回root.right</li><li>②当<strong>root.right == null</strong>时，我们返回root.left</li><li>③当<strong>root.left、root.right都不为null</strong>时，我们有两种方案进行选择，要么将左子树中最大的节点换上来，要么将右子树中最小的节点换上来</li><li>换上来的节点，需要在删除后，才进行对root的替换</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt;key)</span><br><span class="line">            root.left = deleteNode(root.left,key);</span><br><span class="line">        <span class="keyword">if</span>(root.val&lt;key)</span><br><span class="line">            root.right = deleteNode(root.right,key);</span><br><span class="line">        <span class="keyword">if</span>(root.val == key)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            <span class="keyword">if</span>(root.right == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line">            TreeNode leftMax = <span class="keyword">new</span> TreeNode(-<span class="number">1</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">            TreeNode node = root.left;</span><br><span class="line">            <span class="keyword">while</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">                node = node.right;</span><br><span class="line">            root.left = deleteNode(root.left,node.val);  <span class="comment">//换上来的节点，需要在删除后，才进行对root的替换</span></span><br><span class="line">            leftMax.val = node.val;</span><br><span class="line">            leftMax.left = root.left;</span><br><span class="line">            leftMax.right = root.right;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">return</span> leftMax;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 21天刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉搜索树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21天刷题计划（10）二叉树算法入门</title>
      <link href="/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"/>
      <url>/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="反转二叉树"><a href="#反转二叉树" class="headerlink" title="反转二叉树"></a>反转二叉树</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/28.jpg" alt="28"></p><p><strong>思路总结</strong></p><ol><li>写递归函数要推算出当前节点在干嘛，然后再相信自己对该递归函数的定义。</li><li><strong>一定要有递归基，即递归返回条件</strong>！</li><li>二叉树题目的一个难点就是，<strong>如何把题目的要求细化成每个节点需要做的事情。</strong></li><li>对于该题：我们发现只要把二叉树上的每一个节点的左右子节点进行交换，最后的结果就是完全翻转之后的二叉树。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode node = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = node;</span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="填充每个节点的下一个右侧节点指针"><a href="#填充每个节点的下一个右侧节点指针" class="headerlink" title="填充每个节点的下一个右侧节点指针"></a>填充每个节点的下一个右侧节点指针</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/29.jpg" alt="29"></p><p>第一种思路：</p><ul><li>利用题目的性质：每个父节点都有两个子节点</li><li>传入两个节点，这样就可以将node1的right节点，与node2的left节点进行连接了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        connect(root.left,root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(Node node1,Node node2)</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span>(node1 == <span class="keyword">null</span>||node2 == <span class="keyword">null</span>) <span class="comment">//这样子去写递归基是因为，每个父节点都有两个子节点</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        node1.next = node2;</span><br><span class="line"></span><br><span class="line">        connect(node1.left,node1.right);</span><br><span class="line">        connect(node2.left,node2.right);</span><br><span class="line">        connect(node1.right,node2.left); <span class="comment">//node1的right节点,与node2的left节点传入递归函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种思路：</p><ul><li>充分利用root.next思想，理解root.next其实指的就是root的右边的兄弟节点</li><li>如果想连接node1的right节点与node2的left节点，只需要在满足相关节点不为null的条件下：node.right.next = node.next.left;</li><li>如果采用这种思路，就必须使用前序遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二思路：在前序遍历中，利用next指针，来进行指向操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="comment">//这两句代码要放到最前面，因为当root为null时，就不能去索引root.left,root.right</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>((root.left == <span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>))</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root.next == <span class="keyword">null</span>)</span><br><span class="line">            root.right.next=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            root.right.next = root.next.left; <span class="comment">//连接node1的right节点与node2的left节点</span></span><br><span class="line">        root.left.next = root.right;  <span class="comment">//连接root的本身的两个节点</span></span><br><span class="line">        connect(root.left);</span><br><span class="line">        connect(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a>二叉树展开为链表</h1><p><img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/30.jpg" alt="30"></p><p>二叉树题目的一个难点就是，如何把题目的要求细化成每个节点需要做的事情<br><strong>思路整理</strong></p><ul><li>这题难在原地修改，仅用二叉树的right的指针，将二叉树展开为一个链表</li><li>每个节点所要做的事：<ol><li><strong>首先将当前节点的left和right进行记录</strong></li><li>将root.right指向left,将root.left指向null</li><li>使用临时变量p指向root，进行链表操作，即p=p.right找到表尾</li><li>找到表尾后，将最开始记录的right,放置到p.right</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        flatten(root.left);</span><br><span class="line">        flatten(root.right);</span><br><span class="line">        TreeNode left = root.left;</span><br><span class="line">        TreeNode right = root.right;</span><br><span class="line">        root.right = left;</span><br><span class="line">        root.left = <span class="keyword">null</span>;</span><br><span class="line">        TreeNode p = root;</span><br><span class="line">        <span class="keyword">while</span>(p.right!=<span class="keyword">null</span>)</span><br><span class="line">        p = p.right;</span><br><span class="line">        p.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 21天刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21天刷题计划（9）LRU数据结构的设计</title>
      <link href="/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%889%EF%BC%89LRU%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%889%EF%BC%89LRU%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h1><p><img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/27.jpg" alt="27"></p><p><strong>思路分析</strong></p><p><strong>在思考：如何在双向链表里以O（1）的复杂度进行get,解决方案就用HashMap&lt;key,Node&gt;,这个思路和数组以O（1）的复杂度删除是一样的思路。</strong></p><p>注意: 数组可以保证以O(1)获取，双向链表可以保证以0（1）进行删除，我们需要用HashMap与双向链表进行结合。这样既保证了双线链表0（1）删除，也保证了O（1）时间获取。</p><ul><li>当调用LRUCache的get方法时：该节点在双向链表里需要调整到最后一个位置</li><li>当调用LRUCache的put方法时：若该节点存在，则更新该节点val,并将其移动到最后一个节点。若该节点不存在，判断是否已到达最大容量，若已到达最大容量，删除头节点，并删除map中对应的key；最后将该节点插入到尾部，并在map中加入相关的key；</li></ul><p><img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/26.jpg" alt="26"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line">    HashMap&lt;Integer,Node&gt;map;</span><br><span class="line">    DoubleList dblist;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        cap = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        dblist = <span class="keyword">new</span> DoubleList();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(key))&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> makeNow(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(key,value);</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            Node temp = map.get(key);</span><br><span class="line">            dblist.remove(temp);</span><br><span class="line">            temp.val = value;</span><br><span class="line">            dblist.addLast(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dblist.size() == cap)&#123;</span><br><span class="line">            Node first = dblist.removeFirst();</span><br><span class="line">            map.remove(first.key);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(key,node);</span><br><span class="line">        dblist.addLast(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">makeNow</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node node = map.get(key);</span><br><span class="line">        <span class="keyword">int</span> val = node.val;</span><br><span class="line">        dblist.remove(node);</span><br><span class="line">        dblist.addLast(node);</span><br><span class="line">        <span class="keyword">return</span> node.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> key,val;</span><br><span class="line">    <span class="keyword">public</span> Node next,pre;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = k;</span><br><span class="line">        <span class="keyword">this</span>.val = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleList</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node head,tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">removeFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next == tail)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node first = head.next;</span><br><span class="line">        head.next = first.next;</span><br><span class="line">        first.next.pre = head;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        node.pre = tail.pre;</span><br><span class="line">        node.next = tail;</span><br><span class="line">        tail.pre.next = node;</span><br><span class="line">        tail.pre = node;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        node.pre.next = node.next;</span><br><span class="line">        node.next.pre = node.pre;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 21天刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LRU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21天刷题计划（8）如何在数组中以O（1）删除元素</title>
      <link href="/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%888%EF%BC%89%E5%A6%82%E4%BD%95%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E4%BB%A5O%EF%BC%881%EF%BC%89%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0/"/>
      <url>/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%888%EF%BC%89%E5%A6%82%E4%BD%95%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E4%BB%A5O%EF%BC%881%EF%BC%89%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="常数时间插入、删除和获取元素"><a href="#常数时间插入、删除和获取元素" class="headerlink" title="常数时间插入、删除和获取元素"></a>常数时间插入、删除和获取元素</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/24.jpg" alt="24"></p><p><strong>思路整理</strong></p><ul><li>常数时间进行获取元素一定是连续数组，<strong>要么实际就是连续数组</strong>，<strong>要么通过HashMap构造成逻辑上连续的数组</strong></li><li><strong>通过HashMap存储 数值-下标映射</strong></li><li>需要一个<strong>变量arraySize，记录数组实际的大小</strong>，用于删除数据，插入数据</li><li>删除操作 ： 先拿到 val 的索引，将最后一个元素对应在map中的索引修改为 index，交换 val 和最后一个元素，arraySize–，最后在map中删除元素 val 对应的索引</li><li>插入操作：val 不存在，根据arraySize插入到 nums 尾部</li><li>获取操作：注意通过上述的操作，整个数组已经是连续的了，所以我直接通过random生成[0,arraysize-1]的索引即可</li><li>注意 <strong>random.nextInt(0,arraysize);才表示生成[0,arraysize-1]区间的数</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> []array;</span><br><span class="line">    <span class="keyword">int</span> arraySize;</span><br><span class="line">    HashMap &lt;Integer,Integer&gt;valToIndex;</span><br><span class="line">    Random random;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomizedSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2000001</span>];</span><br><span class="line">        arraySize = <span class="number">0</span>;</span><br><span class="line">        valToIndex = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        random = <span class="keyword">new</span> Random();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(valToIndex.containsKey(val))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        array[arraySize] = val;</span><br><span class="line">        valToIndex.put(val,arraySize);</span><br><span class="line">        arraySize++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!valToIndex.containsKey(val))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> index = valToIndex.get(val);</span><br><span class="line">        <span class="keyword">int</span> temp = array[arraySize -<span class="number">1</span>];</span><br><span class="line">        array[arraySize -<span class="number">1</span>] = array[index];</span><br><span class="line">        array[index] = temp;</span><br><span class="line"></span><br><span class="line">        valToIndex.put(temp,index); <span class="comment">//这一步一定要修改！！数组的值调换之后，hashMap上对应的键值对也要一并修改，而且这一步必须要在下一句的前面，以免删除的元素，就是数组的最后一个元素</span></span><br><span class="line">        valToIndex.remove(val);</span><br><span class="line">        </span><br><span class="line">        arraySize--;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arraySize&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = random.nextInt(arraySize);</span><br><span class="line">        <span class="keyword">return</span> array[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="黑名单中的随机数"><a href="#黑名单中的随机数" class="headerlink" title="黑名单中的随机数"></a>黑名单中的随机数</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/25.jpg" alt="25"></p><p><strong>思路整理</strong></p><ol><li>本题的核心思想是将数组根据有效长度为阈值，划分前后数组</li><li>将前部分数组中的黑名单元素通过HashMap映射到后半部分数组的有效值</li><li>后半部分的遍历通过一个last下标变量进行辅助遍历，遍历的时候，要判断当前last坐标值是否为黑名单，若是黑名单就不要映射，直接last–;</li><li>切记一点：如果想高效地，等概率地随机获取元素，就要使用数组作为底层容器。</li></ol><ul><li>如果要保持数组元素的紧凑性，可以把待删除元素换到最后，然后 pop 掉末尾的元素，这样时间复杂度就是 O(1) 了。当然，我们需要额外的哈希表记录值到索引的映射。</li><li>对于第二题，数组中含有「空洞」（黑名单数字），也可以利用哈希表巧妙处理映射关系，让数组在逻辑上是紧凑的，方便随机取元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">//用于映射黑名单</span></span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] blacklist)</span> </span>&#123;</span><br><span class="line">        size = n - blacklist.length; <span class="comment">//以size进行划分 逻辑分割线</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> item:blacklist)&#123;</span><br><span class="line">            map.put(item,-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> last = n -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> item:blacklist)&#123;</span><br><span class="line">            <span class="keyword">if</span>(item&gt;=size)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span>(map.containsKey(last))&#123;</span><br><span class="line">                last--;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(item,last);</span><br><span class="line">            last--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        Integer res =random.nextInt(size);</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(res))</span><br><span class="line">            <span class="keyword">return</span> map.get(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 21天刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> O(1)复杂度删除元素 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21天刷题计划（7）递归反转链表</title>
      <link href="/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%887%EF%BC%89%E9%80%92%E5%BD%92%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%887%EF%BC%89%E9%80%92%E5%BD%92%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/21.jpg" alt="21"></p><p><strong>思路整理</strong></p><ul><li>首先通过递归返回链表的最后一个节点，由于递归函数的写法为reverseList(head.next)，所以此时的head为倒数第二个节点。</li><li>head.next.next = head; 开始改变指向</li><li>再通过递归栈的逐步释放，是的链表反转完毕</li></ul><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/20.jpg" alt="20"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode last = reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="反转链表2"><a href="#反转链表2" class="headerlink" title="反转链表2"></a>反转链表2</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/23.jpg" alt="23"></p><p>方案1，采用递归进行反转<br><strong>思路整理</strong></p><ul><li>通过第一层递归找到，反转链表的起始位置</li><li>第二层递归式反转right - left + 1个节点，相当于reverseN(head,right-left +1)</li><li>再通过第一次的递归栈释放，将反转后的节点进行返回连接</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ListNode successor = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> reverseN(head,right);</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = reverseBetween(head.next,left-<span class="number">1</span>,right-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseN</span><span class="params">(ListNode head,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            successor = head.next;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode last = reverseN(head.next,n-<span class="number">1</span>);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = successor;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案2，采用头插法进行反转，这时候一定要设立一个虚拟头节点dummy这样可以避免很多特殊情况的套路</p><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/22.jpg" alt="22"></p><p>使用三个指针变量 pre、curr、next 来记录反转的过程中需要的变量，它们的意义如下：</p><ul><li>curr：指向待反转区域的第一个节点 left；</li><li>next：永远指向 curr 的下一个节点，循环过程中，curr 变化以后 next 会变化；</li><li>pre：永远指向待反转区域的第一个节点 left 的前一个节点，在循环过程中不变。</li><li>先将 curr 的下一个节点记录为 next；</li><li>把 curr 的下一个节点指向 next 的下一个节点；</li><li>把 next 的下一个节点指向 pre 的下一个节点；</li><li>把 pre 的下一个节点指向 next。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; right - left; i++) &#123;  <span class="comment">//注意i从0开始，遍历结束条件为 i&lt;right-left   若i从1开始，则变成 i&lt;right-left +1</span></span><br><span class="line">    next = cur.next;</span><br><span class="line">    cur.next = next.next;</span><br><span class="line">    next.next = pre.next;</span><br><span class="line">    pre.next = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dummyNode.next;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 21天刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归反转链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21天刷题计划（6）二分查找</title>
      <link href="/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%886%EF%BC%89%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%886%EF%BC%89%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/18.jpg" alt="18"></p><p><strong>思路整理</strong><br>1：搜索区间很重要： 搜索区间的范围由while循环确定，<strong>若while(left&lt;=right)，区间为[left,right]</strong>,<strong>若while(left&lt;right)，区间为[left,right)</strong><br>2: 缩小搜索边界很重要：<strong>缩小边界范围</strong>，<strong>主要在nums[mid] == target时确定，当区间统一为闭区间时，我们在缩小边界时就要right = mid - 1 或 left = mid+1</strong><br>3. <strong>最终返回谁也很重要</strong>：根据边界缩小的条件，进行判断选择返回谁，若寻找左边界，需要返回left，并且在最后返回之前需要判断位置的合法性，因为数组中可能没有该元素，所以一定要进行合法性检测。</p><p><strong>确定左边界举例****：我们选取闭区间进行查找，所以当nums[mid] == target时，我们left不动，然后让right = mid - 1,当while循环结束时，left是大于right的,也就是</strong>left = right+1, 注意：因为我们之前left不动，然后让right = mid - 1，最后情况下mid就是左边界，所以我们应该返回left，也可以是right+1</p><p>*<em>返回值判断举例</em>***：如果是左边界，我们选择返回left，那么就要考虑两个极端情况</p><ul><li>当target 不存在时，且target小于数组中的所有值，那就应该判断 nums[left]==target</li><li>当target 不存在时，且target大于数组中的所有值，就需要判断 left是否大于nums.length</li><li>当存在时，直接返回left或right + 1即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> []ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> left = leftBound(nums,target);</span><br><span class="line">        <span class="keyword">int</span> right = rightBound(nums,target);</span><br><span class="line">        ans[<span class="number">0</span>] = left;</span><br><span class="line">        ans[<span class="number">1</span>] = right; </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leftBound</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">                right = mid - <span class="number">1</span>; <span class="comment">//根据缩小边界的条件，确定最后返回谁</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= nums.length || nums[left]!=target)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rightBound</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">                left = mid + <span class="number">1</span>; <span class="comment">//根据这一句，再根据循环结束条件为left &gt; right 即left-1= right.可知我们最终需要返回right或则left-1 </span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">                right = mid -<span class="number">1</span>;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right &lt; <span class="number">0</span>|| nums[right]!=target)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常规二分查找"><a href="#常规二分查找" class="headerlink" title="常规二分查找"></a>常规二分查找</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/19.jpg" alt="19"></p><p><strong>思路整理</strong></p><ul><li>这个是常规的二分查找，查找左右边界的题目请见34题</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int search(int[] nums, int target) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = nums.length-1;</span><br><span class="line">        while(left &lt;= right)&#123;</span><br><span class="line">            int mid = (left+right)/2;</span><br><span class="line">            if(nums[mid] == target)</span><br><span class="line">                return mid;</span><br><span class="line">            else if(nums[mid] &gt; target)</span><br><span class="line">                right = mid -1;</span><br><span class="line">            else if(nums[mid] &lt; target)</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 21天刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21天刷题计划（5）滑动窗口</title>
      <link href="/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%885%EF%BC%89%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
      <url>/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%885%EF%BC%89%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="无重复的最长字串"><a href="#无重复的最长字串" class="headerlink" title="无重复的最长字串"></a>无重复的最长字串</h1><p><img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/17.jpg" alt="17"></p><p><strong>思路总结：</strong></p><ol><li>很典型的滑动窗口问题</li><li>只不过这里不需要两个map了，只需要一个window map即可，在遍历的过程中查重即可</li><li>这种情况下，right也需要遍历到字符串的最右端</li><li>重点还是掌握left 与 right的闭开区间设置，这个技巧很关键</li><li>我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引左闭右开区间 [left, right) 称为一个「窗口」，理论上你可以设计两端都开或者两端都闭的区间，但设计为左闭右开区间是最方便处理的。因为这样初始化 left = right = 0 时区间 [0, 0) 中没有元素，但只要让 right 向右移动一位，区间 [0, 1) 就包含一个元素 0 了。如果你设置为两端都开的区间，那么让 right 向右移动一位后开区间 (0, 1) 仍然没有元素；如果你设置为两端都闭的区间，那么初始区间 [0, 0] 就包含了一个元素。这两种情况都会给边界处理带来不必要的麻烦。</li><li>当我们将left,right初始化0时，需要先取rc = s.charAt(right) , 然后直接right++</li><li>程序的滑动窗口结束条件为right&lt;s.length()</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(s.length()&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> s.length();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        HashMap &lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(right&lt;s.length())&#123;</span><br><span class="line">            Character c = s.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line">            map.put(c,map.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(map.get(c)&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                map.put(s.charAt(left),map.get(s.charAt(left))-<span class="number">1</span>);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans,right-left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h1><p><img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/14.jpg" alt="14"></p><p><strong>思路总结</strong></p><p>边界注意事项：</p><ol><li>我们在字符串 S 中使用双指针中的左右指针技巧，<strong>初始化 left = right = 0，把索引左闭右开区间 [left, right) 称为一个「窗口」</strong></li><li>理论上你可以设计两端都开或者两端都闭的区间，但设计为左闭右开区间是最方便处理的。因为这样初始化 left = right = 0 时区间 [0, 0) 中没有元素，但只要让 right 向右移动一位，区间 [0, 1) 就包含一个元素 0 了。如果你设置为两端都开的区间，那么让 right 向右移动一位后开区间 (0, 1) 仍然没有元素；如果你设置为两端都闭的区间，那么初始区间 [0, 0] 就包含了一个元素。<strong>这两种情况都会给边界处理带来不必要的麻烦。</strong></li></ol><p>HashMap注意事项：</p><ol><li>need map是用来确定题目需要的字符种类及个数</li><li>windows map是用来确定窗口内的字符种类及个数</li><li>我们需要设立一个变量valid来确定window窗口内满足条件的个数，valid的值更新也有讲究，分别在if(wcount == needCount) if(lcount == need.get(lc)-1)</li></ol><p>遍历注意事项：</p><ol><li>我们先不断地增加 right 指针扩大窗口 [left, right)，<strong>直到窗口中的字符串符合要求</strong>（包含了 T 中的所有字符）</li><li><strong>此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right)，直到窗口中的字符串不再符合要求</strong>（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。</li><li>重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        String ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> ansRight = s.length()+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ansLeft = <span class="number">0</span>;</span><br><span class="line">        HashMap &lt;Character,Integer&gt;need = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        HashMap &lt;Character,Integer&gt;windows = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//初始化窗口</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t.length();i++)&#123;</span><br><span class="line">            need.put(t.charAt(i),need.getOrDefault(t.charAt(i),<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            windows.put(t.charAt(i),<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;s.length())&#123;</span><br><span class="line">            <span class="keyword">char</span> rc = s.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span>(windows.containsKey(rc))&#123;</span><br><span class="line">                <span class="keyword">int</span> wcount = windows.get(rc)+<span class="number">1</span>;</span><br><span class="line">                windows.put(rc,wcount);</span><br><span class="line">                <span class="keyword">int</span> needCount = need.get(rc);</span><br><span class="line">                <span class="keyword">if</span>(wcount == needCount)</span><br><span class="line">                    valid++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若满足条件，则进行窗口的缩小</span></span><br><span class="line">            <span class="keyword">while</span>(valid == need.size())&#123;</span><br><span class="line">                <span class="keyword">if</span>(ansRight - ansLeft &gt; right - left)</span><br><span class="line">                &#123;</span><br><span class="line">                    ansRight = right;</span><br><span class="line">                    ansLeft = left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">char</span> lc = s.charAt(left);</span><br><span class="line">                left++;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(windows.containsKey(lc))&#123;</span><br><span class="line">                    <span class="keyword">int</span> lcount = windows.get(lc)-<span class="number">1</span>;</span><br><span class="line">                    windows.put(lc,lcount);</span><br><span class="line">                    <span class="keyword">if</span>(lcount == need.get(lc)-<span class="number">1</span>)</span><br><span class="line">                        valid--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ansRight == s.length()+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=ansLeft;i&lt;ansRight;i++)&#123;</span><br><span class="line">            ans += s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/15.jpg" alt="15"></p><p><strong>思路总结</strong></p><ol><li>总体思想采用的76题的滑动窗口</li><li><strong>这里只需要注意左边界需要缩小的时刻为 right-left&gt;=s1.length()，因为这里求的是子串</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        HashMap &lt;Character,Integer&gt;need = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        HashMap &lt;Character,Integer&gt;windows = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//初始化窗口</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s1.length();i++)&#123;</span><br><span class="line">            need.put(s1.charAt(i),need.getOrDefault(s1.charAt(i),<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            windows.put(s1.charAt(i),<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;s2.length())&#123;</span><br><span class="line">            <span class="keyword">char</span> rc = s2.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span>(windows.containsKey(rc))&#123;</span><br><span class="line">                <span class="keyword">int</span> wcount = windows.get(rc)+<span class="number">1</span>;</span><br><span class="line">                windows.put(rc,wcount);</span><br><span class="line">                <span class="keyword">int</span> needCount = need.get(rc);</span><br><span class="line">                <span class="keyword">if</span>(wcount == needCount)</span><br><span class="line">                    valid++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若满足条件，则进行窗口的缩小</span></span><br><span class="line">            <span class="keyword">if</span>(right-left&gt;=s1.length())&#123;</span><br><span class="line">               <span class="keyword">if</span>(valid == need.size())</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">char</span> lc = s2.charAt(left);</span><br><span class="line">                left++;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(windows.containsKey(lc))&#123;</span><br><span class="line">                    <span class="keyword">int</span> lcount = windows.get(lc)-<span class="number">1</span>;</span><br><span class="line">                    windows.put(lc,lcount);</span><br><span class="line">                    <span class="keyword">if</span>(lcount == need.get(lc)-<span class="number">1</span>)</span><br><span class="line">                        valid--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a>找到字符串中所有字母异位词</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/16.jpg" alt="16"></p><p><strong>思路总结</strong></p><ol><li>总体思想采用的76题的滑动窗口</li><li>这里只需要注意左边界需要缩小的时刻为 right-left&gt;=s1.length()</li><li>因为这里求的是所有子串，所以right必须遍历到字符串的最右端，且需要一个List来存储这个过程中的所有可行解</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        HashMap &lt;Character,Integer&gt;need = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        HashMap &lt;Character,Integer&gt;windows = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//初始化窗口</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;p.length();i++)&#123;</span><br><span class="line">            need.put(p.charAt(i),need.getOrDefault(p.charAt(i),<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            windows.put(p.charAt(i),<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;s.length())&#123;</span><br><span class="line">            <span class="keyword">char</span> rc = s.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span>(windows.containsKey(rc))&#123;</span><br><span class="line">                <span class="keyword">int</span> wcount = windows.get(rc)+<span class="number">1</span>;</span><br><span class="line">                windows.put(rc,wcount);</span><br><span class="line">                <span class="keyword">int</span> needCount = need.get(rc);</span><br><span class="line">                <span class="keyword">if</span>(wcount == needCount)</span><br><span class="line">                    valid++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若满足条件，则进行窗口的缩小</span></span><br><span class="line">            <span class="keyword">if</span>(right-left&gt;=p.length())&#123;</span><br><span class="line">               <span class="keyword">if</span>(valid == need.size())</span><br><span class="line">                   ans.add(left);</span><br><span class="line">                <span class="keyword">char</span> lc = s.charAt(left);</span><br><span class="line">                left++;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(windows.containsKey(lc))&#123;</span><br><span class="line">                    <span class="keyword">int</span> lcount = windows.get(lc)-<span class="number">1</span>;</span><br><span class="line">                    windows.put(lc,lcount);</span><br><span class="line">                    <span class="keyword">if</span>(lcount == need.get(lc)-<span class="number">1</span>)</span><br><span class="line">                        valid--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 21天刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21天刷题计划（4）二维数组花式遍历技巧</title>
      <link href="/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%884%EF%BC%89%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E8%8A%B1%E5%BC%8F%E9%81%8D%E5%8E%86%E6%8A%80%E5%B7%A7/"/>
      <url>/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%884%EF%BC%89%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E8%8A%B1%E5%BC%8F%E9%81%8D%E5%8E%86%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/10.jpg" alt="10"></p><p><strong>思路整理</strong></p><ol><li>遇到矩阵旋转题目，需要往转置，翻转上去考虑</li><li>需要考虑是逆时针旋转90，还是顺时针旋转90°，因为这个决定矩阵沿着哪条对角线进行转置</li><li>最后沿着中垂线reverse</li></ol><p>总的来说涉及旋转图像就两个操作，先决定以哪个对角线进行转置，最后沿着中垂线reverse反转即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//沿对角线转置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;matrix[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将每一行进行reverse</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">            reverse(matrix[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=arr.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/11.jpg" alt="11"></p><p><strong>思路整理</strong></p><ol><li>本题之前在剑指offer上做过一次，当时自己只用四个for循环，做的效果很不好，拆了东墙补西墙。</li><li>本次借鉴今天学习的思想，设立四个边界，即：<strong>上边界、右边界、下边界、左边界</strong></li><li>注意的时在遍历的过程当中，四个边界的灵活运用以及<strong>状态更新</strong>，以及<strong>利用边界确定遍历范围以及遍历的合法性</strong></li></ol><p>边界定义如下，仔细理解这四个边界的含义！</p><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/12.jpg" alt="12"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//该题目最好的方式就是去圈定4个顶点</span></span><br><span class="line">        List&lt;Integer&gt;ansList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> upperEdge = <span class="number">0</span>,rightEdge = matrix[<span class="number">0</span>].length-<span class="number">1</span>,lowEdge = matrix.length-<span class="number">1</span>,leftEdge = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>; <span class="comment">//记录已经遍历的元素</span></span><br><span class="line">        <span class="keyword">int</span> totalElement = matrix[<span class="number">0</span>].length*matrix.length;</span><br><span class="line">        <span class="keyword">while</span>(res&lt;totalElement)&#123;</span><br><span class="line">            <span class="keyword">if</span>(upperEdge&lt;=lowEdge)&#123; ** <span class="comment">// 遍历的合法性**</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=leftEdge;i&lt;=rightEdge;i++)&#123; ** <span class="comment">//确定遍历范围**</span></span><br><span class="line">                    ansList.add(matrix[upperEdge][i]);</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">                upperEdge++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(rightEdge&gt;=leftEdge)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=upperEdge;i&lt;=lowEdge;i++)&#123;</span><br><span class="line">                    ansList.add(matrix[i][rightEdge]);</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">                rightEdge--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(lowEdge&gt;=upperEdge) &#123;</span><br><span class="line">                 <span class="keyword">for</span>(<span class="keyword">int</span> i=rightEdge;i&gt;=leftEdge;i--)&#123;</span><br><span class="line">                    ansList.add(matrix[lowEdge][i]);</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">                lowEdge--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(leftEdge&lt;=rightEdge)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=lowEdge;i&gt;=upperEdge;i--)&#123;</span><br><span class="line">                ansList.add(matrix[i][leftEdge]);</span><br><span class="line">                res++;</span><br><span class="line">                &#125;</span><br><span class="line">                leftEdge++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ansList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="螺旋矩阵2"><a href="#螺旋矩阵2" class="headerlink" title="螺旋矩阵2"></a>螺旋矩阵2</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/13.jpg" alt="13"></p><p><strong>思路整理</strong></p><ol><li>直接创建一个n*n的矩阵，进行螺旋遍历，遍历的时候，给矩阵进行重新赋值即可</li><li>遍历的方案参照第54题螺旋矩阵的遍历思路，创建4个边界</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span> [][]matrix = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">         <span class="comment">//该题目最好的方式就是去圈定4个顶点</span></span><br><span class="line">        <span class="keyword">int</span> upperEdge = <span class="number">0</span>,rightEdge = matrix[<span class="number">0</span>].length-<span class="number">1</span>,lowEdge = matrix.length-<span class="number">1</span>,leftEdge = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>; <span class="comment">//记录已经遍历的元素</span></span><br><span class="line">        <span class="keyword">int</span> totalElement = matrix[<span class="number">0</span>].length*matrix.length;</span><br><span class="line">        <span class="keyword">while</span>(res&lt;totalElement)&#123;</span><br><span class="line">            <span class="keyword">if</span>(upperEdge&lt;=lowEdge)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=leftEdge;i&lt;=rightEdge;i++)&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    matrix[upperEdge][i] = res;</span><br><span class="line">                &#125;</span><br><span class="line">                upperEdge++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(rightEdge&gt;=leftEdge)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=upperEdge;i&lt;=lowEdge;i++)&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    matrix[i][rightEdge] = res;</span><br><span class="line">                &#125;</span><br><span class="line">                rightEdge--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(lowEdge&gt;=upperEdge) &#123;</span><br><span class="line">                 <span class="keyword">for</span>(<span class="keyword">int</span> i=rightEdge;i&gt;=leftEdge;i--)&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    matrix[lowEdge][i] = res;</span><br><span class="line">                &#125;</span><br><span class="line">                lowEdge--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(leftEdge&lt;=rightEdge)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=lowEdge;i&gt;=upperEdge;i--)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                matrix[i][leftEdge] = res;</span><br><span class="line">                &#125;</span><br><span class="line">                leftEdge++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 21天刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二维数组花式遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21天刷题计划（3）差分数组</title>
      <link href="/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%883%EF%BC%89%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"/>
      <url>/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%883%EF%BC%89%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p><strong>前缀和主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和</strong>。</p><p><strong>差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减</strong></p><h1 id="区间加法"><a href="#区间加法" class="headerlink" title="区间加法"></a>区间加法</h1><p><img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/7.jpg" alt="7"></p><p><strong>思路整理</strong></p><ol><li>对 nums 数组构造一个 diff 差分数组，<strong>diff[i] 就是 nums[i] 和 nums[i-1] 之差：</strong></li><li><strong>diff差分数组是可以反推出原始数组 nums的，res[i] = res[i - 1] + diff[i]</strong>,尤其注意这里，一旦diff[i]+1了，就会对i之后包括i的所有元素产生影响，这是一个串联的过程;</li><li><strong>如果你想对区间 nums[i..j] 的元素全部加3，那么只需要让 diff[i] += 3，然后再让 diff[j+1]-= 3 即可</strong>，这样才能区间操作。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] getModifiedArray(int length, int[][] updates) &#123;</span><br><span class="line">        Difference d = new Difference(length);</span><br><span class="line">        for(int i=0;i&lt;updates.length;i++)&#123;</span><br><span class="line">            </span><br><span class="line">                d.increase(updates[i][0],updates[i][1],updates[i][2]);</span><br><span class="line">        &#125;</span><br><span class="line">         return d.primary();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Difference&#123;</span><br><span class="line">    int []diff;</span><br><span class="line">    public Difference(int length)&#123;</span><br><span class="line">        diff = new int[length];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void increase(int i,int j,int inc)</span><br><span class="line">    &#123;</span><br><span class="line">        this.diff[i] = this.diff[i]+inc;</span><br><span class="line">        if(j+1&lt;diff.length) //这里进行边界判断</span><br><span class="line">            this.diff[j+1] = this.diff[j+1] - inc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int[]primary()&#123;</span><br><span class="line">        int []arr = new int[this.diff.length];</span><br><span class="line">        arr[0] = diff[0];</span><br><span class="line">        for(int i=1;i&lt;this.diff.length;i++)&#123;</span><br><span class="line">            arr[i] = arr[i-1] + diff[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="航班预订统计"><a href="#航班预订统计" class="headerlink" title="航班预订统计"></a>航班预订统计</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/8.jpg" alt="8"></p><p><strong>差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。</strong></p><ol><li>对 nums 数组构造一个 diff 差分数组，diff[i] 就是 nums[i] 和 nums[i-1] 之差：</li><li>diff差分数组是可以反推出原始数组 nums的，res[i] = res[i - 1] + diff[i],尤其注意这里，一旦diff[i]+1了，就会对i之后包括i的所有元素产生影响，这是一个串联的过程;</li><li>如果你想对区间 nums[i..j] 的元素全部加3，那么只需要让 diff[i] += 3，然后再让 diff[j+1]-= 3 即可，这样才能区间操作。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] corpFlightBookings(<span class="keyword">int</span>[][] bookings, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        Difference d =  <span class="keyword">new</span> Difference(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bookings.length;i++)&#123;</span><br><span class="line">            d.increase(bookings[i][<span class="number">0</span>]-<span class="number">1</span>,bookings[i][<span class="number">1</span>]-<span class="number">1</span>,bookings[i][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d.primary();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Difference</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> []diff;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Difference</span><span class="params">(<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        diff = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> inc)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.diff[i] = <span class="keyword">this</span>.diff[i]+inc;</span><br><span class="line">        <span class="keyword">if</span>(j+<span class="number">1</span>&lt;diff.length)</span><br><span class="line">            <span class="keyword">this</span>.diff[j+<span class="number">1</span>] = <span class="keyword">this</span>.diff[j+<span class="number">1</span>] - inc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[]primary()&#123;</span><br><span class="line">        <span class="keyword">int</span> []arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.diff.length];</span><br><span class="line">        arr[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="keyword">this</span>.diff.length;i++)&#123;</span><br><span class="line">            arr[i] = arr[i-<span class="number">1</span>] + diff[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="拼车"><a href="#拼车" class="headerlink" title="拼车"></a>拼车</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/9.jpg" alt="9"></p><p><strong>思路整理：</strong></p><ol><li><strong>计算出每个时刻车子上的人数，最终比较即可</strong></li><li>由于<strong>场景是频繁对原始数组的某个区间的元素进行增减，所以这里利用差分数组</strong></li><li><strong>由于先下后上原则，所以我们在trips[i][2]-1位置进行下车操作，保证了trips[i][2]位子的容量</strong></li><li>最终遍历每个时刻乘客数量最大值与capability比较即可</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">carPooling</span><span class="params">(<span class="keyword">int</span>[][] trips, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;trips.length;i++)&#123;</span><br><span class="line">            <span class="comment">//遍出区间长度的最大值，当然这里题目给出了最大值为1000，所以我们也可以直接令length = 1001</span></span><br><span class="line">            length = Math.max(length,trips[i][<span class="number">2</span>]); </span><br><span class="line">        &#125;</span><br><span class="line">        Difference d = <span class="keyword">new</span> Difference(length);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;trips.length;i++)&#123;</span><br><span class="line">            d.increase(trips[i][<span class="number">1</span>],trips[i][<span class="number">2</span>]-<span class="number">1</span>,trips[i][<span class="number">0</span>]);  <span class="comment">//注意传入的trips[i][2]-1，表示trips[i][2]已下车。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> []num_passengers = d.primary();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num_passengers.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num_passengers[i]&gt;capacity)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Difference</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> []diff;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Difference</span><span class="params">(<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        diff = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> inc)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.diff[i] = <span class="keyword">this</span>.diff[i]+inc;</span><br><span class="line">        <span class="keyword">if</span>(j+<span class="number">1</span>&lt;diff.length)</span><br><span class="line">            <span class="keyword">this</span>.diff[j+<span class="number">1</span>] = <span class="keyword">this</span>.diff[j+<span class="number">1</span>] - inc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[]primary()&#123;</span><br><span class="line">        <span class="keyword">int</span> []arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.diff.length];</span><br><span class="line">        arr[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="keyword">this</span>.diff.length;i++)&#123;</span><br><span class="line">            arr[i] = arr[i-<span class="number">1</span>] + diff[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 21天刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 差分数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21天刷题计划（2）前缀和数组技巧</title>
      <link href="/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%882%EF%BC%89%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84%E6%8A%80%E5%B7%A7/"/>
      <url>/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%882%EF%BC%89%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303. 区域和检索 - 数组不可变"></a>303. 区域和检索 - 数组不可变</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/4.jpg" alt="4"></p><p><strong>思路整理</strong></p><ol><li>新建一个数组，这个数组要多建立一维，方便我们的边界处理，每个位置存放前i个数的和</li><li>区间和为preSum[right+1] - preSum[left]</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前缀和数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] preSum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 输入一个数组，构造前缀和 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// preSum[0] = 0，便于计算累加和</span></span><br><span class="line">        preSum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 计算 nums 的累加和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; preSum.length; i++) &#123;</span><br><span class="line">            preSum[i] = preSum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 查询闭区间 [left, right] 的累加和 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> preSum[right + <span class="number">1</span>] - preSum[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二维区域和检索-矩阵不可变"><a href="#二维区域和检索-矩阵不可变" class="headerlink" title="二维区域和检索 - 矩阵不可变"></a>二维区域和检索 - 矩阵不可变</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/5.jpg" alt="5"></p><p><strong>思路总结</strong></p><ol><li><strong>就像是一个求面积的问题，多退少补</strong></li><li>preSum的定义很有讲究，如果不多加一个维度进行辅助，会导致面积加减很不方便，还要考虑有没有多减的问题</li><li><strong>以后遇到前缀和的问题，辅助数组就多定义一维</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> [][] preSum;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.preSum = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length+<span class="number">1</span>][matrix[<span class="number">0</span>].length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;preSum.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;preSum[<span class="number">0</span>].length;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                preSum[i][j] = preSum[i-<span class="number">1</span>][j] + preSum[i][j-<span class="number">1</span>] - preSum[i-<span class="number">1</span>][j-<span class="number">1</span>] + matrix[i-<span class="number">1</span>][j-<span class="number">1</span>]; <span class="comment">//构造前缀和，往面积上去想，多退少补</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> preSum[row2+<span class="number">1</span>][col2+<span class="number">1</span>] - preSum[row2+<span class="number">1</span>][col1] - preSum[row1][col2+<span class="number">1</span>] + preSum[row1][col1]; <span class="comment">//多退少补</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="和为K的子数组"><a href="#和为K的子数组" class="headerlink" title="和为K的子数组"></a>和为K的子数组</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/6.jpg" alt="6"></p><p><strong>思路总结：</strong></p><ol><li>如果计算出前缀和之后，暴力寻找的话，时间复杂度上升</li><li>通过公式<strong>变换 preSum[i] - preSum[j] = k 转化为寻找preSum[j] = preSum[i] - k</strong></li><li>由于preSum[j] j是小于i的，所以j位置的前缀和肯定已经被计算过了</li><li><strong>通过Hashmap记录之前已经出现过的前缀和，和为key,次数为value</strong></li><li><strong>这样我们在一次遍历当中就可以找出answer</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []preSum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>];</span><br><span class="line">        HashMap &lt;Integer,Integer&gt;map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//注 ： 这里的空间复杂度还可以优化，这里每次只用到 preSum[i-1] 与 preSum[i],所以可以直接利用两个临时变量代替即可</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;preSum.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            preSum[i] = preSum[i-<span class="number">1</span>] + nums[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> find = preSum[i] - k;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(find))</span><br><span class="line">            &#123;</span><br><span class="line">                ans += map.get(find);</span><br><span class="line">            &#125;</span><br><span class="line">                  map.put(preSum[i],map.getOrDefault(preSum[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>前缀和数组的维度要比原数组多定义一维，方便我们进行边界处理</li><li>要注意问题转化，尤其是和为K的子数组，利用hashmap在一次遍历中，就可以得到答案！</li></ul>]]></content>
      
      
      <categories>
          
          <category> 21天刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21天刷题计划（1）单链表解题技巧</title>
      <link href="/2022/03/21/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%881%EF%BC%89%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/"/>
      <url>/2022/03/21/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%881%EF%BC%89%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="21天刷题计划（1）单链表解题技巧"><a href="#21天刷题计划（1）单链表解题技巧" class="headerlink" title="21天刷题计划（1）单链表解题技巧"></a>21天刷题计划（1）单链表解题技巧</h1><h1 id="合并K个升序链表"><a href="#合并K个升序链表" class="headerlink" title="合并K个升序链表"></a>合并K个升序链表</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/1.jpg" alt="1"></p><p>本题中的k数目很大，如果使用暴力方法直接去接，复杂度肯定无法通过所有测试！<strong>使用优先队列，优先队列向上、向下调整元素的时间复杂度是logN。</strong></p><p><strong>解题思路梳理</strong>：</p><ol><li><p>首先做一些basecase的判断，比如是否有空链表等，将lists中每个链表头节点加入最小堆优先队列，</p></li><li><p>通过while循环，每次取出头节点数值最小的，将取出的头节点加入到我们的dummy链表中，其中temp为其临时遍历节点。</p></li><li><p>将取出的最小头节点加入到我们的新建链表中后，我们需要判断最小头节点的next是否为空，若不为空，我们将head.next继续加入到最小堆优先队列中。</p></li><li><p>while循环的结束条件是优先队列是否为空！</p><p><strong>关键词</strong>：<strong>最小堆、优先队列元素节点为链表头节点</strong></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> len = lists.length;</span><br><span class="line">          <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Comparator&lt;ListNode&gt; cmp = <span class="keyword">new</span> Comparator&lt;ListNode&gt;() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ListNode a, ListNode b)</span> </span>&#123; <span class="comment">//这里是小根堆</span></span><br><span class="line"><span class="keyword">return</span> a.val - b.val; <span class="comment">//第一键值做参考</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">        PriorityQueue&lt;ListNode&gt;priQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(lists.length,cmp);</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//将k个链表的头节点加入优先队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(lists[i] != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                priQueue.add(lists[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode temp = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!priQueue.isEmpty())&#123;</span><br><span class="line">            ListNode head = priQueue.poll();</span><br><span class="line">            temp.next = head;</span><br><span class="line">            head = head.next;</span><br><span class="line">            <span class="keyword">if</span>(head!=<span class="keyword">null</span>)</span><br><span class="line">                priQueue.add(head);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/2.jpg" alt="2"></p><p><strong>解决这个问题的关键是，通过某些方式，让 p1 和 p2 能够同时到达相交节点 c1</strong></p><p>两种思路：</p><ol><li>我们可以让 p1 遍历完链表 A 之后开始遍历链表 B，让 p2 遍历完链表 B 之后开始遍历链表 A</li><li>我们可以让 p1 p2 同时遍历，若p1先遍历完，就让p2剩余的遍历次数k，使得temp2移动k次，这样temp1与temp2就处在同一起跑线<br><strong>显然第一种思路更为巧妙简单</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//labuladong优美解法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode p1 = headA;</span><br><span class="line">        ListNode p2 = headB;</span><br><span class="line">        <span class="keyword">while</span>(p1!=p2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1 != <span class="keyword">null</span>)</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p1 = headB;</span><br><span class="line">            <span class="keyword">if</span>(p2 != <span class="keyword">null</span>)</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                p2 = headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我个人写的代码，冗杂很多！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       ListNode tempA = headA;</span><br><span class="line">       ListNode tempB = headB;</span><br><span class="line">       <span class="keyword">while</span>(tempA != <span class="keyword">null</span> &amp;&amp; tempB!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           tempA = tempA.next;</span><br><span class="line">           tempB = tempB.next;</span><br><span class="line">       &#125;</span><br><span class="line">       ListNode temp1 = headA;</span><br><span class="line">       ListNode temp2 = headB;</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">if</span>(tempA == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">while</span>(tempB != <span class="keyword">null</span>)&#123;</span><br><span class="line">               tempB = tempB.next;</span><br><span class="line">               temp2 = temp2.next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(tempB == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">while</span>(tempA != <span class="keyword">null</span>)&#123;</span><br><span class="line">               tempA = tempA.next;</span><br><span class="line">               temp1 = temp1.next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(temp1!=<span class="keyword">null</span> &amp;&amp; temp2!= <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(temp1 == temp2)</span><br><span class="line">               <span class="keyword">return</span> temp1;</span><br><span class="line">           temp1 = temp1.next;</span><br><span class="line">           temp2 = temp2.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/3.jpg" alt="3"></p><p><strong>对于链表题，最常用的就是双指针的技巧了。</strong>比如找链表中点、倒数第k个节点。找倒数第K个节点的思路是让快指针先走K步，然后然两个指针一起走，一直到链表末尾！这样慢指针便是倒数第K个节点。</p><p>对于本题解题思路：</p><p><strong>我的思路</strong></p><ol><li>找出倒数第k个节点</li><li>找出倒数第K+1节点<br>实在是没必要，添加了很多不必要的代码。</li></ol><p><strong>东哥思路</strong></p><ol><li><strong>添加一个虚拟头节点节点dummy</strong> (<strong>这里的添加虚拟头节点，十分有必要，尤其涉及到链表的插入删除，虚拟头节点的作用非常大，节省了很多不必要的代码量</strong>)</li><li>直接利用模板找出倒数第k+1个节点</li><li>删除后，返回dummy.next</li></ol><p>该思路确实整洁巧妙，虚拟节点的作用也十分明显，就算是倒数第K个节点在头节点的位置，也可以直接找出倒数K+1个节点，此时的倒数k+1节点正是dummy~</p><p>东哥代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 虚拟头结点</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="comment">// 删除倒数第 n 个，要先找倒数第 n + 1 个节点</span></span><br><span class="line">    ListNode x = findFromEnd(dummy, n + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 删掉倒数第 n 个节点</span></span><br><span class="line">    x.next = x.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回链表的倒数第 k 个节点</span></span><br><span class="line"><span class="function">ListNode <span class="title">findFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode p1 = head;</span><br><span class="line">    <span class="comment">// p1 先走 k 步</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode p2 = head;</span><br><span class="line">    <span class="comment">// p1 和 p2 同时走 n - k 步</span></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p2 现在指向第 n - k 个节点</span></span><br><span class="line">    <span class="keyword">return</span> p2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>我的代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode p1 = head;</span><br><span class="line">    ListNode p2 = head;</span><br><span class="line">    ListNode p3 = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1 != head)</span><br><span class="line">            p3 = p3.next;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p1 == head)</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    p3.next = p1.next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 21天刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker基础命令学习</title>
      <link href="/2022/03/21/Docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/03/21/Docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-简介"><a href="#Docker-简介" class="headerlink" title="Docker 简介"></a>Docker 简介</h1><p>我在云服务器安装docker，是按照docker官网的说明进行安装的。</p><p>1.传统虚拟机，虚拟出硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件。</p><p>2.Docker容器内的应用直接运行在宿主机的内容，容器是没有自己的内核的，也没有虚拟硬件。</p><p>3.每个容器都是相互隔离的，每个容器都有属于自己的文件系统，互不影响。</p><p><img src="/articleImg/60_article/1.jpg" alt="1"></p><h1 id="Docker基础命令"><a href="#Docker基础命令" class="headerlink" title="Docker基础命令"></a>Docker基础命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker version          #查看docker的版本信息</span><br><span class="line">docker info             #查看docker的系统信息,包括镜像和容器的数量</span><br><span class="line">docker 命令 --help       #帮助命令(可查看可选的参数)</span><br><span class="line">docker COMMAND --help</span><br></pre></td></tr></table></figure><h1 id="Docker镜像命令"><a href="#Docker镜像命令" class="headerlink" title="Docker镜像命令"></a>Docker镜像命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker images # 查看本地主机的所有镜像</span><br><span class="line">docker search 镜像名 # 搜索镜像</span><br><span class="line">docker pull 镜像名[:tag] # 下载镜像 []表示可选参数</span><br><span class="line">docker rmi -f 镜像名 #删除镜像 -f强制删除</span><br></pre></td></tr></table></figure><h1 id="Docker-容器命令"><a href="#Docker-容器命令" class="headerlink" title="Docker 容器命令"></a>Docker 容器命令</h1><p>切记：必须先有镜像，才能运行容器。（打个比喻：镜像就像是软件安装包.apk, 在容器中运行，相当于安装APP）</p><h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos # 拉取centos镜像</span><br><span class="line"><span class="meta">#</span><span class="bash"> 有了镜像之后，我们可以开始运行容器</span></span><br><span class="line">docker run [可选参数] image</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">参数说明</span></span><br><span class="line">--name=&quot;名字&quot;           #指定容器名字</span><br><span class="line">-d                     #后台方式运行</span><br><span class="line">-it                    #使用交互方式运行,进入容器查看内容</span><br><span class="line">-p ip:主机端口:容器端口   #配置主机端口映射到容器端口</span><br></pre></td></tr></table></figure><h2 id="例如运行并进入容器centos"><a href="#例如运行并进入容器centos" class="headerlink" title="例如运行并进入容器centos"></a>例如运行并进入容器centos</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -it centos /bin/bash</span><br><span class="line">exit #退出容器命令</span><br><span class="line">ctrl+p+q #退出容器，容器仍在后台运行</span><br></pre></td></tr></table></figure><h2 id="列出运行过的容器命令"><a href="#列出运行过的容器命令" class="headerlink" title="列出运行过的容器命令"></a>列出运行过的容器命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker ps </span><br><span class="line">-a   # 列出所有容器的运行记录</span><br><span class="line">-n=? # 显示最近创建的n个容器</span><br><span class="line">-q   # 只显示容器的编号</span><br></pre></td></tr></table></figure><h2 id="删除容器命令"><a href="#删除容器命令" class="headerlink" title="删除容器命令"></a>删除容器命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器id                 #删除指定的容器,不能删除正在运行的容器,强制删除使用 rm -f</span><br><span class="line">docker rm -f $(docker ps -aq)   #删除所有的容器</span><br><span class="line">docker ps -a -q|xargs docker rm #删除所有的容器</span><br></pre></td></tr></table></figure><h2 id="启动和停止容器命令"><a href="#启动和停止容器命令" class="headerlink" title="启动和停止容器命令"></a>启动和停止容器命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器id          #启动容器</span><br><span class="line">docker restart 容器id        #重启容器</span><br><span class="line">docker stop 容器id           #停止当前运行的容器</span><br><span class="line">docker kill 容器id           #强制停止当前容器</span><br></pre></td></tr></table></figure><h1 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h1><h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker logs -tf 容器id           </span><br><span class="line">docker logs --tail number 容器id #num为要显示的日志条数  </span><br></pre></td></tr></table></figure><h2 id="查看容器中进程信息"><a href="#查看容器中进程信息" class="headerlink" title="查看容器中进程信息"></a>查看容器中进程信息</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top c703b5b1911f  </span><br></pre></td></tr></table></figure><h2 id="查看容器的元数据"><a href="#查看容器的元数据" class="headerlink" title="查看容器的元数据"></a>查看容器的元数据</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器id</span><br></pre></td></tr></table></figure><h2 id="进入当前正在运行的容器"><a href="#进入当前正在运行的容器" class="headerlink" title="进入当前正在运行的容器"></a>进入当前正在运行的容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it c703b5b1911f /bin/bash # 在容器中新开一个终端</span><br><span class="line">docker attach c703b5b1911f # 进入容器之前的终端</span><br></pre></td></tr></table></figure><h1 id="dockers命令图及命令小结"><a href="#dockers命令图及命令小结" class="headerlink" title="dockers命令图及命令小结"></a>dockers命令图及命令小结</h1><p><img src="/articleImg/60_article/2.jpg" alt="2"></p><p>​       命令下方是对该命令的中文解释</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">attach    Attach to a running container</span><br><span class="line"><span class="meta">#</span><span class="bash">当前she1l 下attach连接指定运行镜像</span></span><br><span class="line">build     Build an image from a Dockerfile</span><br><span class="line"><span class="meta">#</span><span class="bash">通过 Dockerfile定制镜像</span></span><br><span class="line">commit    Create a new image from a container changes</span><br><span class="line"><span class="meta">#</span><span class="bash">提交当前容器为新的镜像</span></span><br><span class="line">cp        copy files/fo lders from the containers filesystem to the host path</span><br><span class="line"><span class="meta">#</span><span class="bash">从容器中拷贝指定文件或者目录到宿主机中</span></span><br><span class="line">create    Create a new container</span><br><span class="line"><span class="meta">#</span><span class="bash">创建一个新的容器，同run，但不启动容器</span></span><br><span class="line">diff      Inspect changes on a container&#x27;s filesystem</span><br><span class="line"><span class="meta">#</span><span class="bash">查看docker容器变化</span></span><br><span class="line">events    Get real time events from the server</span><br><span class="line"><span class="meta">#</span><span class="bash">从docker服务获取容器实时事件</span></span><br><span class="line">exec      Run a command in an existing container</span><br><span class="line"><span class="meta">#</span><span class="bash">  在已存在的容器上运行命令</span></span><br><span class="line">export    Stream the contents of a container as a tar anchive</span><br><span class="line"><span class="meta">#</span><span class="bash">导出容器的内容流作为一个 tar归档文件[对应import]</span></span><br><span class="line">history   show the history of an image</span><br><span class="line"><span class="meta">#</span><span class="bash">展示一个镜像形成历史</span></span><br><span class="line">images    List images</span><br><span class="line"><span class="meta">#</span><span class="bash">列出系统当前镜像</span></span><br><span class="line">import    create a new filesystem image from the contents of a tarball </span><br><span class="line"><span class="meta">#</span><span class="bash">从tar包中的内容创建一个新的文件系统映像[对应<span class="built_in">export</span>]</span></span><br><span class="line">info      Display system-wide information</span><br><span class="line"><span class="meta">#</span><span class="bash">显示系统相关信息</span></span><br><span class="line">inspect   Return low-1evel information on a container</span><br><span class="line"><span class="meta">#</span><span class="bash">查看容器详细信息</span></span><br><span class="line">kill      Kill a running container</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">kill</span>指定docker容器</span></span><br><span class="line">1oad      Load an image from a tar archive</span><br><span class="line"><span class="meta">#</span><span class="bash">从一个tar 包中加载一个镜像[对应save]</span></span><br><span class="line">login     Register or Login to the docker registry server</span><br><span class="line"><span class="meta">#</span><span class="bash">注册或者登陆一个docker源服务器</span></span><br><span class="line">1ogout    Log out from a Docker registry server</span><br><span class="line"><span class="meta">#</span><span class="bash">从当前 Docker registry退出</span></span><br><span class="line">logs      Fetch the logs of a container</span><br><span class="line"><span class="meta">#</span><span class="bash">输出当前容器日志信息</span></span><br><span class="line">port      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT</span><br><span class="line"><span class="meta">#</span><span class="bash">查看映射端口对应的容器内部源端口</span></span><br><span class="line">pause     Pause a11 processes within a container</span><br><span class="line"><span class="meta">#</span><span class="bash">暂停容器</span></span><br><span class="line">ps        List containers</span><br><span class="line"><span class="meta">#</span><span class="bash">列出容器列表</span></span><br><span class="line">pu11      Pu1l an image or a repository from the docker registry server#从docker镜像源服务器拉取指定镜像或者库镜像</span><br><span class="line">push      Push an image or a repository to the docker registry server#推送指定镜像或者库镜像至docker源服务器</span><br><span class="line">restart   Restart a running container</span><br><span class="line"><span class="meta">#</span><span class="bash">重启运行的容器</span></span><br><span class="line">rm        Remove one or more containers</span><br><span class="line"><span class="meta">#</span><span class="bash">移除一个或者多个容器</span></span><br><span class="line">rmi       Remove one or more images</span><br><span class="line"><span class="meta">#</span><span class="bash">移除一个或多个镜像[无容器使用该镜像才可刷除，否则需删除相关容器才可继续或-f强制制除]</span></span><br><span class="line">run       Run a command in a new container</span><br><span class="line"><span class="meta">#</span><span class="bash">创建一个新的容器并运行一个命令</span></span><br><span class="line">save      save an image to a tar archive</span><br><span class="line"><span class="meta">#</span><span class="bash">保存一个镜像为一个tar包[对应1oad]</span></span><br><span class="line">search    Search for an image on the Docker Hub</span><br><span class="line"><span class="meta">#</span><span class="bash">在docker hub中搜素镜像</span></span><br><span class="line">start     start a stopped containers</span><br><span class="line"><span class="meta">#</span><span class="bash">启动容器</span></span><br><span class="line">stop      stop a running containers</span><br><span class="line"><span class="meta">#</span><span class="bash">停止容器</span></span><br><span class="line">tag       Tag an image into a repository</span><br><span class="line"><span class="meta">#</span><span class="bash">结源中镜像打标签</span></span><br><span class="line">top       Lookup the running processes of a container</span><br><span class="line"><span class="meta">#</span><span class="bash">查看容器中运行的进程信息</span></span><br><span class="line">unpause   Unpause a paused container</span><br><span class="line"><span class="meta">#</span><span class="bash">取消暂停容器</span></span><br><span class="line">version   show the docker version information</span><br><span class="line"><span class="meta">#</span><span class="bash">查看docker版本号</span></span><br><span class="line">wait      Block until a container stops，then print its exit code</span><br><span class="line"><span class="meta">#</span><span class="bash">截取容器停止时的退出状态值</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker基础命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String与StringBuilder常用方法总结</title>
      <link href="/2022/03/20/String%E4%B8%8EStringBuilder%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2022/03/20/String%E4%B8%8EStringBuilder%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="String-与StringBuilder常用方法总结"><a href="#String-与StringBuilder常用方法总结" class="headerlink" title="String 与StringBuilder常用方法总结"></a>String 与StringBuilder常用方法总结</h1><p>本周末参加了leetcode的双周赛和周赛，都只是answer了两道题目，自己还算满意吧，毕竟是第一次参加。进步空间还是很大的！在参加比赛的时候，我因为String和StringBuilder的不熟练，导致我在作答题目的时候，耽误了很多时间，写了很多冗余代码，在这里我将这二者的常用方法进行简介！</p><h1 id="二者简介"><a href="#二者简介" class="headerlink" title="二者简介"></a>二者简介</h1><p>在java中String类不可变的，创建一个String对象后不能更改它的值。所以如果需要对原字符串进行一些改动操作，就需要用StringBuilder类或者StringBuffer类，StringBuilder比StringBuffer更快一些，缺点是StringBuilder不是线程安全的，但在算法竞赛中一般我们用不到多线程。所以，主要推荐使用StringBuilder类。</p><h1 id="String类常用方法"><a href="#String类常用方法" class="headerlink" title="String类常用方法"></a>String类常用方法</h1><h3 id="String遍历"><a href="#String遍历" class="headerlink" title="String遍历"></a>String遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String有两种遍历方式，第一种charAt()方法</span><br><span class="line">第二种是先转化为字符数组，再挨个遍历</span><br><span class="line">charAt(<span class="keyword">int</span> i);<span class="comment">//返回索引i处的字符</span></span><br><span class="line">length();<span class="comment">//返回此字符串的长度</span></span><br><span class="line">isEmpty();<span class="comment">//判空 当length()为0时返回true</span></span><br></pre></td></tr></table></figure><h3 id="String转字符数组"><a href="#String转字符数组" class="headerlink" title="String转字符数组"></a>String转字符数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] s1 = <span class="keyword">new</span> <span class="keyword">char</span>[s.length()];  <span class="comment">//这里的字符数组大小要注意</span></span><br><span class="line">s1 = s.toCharArray();</span><br></pre></td></tr></table></figure><h3 id="String间的比较"><a href="#String间的比较" class="headerlink" title="String间的比较"></a>String间的比较</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">切记不能使用 == ,这个会比较内存地址</span><br><span class="line">常用的是：</span><br><span class="line">equals(String anotherString)<span class="comment">//判断两个字符串是否相等，相等返回true否则返回false</span></span><br><span class="line">equalsIgnoreCase(String str)<span class="comment">//同上，不区分大小写。</span></span><br></pre></td></tr></table></figure><h3 id="String检索字串"><a href="#String检索字串" class="headerlink" title="String检索字串"></a>String检索字串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一次出现的位置</span></span><br><span class="line">indexOf(<span class="keyword">int</span> ch);<span class="comment">// 返回指定字符在此字符串中第一次出现的索引</span></span><br><span class="line">indexOf(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromindex); <span class="comment">// 同上， 从指定索引开始搜索</span></span><br><span class="line">indexOf(String str);<span class="comment">//返回子串在此字符串中第一次出现的索引</span></span><br><span class="line">indexOf(String str, <span class="keyword">int</span> fromindex);同上，从指定索引开始搜索</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后一次出现的位置索引</span></span><br><span class="line">lastIndexOf(<span class="keyword">int</span> ch);<span class="comment">//返回指定字符在此字符串最后一次出现的索引</span></span><br><span class="line">lastIndexOf(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromindex);<span class="comment">//同上， 从指定索引开始搜索</span></span><br><span class="line">lastIndexOf(String str);<span class="comment">//返回子串在此字符串最后一次出现的索引</span></span><br><span class="line">lastIndexOf(String str, <span class="keyword">int</span> fromindex);<span class="comment">//同上， 从指定索引开始搜索</span></span><br><span class="line"></span><br><span class="line">以上如果不存在，均返回 -<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="String字符串拆分"><a href="#String字符串拆分" class="headerlink" title="String字符串拆分"></a>String字符串拆分</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">split(String regex); <span class="comment">// 根据正则表达式拆分</span></span><br><span class="line">String s = <span class="string">&quot;ABC DEF&quot;</span>;</span><br><span class="line">String s1[] = s.split(<span class="string">&quot; &quot;</span>);<span class="comment">//根据空格拆分，这里也要注意要使用字符串数组进行接收</span></span><br><span class="line">System.out.println(s1[<span class="number">0</span>]);<span class="comment">// ABC</span></span><br><span class="line">System.out.println(s1[<span class="number">1</span>]);<span class="comment">// DEF</span></span><br></pre></td></tr></table></figure><h3 id="String提取子字符串"><a href="#String提取子字符串" class="headerlink" title="String提取子字符串"></a>String提取子字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">substring(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)；<span class="comment">//返回从begin开始到end结束的子串 ，不包含endIndex</span></span><br><span class="line">substring(<span class="keyword">int</span> beginIndex)； <span class="comment">//返回从起始位置（beginIndex）至字符串末尾的字符串</span></span><br></pre></td></tr></table></figure><h3 id="String转化大小写"><a href="#String转化大小写" class="headerlink" title="String转化大小写"></a>String转化大小写</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">toUpperCase(); <span class="comment">//将此字符串中的所有字母都换为大写</span></span><br><span class="line">toLowerCase()<span class="comment">//将此字符串中的所有字母都换为小写</span></span><br></pre></td></tr></table></figure><h3 id="将其他类型数据转化为String"><a href="#将其他类型数据转化为String" class="headerlink" title="将其他类型数据转化为String"></a>将其他类型数据转化为String</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">valueOf(<span class="keyword">char</span>[] data);<span class="comment">//返回 char数组的字符串表示形式</span></span><br><span class="line">valueOf(<span class="keyword">char</span>[] data,<span class="keyword">int</span> offset, <span class="keyword">int</span> count)<span class="comment">//返回 char 数组参数的特定子数组的字符串表示形式。</span></span><br><span class="line">valueOf(<span class="keyword">int</span> i);<span class="comment">//返回 int 参数的字符串表示形式。</span></span><br></pre></td></tr></table></figure><h1 id="StringBuilder常用方法"><a href="#StringBuilder常用方法" class="headerlink" title="StringBuilder常用方法"></a>StringBuilder常用方法</h1><p>一个可变的字符序列</p><h3 id="StringBuilder构造方法"><a href="#StringBuilder构造方法" class="headerlink" title="StringBuilder构造方法"></a>StringBuilder构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder();<span class="comment">//构建一个空的可变字符串。</span></span><br><span class="line">StringBuilder(String str);<span class="comment">//构建一个值为str的可变字符串。</span></span><br></pre></td></tr></table></figure><h3 id="StringBuilder转String"><a href="#StringBuilder转String" class="headerlink" title="StringBuilder转String"></a>StringBuilder转String</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toString(); //返回一个与构建起或缓冲器内容相同的字符串</span><br></pre></td></tr></table></figure><h3 id="StringBuilder遍历"><a href="#StringBuilder遍历" class="headerlink" title="StringBuilder遍历"></a>StringBuilder遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用下面两个方法即可完成遍历</span></span><br><span class="line">charAt(<span class="keyword">int</span> i);<span class="comment">// 返回索引i位置的字符</span></span><br><span class="line">length();<span class="comment">//返回此字符串的长度</span></span><br></pre></td></tr></table></figure><h3 id="StringBuilder增加和插入字符"><a href="#StringBuilder增加和插入字符" class="headerlink" title="StringBuilder增加和插入字符"></a>StringBuilder增加和插入字符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加字符</span></span><br><span class="line">append(String str);<span class="comment">//在此字符串追加str。</span></span><br><span class="line">append(StringBuilder str);<span class="comment">//在此字符串追加str。</span></span><br><span class="line">append(<span class="keyword">char</span>[] str, <span class="keyword">int</span> offset, <span class="keyword">int</span> len);<span class="comment">//将char的子数组追加到此字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//insert字符</span></span><br><span class="line">insert(<span class="keyword">int</span> offset, String str);<span class="comment">//一定要注意是在该位置之前插入</span></span><br><span class="line">insert(<span class="keyword">int</span> offset, Char c)；<span class="comment">//在指定位置**之前**插入字符(串)</span></span><br></pre></td></tr></table></figure><h3 id="StringBuilder删除字符"><a href="#StringBuilder删除字符" class="headerlink" title="StringBuilder删除字符"></a>StringBuilder删除字符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete(<span class="keyword">int</span> start, <span class="keyword">int</span> end);<span class="comment">//移除此序列从start到end-1的字符串</span></span><br><span class="line">deleteCharAt(<span class="keyword">int</span> index);<span class="comment">//移除指定索引上的char</span></span><br></pre></td></tr></table></figure><h3 id="StringBuilder修改字符"><a href="#StringBuilder修改字符" class="headerlink" title="StringBuilder修改字符"></a>StringBuilder修改字符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setCharAt(<span class="keyword">int</span> index, <span class="keyword">char</span> ch);<span class="comment">//将指定索引处的字符替换为ch</span></span><br></pre></td></tr></table></figure><h3 id="StringBuilder字符串查找"><a href="#StringBuilder字符串查找" class="headerlink" title="StringBuilder字符串查找"></a>StringBuilder字符串查找</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">indexOf(String str);<span class="comment">//返回子字符串第一次出现的索引</span></span><br><span class="line">indexOf(String str, <span class="keyword">int</span> fromIndex);<span class="comment">//同上，从指定位置查找</span></span><br><span class="line"></span><br><span class="line">lastIndexOf(String str);<span class="comment">//返回子字符串最后一次出现的索引</span></span><br><span class="line">lastIndexOf(String str, <span class="keyword">int</span> fromIndex);<span class="comment">//同上，从指定位置查找</span></span><br></pre></td></tr></table></figure><h3 id="StringBuilder反转"><a href="#StringBuilder反转" class="headerlink" title="StringBuilder反转"></a>StringBuilder反转</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reverse();<span class="comment">//将此字符串反转</span></span><br></pre></td></tr></table></figure><h3 id="StringBuilder截取"><a href="#StringBuilder截取" class="headerlink" title="StringBuilder截取"></a>StringBuilder截取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">substring(<span class="keyword">int</span> start);<span class="comment">//返回此字符串从start开始至结束的String</span></span><br><span class="line">substring(<span class="keyword">int</span> start, <span class="keyword">int</span> end);<span class="comment">//返回此字符串从start开始至end结束的String</span></span><br><span class="line">toString();<span class="comment">//返回此序列中的String表示形式。</span></span><br><span class="line">(注意以上方法的返回值都是String而不是StringBuilder)</span><br></pre></td></tr></table></figure><p>本次周赛最终采用的字符串操作方案：将String利用toCharArray转化为char[],然后对字符数组进行原地的修改、遍历操作。如果涉及到字符的插入删除，那么还是使用StringBuilder的相关API比较方便！</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云服务器练习Linux</title>
      <link href="/2022/03/20/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%83%E4%B9%A0Linux/"/>
      <url>/2022/03/20/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%83%E4%B9%A0Linux/</url>
      
        <content type="html"><![CDATA[<h1 id="linux-基础-一切皆文件"><a href="#linux-基础-一切皆文件" class="headerlink" title="linux 基础-一切皆文件"></a>linux 基础-一切皆文件</h1><p>今天购置了一台阿里云服务器，并在上面进行了一些基础练习</p><p><img src="/articleImg/59_article/5.jpg" alt="5"></p><h2 id="软连接与硬链接"><a href="#软连接与硬链接" class="headerlink" title="软连接与硬链接"></a>软连接与硬链接</h2><p>硬链接 ：<strong>相当于是程序语言中多开辟一个指针指向文件</strong>。删除源文件后，硬连接仍然可以访问。<strong>尤其注意这个和文件的复制不是一个概念！</strong></p><p>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p><p>软连接：相当于Windows下的快捷方式，删除源文件，快捷方式也访问不了。</p><p> <img src="/articleImg/59_article/1.jpg" alt="1"></p><h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df -h 列出文件系统的整体磁盘使用量</span><br><span class="line">du -a 检查磁盘空间使用量</span><br></pre></td></tr></table></figure><p> <img src="/articleImg/59_article/2.jpg" alt="2"></p><h3 id="挂载（我遇到的几乎都是自动挂载设备）"><a href="#挂载（我遇到的几乎都是自动挂载设备）" class="headerlink" title="挂载（我遇到的几乎都是自动挂载设备）"></a>挂载（我遇到的几乎都是自动挂载设备）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 装置文件名 挂载点</span><br><span class="line">mount /dev/hdc6 /mnt/hdc6</span><br></pre></td></tr></table></figure><h3 id="卸除"><a href="#卸除" class="headerlink" title="卸除"></a>卸除</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">umount [-fn] 装置文件名或挂载点</span><br><span class="line">umount /dev/hdc6</span><br></pre></td></tr></table></figure><h2 id="进程查看"><a href="#进程查看" class="headerlink" title="进程查看"></a>进程查看</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -aux  # 查看所有进程</span><br><span class="line">ps -aux|grep mysql #过滤进程信息，只查看关于mysql的相关进程</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">进程树：pstree -pu</span><br><span class="line">p是显示父id</span><br><span class="line">u是显示用户组</span><br></pre></td></tr></table></figure><p>​         <img src="/articleImg/59_article/3.jpg" alt="3"></p><p>​        杀死进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 进程id  #和windows的任务管理器是一样的，nohup的进程表示后台进程</span><br></pre></td></tr></table></figure><h2 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h2><p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p><p>添加账号 ： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">选项 :  useradd 选项 用户名</span><br><span class="line"></span><br><span class="line">-c comment 指定一段注释性描述。</span><br><span class="line"></span><br><span class="line">-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。</span><br><span class="line"></span><br><span class="line">-g 用户组 指定用户所属的用户组。 一般在新建用户时，会指定-g参数</span><br><span class="line"></span><br><span class="line">-G 用户组，用户组 指定用户所属的附加组。</span><br><span class="line"></span><br><span class="line">-m　使用者目录如不存在则自动建立。</span><br><span class="line"></span><br><span class="line">-s Shell文件 指定用户的登录Shell。</span><br><span class="line"></span><br><span class="line">-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</span><br><span class="line"></span><br><span class="line">用户名 :</span><br><span class="line"></span><br><span class="line">指定新账号的登录名。</span><br></pre></td></tr></table></figure><p> 创建用户，并设立密码</p><p><img src="/articleImg/59_article/6.png" alt="6"></p><p><strong>/etc/passwd文件是用户管理工作涉及的最重要的一个文件。Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。</strong></p><h2 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h2><p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。</p><p>（1）增加一个新的用户组使用groupadd命令： groupadd 选项 用户组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd -g 101 group2</span><br><span class="line">此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。</span><br></pre></td></tr></table></figure><p>（2）删除一个已有的用户组，使用groupdel命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel group1</span><br></pre></td></tr></table></figure><p>（3）修改用户组的属性使用groupmod命令，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 此命令将组group2的组标识号修改为102。</span><br><span class="line">groupmod -g 102 group2</span><br><span class="line"></span><br><span class="line"># 将组group2的标识号改为10000，组名修改为group3。</span><br><span class="line">groupmod –g 10000 -n group3 group2</span><br></pre></td></tr></table></figure><p>（4）切换组 ：如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newgrp root  用户可以在登录后，使用命令newgrp切换到其他用户组</span><br><span class="line">这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。</span><br></pre></td></tr></table></figure><h1 id="开启Linux的防火墙"><a href="#开启Linux的防火墙" class="headerlink" title="开启Linux的防火墙"></a>开启Linux的防火墙</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 查看firewall服务状态</span><br><span class="line">systemctl status firewalld</span><br><span class="line"></span><br><span class="line"># 开启、重启、关闭、firewalld.service服务</span><br><span class="line"># 开启</span><br><span class="line">service firewalld start</span><br><span class="line"># 重启</span><br><span class="line">service firewalld restart</span><br><span class="line"># 关闭</span><br><span class="line">service firewalld stop</span><br><span class="line"></span><br><span class="line"># 查看防火墙规则</span><br><span class="line">firewall-cmd --list-all    # 查看全部信息</span><br><span class="line">firewall-cmd --list-ports  # 只看端口信息</span><br><span class="line"></span><br><span class="line"># 开启端口</span><br><span class="line">开端口命令：firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line">重启防火墙：systemctl restart firewalld.service</span><br><span class="line"></span><br><span class="line">命令含义：</span><br><span class="line">--zone #作用域</span><br><span class="line">--add-port=80/tcp  #添加端口，格式为：端口/通讯协议</span><br><span class="line">--permanent   #永久生效，没有此参数重启后失效</span><br></pre></td></tr></table></figure><p>如果想要自己的项目在服务器上成功运行一定要确保Linux的防火墙端口是开启的，如果是阿里云，需要保证阿里云的安全组策略是开放的。</p><h1 id="宝塔linux面板"><a href="#宝塔linux面板" class="headerlink" title="宝塔linux面板"></a>宝塔linux面板</h1><p><a href="https://www.bt.cn/new/index.html">https://www.bt.cn/new/index.html</a></p><p>这是一个快速安装远程服务器环境的网站。一键安装。</p><p>我的账号的手机号码</p><p>密码是首字母大写，中间加了一个@</p><p><img src="/articleImg/59_article/4.jpg" alt="4"></p><h1 id="今日份linux学习总结"><a href="#今日份linux学习总结" class="headerlink" title="今日份linux学习总结"></a>今日份linux学习总结</h1><p>昨天晚上购置了一台阿里云服务器。利用该台服务器我复习了linux的相关基础命令。</p><p>利用xshell远程连接，利用xftp进行文件传输，安装了java环境和tomcat环境。从docker的官网配置了centos7的环境。</p><p>继续加油吧~</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阿里云服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM整合</title>
      <link href="/2022/03/17/SSM%E6%95%B4%E5%90%88/"/>
      <url>/2022/03/17/SSM%E6%95%B4%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合</h1><p>SSM : SpringMVC + Spring + Mybatis</p><h1 id="Spring-搭建流程"><a href="#Spring-搭建流程" class="headerlink" title="Spring 搭建流程"></a>Spring 搭建流程</h1><p><img src="/articleImg/58_article/Spring%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.jpg" alt="Spring环境搭建"></p><h2 id="Spring-开启事务"><a href="#Spring-开启事务" class="headerlink" title="Spring 开启事务"></a>Spring 开启事务</h2><p> <img src="/articleImg/58_article/Spring%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1.jpg" alt="Spring开启事务"></p><h2 id="Mybatis原生环境搭建"><a href="#Mybatis原生环境搭建" class="headerlink" title="Mybatis原生环境搭建"></a>Mybatis原生环境搭建</h2><p> <img src="/articleImg/58_article/mybatis%E5%8E%9F%E7%94%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.jpg" alt="mybatis原生环境搭建"></p><h2 id="Spring-整合mybatis"><a href="#Spring-整合mybatis" class="headerlink" title="Spring 整合mybatis"></a>Spring 整合mybatis</h2><p><img src="/articleImg/58_article/Spring%E6%95%B4%E5%90%88mybatis.jpg" alt="Spring整合mybatis"></p><h2 id="spring-MVC简介"><a href="#spring-MVC简介" class="headerlink" title="spring MVC简介"></a>spring MVC简介</h2><p>SpringMVC: 对web层进行的封装,提供了MVC框架。M: model(数据封装)、V: view(视图,形成最终的物理视图、C: Controller(控制器)<br>  三大组件:处理器: 我们自己编写的类<br>        1.处理器映射器: 建立请求路径与方法的对应关系<br>        2.处理器适配器: 适配处理器的实现方式,调用指定的类反射执行方法<br>        3.视图解析器: 根据逻辑视图生成物理视图<br>web层的作用:<br>    接收请求 : @WebServlet(“/路径”)  这个是当时学servlet，学的url映射注解<br>    获取请求携带的数据信息<br>    处理请求 : 调用service处理请求<br>SpringMVC:<br>    接收请求 : <strong>DispatcherServlet</strong>接收所有请求(解析请求携带的一切信息,截取请求路径)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/路径&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">demo1</span><span class="params">(request,Model,ModelAndView)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 响应:</span></span><br><span class="line">    <span class="comment">//同步: </span></span><br><span class="line">    <span class="comment">// 封装返回结果</span></span><br><span class="line">    <span class="comment">// request + String : requestAPI和逻辑视图</span></span><br><span class="line">    <span class="comment">// Model + String</span></span><br><span class="line">    <span class="comment">// ModelAndView</span></span><br><span class="line">    <span class="comment">//请求转发: 直接返回字符串找视图解析器 | forward:/路径</span></span><br><span class="line">    <span class="comment">//重定向: redirect:/路径</span></span><br><span class="line">    <span class="comment">//异步: </span></span><br><span class="line">    <span class="comment">//response.getWriter().print(..);</span></span><br><span class="line">    <span class="comment">//@ResponseBody + String</span></span><br><span class="line">    <span class="comment">//@ResponseBody + 对象 (将对象转成json返回)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">异步:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">(HttpServletResponse response)</span></span>&#123;</span><br><span class="line">    response.getWriter().print(..);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@ResponseBody</span>  <span class="comment">//将对象序列化为字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">demo2</span><span class="params">(<span class="meta">@RequestBody</span> User vo)</span></span>&#123; <span class="comment">//RequestBody将字符串序列化为对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;返回的数据信息&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">demo3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;对象&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-整合-Spring-MVC"><a href="#Spring-整合-Spring-MVC" class="headerlink" title="Spring 整合 Spring MVC"></a>Spring 整合 Spring MVC</h2><p><img src="/articleImg/58_article/Spring%E6%95%B4%E5%90%88springMVC.jpg" alt="Spring整合springMVC"></p><h2 id="SSM实现增删改"><a href="#SSM实现增删改" class="headerlink" title="SSM实现增删改"></a>SSM实现增删改</h2><p><img src="/articleImg/58_article/SSM%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%88%A0%E6%94%B9.jpg" alt="SSM实现增删改"></p>]]></content>
      
      
      <categories>
          
          <category> javaweb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM整合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java双向队列Deque栈与队列</title>
      <link href="/2021/12/29/Java%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97Deque%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
      <url>/2021/12/29/Java%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97Deque%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java中实际上提供了java.util.Stack来实现栈结构,但官方目前已不推荐使用,而是使用java.util.Deque双端队列来实现队列与栈的各种需求.如下图所示java.util.Deque的实现子类有java.util.LinkedList和java.util.ArrayDeque.顾名思义前者是基于链表,后者基于数据实现的双端队列.</p><p> <img src="/articleImg/56_article/image1.png" alt="image1"></p><h1 id="Deque即可当栈也可当队列"><a href="#Deque即可当栈也可当队列" class="headerlink" title="Deque即可当栈也可当队列"></a>Deque即可当栈也可当队列</h1><p>要讲栈和队列，首先要讲Deque接口。Deque的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。下表列出了Deque与Queue相对应的接口：</p><p> <img src="/articleImg/56_article/image2.png" alt="image2"></p><p>下表列出了Deque与Stack对应的接口：</p><p> <img src="/articleImg/56_article/image3.png" alt="image3"></p><h1 id="声明示例"><a href="#声明示例" class="headerlink" title="声明示例"></a>声明示例</h1><p>普通队列(一端进另一端出):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue queue = <span class="keyword">new</span> LinkedList() 或 Deque deque = <span class="keyword">new</span> LinkedList()</span><br></pre></td></tr></table></figure><p>双端队列(两端都可进出)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Deque deque = <span class="keyword">new</span> LinkedList()</span><br><span class="line">Deque&lt;泛型&gt;deque = <span class="keyword">new</span> LinkedList&lt;&gt;()</span><br></pre></td></tr></table></figure><p>堆栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque deque = <span class="keyword">new</span> LinkedList()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双向队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>替换空格</title>
      <link href="/2021/12/29/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
      <url>/2021/12/29/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h1><p> <img src="/articleImg/55_article/image1.png" alt="image1"></p><p>借助栈来解决问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 本题用栈的思想更为巧妙，自己选用了字符串切片后在拼接，造成自己很多繁琐的讨论~~</span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    public String replaceSpace(String s) &#123;</span></span><br><span class="line"><span class="comment">        int length = s.length();</span></span><br><span class="line"><span class="comment">        char[] array = new char[length * 3];</span></span><br><span class="line"><span class="comment">        int size = 0;</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; length; i++) &#123;</span></span><br><span class="line"><span class="comment">            char c = s.charAt(i);</span></span><br><span class="line"><span class="comment">            if (c == &#x27; &#x27;) &#123;</span></span><br><span class="line"><span class="comment">                array[size++] = &#x27;%&#x27;;</span></span><br><span class="line"><span class="comment">                array[size++] = &#x27;2&#x27;;</span></span><br><span class="line"><span class="comment">                array[size++] = &#x27;0&#x27;;</span></span><br><span class="line"><span class="comment">            &#125; else &#123;</span></span><br><span class="line"><span class="comment">                array[size++] = c;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        String newStr = new String(array, 0, size);</span></span><br><span class="line"><span class="comment">        return newStr;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        ArrayList&lt;String&gt; ans_list =<span class="keyword">new</span> ArrayList&lt;String&gt; ();</span><br><span class="line">        <span class="keyword">int</span> last_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27; &#x27;</span>)&#123; <span class="comment">//该位置是空格</span></span><br><span class="line">                String temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">if</span>(i == s.length() -<span class="number">1</span>)&#123; <span class="comment">//java中的substring不太好用，取不到最后一个字符</span></span><br><span class="line">                    temp = s.substring(last_index,i);</span><br><span class="line">                    last_index = i+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    temp = s.substring(last_index,i);</span><br><span class="line">                    last_index = i+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans_list.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(s.length()-<span class="number">1</span>)!= <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            String temp = s.substring(last_index);</span><br><span class="line">            ans_list.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(s.length()-<span class="number">1</span>)==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">             ans_list.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历到所有的分段集合，进行合并处理</span></span><br><span class="line">        String ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ans_list.size();i++)&#123;</span><br><span class="line">            ans += ans_list.get(i);</span><br><span class="line">            <span class="keyword">if</span>((ans_list.get(i)==<span class="string">&quot;&quot;</span>&amp;&amp;ans_list.size() == <span class="number">1</span>)||i&lt;ans_list.size() -<span class="number">1</span>)</span><br><span class="line">                ans+=<span class="string">&quot;%20&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>把数组排成最小的数</title>
      <link href="/2021/12/29/%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/"/>
      <url>/2021/12/29/%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h1><p>本题是剑指offer面试题45，核心解决方案是根据题目要求设计一个排序算法。自己设计的比较方法思路并不能通过所有的案例，正确的排序规则应该是 将两个字符串，正反拼接起来，这样得到的两个字符串就时长度一致的，在排序方法中使用compareTo方法即可。</p><h2 id="参考高赞解"><a href="#参考高赞解" class="headerlink" title="参考高赞解"></a>参考高赞解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">            strs[i] = String.valueOf(nums[i]);</span><br><span class="line">        Arrays.sort(strs,<span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1,String o2)</span></span>&#123;</span><br><span class="line">           <span class="keyword">return</span> (o1+o2).compareTo(o2+o1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//Arrays.sort(strs, (x, y) -&gt; (x + y).compareTo(y + x));</span></span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(String s : strs)</span><br><span class="line">            res.append(s);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="个人思路"><a href="#个人思路" class="headerlink" title="个人思路"></a>个人思路</h2><p>不能通过所有案例</p><p> <img src="/articleImg/51_article/image1.png" alt="image1"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String minNumber(int[] nums) &#123;</span><br><span class="line">        if(nums.length == 1)</span><br><span class="line">            return &quot;&quot;+nums[0];</span><br><span class="line">       QuickSort(nums,0,nums.length-1);</span><br><span class="line">       String ans = &quot;&quot;;</span><br><span class="line">       for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">           ans = ans + nums[i];</span><br><span class="line">       &#125;</span><br><span class="line">       return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //根据题意设计出的：两数大小比较法则  判断a元素是否大于等于b元素</span><br><span class="line">    public boolean juageNumSize(int a,int b)&#123;</span><br><span class="line">        String str1 = &quot;&quot;+a;</span><br><span class="line">        String str2 = &quot;&quot;+b;</span><br><span class="line">        int length1 = str1.length();</span><br><span class="line">        int length2 = str2.length();</span><br><span class="line">        int length = length1&lt;length2?length1:length2;</span><br><span class="line">        int i =0;</span><br><span class="line">        //判断共同部分</span><br><span class="line">        for(i=0;i&lt;length;i++)&#123;</span><br><span class="line">            if(str1.charAt(i)&gt;str2.charAt(i)) </span><br><span class="line">                return true;</span><br><span class="line">            else if(str1.charAt(i)&lt;str2.charAt(i)) </span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断多余的部分</span><br><span class="line">        if(length1 == length2)</span><br><span class="line">            return true;</span><br><span class="line">        else if(length1&gt;length2)&#123;</span><br><span class="line">            while(i&lt;length1)&#123;</span><br><span class="line">                if(str1.charAt(i)&lt;str2.charAt(0))</span><br><span class="line">                    return false;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else if(length1&lt;length2)&#123;</span><br><span class="line">            while(i&lt;length2)&#123;</span><br><span class="line">                if(str2.charAt(i)&gt;str1.charAt(0))</span><br><span class="line">                    return false;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //快速排序</span><br><span class="line">    void QuickSort(int[] num, int left, int right) &#123;</span><br><span class="line">//如果left等于right，即数组只有一个元素，直接返回</span><br><span class="line">if(left&gt;=right) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//设置最左边的元素为基准值</span><br><span class="line">int key=num[left];</span><br><span class="line">//数组中比key小的放在左边，比key大的放在右边，key值下标为i</span><br><span class="line">int i=left;</span><br><span class="line">int j=right;</span><br><span class="line">while(i&lt;j)&#123;</span><br><span class="line">//j向左移，直到遇到比key小的值</span><br><span class="line">while(juageNumSize(num[j],key)&amp;&amp; i&lt;j)&#123; //num[j]&gt;=key </span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">//i向右移，直到遇到比key大的值</span><br><span class="line">while(juageNumSize(key,num[i]) &amp;&amp; i&lt;j)&#123; //num[i]&lt;=key</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">//i和j指向的元素交换</span><br><span class="line">if(i&lt;j)&#123;</span><br><span class="line">int temp=num[i];</span><br><span class="line">num[i]=num[j];</span><br><span class="line">num[j]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">num[left]=num[i];</span><br><span class="line">num[i]=key;</span><br><span class="line">//count++;</span><br><span class="line">QuickSort(num,left,i-1);</span><br><span class="line">QuickSort(num,i+1,right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组中的逆序对</title>
      <link href="/2021/12/29/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
      <url>/2021/12/29/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h1><p>本体的核心思想是使用归并排序。</p><div style="background-color:orange">另外本题教育自己在递归中，每次都需要开辟同一大量辅助空间时，一定要放为全局变量。这也是记录这道题的主要原因</div><h2 id="题目描述：剑指offer面试题51"><a href="#题目描述：剑指offer面试题51" class="headerlink" title="题目描述：剑指offer面试题51"></a>题目描述：剑指offer面试题51</h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,5,6,4]</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><p>合并阶段 本质上是 合并两个排序数组 的过程，而每当遇到 左子数组当前元素 &gt; 右子数组当前元素 时，意味着 「左子数组当前元素 至 末尾元素」 与 「右子数组当前元素」 构成了若干 「逆序对」 。</p><p>上面一句话的意思简单来说，就是当在合并的时候，选择的是右边元素时，这时便构成了mid - i  +1 个逆序对，i代表此时左边序列该合并的下标位置。如下图</p><p> <img src="/articleImg/54_aiticle/image1.png" alt="image1"></p><h2 id="代码实现-主要思想是归并排序"><a href="#代码实现-主要思想是归并排序" class="headerlink" title="代码实现  主要思想是归并排序"></a>代码实现  主要思想是归并排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> []tmp;<span class="comment">//辅助数组</span></span><br><span class="line">    <span class="comment">//O(n平方)的解法必然超时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        tmp=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];  <span class="comment">//这里开辟数组空间一定要放为全局变量  ★★★★★★★★★★★★★</span></span><br><span class="line">        mergeSort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两路归并算法，两个排好序的子序列合并为一个子序列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> []a,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">//左边序列是指[left,mid] 右边序列范围[mid+1,right]</span></span><br><span class="line">        <span class="keyword">int</span> p1=left,p2=mid+<span class="number">1</span>,k=left;<span class="comment">//p1、p2是检测指针，k是存放指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p1&lt;=mid &amp;&amp; p2&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[p1]&lt;=a[p2])</span><br><span class="line">                tmp[k++]=a[p1++];</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//在这里说名右边的元素比左边的要小，在这里进行逆序对的统计</span></span><br><span class="line">                ans = ans + (mid-p1+<span class="number">1</span>);</span><br><span class="line">                tmp[k++]=a[p2++];</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p1&lt;=mid) tmp[k++]=a[p1++];<span class="comment">//如果第一个序列未检测完，直接将后面所有元素加到合并的序列中</span></span><br><span class="line">        <span class="keyword">while</span>(p2&lt;=right) tmp[k++]=a[p2++];<span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//复制回原素组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;=right; i++) </span><br><span class="line">            a[i]=tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> [] a,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;  <span class="comment">//这里就像是二叉树的一个后序遍历的过程</span></span><br><span class="line">        <span class="keyword">if</span>(start&lt;end)&#123;<span class="comment">//当子序列中只有一个元素时结束递归</span></span><br><span class="line">            <span class="keyword">int</span> mid=(start+end)/<span class="number">2</span>;<span class="comment">//划分子序列</span></span><br><span class="line">            mergeSort(a, start, mid);<span class="comment">//对左侧子序列进行递归排序</span></span><br><span class="line">            mergeSort(a, mid+<span class="number">1</span>, end);<span class="comment">//对右侧子序列进行递归排序</span></span><br><span class="line">            merge(a, start, mid, end);<span class="comment">//合并</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/2021/12/29/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2021/12/29/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>归并排序是一种概念上最简单的排序算法，与快速排序一样，归并排序也是基于分治法的。归并排序将待排序的元素序列分成两个长度相等的子序列，为每一个子序列排序，然后再将他们合并成一个子序列。合并两个子序列的过程也就是两路归并。</p><p>归并排序是一种稳定的排序算法，归并排序的主要问题在于它需要一个与待排序数组一样大的辅助数组空间。由于归并排序每次划分时两个子序列的长度基本一样，所以归并排序最好、最差和平均时间复杂度都是nlog2n。</p><p>归并排序的过程就像是二叉树的一个后序遍历的过程，</p><p> <img src="/articleImg/53_article/image1.png" alt="image1"></p><p>要将两个排好序的子序列合并为一个子序列的方法：每次都是从未比较的两个子序列的最小值中选出一个更小值。</p><p> <img src="/articleImg/53_article/20180812233124752~2.gif" alt="20180812233124752~2"></p><h2 id="java代码一看便知道归并排序的过程"><a href="#java代码一看便知道归并排序的过程" class="headerlink" title="java代码一看便知道归并排序的过程"></a>java代码一看便知道归并排序的过程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//两路归并算法，两个排好序的子序列合并为一个子序列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> []a,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []tmp=<span class="keyword">new</span> <span class="keyword">int</span>[a.length];<span class="comment">//辅助数组</span></span><br><span class="line">        <span class="comment">//左边序列是指[left,mid] 右边序列范围[mid+1,right]</span></span><br><span class="line">        <span class="keyword">int</span> p1=left,p2=mid+<span class="number">1</span>,k=left;<span class="comment">//p1、p2是检测指针，k是存放指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p1&lt;=mid &amp;&amp; p2&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[p1]&lt;=a[p2])</span><br><span class="line">                tmp[k++]=a[p1++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tmp[k++]=a[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p1&lt;=mid) tmp[k++]=a[p1++];<span class="comment">//如果第一个序列未检测完，直接将后面所有元素加到合并的序列中</span></span><br><span class="line">        <span class="keyword">while</span>(p2&lt;=right) tmp[k++]=a[p2++];<span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//复制回原素组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;=right; i++) </span><br><span class="line">            a[i]=tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> [] a,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;  <span class="comment">//这里就像是二叉树的一个后序遍历的过程</span></span><br><span class="line">        <span class="keyword">if</span>(start&lt;end)&#123;<span class="comment">//当子序列中只有一个元素时结束递归</span></span><br><span class="line">            <span class="keyword">int</span> mid=(start+end)/<span class="number">2</span>;<span class="comment">//划分子序列</span></span><br><span class="line">            mergeSort(a, start, mid);<span class="comment">//对左侧子序列进行递归排序</span></span><br><span class="line">            mergeSort(a, mid+<span class="number">1</span>, end);<span class="comment">//对右侧子序列进行递归排序</span></span><br><span class="line">            merge(a, start, mid, end);<span class="comment">//合并</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123; <span class="number">49</span>, <span class="number">38</span>, <span class="number">65</span>, <span class="number">97</span>, <span class="number">76</span>, <span class="number">13</span>, <span class="number">27</span>, <span class="number">50</span> &#125;;</span><br><span class="line">        mergeSort(a, <span class="number">0</span>, a.length-<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;排好序的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e : a)</span><br><span class="line">            System.out.print(e+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本篇博客大部分粘贴CSDN博主：<a href="https://blog.csdn.net/qq_36442947">华山派副掌门人</a></p><p>非常感谢他的工作~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>会有重复字符的字符串的排列</title>
      <link href="/2021/12/29/%E4%BC%9A%E6%9C%89%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
      <url>/2021/12/29/%E4%BC%9A%E6%9C%89%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h1><p>注意这里字符可能会有重复的情况，所以需要在交换的过程当中，用一个set去重</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  List&lt;String&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  <span class="keyword">char</span> []c;</span><br><span class="line">  <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">​    c = s.toCharArray();</span><br><span class="line">​    dfs(<span class="number">0</span>);</span><br><span class="line">​    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> String[res.size()]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">​    <span class="keyword">if</span>(x == c.length -<span class="number">1</span>)&#123;</span><br><span class="line">​      res.add(String.valueOf(c));</span><br><span class="line">​      <span class="keyword">return</span>;</span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    HashSet &lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">​    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;c.length;i++)&#123;</span><br><span class="line">​      <span class="keyword">if</span>(set.contains(c[i])) </span><br><span class="line">​      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">​      set.add(c[i]);</span><br><span class="line">​      swap(c,i,x);</span><br><span class="line">​      dfs(x+<span class="number">1</span>);</span><br><span class="line">​      swap(c,i,x);</span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[]c,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">char</span> temp = c[i];</span><br><span class="line">​    c[i] = c[j];</span><br><span class="line">​    c[j] = temp;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 全排列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决maven引入依赖失败</title>
      <link href="/2021/12/29/%E8%A7%A3%E5%86%B3maven%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96%E5%A4%B1%E8%B4%A5/"/>
      <url>/2021/12/29/%E8%A7%A3%E5%86%B3maven%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96%E5%A4%B1%E8%B4%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="解决maven引入依赖失败"><a href="#解决maven引入依赖失败" class="headerlink" title="解决maven引入依赖失败"></a>解决maven引入依赖失败</h1><h2 id="JDK版本需要对应上"><a href="#JDK版本需要对应上" class="headerlink" title="JDK版本需要对应上"></a>JDK版本需要对应上</h2><ul><li>项目JDK</li></ul><p> <img src="/articleImg/50_article/image1.png" alt="image1"></p><ul><li>maven中JDK for Importer 选择 jdk 1.8</li></ul><p> <img src="/articleImg/50_article/image3.png" alt="image3"></p><ul><li>确定自己的maven仓库在IDEA中的配置都是正确的，并且maven的setting.xml 也已经被设置更改好</li></ul><p> <img src="/articleImg/50_article/image4.png" alt="image4"></p><ul><li>lifestle –&gt; clean 之后再reimport</li></ul><p> <img src="/articleImg/50_article/image2.png" alt="image2"></p><p>根据上面的几个步骤大概率是能把问题解决的</p>]]></content>
      
      
      <categories>
          
          <category> javaweb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>丑数</title>
      <link href="/2021/12/29/%E4%B8%91%E6%95%B0/"/>
      <url>/2021/12/29/%E4%B8%91%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h5><p>输入: n = 10<br>输出: 12<br>解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。<br>说明:  </p><p>1 是丑数。<br>n 不超过1690。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>该题目是剑指offer的面试题49，正向解法的话必然无法通过所有的测试用例。需要用到动态规划，找出递推公式。</p><p>丑数Xn+1满足下式：</p><p><img src="/articleImg/52_article/1.png" alt="1"></p><p><strong>丑数递推公式：</strong> 若索引 a,b,c满足以上条件，则下个丑数 Xn+1为三种情况中的 <strong>最小值</strong> ；<br>$$<br>Xn+1 = Math.min(Math.min(Xa, Xb),Xc);<br>$$<br>因此，可设置指针 a,b,c 指向首个丑数，循环根据递推公式得到下个丑数，<strong>并每轮将对应指针执行 +1 即可</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法二：是用动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line">    <span class="keyword">int</span> []dp = <span class="keyword">new</span> <span class="keyword">int</span> [n];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>; <span class="comment">//每次只移动2</span></span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">0</span>; <span class="comment">//每次只移动3</span></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>; <span class="comment">//每次只移动5</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> n1=dp[a] *<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> n2=dp[b]*<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> n3 = dp[c]*<span class="number">5</span>;</span><br><span class="line">        dp[i] = Math.min(Math.min(n1,n2),n3);</span><br><span class="line">        <span class="keyword">if</span>(dp[i] == n1) a++;</span><br><span class="line">        <span class="keyword">if</span>(dp[i] == n2) b++;</span><br><span class="line">        <span class="keyword">if</span>(dp[i] == n3) c++;</span><br><span class="line">        &#125;</span><br><span class="line">   <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="直接暴力正向会超时"><a href="#直接暴力正向会超时" class="headerlink" title="直接暴力正向会超时"></a>直接暴力正向会超时</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//超时 常规的正向解法，虽然加了备忘录，但是人需要判断每个数是不是丑数，所以最后提交的时候超出时间限制</span></span><br><span class="line">    LinkedList&lt;Integer&gt;uglyList = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">//用于已确定的丑数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> number = <span class="number">0</span>; <span class="comment">//递增的数字</span></span><br><span class="line">        <span class="keyword">int</span> uglyFound =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(uglyFound&lt;n)&#123;</span><br><span class="line">            number++;</span><br><span class="line">            <span class="keyword">if</span>(isUgly(number))&#123;</span><br><span class="line">                uglyList.add(number);</span><br><span class="line">                uglyFound++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(num%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(uglyList.contains(num)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            num = num/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">while</span>(num%<span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(uglyList.contains(num)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            num = num/<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">while</span>(num%<span class="number">5</span>==<span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">if</span>(uglyList.contains(num)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            num = num/<span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (num == <span class="number">1</span>)?<span class="keyword">true</span>:<span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字序列中某一位的数字</title>
      <link href="/2021/12/27/%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2021/12/27/%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="数字序列中某一位的数字"><a href="#数字序列中某一位的数字" class="headerlink" title="数字序列中某一位的数字"></a>数字序列中某一位的数字</h1><p>不得不说剑指offer的第五章有很多好题，直接暴力的话效果很不好，需要自己发现规律，在发现规律之后，也要认真思考代码的编写。</p><p>代码编写的过程中，一定要明确变量所对应的含义，这样才可确保万无一失。另外在大数代码失效的情况下，自己要考虑是否发生变量溢出的问题。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p><p>请写一个函数，求任意第n位对应的数字。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p> <img src="/articleImg/49_article/image1.png" alt="image1"></p><h2 id="很经典的两句代码"><a href="#很经典的两句代码" class="headerlink" title="很经典的两句代码"></a>很经典的两句代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//根据高赞解修改后的写法（最经典的就是这两句）                   //变量的意义</span><br><span class="line">   result = (long)Math.pow(10,cur) + ((copyN-1)/(cur+1)); //这里的cur+1就相当于元素的位数，copyN相当于还剩下的位数，这里是从1开始</span><br><span class="line">   return Long.toString(result).charAt((copyN - 1) % (cur+1)) - &#x27;0&#x27;;</span><br></pre></td></tr></table></figure><p>给自己的启示就是：一定要明确变量的含义及作用范围再去编写代码。三思而后码。</p><h2 id="个人解法，经1次参考修改"><a href="#个人解法，经1次参考修改" class="headerlink" title="个人解法，经1次参考修改"></a>个人解法，经1次参考修改</h2><p>数字的位数和个数之间是有对应关系的，是有规律的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">9</span>) <span class="keyword">return</span> n;</span><br><span class="line">        n = n-<span class="number">9</span>;</span><br><span class="line">        <span class="keyword">int</span> cur=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> copyN = n;</span><br><span class="line">        <span class="keyword">long</span> everyWeight=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> start = (<span class="keyword">int</span>)Math.pow(<span class="number">10</span>,cur);</span><br><span class="line">            <span class="keyword">if</span>(cur == <span class="number">0</span>) start = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> end = (<span class="keyword">int</span>)Math.pow(<span class="number">10</span>,cur+<span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">            everyWeight = (<span class="keyword">long</span>)(end - start + <span class="number">1</span>)*(cur+<span class="number">1</span>);  <span class="comment">//int 最大值 2147483647，但是这里数据较大时，会产生溢出</span></span><br><span class="line">            <span class="keyword">long</span> judge = copyN - everyWeight;</span><br><span class="line">            <span class="keyword">if</span>(judge &lt;=<span class="number">0</span>)&#123; <span class="comment">//说明找到，在该区间内</span></span><br><span class="line">                <span class="comment">//根据位数n的值去计算这个数到底是多少</span></span><br><span class="line">                <span class="keyword">int</span> remainder = copyN % (cur+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">int</span> num = copyN/(cur+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//根据高赞解修改后的写法（最经典的就是这两句）                   //变量的意义</span></span><br><span class="line">                result = (<span class="keyword">long</span>)Math.pow(<span class="number">10</span>,cur) + ((copyN-<span class="number">1</span>)/(cur+<span class="number">1</span>)); <span class="comment">//这里的cur+1就相当于元素的位数，copyN相当于还剩下的位数，这里是从1开始</span></span><br><span class="line">                <span class="keyword">return</span> Long.toString(result).charAt((copyN - <span class="number">1</span>) % (cur+<span class="number">1</span>)) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="comment">//第一次写法</span></span><br><span class="line">                <span class="comment">// if(remainder == 0)&#123;</span></span><br><span class="line">                <span class="comment">//     int result = 0;</span></span><br><span class="line">                <span class="comment">//     result = (int)Math.pow(10,cur) + num - 1;</span></span><br><span class="line">                <span class="comment">//     return result%10;</span></span><br><span class="line">                <span class="comment">// &#125;else&#123;</span></span><br><span class="line">                <span class="comment">//     int result = (int)Math.pow(10,cur) + num ;</span></span><br><span class="line">                <span class="comment">//     return (result/(int)Math.pow(10,(cur+1)-remainder))%10;</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur + <span class="number">1</span>;</span><br><span class="line">            copyN -= everyWeight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高赞写法，确实值得自己去学习"><a href="#高赞写法，确实值得自己去学习" class="headerlink" title="高赞写法，确实值得自己去学习"></a>高赞写法，确实值得自己去学习</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//高赞解，要学习的地方真的太多了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> digit = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> start = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> count = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; count) &#123; <span class="comment">// 1.</span></span><br><span class="line">            n -= count;</span><br><span class="line">            digit += <span class="number">1</span>;</span><br><span class="line">            start *= <span class="number">10</span>;</span><br><span class="line">            count = digit * start * <span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对于第二步：这里取n-1的原因是:当n对应num中的最后一位时，不会由于进位，错误的寻找到下一个数字。</span></span><br><span class="line">        <span class="comment">//对于第三步：这里取n-1使得num中各位的位置坐标从左到右从0开始增加，即0,1,....,(digit-1)，更容易理解。</span></span><br><span class="line">        <span class="keyword">long</span> num = start + (n - <span class="number">1</span>) / digit; <span class="comment">// 2.</span></span><br><span class="line">        <span class="keyword">return</span> Long.toString(num).charAt((n - <span class="number">1</span>) % digit) - <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 3.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>继续加油吧！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化时间和空间效率 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据流中的中位数</title>
      <link href="/2021/12/27/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
      <url>/2021/12/27/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="数据流中的中位数"><a href="#数据流中的中位数" class="headerlink" title="数据流中的中位数"></a>数据流中的中位数</h1><p>发这篇博文主要是想对比一下自己的代码和高赞解代码的区别，告诉自己以后写代码真的需要三思而后码，不然自己累得不行才得到跟差不多的效果。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。对应剑指offer41题</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><p>​        void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>​        double findMedian() - 返回目前所有元素的中位数。</p><h2 id="自己的解答"><a href="#自己的解答" class="headerlink" title="自己的解答"></a>自己的解答</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用最大最小堆来解决问题，java中优先队列形同于堆</span></span><br><span class="line">    <span class="comment">//切记一档要确保在插入的过程中：最大堆中的元素必须全部小于最小堆中的元素</span></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    Queue&lt;Integer&gt; maxHeap;</span><br><span class="line">    Queue&lt;Integer&gt; minHeap;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count=<span class="number">0</span>;<span class="comment">//记录元素的总个数</span></span><br><span class="line"></span><br><span class="line">        Comparator&lt;Integer&gt;minCmp = <span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a,Integer b)</span></span>&#123;</span><br><span class="line">                 <span class="keyword">return</span> a-b; <span class="comment">//升序，也就是最小的元素在前面，表示最小堆</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">         Comparator&lt;Integer&gt;maxCmp = <span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a,Integer b)</span></span>&#123;</span><br><span class="line">                 <span class="keyword">return</span> b-a; <span class="comment">//降序，也就是最大的元素在前面，表示最大堆</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化最大堆</span></span><br><span class="line">        maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(maxCmp);</span><br><span class="line">        minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(minCmp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//插入元素的规则： 1 最大堆中的元素必须全部小于最小堆中的元素 2：当元素总数为偶数时，插入最小堆，总数为奇数时，插入最大堆</span></span><br><span class="line">    <span class="comment">//3.当需要插入最小堆的元素比最大堆中的一些元素还要小时，则进行调整，调整规则按1为准</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count%<span class="number">2</span>==<span class="number">0</span>)&#123; <span class="comment">//元素总数为偶数</span></span><br><span class="line">            <span class="keyword">if</span>(!minHeap.isEmpty()&amp;&amp;!maxHeap.isEmpty())&#123;</span><br><span class="line">                <span class="comment">//判断是否与1规则冲突</span></span><br><span class="line">                <span class="keyword">int</span> temp = maxHeap.peek();</span><br><span class="line">                <span class="keyword">if</span>(num&lt;=temp)&#123;</span><br><span class="line">                    maxHeap.add(num);</span><br><span class="line">                    <span class="keyword">int</span> realNum = maxHeap.poll();</span><br><span class="line">                    minHeap.add(realNum);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    minHeap.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                minHeap.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="comment">//元素总数为奇数</span></span><br><span class="line">            <span class="keyword">if</span>(!maxHeap.isEmpty())&#123;</span><br><span class="line">                <span class="comment">//插入maxHeap的元素也要进行筛查</span></span><br><span class="line">                <span class="keyword">int</span> temp = minHeap.peek();</span><br><span class="line">                <span class="keyword">if</span>(temp&gt;num)</span><br><span class="line">                    maxHeap.add(num);</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    temp = minHeap.poll();</span><br><span class="line">                    maxHeap.add(temp);</span><br><span class="line">                    minHeap.add(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = minHeap.peek();</span><br><span class="line">                <span class="keyword">if</span>(temp&gt;num)</span><br><span class="line">                    maxHeap.add(num);</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    temp = minHeap.poll();</span><br><span class="line">                    maxHeap.add(temp);</span><br><span class="line">                    minHeap.add(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count%<span class="number">2</span> == <span class="number">0</span>)&#123; <span class="comment">//总元素为偶数</span></span><br><span class="line">            <span class="keyword">int</span> temp1 = maxHeap.peek();</span><br><span class="line">            <span class="keyword">int</span> temp2 = minHeap.peek();</span><br><span class="line">            <span class="keyword">return</span> (temp1+temp2)*<span class="number">1.0</span>/<span class="number">2</span>; <span class="comment">//这里要注意整数的除法  和  浮点数的除法的不同</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">           <span class="comment">// System.out.print(minHeap.size());</span></span><br><span class="line">            System.out.print(minHeap.peek());</span><br><span class="line">            <span class="keyword">return</span> minHeap.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="高赞解"><a href="#高赞解" class="headerlink" title="高赞解"></a>高赞解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//高赞解法：确实值得自己学习</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; A, B;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A = <span class="keyword">new</span> PriorityQueue&lt;&gt;(); <span class="comment">// 小顶堆，保存较大的一半</span></span><br><span class="line">        B = <span class="keyword">new</span> PriorityQueue&lt;&gt;((x, y) -&gt; (y - x)); <span class="comment">// 大顶堆，保存较小的一半</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//尤其是这两句非常值得学习，对一下自己的if else写了多少句</span></span><br><span class="line">        <span class="keyword">if</span>(A.size() != B.size()) &#123;</span><br><span class="line">            A.add(num);  <span class="comment">//多一次插入操作，确保了每次插入到大顶堆B中的都是最小值</span></span><br><span class="line">            B.add(A.poll());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            B.add(num); <span class="comment">//多一次插入操作，确保了每次插入到大顶堆A中的都是最大值</span></span><br><span class="line">            A.add(B.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> A.size() != B.size() ? A.peek() : (A.peek() + B.peek()) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：vRIkXGwZl4</span><br></pre></td></tr></table></figure><p>对自己的解法真的是降维打击。继续努力吧。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化时间和空间效率 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不同基准元素下的快速排序</title>
      <link href="/2021/12/27/%E4%B8%8D%E5%90%8C%E5%9F%BA%E5%87%86%E5%85%83%E7%B4%A0%E4%B8%8B%E7%9A%84%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2021/12/27/%E4%B8%8D%E5%90%8C%E5%9F%BA%E5%87%86%E5%85%83%E7%B4%A0%E4%B8%8B%E7%9A%84%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="不同基准元素下的快速排序"><a href="#不同基准元素下的快速排序" class="headerlink" title="不同基准元素下的快速排序"></a>不同基准元素下的快速排序</h1><h2 id="快速排序核心思想"><a href="#快速排序核心思想" class="headerlink" title="快速排序核心思想"></a>快速排序核心思想</h2><p>1、快速排序的基本思想：</p><p>​       快速排序使用分治的思想，通过一趟排序将待排序列分割成两部分，其中一部分记录的关键字均比另一部分记录的关键字小。之后分别对这两部分记录继续进行排序，以达到整个序列有序的目的。</p><p>2、快速排序的三个步骤：</p><p>(1)选择基准：在待排序列中，按照某种方式挑出一个元素，作为 “基准”（pivot）</p><p>(2)分割操作：以该基准在序列中的实际位置，把序列分成两个子序列。此时，在基准左边的元素都比该基准小，在基准右边的元素都比基准大</p><p>(3)递归地对两个序列进行快速排序，直到序列为空或者只有一个元素。</p><p>3、选择基准的方式</p><p>​       对于分治算法，当每次划分时，算法若都能分成两个等长的子序列时，那么分治算法效率会达到最大。也就是说，基准的选择是很重要的。选择基准的方式决定了两个分割后两个子序列的长度，进而对整个算法的效率产生决定性影响。</p><p>最理想的方法是，选择的基准恰好能把待排序序列分成两个等长的子序列</p><h2 id="三种选择基准的方法"><a href="#三种选择基准的方法" class="headerlink" title="三种选择基准的方法"></a>三种选择基准的方法</h2><h3 id="方法-1-：固定位置"><a href="#方法-1-：固定位置" class="headerlink" title="方法(1)：固定位置"></a>方法(1)：固定位置</h3><p>思想：取序列的第一个或最后一个元素作为基准</p><p>基本的快速排序，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果left等于right，即数组只有一个元素，直接返回</span></span><br><span class="line"><span class="keyword">if</span>(left&gt;=right) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置最左边的元素为基准值</span></span><br><span class="line"><span class="keyword">int</span> key=num[left];</span><br><span class="line"><span class="comment">//数组中比key小的放在左边，比key大的放在右边，key值下标为i</span></span><br><span class="line"><span class="keyword">int</span> i=left;</span><br><span class="line"><span class="keyword">int</span> j=right;</span><br><span class="line"><span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line"><span class="comment">//j向左移，直到遇到比key小的值</span></span><br><span class="line"><span class="keyword">while</span>(num[j]&gt;=key &amp;&amp; i&lt;j)&#123;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//i向右移，直到遇到比key大的值</span></span><br><span class="line"><span class="keyword">while</span>(num[i]&lt;=key &amp;&amp; i&lt;j)&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//i和j指向的元素交换</span></span><br><span class="line"><span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line"><span class="keyword">int</span> temp=num[i];</span><br><span class="line">num[i]=num[j];</span><br><span class="line">num[j]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">num[left]=num[i];</span><br><span class="line">num[i]=key;</span><br><span class="line">count++;</span><br><span class="line">QuickSort(num,left,i-<span class="number">1</span>);</span><br><span class="line">QuickSort(num,i+<span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法-2-：随机选取基准"><a href="#方法-2-：随机选取基准" class="headerlink" title="方法(2)：随机选取基准"></a>方法(2)：随机选取基准</h2><p>引入的原因：在待排序列是部分有序时，固定选取基准使快排效率底下，要缓解这种情况，就引入了随机选取基准</p><p>代码参照剑指offer80页,回头回顾的时候，认真对待这个解法。可学习的地方还是很多的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//这个函数很有参考意义，实现的主要功能是：以一个随机基准数参考，将比参考值大的数放置在基准数的左边，将比参考值小的数放置在基准数的右边，</span></span><br><span class="line"><span class="comment">//但基准数的左右两边的数是非有序的，并且每次的基准数是操作范围内的随机值</span></span><br><span class="line"><span class="comment">//该函数目前应用在topk、快排等算法中</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> []data,<span class="keyword">int</span> length,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(start&gt;end||length&lt;<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">//数据格式不符合要求</span></span><br><span class="line">     Random r = <span class="keyword">new</span> Random();</span><br><span class="line">     <span class="comment">//rand.nextInt(MAX - MIN + 1) + MIN</span></span><br><span class="line">     <span class="keyword">int</span> index = r.nextInt(end-start+<span class="number">1</span>)+start; <span class="comment">//生成[start,end]之间的随机整数   //随机选取基准</span></span><br><span class="line">     Swap(data,index,end);</span><br><span class="line">     <span class="keyword">int</span> small = start-<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;end;i++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(data[i]&lt;data[end])&#123;</span><br><span class="line">         ++small;</span><br><span class="line">         <span class="keyword">if</span>(small!=i)</span><br><span class="line">         Swap(data,small,i);</span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++small;</span><br><span class="line">        Swap(data,small,end);</span><br><span class="line">        <span class="keyword">return</span> small;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="comment">//下面更具上述的Partition函数，写出快排</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> []data,<span class="keyword">int</span> length,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;  <span class="comment">//起始start是0；起始end是arr.length-1;</span></span><br><span class="line"><span class="keyword">if</span>(start == end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> index = Partition(data,length,start,end);</span><br><span class="line">    <span class="keyword">if</span>(index&gt;start)</span><br><span class="line">        QuickSort(data,length,start,index-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(index&lt;end)</span><br><span class="line">        QuickSort(data,length,index+<span class="number">1</span>,end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速幂和超级次方</title>
      <link href="/2021/12/26/%E5%BF%AB%E9%80%9F%E5%B9%82%E5%92%8C%E8%B6%85%E7%BA%A7%E6%AC%A1%E6%96%B9/"/>
      <url>/2021/12/26/%E5%BF%AB%E9%80%9F%E5%B9%82%E5%92%8C%E8%B6%85%E7%BA%A7%E6%AC%A1%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="快速幂和超级次方"><a href="#快速幂和超级次方" class="headerlink" title="快速幂和超级次方"></a>快速幂和超级次方</h1><p>分别对应leetcode50和leetcode372</p><h2 id="快速幂的思想"><a href="#快速幂的思想" class="headerlink" title="快速幂的思想"></a>快速幂的思想</h2><p>对于 a ^ b来说，若果把 b 写成2 进制，那么b 就可以写成若干二次幂之和，如13 的二进制 1101，于是3 号位 、2号位、0号位就都是1，那么就可以得到13 = 2^3 + 2^2 + 2^1 = 8 + 4 + 1。所以a ^13 = a^8 * a^4 * a^1。</p><p>通过同样的推导，我们可以把任意的a^b 表示成 a^(2^k)……、a^8、a^4、a^2、a^1中若干的乘积。若果二进制的i号位为1.那么想中的a^(2^i)就被选中。于是可以得到计算a^b的大致思路：令i 从0到k枚举b的二进制的每一位，如果为1 那就累计a^(2^i)。注意</p><p>a^(2^k)……、a^8、a^4、a^2、a^1前一项总是等于后一项的平方。</p><p>有了上述的思想，快速幂的编码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> num = n;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123; <span class="comment">//处理负数情况</span></span><br><span class="line">            x = <span class="number">1</span>/x;</span><br><span class="line">            num = -num;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((num&amp;<span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">                ans = ans*x;</span><br><span class="line">            num&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">            x = x*x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="超级次方"><a href="#超级次方" class="headerlink" title="超级次方"></a>超级次方</h2><h4 id="倒序遍历的方法解决该题"><a href="#倒序遍历的方法解决该题" class="headerlink" title="倒序遍历的方法解决该题"></a>倒序遍历的方法解决该题</h4><p>取余规则：ab % k = (a%k)(b%k)%k</p><p>迭代法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOD = <span class="number">1337</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            ans = (<span class="keyword">int</span>) ((<span class="keyword">long</span>) ans * pow(a, b[i]) % MOD);</span><br><span class="line">            a = pow(a, <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                res = (<span class="keyword">int</span>) ((<span class="keyword">long</span>) res * x % MOD);</span><br><span class="line">            &#125;</span><br><span class="line">            x = (<span class="keyword">int</span>) ((<span class="keyword">long</span>) x * x % MOD);</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> base = <span class="number">1337</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt;numList = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b.length;i++)&#123;</span><br><span class="line">            numList.addLast(b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = mysuperPow(a,numList);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mysuperPow</span><span class="params">(<span class="keyword">int</span> a,LinkedList&lt;Integer&gt; numList)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numList.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> last = numList.removeLast();</span><br><span class="line">        <span class="keyword">int</span> part1 = myPow(a,last);</span><br><span class="line">        <span class="keyword">int</span> part2 = myPow(mysuperPow(a,numList),<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> part1*part2%base;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myPow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123; <span class="comment">//这里在快速幂的基础之上加上取余运算</span></span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        x = x%base;</span><br><span class="line">        <span class="keyword">while</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((k&amp;<span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">                ans = ans*x%base;</span><br><span class="line">            k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">            x = x*x%base;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer[二进制中1的个数]</title>
      <link href="/2021/12/26/%E5%89%91%E6%8C%87offer-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
      <url>/2021/12/26/%E5%89%91%E6%8C%87offer-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offer-二进制中1的个数"><a href="#剑指offer-二进制中1的个数" class="headerlink" title="剑指offer[二进制中1的个数]"></a>剑指offer[二进制中1的个数]</h1><p><strong>负数的右移：负数右移的话，由于要保持它是负数，所以负数的二进制的右边补1。如果一直右移的话，最后就就变成0xFFFFFFFF 即-1</strong><br><strong>如： -4&gt;&gt;1 为-2 ；-4&gt;&gt;2为-1</strong> </p><p>负数的左移：跟正整数左移一样，右边补0，一直左移的话，最后就是0啦。-2&lt;&lt;2 为-4 ； -2&lt;&lt;31为0</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 汉明重量).）。</p><p>提示：</p><p>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>这里通过一个flag的位左移动，来查询待查数字二进制1的个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(flag != <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>((n&amp;flag) != <span class="number">0</span>)  <span class="comment">//(n&amp;flag) 这里一定要加括号啊！！</span></span><br><span class="line">                ans++;</span><br><span class="line">            flag&lt;&lt;=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里一定要注意负数的右移的特点。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开题报告</title>
      <link href="/2021/12/26/%E5%BC%80%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
      <url>/2021/12/26/%E5%BC%80%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="开题报告"><a href="#开题报告" class="headerlink" title="开题报告"></a>开题报告</h1><p>上周进行了自己的开题报告答辩，自己的方向实打实的确定了下来，在这里我把自己的开题报告内容进行记录，以作留念。</p><h2 id="选题背景"><a href="#选题背景" class="headerlink" title="选题背景"></a>选题背景</h2><p>​        国内汽车市场的发展越来越快，因此汽车安全技术的研发，也在汽车行业里兴起。汽车的智能化成为其中的一个重点，<strong>要让汽车的行驶能够智能化，就必须要实现车辆目标的有效检测。</strong>车辆目标的有效检测，能够给驾驶员提供目标信息来警示驾驶员前方的路况，也能为进一步的自动驾驶提供研究的基础。</p><p>​        与光学传感器相比，雷达在成像分辨率上不如光学传感器，不过它在测距测速功能和恶劣天气下的工作性能明显更胜一筹，穿透烟、尘、雨、雾的能力非常强，有着全天候、全天时的工作特点。相比之下，摄像头在雨雾、黑暗的环境下就会“失明”，强光和弱光环境它也不能正常工作。虽然光学传感器在恶劣天气下能力受限，但它成像分辨率上依然有优势。可以说每种传感器都有自己的优势也有自己的软肋。若雷达和摄像头感测若能相互搭配，将达到相辅相成的效果，因此在处理器或MCU中加入整合不同讯号的感测融合技术，让处理器能运算多种讯号，成为重要趋势。</p><h2 id="研究思路："><a href="#研究思路：" class="headerlink" title="研究思路："></a><strong>研究思路</strong>：</h2><p>总体框架</p><p> <img src="/articleImg/48_article/image1.png" alt="image1"></p><p><strong>第一</strong>：掌握超宽带雷达的使用方法，理解超宽带雷达X4M03的数据采集原理与基本的雷达成像原理。使用python驱动超宽带雷达在树莓派（Raspberry Pi）端的实时工作。对超宽带雷达采集的数据进行实时成像处理，获取目标的雷达成像信息。</p><p><strong>第二</strong>：驱动深度相机intel D455在嵌入式JetsonNano端的工作，应用yolov5目标识别网络，对深度相机的拍摄内容，进行实时的特定目标识别，得到目标的类别信息；并从相机深度图中获取目标点的距离信息。从而可以达到对目标进行类别与距离的信息标注。</p><p><strong>第三</strong>：将雷达坐标系与摄像头坐标系匹配并校准，设计概率融合算法，完成雷达成像信息与摄像头图像识别信息的融合，当系统运行时，达到对雷达成像中的目标实时标注类别及距离信息的效果。</p><p><strong>第四</strong>：选取实验场景，根据所建立的系统，对场景进行数据采集，进行自动化的雷达图像与摄像头图像的信息标注，建立一个雷达-摄像头融合的目标识别数据集。</p><p><strong>第五</strong>：尝试设计搭建一个摄像头与雷达交叉学习监督的目标识别网络，提高雷达单独成像时的目标识别效果，从而当遇到恶劣天气天气时，只使用雷达进行目标的检测与识别，提升系统工作的可靠性。</p><h2 id="摄像头3D目标识别基本思路"><a href="#摄像头3D目标识别基本思路" class="headerlink" title="摄像头3D目标识别基本思路"></a><strong>摄像头3D目标识别基本思路</strong></h2><p><img src="/articleImg/48_article/image2.png" alt="image2"></p><p>3D目标的识别效果如下图，同时返回类别及深度信息：</p><p> <img src="/articleImg/48_article/camera.gif" alt="camera"></p><h2 id="X4M03雷达实时成像及目标识别基本思路"><a href="#X4M03雷达实时成像及目标识别基本思路" class="headerlink" title="X4M03雷达实时成像及目标识别基本思路"></a>X4M03雷达实时成像及目标识别基本思路</h2><p><img src="/articleImg/48_article/image3.png" alt="image3"></p><p>这里展示的雷达成像效果对应3D目标识别中的实时场景</p><p> <img src="/articleImg/48_article/radar.gif" alt="radar"></p><h1 id="期待研究成果"><a href="#期待研究成果" class="headerlink" title="期待研究成果"></a>期待研究成果</h1><ul><li>边缘端雷达实时成像</li><li>边缘端摄像头3D目标识别</li><li>边缘端雷达与摄像头目标识别信息融合</li><li>建立雷达-摄像头目标识别数据集</li><li>设计深度学习网络单独训练雷达目标识别，最终达到雷达与摄像头的交互感知识别</li></ul><p><strong>非常感激</strong>自己的导师赵博老师和组内的梁承美同学对我这么长一段时间的支持和鼓励！</p>]]></content>
      
      
      <categories>
          
          <category> 深圳大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开题报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yolov5n如何训练自己的参数</title>
      <link href="/2021/12/26/yolov5n%E5%A6%82%E4%BD%95%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8F%82%E6%95%B0/"/>
      <url>/2021/12/26/yolov5n%E5%A6%82%E4%BD%95%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="yolov5n如何训练自己的参数"><a href="#yolov5n如何训练自己的参数" class="headerlink" title="yolov5n如何训练自己的参数"></a>yolov5n如何训练自己的参数</h1><p>自己的项目到了一个很关键的时刻，那就是雷达的信息融合，但是自己手里的Nano识别帧率FPS只能达到5，昨天发现yolo官方又出了一个新的版本yolov5n，首次发布支持移动端的最小化模型YOLOv5n，只有1.9MB，全称为YOLOv5 Nano。</p><p>下面把握如何训练yolov5n的过程记录下来</p><h2 id="1，源码"><a href="#1，源码" class="headerlink" title="1，源码"></a>1，源码</h2><p>yolo官方下载yolov5 - n(6.0)版本代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/ultralytics/yolov5</span><br></pre></td></tr></table></figure><h2 id="2，数据标注"><a href="#2，数据标注" class="headerlink" title="2，数据标注"></a>2，数据标注</h2><p>使用labelImg对自己的数据集进行标注 images、Annotations、 ImageSets、 JPEGImages、labels, 创立这几个文件夹的主要作用是为了后续使用step1.py,step2.py运行时，xml格式数据转VOc数据格式，放置相关训练文件用。</p><h2 id="3，配置文件"><a href="#3，配置文件" class="headerlink" title="3，配置文件"></a>3，配置文件</h2><p>在源码data文件夹下创建如下几个文件夹  </p><p><strong>需要放入自己文件的只有两个：</strong> images内为数据集原始图片，Annotations内为标注的xml文件，并将images内文件复制到JPEGIamges中</p><p>根目录下创建 <em>step1.py</em> 文件，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">trainval_percent = <span class="number">0.1</span></span><br><span class="line">train_percent = <span class="number">0.9</span></span><br><span class="line">xmlfilepath = <span class="string">&#x27;data/Annotations&#x27;</span></span><br><span class="line">txtsavepath = <span class="string">&#x27;data/ImageSets&#x27;</span></span><br><span class="line">total_xml = os.listdir(xmlfilepath)</span><br><span class="line">num = <span class="built_in">len</span>(total_xml)</span><br><span class="line"><span class="built_in">list</span> = <span class="built_in">range</span>(num)</span><br><span class="line">tv = <span class="built_in">int</span>(num * trainval_percent)</span><br><span class="line">tr = <span class="built_in">int</span>(tv * train_percent)</span><br><span class="line">trainval = random.sample(<span class="built_in">list</span>, tv)</span><br><span class="line">train = random.sample(trainval, tr)</span><br><span class="line">ftrainval = <span class="built_in">open</span>(<span class="string">&#x27;data/ImageSets/trainval.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">ftest = <span class="built_in">open</span>(<span class="string">&#x27;data/ImageSets/test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">ftrain = <span class="built_in">open</span>(<span class="string">&#x27;data/ImageSets/train.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">fval = <span class="built_in">open</span>(<span class="string">&#x27;data/ImageSets/val.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">    name = total_xml[i][:-<span class="number">4</span>] + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">in</span> trainval:</span><br><span class="line">        ftrainval.write(name)</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> train:</span><br><span class="line">            ftest.write(name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            fval.write(name)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ftrain.write(name)</span><br><span class="line">ftrainval.close()</span><br><span class="line">ftrain.close()</span><br><span class="line">fval.close()</span><br><span class="line">ftest.close()</span><br></pre></td></tr></table></figure><p>根目录下继续创建 <em>step2.py</em> 文件，运行完这两个文件后，会在你刚才创立的几个文件夹下生成一些文件，这个文件就是等会运行train.py所需要的训练文件,代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> listdir, getcwd</span><br><span class="line"><span class="keyword">from</span> os.path <span class="keyword">import</span> join</span><br><span class="line">sets = [<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;test&#x27;</span>,<span class="string">&#x27;val&#x27;</span>]</span><br><span class="line">classes = [<span class="string">&quot;reflector&quot;</span>, <span class="string">&quot;bicycle&quot;</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert</span>(<span class="params">size, box</span>):</span></span><br><span class="line">    dw = <span class="number">1.</span> / size[<span class="number">0</span>]</span><br><span class="line">    dh = <span class="number">1.</span> / size[<span class="number">1</span>]</span><br><span class="line">    x = (box[<span class="number">0</span>] + box[<span class="number">1</span>]) / <span class="number">2.0</span></span><br><span class="line">    y = (box[<span class="number">2</span>] + box[<span class="number">3</span>]) / <span class="number">2.0</span></span><br><span class="line">    w = box[<span class="number">1</span>] - box[<span class="number">0</span>]</span><br><span class="line">    h = box[<span class="number">3</span>] - box[<span class="number">2</span>]</span><br><span class="line">    x = x * dw</span><br><span class="line">    w = w * dw</span><br><span class="line">    y = y * dh</span><br><span class="line">    h = h * dh</span><br><span class="line">    <span class="keyword">return</span> (x, y, w, h)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_annotation</span>(<span class="params">image_id</span>):</span></span><br><span class="line">    in_file = <span class="built_in">open</span>(<span class="string">&#x27;data/Annotations/%s.xml&#x27;</span> % (image_id))</span><br><span class="line">    out_file = <span class="built_in">open</span>(<span class="string">&#x27;data/labels/%s.txt&#x27;</span> % (image_id), <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    tree = ET.parse(in_file)</span><br><span class="line">    root = tree.getroot()</span><br><span class="line">    size = root.find(<span class="string">&#x27;size&#x27;</span>)</span><br><span class="line">    w = <span class="built_in">int</span>(size.find(<span class="string">&#x27;width&#x27;</span>).text)</span><br><span class="line">    h = <span class="built_in">int</span>(size.find(<span class="string">&#x27;height&#x27;</span>).text)</span><br><span class="line">    <span class="keyword">for</span> obj <span class="keyword">in</span> root.<span class="built_in">iter</span>(<span class="string">&#x27;object&#x27;</span>):</span><br><span class="line">        difficult = obj.find(<span class="string">&#x27;difficult&#x27;</span>).text</span><br><span class="line">        cls = obj.find(<span class="string">&#x27;name&#x27;</span>).text</span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> classes <span class="keyword">or</span> <span class="built_in">int</span>(difficult) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        cls_id = classes.index(cls)</span><br><span class="line">        xmlbox = obj.find(<span class="string">&#x27;bndbox&#x27;</span>)</span><br><span class="line">        b = (<span class="built_in">float</span>(xmlbox.find(<span class="string">&#x27;xmin&#x27;</span>).text), <span class="built_in">float</span>(xmlbox.find(<span class="string">&#x27;xmax&#x27;</span>).text), <span class="built_in">float</span>(xmlbox.find(<span class="string">&#x27;ymin&#x27;</span>).text),</span><br><span class="line">             <span class="built_in">float</span>(xmlbox.find(<span class="string">&#x27;ymax&#x27;</span>).text))</span><br><span class="line">        bb = convert((w, h), b)</span><br><span class="line">        out_file.write(<span class="built_in">str</span>(cls_id) + <span class="string">&quot; &quot;</span> + <span class="string">&quot; &quot;</span>.join([<span class="built_in">str</span>(a) <span class="keyword">for</span> a <span class="keyword">in</span> bb]) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">wd = getcwd()</span><br><span class="line"><span class="built_in">print</span>(wd)</span><br><span class="line"><span class="keyword">for</span> image_set <span class="keyword">in</span> sets:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&#x27;data/labels/&#x27;</span>):</span><br><span class="line">        os.makedirs(<span class="string">&#x27;data/labels/&#x27;</span>)</span><br><span class="line">    image_ids = <span class="built_in">open</span>(<span class="string">&#x27;data/ImageSets/%s.txt&#x27;</span> % (image_set)).read().strip().split()</span><br><span class="line">    list_file = <span class="built_in">open</span>(<span class="string">&#x27;data/%s.txt&#x27;</span> % (image_set), <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> image_id <span class="keyword">in</span> image_ids:</span><br><span class="line">        list_file.write(<span class="string">&#x27;data/images/%s.jpg\n&#x27;</span> % (image_id))</span><br><span class="line">        convert_annotation(image_id)</span><br><span class="line">    list_file.close()</span><br></pre></td></tr></table></figure><p>在data文件夹下新建立radar.yaml,复制以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">train:</span> <span class="string">data/train.txt</span>  <span class="comment"># train images (relative to &#x27;path&#x27;) 118287 images</span></span><br><span class="line"><span class="attr">val:</span> <span class="string">data/val.txt</span>  <span class="comment"># train images (relative to &#x27;path&#x27;) 5000 images</span></span><br><span class="line"><span class="attr">test:</span> <span class="string">data/test.txt</span>  <span class="comment"># 20288 of 40670 images, submit to https://competitions.codalab.org/competitions/20794</span></span><br><span class="line"></span><br><span class="line"><span class="string">需要修改的就只有下面的Classes与names</span></span><br><span class="line"><span class="comment"># Classes</span></span><br><span class="line"><span class="attr">nc:</span> <span class="number">2</span>  <span class="comment"># number of classes   </span></span><br><span class="line"><span class="attr">names:</span> [<span class="string">&quot;reflector&quot;</span>, <span class="string">&quot;bicycle&quot;</span>]  <span class="comment"># class names</span></span><br></pre></td></tr></table></figure><p>修改models下面的yolov5n.yaml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">nc:</span> <span class="number">2</span>  <span class="comment"># number of classes # 就修改这一个文件参数即可</span></span><br></pre></td></tr></table></figure><p>修改train.py的初始化参数设置，就只用改三个地方，如下图</p><p> <img src="/articleImg/47_article/image1.png" alt="image1"></p><p>下面两个文件，也就是刚刚修改过的两个文件，第一个参数文件，在yolo官网下载即可。</p><h1 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h1><p><img src="/articleImg/47_article/image2.png" alt="image2"></p><p>配置好上面的文件，就可以运行训练了，但是前提是在你已经配置好torch和torchvision等相关环境的条件下。</p><p>从上图的训练得到的训练参数大小可以看到，总大小只有3.9M，确实十分的轻量化，这里再给出我识别角反的结果。</p><p><img src="/articleImg/47_article/image3.png" alt="image3"></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis简介</title>
      <link href="/2021/12/18/Redis%E7%AE%80%E4%BB%8B/"/>
      <url>/2021/12/18/Redis%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><h2 id="什么是redis"><a href="#什么是redis" class="headerlink" title="什么是redis"></a>什么是redis</h2><p>Redis是用C语言开发的一个开源的高性能<strong>键值对（key-value）数据库</strong>，<strong>数据是保存在内存里面的</strong></p><p>Redis支持的键值数据类型如下： </p><ul><li>字符串类型 string(最常用)</li><li>散列类型 hash  </li><li>列表类型 list</li><li>集合类型 set   </li><li>有序集合类型 sortedset</li></ul><h3 id="redis的应用场景"><a href="#redis的应用场景" class="headerlink" title="redis的应用场景"></a>redis的应用场景</h3><ul><li><strong>缓存（数据查询、短连接、新闻内容、商品内容等等）</strong></li><li><strong>任务队列。（秒杀、抢购、12306等等）</strong></li><li><strong>数据过期处理（可以精确到毫秒, 短信验证码)</strong>       </li><li><strong>分布式集群架构中的session分离  session 服务器里面</strong></li><li>聊天室的在线好友列表 </li><li>应用排行榜</li><li><strong>网站访问统计</strong></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>Redis: 由C语言编写的一种NoSQL, 以key-value存在, 数据保存在内存里面 性能特别高</li><li>Redis应用场景<ul><li>缓存(eg: 电商项目里面首页的轮播图)</li><li>队列(eg: 秒杀)</li><li>数据过期处理(eg: 短信验证码…)</li><li>分布式集群架构中的session分离</li></ul></li></ol><p> <img src="/articleImg/46_article/redis.png" alt="redis"></p>]]></content>
      
      
      <categories>
          
          <category> javaweb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jquery与Ajax比较有用的API</title>
      <link href="/2021/12/15/Jquery%E4%B8%8EAjax%E6%AF%94%E8%BE%83%E6%9C%89%E7%94%A8%E7%9A%84API/"/>
      <url>/2021/12/15/Jquery%E4%B8%8EAjax%E6%AF%94%E8%BE%83%E6%9C%89%E7%94%A8%E7%9A%84API/</url>
      
        <content type="html"><![CDATA[<h1 id="Jquery与Ajax比较有用的API"><a href="#Jquery与Ajax比较有用的API" class="headerlink" title="Jquery与Ajax比较有用的API"></a>Jquery与Ajax比较有用的API</h1><h2 id="jQuery的概述"><a href="#jQuery的概述" class="headerlink" title="jQuery的概述"></a>jQuery的概述</h2><p>​    说白了: JQ就是js库, 封装了JS常见的操作,我们使用JS起来更加的简单  (特别是dom这块)</p><h2 id="jQuery的作用"><a href="#jQuery的作用" class="headerlink" title="jQuery的作用"></a>jQuery的作用</h2><p>​    jQuery最主要的作用是简化js的Dom树的操作 </p><h2 id="需要记忆的语法"><a href="#需要记忆的语法" class="headerlink" title="需要记忆的语法"></a>需要记忆的语法</h2><ul><li>JS对象转成jQ对象  ： $(js对象)</li><li>JQ对象转成JS对象  ： JQ对象[下标] 或者 JQ对象.get(下标) 下标一般写0</li><li>基本选择器</li></ul><table><thead><tr><th>选择器名称</th><th>语法</th><th>解释</th></tr></thead><tbody><tr><td>标签选择器（元素选择器）</td><td>$(“html标签名”)</td><td>获得所有匹配标签名称的于元素</td></tr><tr><td>id选择器</td><td>$(“#id的属性值”)</td><td>获得与指定id属性值匹配的元素</td></tr><tr><td>类选择器</td><td>$(“.class的属性值”)</td><td>获得与指定的class属性值匹配的元素</td></tr></tbody></table><ul><li>JQ操作样式</li></ul><table><thead><tr><th>API方法</th><th align="left">解释</th></tr></thead><tbody><tr><td>css(name) 使用很少</td><td align="left">获取CSS样式</td></tr><tr><td>css(name,value)</td><td align="left">设置CSS样式</td></tr><tr><td>addClass(类名)</td><td align="left">给标签添加类名</td></tr><tr><td>removeClass(类名)</td><td align="left">删除标签的类名</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">//目标: 鼠标移入输入框的时候，设置输入框的背景色为红色，移出输入框的时候设置输入框的背景色为蓝色</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 获取标签的css样式的方法: css(样式名) 用的很少</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 设置标签的css样式的方法: css(样式名,样式值),该方法其实就是改变了标签的行内样式</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//$(&quot;#ipt&quot;).css(&quot;background-color&quot;,&quot;red&quot;)</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="comment">//给输入框标签添加类名为&quot;redStyle&quot;</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// addClass(类名)添加类名</span></span></span><br><span class="line"><span class="javascript">            $(<span class="string">&quot;#ipt&quot;</span>).addClass(<span class="string">&quot;redStyle&quot;</span>)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 移除blueStyle类名</span></span></span><br><span class="line"><span class="javascript">            $(<span class="string">&quot;#ipt&quot;</span>).removeClass(<span class="string">&quot;blueStyle&quot;</span>)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//$(&quot;#ipt&quot;).css(&quot;background-color&quot;,&quot;blue&quot;)</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="comment">//给输入框标签添加类名为&quot;blueStyle&quot;</span></span></span><br><span class="line"><span class="javascript">            $(<span class="string">&quot;#ipt&quot;</span>).addClass(<span class="string">&quot;blueStyle&quot;</span>)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="comment">//移除redStyle类名</span></span></span><br><span class="line"><span class="javascript">            $(<span class="string">&quot;#ipt&quot;</span>).removeClass(<span class="string">&quot;redStyle&quot;</span>)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>使用JQ操作DOM</p><table><thead><tr><th>API方法</th><th>解释</th></tr></thead><tbody><tr><td>val([value])</td><td>获得/设置标签里面value属性相应的值</td></tr><tr><td>text([value])</td><td>获得/设置元素的文本内容</td></tr><tr><td>html([value])</td><td>获得/设置元素的标签体内容</td></tr></tbody></table></li><li><p>JQ中事件的使用</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jq对象.事件方法名(function()&#123;&#125;);</span><br><span class="line"></span><br><span class="line">eg:点击事件</span><br><span class="line">btn.click(function()&#123;&#125;);</span><br></pre></td></tr></table></figure><ul><li>JQ遍历</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jquery对象.each(function(index,element)&#123;&#125;);</span><br><span class="line"></span><br><span class="line">其中:(参数名字随便取的)</span><br><span class="line">index:就是元素在集合中的索引</span><br><span class="line">element：就是集合中的每一个元素对象</span><br></pre></td></tr></table></figure><ul><li>jquery的全局方法遍历</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$.each(jquery对象,function(index,element)&#123;&#125;);</span><br><span class="line"></span><br><span class="line">其中，</span><br><span class="line">index:就是元素在集合中的索引</span><br><span class="line">element：就是集合中的每一个元素对象</span><br></pre></td></tr></table></figure><p>详细见：<a href="http://www.jquery.com/">http://www.jquery.com</a></p><h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><p>解释 ：   AJax是可以做异步的请求,实现局部刷新一种客户端技术 。 注意关键词 异步~</p><h2 id="JQ的AJAX介绍"><a href="#JQ的AJAX介绍" class="headerlink" title="JQ的AJAX介绍"></a>JQ的AJAX介绍</h2><h4 id="JQuery的Ajax的API"><a href="#JQuery的Ajax的API" class="headerlink" title="JQuery的Ajax的API"></a>JQuery的Ajax的API</h4><table><thead><tr><th>请求方式</th><th>语法</th></tr></thead><tbody><tr><td><strong>GET请求</strong></td><td>$.get(url, <em>[data]</em>, <em>[callback]</em>, <em>[type]</em>)</td></tr><tr><td><strong>POST请求</strong></td><td>$.post(url, <em>[data]</em>, <em>[callback]</em>, <em>[type]</em>)</td></tr><tr><td><strong>AJAX请求</strong></td><td>$.ajax([settings])</td></tr></tbody></table><h4 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h4><ul><li><p>get方式,  语法    <code>$.get(url, [data], [callback], [type]);</code></p><table><thead><tr><th>参数名称</th><th>解释</th></tr></thead><tbody><tr><td>url</td><td>请求的服务器端url地址</td></tr><tr><td>data</td><td>发送给服务器端的请求参数，格式是key=value；get请求的参数可以直接写在url后面</td></tr><tr><td>callback</td><td>当请求成功后的回掉函数，可以在函数体中编写我们的逻辑代码</td></tr><tr><td>type</td><td>预期的返回数据的类型(默认为text)，取值可以是 xml, html, script, json, text, _defaul等   (最常用json)</td></tr></tbody></table></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个方法使用jQuery的ajax发送异步的get请求</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $.get(<span class="string">&quot;/demo01?username=tom&quot;</span>,<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//在这个回调函数中处理响应数据result</span></span><br><span class="line">        <span class="comment">//将响应数据展示在id为msg的div中</span></span><br><span class="line">        $(<span class="string">&quot;#msg&quot;</span>).html(result)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="post"><a href="#post" class="headerlink" title="post()"></a>post()</h4><ul><li>post方式, 语法 <code>$.post(url, [data], [callback], [type])</code></li></ul><table><thead><tr><th>参数名称</th><th>解释</th></tr></thead><tbody><tr><td>url</td><td>请求的服务器端url地址</td></tr><tr><td>data</td><td>发送给服务器端的请求参数，格式是key=value</td></tr><tr><td>callback</td><td>当请求成功后的回掉函数，可以在函数体中编写我们的逻辑代码</td></tr><tr><td>type</td><td>预期的返回数据的类型(默认为text)，取值可以是 xml, html, script, json, text, _defaul等  (最常用json)</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个方法使用jQuery的ajax方法发送异步请求</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn5</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        <span class="attr">url</span>:<span class="string">&quot;/demo01&quot;</span>, <span class="comment">//请求路径</span></span><br><span class="line">        <span class="attr">data</span>:<span class="string">&quot;username=lucy&quot;</span>, <span class="comment">//请求参数</span></span><br><span class="line">        <span class="attr">type</span>:<span class="string">&quot;POST&quot;</span>, <span class="comment">//请求方式</span></span><br><span class="line">        <span class="attr">success</span>:<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">            $(<span class="string">&quot;#msg&quot;</span>).html(result)</span><br><span class="line">        &#125;, <span class="comment">//请求成功时候的回调函数</span></span><br><span class="line">        <span class="attr">error</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            $(<span class="string">&quot;#msg&quot;</span>).html(<span class="string">&quot;服务器异常&quot;</span>)</span><br><span class="line">        &#125; <span class="comment">//请求失败时候的回调函数</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用Ajax之后，服务器端的代码一般的写法"><a href="#使用Ajax之后，服务器端的代码一般的写法" class="headerlink" title="使用Ajax之后，服务器端的代码一般的写法"></a>使用Ajax之后，服务器端的代码一般的写法</h2><p> <img src="/articleImg/45_article/mycode.png" alt="mycode"></p><p>自己学后端起步有点晚了，不过我相信，兴趣决定高度，努力决定程度，加油吧~摩托！</p>]]></content>
      
      
      <categories>
          
          <category> javaweb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsp提交form表单到servlet，但取值全为空？</title>
      <link href="/2021/12/15/jsp%E6%8F%90%E4%BA%A4form%E8%A1%A8%E5%8D%95%E5%88%B0servlet%EF%BC%8C%E4%BD%86%E5%8F%96%E5%80%BC%E5%85%A8%E4%B8%BA%E7%A9%BA%EF%BC%9F/"/>
      <url>/2021/12/15/jsp%E6%8F%90%E4%BA%A4form%E8%A1%A8%E5%8D%95%E5%88%B0servlet%EF%BC%8C%E4%BD%86%E5%8F%96%E5%80%BC%E5%85%A8%E4%B8%BA%E7%A9%BA%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="jsp提交form表单到servlet，但取值全为空？"><a href="#jsp提交form表单到servlet，但取值全为空？" class="headerlink" title="jsp提交form表单到servlet，但取值全为空？"></a>jsp提交form表单到servlet，但取值全为空？</h1><p>1.检查你的jsp页面</p><p>（1）当你提交表单到servlet时，当要获取表单的值是，request.getParameter(“（form表单中的name属性的值）”) 所以form表单提交的数据都用控件的name而不是id来控制的，浏览器会根据name来设定发送到服务器的request。因此如果用id，服务器是无 法得到数据的。 所以你需要检查你的form表单中是否忘记写name属性了？</p><p>3.检查jsp跳转到servlet的过程</p><p>jsp提交的方式是post，但是我却在doGet(HttpServletRequest request, HttpServletResponse response)里写代码 doPost方法里啥都没有 数据怎么可能会过去呢？所以粗心呀</p><p>有两种方法可以解决：</p><ul><li>把doGet方法里面的代码放在doPost里就可以了</li><li>也可以在doGet方法里写代码 但是需要在doPost方法里加一句代码：doGet(request, response);</li></ul><p> <img src="/articleImg/44_article/mecode.png" alt="mecode"></p>]]></content>
      
      
      <categories>
          
          <category> javaweb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JetsonNano配置IntelD455深度相机</title>
      <link href="/2021/11/21/JetsonNano%E9%85%8D%E7%BD%AEIntelD455%E6%B7%B1%E5%BA%A6%E7%9B%B8%E6%9C%BA/"/>
      <url>/2021/11/21/JetsonNano%E9%85%8D%E7%BD%AEIntelD455%E6%B7%B1%E5%BA%A6%E7%9B%B8%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Jetson-Nano配置Intel-D455深度相机"><a href="#Jetson-Nano配置Intel-D455深度相机" class="headerlink" title="Jetson Nano配置Intel D455深度相机"></a>Jetson Nano配置Intel D455深度相机</h1><p>首先我要说明为什么这么耽误时间，4天…</p><p>第一：git clone很慢 （后续已被解决）</p><p>第二：安装失败时，我就重装了NANO的镜像，担心旧文件会对下一次的重新编译产生影响</p><p>第三：编译的速度很慢，每次编译结束都需要两个钟左右！</p><p>第四：自己尝试很多其他方案，最终才works! </p><p>费了老鼻子劲了，才把这这东西配置好，嵌入式工程师不好当啊~</p><p>贴出Nvidia官网的安装指导，我安装官网的方式1，即按包去安装，试了几次，每次都不行，UI界面都出来了，但是就是连接不上D455相机。俺也不知道这是为啥，有可能是D455是一款较新的产品吧，相对于D435。（最后得解，源码编译大法解决问题）</p><p> <img src="/articleImg/43_article/meStereo.gif" alt="meStereo"></p><h2 id="在源码编译的过程中，会遇到git-clone相关包，git不下来的现象（先进行这一步！）"><a href="#在源码编译的过程中，会遇到git-clone相关包，git不下来的现象（先进行这一步！）" class="headerlink" title="在源码编译的过程中，会遇到git clone相关包，git不下来的现象（先进行这一步！）"></a>在源码编译的过程中，会遇到git clone相关包，git不下来的现象（先进行这一步！）</h2><p>自己尝试ssr(shadowsocks)与proxychains为nano开代理去git clone，无奈失败，不知道问题出在哪里，后续有时间了可以再排查一下。时间紧任务重，不能死磕！</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>直接在windows上git cone，把这两个包都放到build文件夹下的third-party文件夹下<strong>（尤其注意文件根目录下也有一个thirty-party文件夹，不要放错了）</strong>。然后再把源码cmakelist中的git  clone都注释掉。</p><p>**pybind11 **：git clone <a href="https://github.com/pybind/pybind11.git">https://github.com/pybind/pybind11.git</a></p><p>注释掉 ~/librealsense/third-party文件夹下的pybind11中cmakelist中的git clone <a href="https://github.com/pybind/pybind11.git">https://github.com/pybind/pybind11.git</a></p><p><strong>libcurl</strong>:<a href="https://github.com/curl/curl"> https://github.com/curl/curl </a></p><p>注释掉 ~/librealsense/CMake 文件下的 external_libcurl.cmake 的 GIT_REPOSITORY “git://github.com/curl/curl.git” 。</p><p>并将提前下载后的 curl.zip 解压后 改名为 <strong>libcurl</strong> ，放入到 ~/librealsense/build/third-party。</p><h2 id="尝试源码编译"><a href="#尝试源码编译" class="headerlink" title="尝试源码编译"></a>尝试源码编译</h2><p>经历了按包安装的失败之后，自己便乖乖的去源码编译了。</p><p>源码地址：<a href="https://github.com/JetsonHacksNano/installLibrealsense">https://github.com/JetsonHacksNano/installLibrealsense</a>  直接下载zip即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>:运行udev脚本</span><br><span class="line">    cd librealsense</span><br><span class="line">    ./scripts/setup_udev_rules.sh</span><br><span class="line">    echo <span class="string">&#x27;hid_sensor_custom&#x27;</span> | sudo tee -a /etc/modules</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>：添加环境变量，也可直接添加到bashrc</span><br><span class="line">    export CUDA_HOME=/usr/local/cuda-<span class="number">10.2</span></span><br><span class="line">    export LD_LIBRARY_PATH=/usr/local/cuda-<span class="number">10.2</span>/lib64:$LD_LIBRARY_PATH</span><br><span class="line">    export PATH=/usr/local/cuda-<span class="number">10.2</span>/<span class="built_in">bin</span>:$PATH</span><br><span class="line">        </span><br><span class="line">    source一下</span><br><span class="line">    </span><br><span class="line"><span class="number">3</span>:编译</span><br><span class="line">    mkdir build</span><br><span class="line">    </span><br><span class="line">    cd build</span><br><span class="line">    </span><br><span class="line">    cmake ../ -DBUILD_PYTHON_BINDINGS:<span class="built_in">bool</span>=true -DPYTHON_EXECUTABLE=/home/bingda/archiconda3/envs/py36/<span class="built_in">bin</span>/python -DBUILD_WITH_CUDA=true  （注意我这里用的python环境是Archiconda中envs的py36）</span><br><span class="line">    </span><br><span class="line">    sudo make uninstall &amp;&amp; make clean</span><br><span class="line">    make -j4   <span class="comment">#多核make的时候会报错，可选择直接单核$make 这里尝试 j2</span></span><br><span class="line">    sudo make install</span><br><span class="line">    </span><br><span class="line"><span class="number">4</span>：添加环境变量 vim ~/.bashrc</span><br><span class="line">export PYTHONPATH=$PYTHONPATH:/usr/local/lib:/usr/local/lib/python3<span class="number">.6</span>/pyrealsense2</span><br></pre></td></tr></table></figure><p>验证是否编译成功：终端运行 realsense-viewer 即有相关的UI界面展示出来。</p><h2 id="源码编译之后，会发现在python环境下无法使用pyrealsense2包"><a href="#源码编译之后，会发现在python环境下无法使用pyrealsense2包" class="headerlink" title="源码编译之后，会发现在python环境下无法使用pyrealsense2包"></a>源码编译之后，会发现在python环境下无法使用pyrealsense2包</h2><p>这个问题也困扰了我一天，这里一共要进行两步解决：</p><p>第一： 在python文件下添加 该句代码，因为pyrealsense2包在该路径下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sys.path.append(&#x27;/usr/local/lib/python3.6/&#x27;)</span><br></pre></td></tr></table></figure><p>经过该步之后，发现可以import pyrealsense2 包了，但是其中的相关API功能均无法使用。</p><p>第二：将下述的三个.so文件，copy到python代码所在的路径（路径，文件名会随着你的环境可能不太一样）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib/python3.6/pyrealsense2/pyrealsense2.cpython-36m-aarch64-linux-gnu.so</span><br><span class="line">/usr/lib/python3.6/pyrealsense2/pyrealsense2.cpython-36m-aarch64-linux-gnu.so.2.49</span><br><span class="line">/usr/lib/python3.6/pyrealsense2/pyrealsense2.cpython-36m-aarch64-linux-gnu.so.2.49.0</span><br></pre></td></tr></table></figure><p>经过上述的两不，便可以正常使用pyrealsense2包的相关功能了~</p><p>终于大功告成！！！！！！！！很多问题也都是靠自己尝试得出的解决方案，在网络上没有百分百切合我问题的答案，所以还是蛮有成就感的~</p>]]></content>
      
      
      <categories>
          
          <category> JetsonNano </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Intel D455 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JetsonNano重装系统</title>
      <link href="/2021/11/21/JetsonNano%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/"/>
      <url>/2021/11/21/JetsonNano%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="Jetson-Nano-重装系统"><a href="#Jetson-Nano-重装系统" class="headerlink" title="Jetson Nano 重装系统"></a>Jetson Nano 重装系统</h1><p>最近在装intel的D455相机到jetson nano，是用的SD卡装系统的。当nano中的ubuntu系统环境被我装乱时，<br>我就想重新装系统，所以遇到需要重新格式化的问题。遇到的问题与下图：</p><p><img src="/articleImg/42_article/U%E7%9B%98.png" alt="U盘"></p><p>根本格式化不过来，只能通过终端操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cmd命令行，依次如下命令：</span><br><span class="line"></span><br><span class="line">diskpart</span><br><span class="line"></span><br><span class="line">list disk</span><br><span class="line"></span><br><span class="line">select disk 2*#一定要选对硬盘设备，要不然....* </span><br><span class="line"></span><br><span class="line">clean</span><br></pre></td></tr></table></figure><p>格式化SD卡之后可以通过，此电脑–管理—磁盘管理  进行对SD卡的从新分配磁盘空间。</p><p>ok~</p>]]></content>
      
      
      <categories>
          
          <category> JetsonNano </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 格式化SD卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以nano为载体的Ubuntu系统的各种下载源配置</title>
      <link href="/2021/11/21/%E4%BB%A5nano%E4%B8%BA%E8%BD%BD%E4%BD%93%E7%9A%84Ubuntu%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%84%E7%A7%8D%E4%B8%8B%E8%BD%BD%E6%BA%90%E9%85%8D%E7%BD%AE/"/>
      <url>/2021/11/21/%E4%BB%A5nano%E4%B8%BA%E8%BD%BD%E4%BD%93%E7%9A%84Ubuntu%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%84%E7%A7%8D%E4%B8%8B%E8%BD%BD%E6%BA%90%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="以nano为载体的Ubuntu系统的各种下载源配置"><a href="#以nano为载体的Ubuntu系统的各种下载源配置" class="headerlink" title="以nano为载体的Ubuntu系统的各种下载源配置"></a>以nano为载体的Ubuntu系统的各种下载源配置</h1><h2 id="安装Archiconda3"><a href="#安装Archiconda3" class="headerlink" title="安装Archiconda3"></a>安装Archiconda3</h2><p>下载地址：<a href="https://github.com/Archiconda/build-tools">https://github.com/Archiconda/build-tools</a></p><p>到release中找对应的版本就可以了</p><h2 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit ~/.bashrc </span><br><span class="line"></span><br><span class="line">export CUDA_HOME=/usr/local/cuda-10.2</span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/cuda-10.2/lib64:$LD_LIBRARY_PATH</span><br><span class="line">export PATH=/usr/local/cuda-10.2/bin:$PATH</span><br><span class="line"></span><br><span class="line">source一下</span><br></pre></td></tr></table></figure><h2 id="启动脚本"><a href="#启动脚本" class="headerlink" title="启动脚本"></a>启动脚本</h2><p>chmod a+x  -xxx.sh<br>./Archiconda-xxx.sh</p><h2 id="再次添加环境变量"><a href="#再次添加环境变量" class="headerlink" title="再次添加环境变量"></a>再次添加环境变量</h2><p>安装conda之后如果找不见，需要添加环境变量，方法如下：</p><p>（1）：sudo gedit~/.bashrc </p><p>（2）：export PATH=~/archiconda3/bin:$PATH</p><h2 id="更换conda源"><a href="#更换conda源" class="headerlink" title="更换conda源"></a>更换conda源</h2><p>conda 换源（清华源只能用http）</p><h3 id="方式1：通过终端添加"><a href="#方式1：通过终端添加" class="headerlink" title="方式1：通过终端添加"></a>方式1：通过终端添加</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/</span><br><span class="line"></span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure><p>如果需要删除某个通道的源，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config –remove channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br></pre></td></tr></table></figure><h3 id="方式二：通过文件写入添加"><a href="#方式二：通过文件写入添加" class="headerlink" title="方式二：通过文件写入添加"></a>方式二：通过文件写入添加</h3><p>sudo gedit ~/.condarc  （实测中该种方法表现并不佳，最终采用的是方式一去添加）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">channels:</span><br><span class="line">  - defaults</span><br><span class="line">show_channel_urls: true</span><br><span class="line">default_channels:</span><br><span class="line">  - http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</span><br><span class="line">  - http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r</span><br><span class="line">  - http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2</span><br><span class="line">custom_channels:</span><br><span class="line">  conda-forge: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  msys2: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  bioconda: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  menpo: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  pytorch: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  simpleitk: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br></pre></td></tr></table></figure><h2 id="更换apt源"><a href="#更换apt源" class="headerlink" title="更换apt源"></a><strong>更换apt源</strong></h2><p>配置文件进行备份</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure><p>如果需要<strong>恢复原来的配置文件</strong>，只需要用备份的配置文件覆盖原来的配置文件即可，命令如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list.bak /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>使用gedit打开source.list文件，命令如下（ubuntu18.04）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/apt/sources.list</span><br><span class="line">粘贴如下内容</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后更软件源，完成配置apt源。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><h2 id="更换pip源"><a href="#更换pip源" class="headerlink" title="更换pip源"></a><strong>更换pip源</strong></h2><p>方法一：在用户路径下创建.pip/pip.conf文件，因为执行pip命令时，会先运行~/.pip/pip.conf文件，命令如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/.pip</span><br><span class="line">sudo gedit ~/.pip/pip.conf</span><br></pre></td></tr></table></figure><p>将下面的命令添加到pip.conf文件中，点击保存，即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = http://pypi.douban.com/simple</span><br><span class="line">trusted-host = pypi.douban.com</span><br></pre></td></tr></table></figure><p>方法二 ：在pip时指定即可 （经常使用该方法）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install 包名  -i http://pypi.mirrors.ustc.edu.cn/simple/  --trusted-host pypi.mirrors.ustc.edu.cn</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JetsonNano </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/2021/10/25/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2021/10/25/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题（即所谓的并、查）。比如说，我们可以用并查集来判断一个森林中有几棵树、某个节点是否属于某棵树等。</p><h2 id="主要构成："><a href="#主要构成：" class="headerlink" title="主要构成："></a>主要构成：</h2><p>并查集主要由一个整型数组pre[ ]和两个函数getFather( )、merge( )构成。<br>数组 pre[ ] 记录了每个点的前驱节点是谁，函数 getFather(x)（路径压缩算法）用于查找指定节点 x 属于哪个集合（即找到当前节点最终的根节点），函数 merge(x,y) 用于合并两个节点 x 和 y 。</p><h2 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h2><p>并查集的主要作用是求连通分支数（如果一个图中所有点都存在可达关系（直接或间接相连），则此图的连通分支数为1；如果此图有两大子图各自全部可达，则此图的连通分支数为2……）</p><h2 id="求犯罪团伙题目"><a href="#求犯罪团伙题目" class="headerlink" title="求犯罪团伙题目"></a>求犯罪团伙题目</h2><h2 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h2><p>现在有10个强盗。<br>1号强盗与2号强盗是同伙。3号强盗与4号强盗是同伙。</p><p>5号强盗与2号强盗是同伙。4号强盗与6号强盗是同伙。</p><p>2号强盗与6号强盗是同伙。8号强盗与7号强盗是同伙。</p><p>9号强盗与7号强盗是同伙。1号强盗与6号强盗是同伙。</p><p>2号强盗与4号强盗是同伙。</p><p>请分析一共有多少个犯罪团伙。</p><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>初始化原则：pre[ ]数组的初始化节点是其本身编号，这很重要，一定要先初始化，在进行后续的操作。</p><p>靠左原则：所给线索中，左边强盗比较强势，让右边强盗归顺左边。</p><p>擒贼先擒王原则：每次需要合并节点时，比较要找到当前节点的根节点，将两个根节点进行合并。另外，在找根的过程中要本着<strong>路径压缩</strong>的思想，即：<strong>把找父过程中，所有的中间点，包括起始点的父都设为最终找到的根节点</strong>。</p><p>路径压缩可以用递归实现，也可以用栈实现。</p><p>java的实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckandSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[]pre = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">12</span>];<span class="comment">//用1~11去表示抓获的11个嫌疑人</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][]clue = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">2</span>&#125;,&#123;<span class="number">4</span>,<span class="number">6</span>&#125;,&#123;<span class="number">2</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">11</span>&#125;,&#123;<span class="number">8</span>,<span class="number">7</span>&#125;,&#123;<span class="number">9</span>,<span class="number">7</span>&#125;,&#123;<span class="number">9</span>,<span class="number">11</span>&#125;,&#123;<span class="number">1</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CheckandSet checkandSet = <span class="keyword">new</span> CheckandSet();</span><br><span class="line">        <span class="comment">//一定要对tree矩阵进行初始化，刚开始忘记了</span></span><br><span class="line">        checkandSet.init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; checkandSet.clue.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> leftF = checkandSet.getFather2(checkandSet.clue[i][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> rightF = checkandSet.getFather2(checkandSet.clue[i][<span class="number">1</span>]);</span><br><span class="line">            checkandSet.merge(leftF,rightF);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(checkandSet.pre));</span><br><span class="line">        System.out.printf(<span class="string">&quot;由上述的结果可得，一共有%d个犯罪团伙&quot;</span>,checkandSet.getAnswer2());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//啊哈算法上的求犯罪团伙的函数为</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getAnswer2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pre.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(pre[i] == i)</span><br><span class="line">                answer++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getAnswer</span><span class="params">()</span></span>&#123; <span class="comment">//从经过并查集算法的数组中，获取一共有多少个犯罪团伙</span></span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; rootStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pre.length; i++) &#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(rootStack.isEmpty())&#123;</span><br><span class="line">                rootStack.push(pre[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> size = rootStack.size();</span><br><span class="line">                <span class="keyword">for</span> (Integer integer : rootStack) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (integer == getFather(i)) &#123;</span><br><span class="line">                        flag = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            rootStack.push(getFather(i));</span><br><span class="line">            answer++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123; <span class="comment">//将两个节点合并，遵循靠左原则</span></span><br><span class="line">        <span class="comment">//i代表左边节点  j代表右边节点</span></span><br><span class="line">        pre[j] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//啊哈算法上的求根部的父节点，在更新中间值时，我用的是栈：先记录，在更新   啊哈算法上用的是递归</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getFather2</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123; <span class="comment">//擒贼先擒王</span></span><br><span class="line">        <span class="keyword">if</span>(pre[num] == num)</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        pre[num] = getFather2(pre[num]);</span><br><span class="line">        <span class="keyword">return</span> pre[num];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getFather</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123; <span class="comment">//擒贼先擒王</span></span><br><span class="line">        Stack&lt;Integer&gt; NumStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> temp = num;</span><br><span class="line">        <span class="keyword">while</span>(pre[temp] != temp)&#123;</span><br><span class="line">            NumStack.add(temp);</span><br><span class="line">            temp = pre[temp];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把找父过程中，所有的中间点，包括起始点的父都设为最终找到的根节点</span></span><br><span class="line">        <span class="keyword">while</span>(!NumStack.isEmpty())&#123;</span><br><span class="line">            Integer pop = NumStack.pop();</span><br><span class="line">            pre[pop] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp; <span class="comment">//返回这轮找到的根父</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pre.length; i++) &#123;</span><br><span class="line">            pre[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的运行结果如下</p><p><img src="/articleImg/40_article/image1.png" alt="image1"></p><p>继续加油~</p><p>最近要准备开题了，希望自己能顺利。锦鲤附体！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集找祖先 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树--堆排序</title>
      <link href="/2021/10/25/%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>/2021/10/25/%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树–堆排序"><a href="#二叉树–堆排序" class="headerlink" title="二叉树–堆排序"></a>二叉树–堆排序</h1><p>二叉树可以用链表表示，也可以用数组去模拟。本次博客实现的算法主要是依赖数组模拟的完全二叉树，去进行堆排序。</p><h2 id="数组模拟完全二叉树的一些特点"><a href="#数组模拟完全二叉树的一些特点" class="headerlink" title="数组模拟完全二叉树的一些特点"></a>数组模拟完全二叉树的一些特点</h2><p> <img src="/articleImg/39_article/image1.png" alt="image1"></p><ul><li><p>通过上图我们发现，如果完全二叉树的一个父结点编号为k，那么它左儿子的编号就是2<em>k，右儿子的编号就是2</em>k+1。如果已知儿子（左儿子或右儿子）的编号是x，那么它父结点的编号就是x/2，注意这里只取商的整数部分。在java、C中，如果除号“”两边都是整数的话，那么商也只有整数部分（即自动向下取整)，即4/2和5/2都是2。</p></li><li><p>另外如果一棵完全二叉树有N个结点，那么这个完全二叉树的高度为logzN，简写为 log N，即最多有 log N层结点。完全二叉树的最典型应用就是——堆。</p></li><li><p>就是所有父结点都比子结点要小 (注意:圆圈里面的数是值，圆圈上面的数是这个结点的编号)。符合这样特点的完全二叉树我们称为最小堆。反之，如果所有父结点都比子结点要大，这样的完全二叉树称为最大堆。那这一特性究竟有什么用呢?下面举例一个最小堆</p></li></ul><p> <img src="/articleImg/39_article/image2.png" alt="image2"></p><h2 id="堆排序思想"><a href="#堆排序思想" class="headerlink" title="堆排序思想"></a>堆排序思想</h2><p><strong>最小堆排序</strong>：每次将根节点的元素值输出，然后将最后一个叶子节点的元素值放到根节点，然后堆节点总数减1，最后向下调整元素。</p><p> <img src="/articleImg/39_article/graph1.png" alt="graph1"></p><p><strong>最大堆排序</strong>：每次将根节点的元素值与最后一个叶子节点的元素值进行互换，然后堆节点总数减1,最后向下调整元素。流程图和最小堆的异曲同工，这里就不画流程图了。</p><h2 id="堆排序代码"><a href="#堆排序代码" class="headerlink" title="堆排序代码"></a>堆排序代码</h2><p>在最小堆排序中需要的函数有：根据数组元素创建最小堆、将节点元素值较大的向下调整位置。</p><p>在最大堆排序中需要的函数有：根据数组元素创建最小堆、将节点元素值较小的向下调整位置。</p><p>另外在创建最小最大堆时，也可以从n/2节点处，向下调整元素，因为我们从最后一个结点开始，依次判断以这个结点为根的子树是否符合最小堆的特性。如果所有的子树都符合最小堆的特性，那么整棵树就是最小堆了。<strong>注意完全二叉树有一个性质:最后一个非叶结点是第n/2个结点。</strong></p><p>相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">heapsort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] binaryTree = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>; <span class="comment">//表示二叉树中的节点个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            heapsort Heapsort = <span class="keyword">new</span> heapsort();</span><br><span class="line">            Heapsort.binaryTree = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,<span class="number">23</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">17</span>,<span class="number">25</span>,<span class="number">19</span>,<span class="number">36</span>,<span class="number">99</span>,<span class="number">22</span>,<span class="number">28</span>,<span class="number">46</span>,<span class="number">92</span>&#125;; <span class="comment">//注意binaryTree是从下表1开始保存数据的，切记这里面有一个-1</span></span><br><span class="line">            Heapsort.num = <span class="number">14</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;排序之前：&quot;</span>+Arrays.toString(Heapsort.binaryTree));</span><br><span class="line">            Heapsort.heapsortFun(Heapsort.binaryTree,Heapsort.num);<span class="comment">//利用最小堆排序</span></span><br><span class="line">            <span class="comment">//Heapsort.heapsortFun2(Heapsort.binaryTree,Heapsort.num); //利用最大堆排序</span></span><br><span class="line">            System.out.println(<span class="string">&quot;排序之后：&quot;</span>+Arrays.toString(Heapsort.binaryTree));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapsortFun2</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> nodeNum)</span></span>&#123; <span class="comment">//堆排序函数，最大堆排序</span></span><br><span class="line">            <span class="keyword">this</span>.BuildMaximumHeap(arr,nodeNum);</span><br><span class="line">            System.out.println(<span class="string">&quot;最大堆：&quot;</span>+Arrays.toString(arr));</span><br><span class="line">            <span class="keyword">int</span> copyNodeNum = nodeNum;</span><br><span class="line">            <span class="keyword">while</span>(copyNodeNum&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.swap(<span class="number">1</span>,copyNodeNum,arr);</span><br><span class="line">                copyNodeNum--; <span class="comment">//先减，因为最后一个叶子节点上的数就是我们想要的排序数，不动它</span></span><br><span class="line">                <span class="keyword">this</span>.siftDownMax(<span class="number">1</span>,arr,copyNodeNum); <span class="comment">//再调整</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapsortFun</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> nodeNum)</span></span>&#123; <span class="comment">//堆排序函数，最小堆排序</span></span><br><span class="line">        <span class="comment">//主要思想：可以先建立最小堆，然后每次删除顶部元素并将顶部元素输出或者放入一个新的数组中，直到堆为空为止。</span></span><br><span class="line">        <span class="comment">// 最终输出的或者存放在新数组中的数就已经是排序好的了。</span></span><br><span class="line">        <span class="keyword">this</span>.BuildMinimumHeap2(); <span class="comment">//将此时的二叉树，转化为最小堆</span></span><br><span class="line">        <span class="keyword">int</span>[] CopyBinaryTree = <span class="keyword">new</span> <span class="keyword">int</span>[nodeNum+<span class="number">1</span>]; <span class="comment">//copy一下最小堆，不然最后转化，会破环原最小堆</span></span><br><span class="line">        System.arraycopy(arr, <span class="number">0</span>, CopyBinaryTree, <span class="number">0</span>, CopyBinaryTree.length);</span><br><span class="line">        System.out.println(<span class="string">&quot;最小堆：&quot;</span>+Arrays.toString(arr));</span><br><span class="line">        <span class="keyword">int</span> copyNum = nodeNum;</span><br><span class="line">        <span class="keyword">while</span>(copyNum&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//System.out.print(CopyBinaryTree[1]+&quot; &quot;);</span></span><br><span class="line">            CopyBinaryTree[<span class="number">1</span>] = CopyBinaryTree[copyNum];</span><br><span class="line">            copyNum--;</span><br><span class="line">            <span class="keyword">this</span>.siftDownMin(<span class="number">1</span>,CopyBinaryTree,copyNum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BuildMaximumHeap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> NodeNum)</span></span>&#123; <span class="comment">//建立最大堆</span></span><br><span class="line">        <span class="comment">//这里也是有两种建立方式，1：边插入元素，边调整元素 2：等元素全部插入完毕，调整节点即可。</span></span><br><span class="line">        <span class="comment">//这里选择第二种方式</span></span><br><span class="line">        <span class="keyword">int</span> copyNum = NodeNum;</span><br><span class="line">        <span class="keyword">while</span>(copyNum&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">            siftUpMax(copyNum,arr);</span><br><span class="line">            copyNum--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BuildMinimumHeap</span><span class="params">()</span></span>&#123; <span class="comment">//建立最小堆</span></span><br><span class="line">        <span class="comment">//每次将元素插入二叉树的末端，然后再把该元素向上调整即可</span></span><br><span class="line">        <span class="keyword">int</span> []standByArray = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">99</span>,<span class="number">5</span>,<span class="number">36</span>,<span class="number">7</span>,<span class="number">22</span>,<span class="number">17</span>,<span class="number">92</span>,<span class="number">12</span>,<span class="number">2</span>,<span class="number">19</span>,<span class="number">25</span>,<span class="number">28</span>,<span class="number">1</span>,<span class="number">46</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; standByArray.length; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.binaryTree[i+<span class="number">1</span>] = standByArray[i];</span><br><span class="line">            <span class="keyword">this</span>.siftUpMin(i+<span class="number">1</span>,<span class="keyword">this</span>.binaryTree);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BuildMinimumHeap2</span><span class="params">()</span></span>&#123; <span class="comment">//建立最小堆</span></span><br><span class="line">        <span class="comment">//我们从最后一个非叶子结点开始，依次判断以这个结点为根的子树是否符合最小堆的特性。</span></span><br><span class="line">        <span class="comment">// 如果所有的子树都符合最小堆的特性，那么整棵树就是最小堆了。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = num/<span class="number">2</span>; i &gt;=<span class="number">1</span> ; i--) &#123;</span><br><span class="line">            siftDownMin(i,binaryTree,<span class="keyword">this</span>.num); <span class="comment">//将binaryTree从num/2节点处开始调整</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最小堆,将上面较大的节点向下调整</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownMin</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span>[]arr,<span class="keyword">int</span> curNum)</span></span>&#123; <span class="comment">//传入一个需要向下调整的节点编号i，最小堆的节点个数，,以及对应的模拟二叉树</span></span><br><span class="line">        <span class="keyword">int</span> temp = i;</span><br><span class="line">        <span class="comment">//注意这里的num可能会变</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">2</span>*i&lt;=curNum)&#123; <span class="comment">//注意binaryTree是从下表1开始保存数据的，所以这里带等于</span></span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;arr[<span class="number">2</span>*i])&#123;</span><br><span class="line">                temp = <span class="number">2</span>*i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">2</span>*i+<span class="number">1</span>&lt;=curNum)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[temp]&gt;arr[<span class="number">2</span>*i+<span class="number">1</span>])</span><br><span class="line">                     temp = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp == i)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">this</span>.swap(i,temp,arr);</span><br><span class="line">            i = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大堆,将上面较小的节点向下调整</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownMax</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span>[]arr,<span class="keyword">int</span> curNum)</span></span>&#123; <span class="comment">//传入一个需要向下调整的节点编号i，最小堆的节点个数，,以及对应的模拟二叉树</span></span><br><span class="line">        <span class="keyword">int</span> temp = i;</span><br><span class="line">        <span class="comment">//注意这里的num可能会变</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">2</span>*i&lt;=curNum)&#123; <span class="comment">//注意binaryTree是从下表1开始保存数据的，所以这里带等于</span></span><br><span class="line">            <span class="keyword">if</span>(arr[i]&lt;arr[<span class="number">2</span>*i])&#123;</span><br><span class="line">                temp = <span class="number">2</span>*i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">2</span>*i+<span class="number">1</span>&lt;=curNum)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[temp]&lt;arr[<span class="number">2</span>*i+<span class="number">1</span>])</span><br><span class="line">                    temp = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp == i)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">this</span>.swap(i,temp,arr);</span><br><span class="line">            i = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最小堆,将下面较小的节点向上调整</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpMin</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span>[] arr)</span></span>&#123; <span class="comment">//传入一个需要向上调整的节点编号，,以及对应的模拟二叉树</span></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            temp = i;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt; arr[i/<span class="number">2</span>])&#123;</span><br><span class="line">                swap(i,i/<span class="number">2</span>,arr);</span><br><span class="line">                i = i/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp == i)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大堆,将下面较大的节点向上调整</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpMax</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span>[] arr)</span></span>&#123; <span class="comment">//传入一个需要向上调整的节点编号，,以及对应的模拟二叉树</span></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            temp = i;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[i/<span class="number">2</span>])&#123;</span><br><span class="line">                swap(i,i/<span class="number">2</span>,arr);</span><br><span class="line">                i = i/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp == i)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j,<span class="keyword">int</span> []arr)</span></span>&#123; <span class="comment">//交换binaryTree中 i 位置 和j 位置的元素,以及对应的模拟二叉树</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面程序的注释也写得蛮清楚的，最重要的还是要理解算法的思想。</p><p>继续加油吧~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图最短路径--贝尔曼福特算法Bellman-Ford</title>
      <link href="/2021/10/25/%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-%E8%B4%9D%E5%B0%94%E6%9B%BC%E7%A6%8F%E7%89%B9%E7%AE%97%E6%B3%95Bellman-Ford/"/>
      <url>/2021/10/25/%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-%E8%B4%9D%E5%B0%94%E6%9B%BC%E7%A6%8F%E7%89%B9%E7%AE%97%E6%B3%95Bellman-Ford/</url>
      
        <content type="html"><![CDATA[<h1 id="图最短路径–贝尔曼福特算法Bellman-Ford"><a href="#图最短路径–贝尔曼福特算法Bellman-Ford" class="headerlink" title="图最短路径–贝尔曼福特算法Bellman-Ford"></a>图最短路径–贝尔曼福特算法Bellman-Ford</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近几天学习算法的状态一般是晚上看算法思想，第二天上午或则下午自己动手实现算法，之后与算法书上的代码进行对比，学习别人优秀简洁的思路，然后整理到博客上。我感觉这样的学习效果还可以。因为这样的话，同一个算法我可以在不同的时间进行回顾。加深了印象~ 在对比代码的时候，确实发现了很多别人优秀的代码，让自己蠢蠢欲动，想要把那种思想吸收到自己身上！这也许就是代码之美吧哈哈哈，来自1024节的快乐~~</p><p>下面我对今天的博客内容进行记录备忘</p><p>对了，最近学习的是《啊哈算法》里面的内容，所以大部分实现的算法都是里面的。</p><h2 id="贝尔曼福特算法思想介绍"><a href="#贝尔曼福特算法思想介绍" class="headerlink" title="贝尔曼福特算法思想介绍"></a>贝尔曼福特算法思想介绍</h2><ul><li><p>Dijkstra算法虽然好，但是它不能解决带有负权边(边的权值为负数)的图。Bellman-Ford算法非常简单，核心代码只有4行，并且可以完美地解决带有负权边的图。</p></li><li><p>贝尔曼福特算法中图的表示用的是邻接表。</p></li></ul><p>核心代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (k=<span class="number">1</span>;k&lt;=n-<span class="number">1</span>;k++) <span class="comment">//只需要进行n-1轮就可以了。因为在一个含有n个顶点的图中，任意两点之间的最短路径最多包含n-1边。</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++) <span class="comment">//m代表边的个数，即枚举每一条边</span></span><br><span class="line"><span class="keyword">if</span>(dis[v[i]] &gt;dis[u[i]] + w[i])</span><br><span class="line">dis[v[i]] = dis [u[i]]+w[i];</span><br><span class="line"><span class="comment">//其中余u、v和w三个数组是用来记录边的信息。例如第i条边存储在u[i]、v[i]和 w[i]中，表示从顶点u[i]到顶点[i]这条边上u[i]到v[i]权值为w[i]。</span></span><br></pre></td></tr></table></figure><ul><li>上面条件判断的两行代码意思是:看看能否通过u[i]→v[ i ] (权值为w[i]）这条边，使得1号顶点到v[i]号顶点的距离变短。即1号顶点到u[i]号顶点的距离（dis[u[i]]）加上u[i]→v[i]这条边（权值为w[i])的值是否会比原先1号顶点到v[i]号顶点的距离(dis[v[i]]）要小。<strong>这一点其实与Dijkstra的“松弛”操作是一样的</strong>。现在我们要把所有的边都松弛一遍，上述的代码是进行了n-1轮松弛操作。</li></ul><h2 id="算法图解"><a href="#算法图解" class="headerlink" title="算法图解"></a>算法图解</h2><p> <img src="/articleImg/38_article/image1.jpg" alt="image1"></p><p>Bellman-Ford算法经常会在未达到n-1轮松弛前就已经计算出最短路，因为n-1其实是最大值。因此可以添加一个一维数组用来备份数组dis。如果在新一轮的松弛中数组dis没有发生变化，则可以提前跳出循环。</p><h2 id="未使用队列优化的代码"><a href="#未使用队列优化的代码" class="headerlink" title="未使用队列优化的代码"></a>未使用队列优化的代码</h2><p>用java实现的算法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//贝尔曼福特算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BellmanFord</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> []first = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>]; <span class="comment">//代表第i个节点的第一条出边</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> []next = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>]; <span class="comment">//代表第j条边的下一条出边, 切记这里的出边仍然是属于第i个节点的出边</span></span><br><span class="line">    <span class="comment">//初始化五个节点，五条边</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] u=&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] v=&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] w=&#123;<span class="number">2</span>,-<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span>[]cost = &#123;<span class="number">0</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>&#125;;<span class="comment">//初始化节点1，到其他节点的最短路径，999模拟无穷大</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BellmanFord bellmanFord = <span class="keyword">new</span> BellmanFord();</span><br><span class="line">        bellmanFord.first = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        bellmanFord.next = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        bellmanFord.bellmanford(<span class="number">5</span>,<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//bellmanFord.bellmanfordQueue(); //使用队列优化贝尔曼福特算法</span></span><br><span class="line">        System.out.println(Arrays.toString(bellmanFord.cost));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bellmanford</span><span class="params">(<span class="keyword">int</span> nodeCount,<span class="keyword">int</span> sideCount)</span></span>&#123; <span class="comment">//未使用队列优化算法</span></span><br><span class="line">        <span class="comment">//可以设立一个标志位，当最小代价数据数值不发生改变的时候，便可以结束整个松弛操作</span></span><br><span class="line">        <span class="keyword">boolean</span> check = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">//用来检测在n-1轮松弛之后，在进行一次松弛操作，来判断是否含有负权回路（判断依据：第n轮松弛是否发生路径代价更新）</span></span><br><span class="line">        <span class="comment">//对每个结点进行n-1轮的松弛，每一轮需要将每一条边都尝试一次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; nodeCount - <span class="number">1</span>; k++) &#123; <span class="comment">//核心算法在这里</span></span><br><span class="line">            check = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sideCount; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.cost[<span class="keyword">this</span>.v[i]-<span class="number">1</span>]&gt;<span class="keyword">this</span>.cost[<span class="keyword">this</span>.u[i]-<span class="number">1</span>]+<span class="keyword">this</span>.w[i] &amp;&amp; <span class="keyword">this</span>.cost[<span class="keyword">this</span>.u[i]-<span class="number">1</span>] != <span class="number">999</span>)&#123;  <span class="comment">//注意这里数组下表是从0开始的，而节点个数是从1开始的，所以需要减1</span></span><br><span class="line">                    <span class="keyword">this</span>.cost[<span class="keyword">this</span>.v[i]-<span class="number">1</span>] = <span class="keyword">this</span>.cost[<span class="keyword">this</span>.u[i]-<span class="number">1</span>]+<span class="keyword">this</span>.w[i];</span><br><span class="line">                    check = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!check)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sideCount; i++) &#123; <span class="comment">//进行第n轮松弛操作，若发生参数更新则说明有负权回路</span></span><br><span class="line">            <span class="keyword">if</span>(cost[<span class="keyword">this</span>.v[i]-<span class="number">1</span>]&gt;cost[<span class="keyword">this</span>.u[i]-<span class="number">1</span>]+w[i] &amp;&amp; cost[<span class="keyword">this</span>.u[i]-<span class="number">1</span>] != <span class="number">999</span>)&#123;  <span class="comment">//注意这里数组下表是从0开始的，而节点个数是从1开始的，所以需要减1</span></span><br><span class="line">                <span class="keyword">this</span>.cost[v[i]-<span class="number">1</span>] = cost[<span class="keyword">this</span>.u[i]-<span class="number">1</span>]+w[i]; <span class="comment">// 因为cost的维度是[5],节点个数是5，first,next数组的维度是[6],从下标1开始，到下标5为止，表示1~5个节点</span></span><br><span class="line">                <span class="comment">//所以这里有减1的操作，如果cost数组维度也是[6],并从1下标开始计数，则可以避免减1的操作</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            System.out.println(<span class="string">&quot;此图中含有负权回路~~~&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用队列优化算法"><a href="#使用队列优化算法" class="headerlink" title="使用队列优化算法"></a>使用队列优化算法</h2><p>Bellman-Ford算法的另一种优化:每次仅对最短路程发生变化了的点的相邻边执行松弛操作。但是如何知道当前哪些点的最短路程发生了变化呢?这里可以用一个队列来维护这些点，算法大致如下。</p><ul><li>每次选取队首顶点u，对顶点u的所有出边进行松弛操作。例如有一条u→v的边，如果通过u→v这条边使得源点到顶点v的最短路程变短(dis[u]+e[u] [v]&lt;dis[v])，且顶点v不在当前的队列中，就将顶点v放入队尾。需要注意的是，同一个顶点同时在队列中出现多次是毫无意义的，所以我们需要一个数组来判重（判断哪些点已经在队列中)。在对顶点u的所有出边松弛完毕后,就将顶点v出队。接下来不断从队列中取出新的队首顶点再进行如上操作，直至队列空为止。</li></ul><h2 id="优化图解"><a href="#优化图解" class="headerlink" title="优化图解"></a>优化图解</h2><p>我们用数组dis来存放1号顶点到其余各个顶点的最短路径。初始时dis[1]为0，其余为无穷大。接下来将1号顶点入队。然后对一号节点的所有出边进行松弛，松弛成功的节点，再加入队列。一直到队列为空结束！</p><p> <img src="/articleImg/38_article/image2.png" alt="image2"></p><h2 id="使用队列优化的代码函数"><a href="#使用队列优化的代码函数" class="headerlink" title="使用队列优化的代码函数"></a>使用队列优化的代码函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用队列优化贝尔曼福特算法的思想就是，每次仅对最短路估计值发生变化了的顶点的所有出边执行松弛操作。</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bellmanfordQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">       <span class="comment">//先用邻接表将所有的边信息进行保存</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">//将所有的边开始读入，并模仿单链表进行存储相关信息</span></span><br><span class="line">           <span class="comment">////这里相当于是一个链表操作，采用头插的方式</span></span><br><span class="line">           <span class="keyword">this</span>.next[i] = <span class="keyword">this</span>.first[<span class="keyword">this</span>.u[i]]; <span class="comment">//将当前节点u[i]中保存的出边，赋值到next[i]</span></span><br><span class="line">           <span class="keyword">this</span>.first[<span class="keyword">this</span>.u[i]] = i; <span class="comment">//将当前是第几条边赋值给first数组当前节点</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       queue.add(<span class="number">1</span>);<span class="comment">//这里模拟的是求1号节点到其他节点的最短路径，所以这里先将节点1入队</span></span><br><span class="line">       <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">           Integer topNode = queue.poll();</span><br><span class="line">           <span class="keyword">int</span> temp = <span class="keyword">this</span>.first[topNode];</span><br><span class="line">           <span class="keyword">while</span>(temp != -<span class="number">1</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span>(<span class="keyword">this</span>.cost[<span class="keyword">this</span>.v[temp]-<span class="number">1</span>]&gt;<span class="keyword">this</span>.cost[<span class="keyword">this</span>.u[temp]-<span class="number">1</span>]+<span class="keyword">this</span>.w[temp] &amp;&amp; <span class="keyword">this</span>.cost[<span class="keyword">this</span>.u[temp]-<span class="number">1</span>]!=<span class="number">999</span>)&#123;</span><br><span class="line">                   <span class="keyword">this</span>.cost[<span class="keyword">this</span>.v[temp]-<span class="number">1</span>] = <span class="keyword">this</span>.cost[<span class="keyword">this</span>.u[temp]-<span class="number">1</span>]+<span class="keyword">this</span>.w[temp];</span><br><span class="line">                   queue.add(<span class="keyword">this</span>.v[temp]);</span><br><span class="line">               &#125;</span><br><span class="line">               temp = <span class="keyword">this</span>.next[temp];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这个算法总结的差不多了，最重要的还是理解算法的思想。写代码就是顺其自然的事了。</p><p>继续加油吧~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bellman-Ford </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图--邻接表的两种实现</title>
      <link href="/2021/10/23/%E5%9B%BE-%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0/"/>
      <url>/2021/10/23/%E5%9B%BE-%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="图–邻接表的两种实现"><a href="#图–邻接表的两种实现" class="headerlink" title="图–邻接表的两种实现"></a>图–邻接表的两种实现</h1><p>图的结构有很多种中的表示方法，邻接矩阵、邻接表表示法、星形表示法、弧表示法、关联矩阵表示法等。这里对邻接表的表示做出记录。</p><p>要表示的图结构如下</p><p> <img src="/articleImg/37_article/image1.png" alt="image1"></p><h2 id="单链表实现邻接表"><a href="#单链表实现邻接表" class="headerlink" title="单链表实现邻接表"></a>单链表实现邻接表</h2><p> <img src="/articleImg/37_article/image2.jpg" alt="image2"></p><p>单链表存储起来还是挺简单的，这里我把每个单链表存在了Arraylist中，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里用链表实现图的邻接表</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">adjaceencyList2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;LinkedList&lt;Integer[]&gt;&gt; linkedLists = <span class="keyword">new</span> ArrayList&lt;LinkedList&lt;Integer[]&gt;&gt;();</span><br><span class="line">    <span class="comment">//这三个数组其实是代表一条边的信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> []u = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>]; <span class="comment">//代表开始节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> []v = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>]; <span class="comment">//代表结束节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> []w = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>]; <span class="comment">//代表这条边的代价</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        adjaceencyList2 adjacencyList = <span class="keyword">new</span> adjaceencyList2();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">5</span> ; i++) &#123; <span class="comment">//初始化链表list,list中的每一个元素是一个单链表</span></span><br><span class="line">            adjacencyList.linkedLists.add(<span class="keyword">new</span> LinkedList&lt;Integer[]&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        adjacencyList.u = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        adjacencyList.v = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        adjacencyList.w = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">5</span> ; i++) &#123; <span class="comment">//初始化链表数组中的相关信息</span></span><br><span class="line">            adjacencyList.linkedLists.get(adjacencyList.u[i]).add(<span class="keyword">new</span> Integer[]&#123;adjacencyList.v[i], adjacencyList.w[i]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//举例显示</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">5</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(adjacencyList.linkedLists.get(i).size() == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;第%d节点没有出边&quot;</span>,i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.printf(<span class="string">&quot;第%d节点：&quot;</span>,i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adjacencyList.linkedLists.get(i).size(); j++) &#123;</span><br><span class="line">                System.out.print(Arrays.toString(adjacencyList.linkedLists.get(i).get(j)));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组模拟实现邻接表"><a href="#数组模拟实现邻接表" class="headerlink" title="数组模拟实现邻接表"></a>数组模拟实现邻接表</h2><p>单链表实现我还挺好懂得，等到了要用数组模拟的时候我卡了一会，啊哈算法上用两个一维数组就把这几个单链表模拟出来了，如果是我来做第一手模拟操作的话，我可能会用一个二维数组去模拟，二维数组的每一行模拟一个单链表。</p><p>下面将模拟过程贴图，方便自己以后复习：</p><p> <img src="/articleImg/37_article/image3.png" alt="image3"></p><p> <img src="/articleImg/37_article/image4.png" alt="image4"></p><p><strong>即 first[u[i]]保存顶点u[i]的第一条边的编号，next[i]存储“编号为i的边”的“下一条边”的编号。</strong></p><p>那么啊哈算法程序中中又是怎么模拟这几个单链表所存储的信息的呢？请看我下面的程序注释。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package com.zhanglei;</span><br><span class="line"></span><br><span class="line">//图的临界表表示方法~ 其实就是用单链表去存储相关信息下</span><br><span class="line"></span><br><span class="line">//但是也可以用数组进行模拟，这里主要讨论的时数组进行模拟，昨天在思考这两句代码时被卡住了</span><br><span class="line">//在这里做出记录~</span><br><span class="line">public class adjacencyList &#123;</span><br><span class="line">    //本次要存储的是一个 4个节点 5条边的图</span><br><span class="line">    private int []first = new int[5]; //代表第i个节点的第一条出边</span><br><span class="line">    private int []next = new int[6]; //代表第j条边的下一条出边, 切记这里的出边仍然是属于第i个节点的出边</span><br><span class="line">    //next数组的作用就是想把第i个节点的所有出边都能索引到</span><br><span class="line"></span><br><span class="line">    //这三个数组其实是代表一条边的信息</span><br><span class="line">    private int []u = new int[6]; //代表开始节点</span><br><span class="line">    private int []v = new int[6]; //代表结束节点</span><br><span class="line">    private int []w = new int[6]; //代表这条边的代价</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        adjacencyList adjacencyList = new adjacencyList();</span><br><span class="line">        adjacencyList.first = new int[]&#123;-1, -1, -1, -1, -1&#125;;</span><br><span class="line">        adjacencyList.next = new int[]&#123;-1, -1, -1, -1, -1,-1&#125;;</span><br><span class="line">        adjacencyList.u = new int[]&#123;1, 4, 1, 2, 1&#125;;</span><br><span class="line">        adjacencyList.v = new int[]&#123;4, 3, 2, 4, 3&#125;;</span><br><span class="line">        adjacencyList.w = new int[]&#123;9, 8, 5, 6, 7&#125;;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123; //将所有的边开始读入，并模仿单链表进行存储相关信息</span><br><span class="line"></span><br><span class="line">            //采用头插的方式   ★关键在这里★</span><br><span class="line">            adjacencyList.next[i] = adjacencyList.first[adjacencyList.u[i]]; //将当前节点u[i]中保存的出边，赋值到next[i]</span><br><span class="line">            adjacencyList.first[adjacencyList.u[i]] = i; //将当前是第几条边赋值给first数组当前节点</span><br><span class="line">            //这里相当于是一个链表操作，</span><br><span class="line">        &#125;</span><br><span class="line">        //经过上述的操作之后，就可以通过节点的一条出边，而访问到该节点的所有出边号</span><br><span class="line">        //比如这里遍历出1号节点的所有出边号</span><br><span class="line">         int k = adjacencyList.first[1];</span><br><span class="line">        while(k!=-1)&#123;</span><br><span class="line">            System.out.printf(&quot;出边号 %d&quot;,k);</span><br><span class="line">            k = adjacencyList.next[k];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面的程序我们可以知道，啊哈算法中的first数组和next数组，都是存储的边号信息，就是存储的这是第几条边，而边对应的信息还需要到u[i]、v[i]、w[i]中去索引。但是上述的两句算法思想还是值得自己去吸收回味的。</p><p>最后的运行结果如下：</p><p> <img src="/articleImg/37_article/image5.png" alt="image5"></p><p>继续加油吧</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图的邻接表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图最短路径--迪杰斯特拉算法Dijkstra</title>
      <link href="/2021/10/23/%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95Dijkstra/"/>
      <url>/2021/10/23/%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95Dijkstra/</url>
      
        <content type="html"><![CDATA[<h1 id="图最短路径–迪杰斯特拉算法Dijkstra"><a href="#图最短路径–迪杰斯特拉算法Dijkstra" class="headerlink" title="图最短路径–迪杰斯特拉算法Dijkstra"></a>图最短路径–迪杰斯特拉算法Dijkstra</h1><h2 id="本次求解的图"><a href="#本次求解的图" class="headerlink" title="本次求解的图"></a>本次求解的图</h2><p> <img src="/articleImg/36_article/image1.png" alt="image1"></p><h2 id="算法思想梳理"><a href="#算法思想梳理" class="headerlink" title="算法思想梳理"></a>算法思想梳理</h2><p> <img src="/articleImg/36_article/image2.png" alt="image2"></p><p>就如上方的算法流程图，那么什么叫代价确定值呢？下面给出解释：</p><p>再图的邻接矩阵表示方法中，我们一般需要用一个一维数组dis来存储1号顶点到其余各个顶点的初始路程，如下：</p><p> <img src="/articleImg/36_article/image3.png" alt="image3"></p><p>既然是求1号顶点到其余各个顶点的最短路程，那就先找一个离1号顶点最近的顶点。通过数组dis可知当前离1号顶点最近的是2号顶点。当选择了2号顶点后，dis[2]的值就已经从“估计值”变为了“确定值”，即1号顶点到2号顶点的最短路程就是当前dis[2]值。为什么呢？ 如下:</p><p>你想啊，目前离1号顶点最近的是2号顶点，并且这个图所有的边都是正数，那么肯定不可能通过第三个顶点中转，使得1号顶点到2号顶点的路程进一步缩短了。</p><h2 id="什么是松弛呢"><a href="#什么是松弛呢" class="headerlink" title="什么是松弛呢"></a>什么是松弛呢</h2><p>这里还以求1号节点到其他节点的最短路径为例：当我们选择确定值对应的2号节点作为中转时，</p><p>我们发现dis[3]=12，dis[2]+e[2] [3]=1+9=10，dis[3]&gt;dis[2]+e[2] [3],因此dis[3]要更新为10。这个过程有个专业术语叫做“<strong>松弛</strong>”，1号顶点到3号顶点的路程即 dis[3]，通过2→3这条边松弛成功。这便是 Dijkstra算法的主要思想:通过“边”来松弛1号顶点到其余各个顶点的路程。</p><p>其中 dis[3]表示1号顶点到3号顶点的路程，e[2] [3]表示2→3这条边。</p><h2 id="给出算法代码及运行结果"><a href="#给出算法代码及运行结果" class="headerlink" title="给出算法代码及运行结果"></a>给出算法代码及运行结果</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图的迪杰斯特拉-单源最短路（一个点到其余各点的最短路径）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dijkstra</span> </span>&#123;</span><br><span class="line">    <span class="comment">//图的邻接矩阵,这里用999表示无穷大值</span></span><br><span class="line">    <span class="comment">//5*6</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [][] map= &#123;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">12</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>&#125;,&#123;<span class="number">999</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">999</span>,<span class="number">999</span>&#125;,&#123;<span class="number">999</span>,<span class="number">999</span>,<span class="number">0</span>,<span class="number">999</span>,<span class="number">5</span>,<span class="number">999</span>&#125;,&#123;<span class="number">999</span>,<span class="number">999</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">13</span>,<span class="number">15</span>&#125;,&#123;<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">0</span>,<span class="number">4</span>&#125;,&#123;<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [][] min_cost= &#123;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">12</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>&#125;,&#123;<span class="number">999</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">999</span>,<span class="number">999</span>&#125;,&#123;<span class="number">999</span>,<span class="number">999</span>,<span class="number">0</span>,<span class="number">999</span>,<span class="number">5</span>,<span class="number">999</span>&#125;,&#123;<span class="number">999</span>,<span class="number">999</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">13</span>,<span class="number">15</span>&#125;,&#123;<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">0</span>,<span class="number">4</span>&#125;,&#123;<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> []mark = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>]; <span class="comment">//来标记“确定值”，也就是该节点处目前已确定的最小值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dijkstra dijkstra = <span class="keyword">new</span> Dijkstra();</span><br><span class="line">        dijkstra.dijkstra();</span><br><span class="line">        System.out.println(<span class="string">&quot;经过迪杰斯特拉算法之后，得到的最小代价矩阵为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : dijkstra.min_cost) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%3d &quot;</span>,anInt);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//先求节点1的单源最短路径</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123; <span class="comment">//这个for是为了求出全部节点的最小代价路径</span></span><br><span class="line">            <span class="keyword">this</span>.zeroMark(<span class="keyword">this</span>.mark);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">this</span>.updateOver(<span class="keyword">this</span>.mark,i))&#123; <span class="comment">//求当前节点的到其他节点的最短路径</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> cur_min_val = <span class="number">999</span>;</span><br><span class="line">                <span class="keyword">int</span> cur_min_pos = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j  &lt; <span class="number">6</span> ; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="keyword">this</span>.min_cost[i][j]!=<span class="number">0</span>&amp;&amp;<span class="keyword">this</span>.min_cost[i][j]!=<span class="number">999</span>&amp;&amp;cur_min_val&gt;<span class="keyword">this</span>.min_cost[i][j]&amp;&amp;<span class="keyword">this</span>.mark[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                        cur_min_val = <span class="keyword">this</span>.min_cost[i][j];</span><br><span class="line">                        cur_min_pos = j; <span class="comment">//当前确定值的坐标</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(cur_min_pos == -<span class="number">1</span>) <span class="comment">//该节点已找出全部的确定最小值</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.mark[cur_min_pos] = <span class="number">1</span>; <span class="comment">//将当前确定值进行标记</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="keyword">this</span>.map[cur_min_pos][j]!=<span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.map[cur_min_pos][j] &lt; <span class="number">999</span>&amp;&amp;j!=<span class="number">0</span>)&#123; <span class="comment">//代表当前确定值，到其他节点有边，那么我们来看看，能不能因此更新代价矩阵</span></span><br><span class="line">                        <span class="keyword">int</span> temp = <span class="keyword">this</span>.min_cost[i][cur_min_pos] + <span class="keyword">this</span>.min_cost[cur_min_pos][j];</span><br><span class="line">                        <span class="keyword">if</span>(<span class="keyword">this</span>.min_cost[i][j] &gt; temp)&#123; <span class="comment">//表示可以更新</span></span><br><span class="line">                            <span class="keyword">this</span>.min_cost[i][j] = temp;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">zeroMark</span><span class="params">(<span class="keyword">int</span>[] mark)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span> ; i++) &#123;</span><br><span class="line">            mark[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">updateOver</span><span class="params">(<span class="keyword">int</span>[] mark,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=j&amp;&amp;mark[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p> <img src="/articleImg/36_article/image4.png" alt="image4"></p><p>附：如果在用迪杰斯特拉算法去求最短路径时，利用临界表去表示图，将会使算法的复杂度下降。</p><p>继续加油吧~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dijkstra最短路径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图最短路径--弗洛伊德算法Floyd</title>
      <link href="/2021/10/23/%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95Floyd/"/>
      <url>/2021/10/23/%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95Floyd/</url>
      
        <content type="html"><![CDATA[<h1 id="图最短路径–弗洛伊德算法Floyd"><a href="#图最短路径–弗洛伊德算法Floyd" class="headerlink" title="图最短路径–弗洛伊德算法Floyd"></a>图最短路径–弗洛伊德算法Floyd</h1><h2 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h2><p> <img src="/articleImg/35_article/image1.png" alt="image1"></p><p>如上图的的图和代价矩阵，我们希望知道任意两个节点间的最短路径。我们当然可以通过DFS遍历出两个节点，如1节点到5节点之间的所有路径，然后比较得出最短路径即可。</p><p>但是后续几篇博客中我将学习几种算法复杂度更低的最短路径算法。</p><h2 id="Floyd算法思想"><a href="#Floyd算法思想" class="headerlink" title="Floyd算法思想"></a>Floyd算法思想</h2><ul><li><p>我们来想一想，根据以往的经验，如果要让任意两点（例如从顶点a到顶点b）之间的路程变短，只能引入第三个点(顶点k)，并通过这个顶点k中转即a→k→b，才可能缩短原来从顶点a到顶点b的路程。那么这个中转的顶点k是1~n中的哪个点呢?甚至有时候不只通过一个点，而是经过两个点或者更多点中转会更短，即 a→k1→k2→b或者a&gt;k1→k2→…ki…→b。我们发现每个顶点都有可能使得另外两个顶点之间的路程变短。<br>当任意两点之间不允许经过第三个点时,这些城市之间的最短路程就是初始路程。</p></li><li><p>假如现在只允许经过1号顶点，求任意两点之间的最短路程，应该如何求呢?<br>只需判断e[i] [1]+e[1] [j]是否比 e[i] [j]要小即可。e[i] [j]表示的是从i号顶点到j号顶点之间的路程。e[i] [1]+e[1] [j]表示的是从i号顶点先到1号顶点，再从1号顶点到j号顶点的路程之和。其中i是1<del>n循环，j也是1</del>n循环，代码实现如下。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在只允许经过1号顶点的情况下,任意两点之间的最短路程更新为:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(j=l;j&lt;=n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i][j] &gt;e[i][<span class="number">1</span>]+e[<span class="number">1</span>][])</span><br><span class="line">e[i][j]=e[i][<span class="number">1</span>] +e[<span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对应代码"><a href="#对应代码" class="headerlink" title="对应代码"></a>对应代码</h2><p>根据上述的算法思想，我们很容易算法推广到允许所有顶点最为中转，去求最短路径，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package com.zhanglei;</span><br><span class="line"></span><br><span class="line">//弗洛伊德算法，求最短路径</span><br><span class="line">public class Floyd &#123;</span><br><span class="line">    private int[][] nodeCost =&#123;&#123;0,2,6,4&#125;,&#123;999,0,3,999&#125;,&#123;7,999,0,1&#125;,&#123;5,999,12,0&#125;&#125;;//原始的代价矩阵4*4</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Floyd floyd = new Floyd();</span><br><span class="line">        floyd.floyd();</span><br><span class="line">        for (int[] ints : floyd.nodeCost) &#123;</span><br><span class="line">            for (int anInt : ints) &#123;</span><br><span class="line">                System.out.printf(&quot;%3d&quot;,anInt);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void floyd()&#123; //弗洛伊德算法</span><br><span class="line">        for (int k = 0; k &lt;4 ; k++) &#123; //k代表以哪个节点为中转节点</span><br><span class="line">            for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">                for (int j = 0; j &lt;4; j++) &#123;</span><br><span class="line">                    if(i == k)</span><br><span class="line">                        break;</span><br><span class="line">                    int temp = this.nodeCost[i][k] + this.nodeCost[k][j];</span><br><span class="line">                    if(this.nodeCost[i][j]&gt;temp)</span><br><span class="line">                        this.nodeCost[i][j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终结果如下：</p><p> <img src="/articleImg/35_article/image2.png" alt="image2"></p><p>继续加油吧~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Floyd最短路径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重装系统后如何恢复hexo博客</title>
      <link href="/2021/10/20/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8Dhexo%E5%8D%9A%E5%AE%A2/"/>
      <url>/2021/10/20/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8Dhexo%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="重装系统后如何恢复hexo博客"><a href="#重装系统后如何恢复hexo博客" class="headerlink" title="重装系统后如何恢复hexo博客"></a>重装系统后如何恢复hexo博客</h1><p>随着博客越写越多，我很担心博客的迁移问题，以后可能会换很多台办公电脑，怎么能保证自己的积累不会前功尽弃呢！这里我特别记录一篇如何迁移恢复hexo博客的文章。</p><h2 id="大前提是自己的本地博客文件都还健在"><a href="#大前提是自己的本地博客文件都还健在" class="headerlink" title="大前提是自己的本地博客文件都还健在~"></a>大前提是自己的本地博客文件都还健在~</h2><p>1.安装Node.js，git，并查看当前软件环境，2021年10月安装的环境版本如下 </p><p> <img src="/articleImg/34_article/image1.png" alt="image1"></p><p>2.配置SSH key</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/. ssh    <span class="comment">//查看C:\Users\用户名.ssh下有无ssh文件夹，没有则创建</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;邮件地址&quot;</span> <span class="comment">//创建key</span></span><br></pre></td></tr></table></figure><p>3.将本地生成的 SSH key配置到github</p><p>4.ssh -T <a href="mailto:&#x67;&#105;&#116;&#64;&#103;&#105;&#116;&#104;&#x75;&#x62;&#46;&#x63;&#x6f;&#109;">&#x67;&#105;&#116;&#64;&#103;&#105;&#116;&#104;&#x75;&#x62;&#46;&#x63;&#x6f;&#109;</a>  测试是否成功</p><p>5.用户名 邮箱配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;zhanglei-underdog&quot;</span><span class="comment">// 你的github用户名，非昵称</span></span><br><span class="line">git config --global user.email  <span class="string">&quot;zhanglei.szu@gmail.com&quot;</span><span class="comment">// 填写你的github注册邮箱</span></span><br></pre></td></tr></table></figure><p>6.进入到博客(pgzxc)文件夹删除<strong>node_modules</strong>   <strong>public</strong>   <strong>.git</strong>   <strong>.deploy_git</strong>文件夹，删除后如下</p><p>  <img src="/articleImg/34_article/image2.png" alt="image2"></p><p>7.关联Github项目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin git<span class="meta">@github</span>.com:PGzxc/PGzxc.github.io.git</span><br></pre></td></tr></table></figure><p>8.运行如下指令”npm install –g hexo ”安装hexo，也可用cnpm,具体参考前面的博客。</p><p>9.<strong>运行如下指令安装项目依赖</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install  </span><br></pre></td></tr></table></figure><p>​    10.hexo -g 生成并本地预览,即可</p><h2 id="顺带记录如何将博客同时推送到GitHub与gitee"><a href="#顺带记录如何将博客同时推送到GitHub与gitee" class="headerlink" title="顺带记录如何将博客同时推送到GitHub与gitee"></a>顺带记录如何将博客同时推送到GitHub与gitee</h2><p>1.查看C:\Users\用户名.ssh下有无ssh文件夹，没有则创建</p><p>2.通过下面的命令，依次生成两个平台的key</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;xxxxxxx@qq.com&quot; -f &quot;github_id_rsa&quot;</span><br><span class="line">$ ssh-keygen -t rsa -C &quot;xxxxxxx@qq.com&quot; -f &quot;gitee_id_rsa&quot;</span><br></pre></td></tr></table></figure><p>3.完成后，.ssh文件夹生成以下文件</p><p> <img src="/articleImg/34_article/image3.png" alt="image3"></p><p>4.打开gitee_id_rsa.pub文件与github_id_rsa.pub文件，将其配置到各自平台的SSH中</p><p>5.在.ssh文件夹下，创建config文件解决ssh冲突（config文件没有后缀名），输入以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># gitee</span><br><span class="line">Host gitee.com</span><br><span class="line">HostName gitee.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/gitee_id_rsa</span><br><span class="line"> </span><br><span class="line"># github</span><br><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/github_id_rsa</span><br></pre></td></tr></table></figure><p>6，测试gitee命令：<strong>ssh -T <a href="mailto:&#103;&#x69;&#116;&#64;&#x67;&#x69;&#x74;&#101;&#x65;&#x2e;&#99;&#111;&#109;">&#103;&#x69;&#116;&#64;&#x67;&#x69;&#x74;&#101;&#x65;&#x2e;&#99;&#111;&#109;</a></strong>        测试GitHub命令：<strong>ssh -T <a href="mailto:&#x67;&#x69;&#116;&#64;&#x67;&#105;&#116;&#104;&#117;&#98;&#x2e;&#x63;&#x6f;&#x6d;">&#x67;&#x69;&#116;&#64;&#x67;&#105;&#116;&#104;&#117;&#98;&#x2e;&#x63;&#x6f;&#x6d;</a></strong></p><p>今天记录完这个，心里终于踏实了~</p><p>继续加油~</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo博客迁移恢复 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图-DFS求最小代价路径</title>
      <link href="/2021/10/20/%E5%9B%BE-DFS%E6%B1%82%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7%E8%B7%AF%E5%BE%84/"/>
      <url>/2021/10/20/%E5%9B%BE-DFS%E6%B1%82%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h1 id="DFS求图中最小代价路径"><a href="#DFS求图中最小代价路径" class="headerlink" title="DFS求图中最小代价路径"></a>DFS求图中最小代价路径</h1><p> <img src="/articleImg/33_article/image1.png" alt="image1"></p><h2 id="程序说明"><a href="#程序说明" class="headerlink" title="程序说明"></a>程序说明</h2><p>利用DFS，从节点1出发，找出到节点5的最小代价路径。&lt;这里注意时最小代价路径，不是最短路径&gt;</p><ul><li>当每条边的代价相同时，用BFS更优，因为BFS第一次到达目标点的时候，便是最小代价路径。</li><li>当每条边的代价不同时，用DFS更优，期间可以返回代价已经大于min的检索。等所有的可能性都遍历完之后，便会的到一条最小代价路径。</li><li>也就是说BFS只遍历到一条路径答案，而DFS则将所有的可行性路径都遍历了一遍，最终的到最小代价路径。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过DFS遍历，求出图中从起始点到终点的最小代价路径</span></span><br><span class="line"><span class="comment">//当每条边的代价相同时，用BFS更优，因为BFS第一次到达目标点的时候，便是最小代价路径</span></span><br><span class="line"><span class="comment">//当每条边的代价不同时，用DFS更优，期间可以返回代价已经大于min的检索。等所有的可能性都遍历完之后，便会的到一条最小代价路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinimumCost</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][]map=&#123;&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">10</span>&#125;,&#123;<span class="number">999</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">999</span>,<span class="number">7</span>&#125;,&#123;<span class="number">4</span>,<span class="number">999</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">999</span>&#125;,&#123;<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">0</span>,<span class="number">5</span>&#125;,&#123;<span class="number">999</span>,<span class="number">999</span>,<span class="number">3</span>,<span class="number">999</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> min = <span class="number">9999</span>;<span class="comment">//最小代价变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cost;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] markNode = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]; <span class="comment">//用来标记节点是否被遍历过</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MinimumCost minimumCost = <span class="keyword">new</span> MinimumCost();</span><br><span class="line">        minimumCost.markNode[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        minimumCost.DFS(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;最小代价为：&quot;</span>+minimumCost.min);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> step,<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="number">4</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本次cost代价为：&quot;</span>+<span class="keyword">this</span>.cost);</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.cost&lt;<span class="keyword">this</span>.min)</span><br><span class="line">                <span class="keyword">this</span>.min = <span class="keyword">this</span>.cost;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.map[cur][i]!=<span class="number">0</span>&amp;&amp;<span class="keyword">this</span>.map[cur][i]!= <span class="number">999</span> )&#123; <span class="comment">//代表有边</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.markNode[i] == <span class="number">1</span>) <span class="comment">//这里判断的是指向边对应节点是否已被遍历过</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">this</span>.cost = <span class="keyword">this</span>.cost+<span class="keyword">this</span>.map[cur][i];</span><br><span class="line">                <span class="keyword">this</span>.markNode[i] = <span class="number">1</span>; <span class="comment">//这里一定要写成this.markNode[i] = 1，因为这里要去指向边了</span></span><br><span class="line">                DFS(step+<span class="number">1</span>,i);</span><br><span class="line">                <span class="comment">//尤其注意this.cost，this.markNode[i]在这里进行清零，如果不理解为什么，就去看看DFS求全排列</span></span><br><span class="line">                <span class="keyword">this</span>.cost = <span class="keyword">this</span>.cost - <span class="keyword">this</span>.map[cur][i];</span><br><span class="line">                <span class="keyword">this</span>.markNode[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>继续加油吧~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS求最小代价路径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFS-连通域检测</title>
      <link href="/2021/10/20/BFS-%E8%BF%9E%E9%80%9A%E5%9F%9F%E6%A3%80%E6%B5%8B/"/>
      <url>/2021/10/20/BFS-%E8%BF%9E%E9%80%9A%E5%9F%9F%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="BFS连通域检测"><a href="#BFS连通域检测" class="headerlink" title="BFS连通域检测"></a>BFS连通域检测</h1><p>0代表不通，大于0的值代表可走，检测从（6，8）处出发的连通域。矩阵形式如下</p><p> <img src="/articleImg/32_article/image1.png" alt="image1"></p><p>本次实现分别用BFS的思想和DFS的思想去解决该连通域检测问题，里面有一两个需要注意的小细节，已经在代码中的注释中写清楚了。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检索出矩阵中所有的连通域</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionDomain</span> </span>&#123;</span><br><span class="line">    <span class="comment">//该map的起始点在（6，8）处，map的大小是10*10的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [][]map = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">4</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [][]mark = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][<span class="number">10</span>];<span class="comment">//用来标记该点有没有走过</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][]dir= &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;; <span class="comment">//每个位置都可以走四个方向</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConnectionDomain connectionDomain = <span class="keyword">new</span> ConnectionDomain();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : connectionDomain.map) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%3d&quot;</span>,anInt);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------------------&quot;</span>);</span><br><span class="line">        connectionDomain.BFS(<span class="number">6</span>,<span class="number">8</span>);</span><br><span class="line">        <span class="comment">//connectionDomain.DFS(6,8,0);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : connectionDomain.map) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%3d&quot;</span>,anInt);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(connectionDomain.sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123; <span class="comment">//用BFS解连通域问题</span></span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;<span class="keyword">int</span>[]&gt;();<span class="comment">//用一个队列来辅助BFS的遍历</span></span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x,y&#125;);</span><br><span class="line">        sum++;</span><br><span class="line">        <span class="keyword">this</span>.mark[x][y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.map[x][y] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span>[] peek = queue.peek(); <span class="comment">//取队列中的队头元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> tempX = peek[<span class="number">0</span>] + <span class="keyword">this</span>.dir[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> tempY = peek[<span class="number">1</span>] + <span class="keyword">this</span>.dir[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(tempX&lt;<span class="number">0</span>||tempY&lt;<span class="number">0</span>||tempX&gt;<span class="number">9</span>||tempY&gt;<span class="number">9</span>||<span class="keyword">this</span>.mark[tempX][tempY] == <span class="number">1</span>||<span class="keyword">this</span>.map[tempX][tempY] == <span class="number">0</span>) <span class="comment">//越界，或则该点已走过，或则该点为海</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.mark[tempX][tempY] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">this</span>.map[tempX][tempY] = -<span class="number">1</span>;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;tempX,tempY&#125;);</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> step)</span></span>&#123; <span class="comment">//用DFS解决连通域问题</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">4</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tempX = x + <span class="keyword">this</span>.dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> tempY = y + <span class="keyword">this</span>.dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(tempX&lt;<span class="number">0</span>||tempY&lt;<span class="number">0</span>||tempX&gt;<span class="number">9</span>||tempY&gt;<span class="number">9</span>||<span class="keyword">this</span>.mark[tempX][tempY] == <span class="number">1</span>||<span class="keyword">this</span>.map[tempX][tempY] == <span class="number">0</span>) <span class="comment">//越界，或则该点已走过，或则该点为海</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">this</span>.mark[tempX][tempY] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">this</span>.map[tempX][tempY] = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">this</span>.sum++;</span><br><span class="line">            DFS(tempX,tempY,step+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>继续加油~~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFS--迷宫求解得一条最短路径</title>
      <link href="/2021/10/20/BFS-%E8%BF%B7%E5%AE%AB%E6%B1%82%E8%A7%A3%E5%BE%97%E4%B8%80%E6%9D%A1%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
      <url>/2021/10/20/BFS-%E8%BF%B7%E5%AE%AB%E6%B1%82%E8%A7%A3%E5%BE%97%E4%B8%80%E6%9D%A1%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h1 id="BFS–迷宫求解得一条最短路径"><a href="#BFS–迷宫求解得一条最短路径" class="headerlink" title="BFS–迷宫求解得一条最短路径"></a>BFS–迷宫求解得一条最短路径</h1><h2 id="BFS自我思考"><a href="#BFS自我思考" class="headerlink" title="BFS自我思考"></a>BFS自我思考</h2><ul><li>利用广度优先搜索解决迷宫问题</li><li>个人感觉广度优先搜索的核心在于，先把把每个点可以到达的位置都加入到队列中，随着队头移动，推进队尾元素的入队，最终实现遍历的效果（网上称为着色法）</li><li>广度优先算法在搜索到目标点的时候，就会开始结束程序，所以只会找到一条可行路径，但是这条路径却是最短的！</li></ul><p>下面我想截三张图，以便自己能够在以后复习的时候，更快回味BFS，截图来自–《啊哈算法》</p><p><img src="/articleImg/31_article/image1.png" alt="image1"></p><ul><li><strong>其实BFS，也没有用到递归，最重要的思想就是用到队列，记录下了每一次都能着色到的点。这很关键，是整个算法的核心。</strong></li></ul><p>有了这样的思路，我们解决迷宫问题就迎刃而解了，因为总有那么一步，我们能能到达终点。但只会找到一条可行路径，这条路径却是最短的。</p><ul><li><strong>切记如果想打印出最短路径，必须在队列节点数据类型中，加入一个前驱节点属性。并在从后往前遍历最短路径的时候，用栈去记录，这样就可以在打印路径的时候，从前往后打印了。</strong></li></ul><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用广度优先搜索解决迷宫问题</span></span><br><span class="line"><span class="comment">//个人感觉广度优先搜索的核心在于，先把把每个点可以到达的位置都加入到队列中，随着队头移动，推进队尾元素的入队，最终实现遍历的效果（网上称为着色法）</span></span><br><span class="line"><span class="comment">//广度优先算法在搜索到目标点的时候，就会开始结束程序，所以只会找到一条可行路径，但是这条路径却是最短的！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mazeSolving</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] mark = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][]dir= &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;; <span class="comment">//每个位置都可以走四个方向</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> queueElementCount;</span><br><span class="line">    <span class="comment">//迷宫地图</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [][]map=&#123;&#123;<span class="number">1</span>,<span class="number">1</span> ,<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> ,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>, <span class="number">0</span> ,<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> ,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">1</span>&#125;,&#123;<span class="number">1</span> ,<span class="number">0</span> ,<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,&#123;<span class="number">1</span> ,<span class="number">0</span>, <span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span>, <span class="number">1</span>&#125;,&#123;<span class="number">1</span>, <span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">        <span class="comment">//因为只有当遍历到终点的时候，才会知道最短路径，如果利用前驱节点，来记录最短路径的话，就需要从后往前走，这时候用栈来记录比较合适</span></span><br><span class="line">        Stack&lt;<span class="keyword">int</span>[]&gt; pathStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        mazeSolving mazeSolving = <span class="keyword">new</span> mazeSolving();</span><br><span class="line"></span><br><span class="line">        mazeSolving.BFS(<span class="number">1</span>,<span class="number">1</span>,queue);</span><br><span class="line"></span><br><span class="line">        Node pathNode = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            Node peek = queue.peek();</span><br><span class="line">            System.out.println(peek);</span><br><span class="line">            <span class="keyword">if</span>(peek.getX() == <span class="number">6</span> &amp;&amp; peek.getY() == <span class="number">5</span>)&#123;</span><br><span class="line">                pathNode = peek; <span class="comment">//将出口处的队列节点保留</span></span><br><span class="line">            &#125;</span><br><span class="line">            queue.remove();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!(pathNode.getX()==<span class="number">1</span>&amp;&amp;pathNode.getY()==<span class="number">1</span>))&#123;</span><br><span class="line">            pathStack.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;pathNode.getX(), pathNode.getY()&#125;);</span><br><span class="line">            pathNode = pathNode.getPreNode();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pathStack.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pathStack.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span>[] pop = pathStack.pop();</span><br><span class="line">            System.out.println(Arrays.toString(pop));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,Queue&lt;Node&gt; queue)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node();</span><br><span class="line">        node.setX(x);</span><br><span class="line">        node.setY(y);</span><br><span class="line">        node.setStep(step);</span><br><span class="line">        queue.add(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line"></span><br><span class="line">            Node peek = queue.peek();</span><br><span class="line">            step = peek.getStep() + <span class="number">1</span>;<span class="comment">//步数更新</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span> ; i++) &#123;</span><br><span class="line">                <span class="comment">//获取头部元素</span></span><br><span class="line">                Node tempNode  = <span class="keyword">new</span> Node();</span><br><span class="line">                <span class="keyword">int</span> tempX = peek.getX() +<span class="keyword">this</span>.dir[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> tempY = peek.getY()+<span class="keyword">this</span>.dir[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(tempX&lt;<span class="number">0</span>||tempY&lt;<span class="number">0</span>||tempX&gt;<span class="number">7</span>||tempY&gt;<span class="number">6</span>||<span class="keyword">this</span>.mark[tempX][tempY] == <span class="number">1</span>||<span class="keyword">this</span>.map[tempX][tempY] == <span class="number">1</span>) <span class="comment">//越界，或则该点已走过，或则该点为墙</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(mark[tempX][tempY] == <span class="number">0</span>)&#123;</span><br><span class="line">                    mark[tempX][tempY] = <span class="number">1</span>;</span><br><span class="line">                    tempNode.setPreNode(peek);</span><br><span class="line">                    tempNode.setX(tempX);</span><br><span class="line">                    tempNode.setY(tempY);</span><br><span class="line">                    tempNode.setStep(step);</span><br><span class="line">                    queue.add(tempNode);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tempX == <span class="number">6</span> &amp;&amp; tempY == <span class="number">5</span>) <span class="comment">//代表已经找到终点</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            queue.remove(); <span class="comment">//该头节点已尽心尽力，把它能到达的位置，都加到队列里了，所以这里删除该头节点</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123; <span class="comment">//（队列节点）迷宫节点需要记录的信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> step;</span><br><span class="line">    <span class="keyword">private</span> Node PreNode;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPreNode</span><span class="params">(Node preNode)</span> </span>&#123;</span><br><span class="line">        PreNode = preNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getPreNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PreNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStep</span><span class="params">(<span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.step = step;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;x=&quot;</span> + x +</span><br><span class="line">                <span class="string">&quot;, y=&quot;</span> + y +</span><br><span class="line">                <span class="string">&quot;, step=&quot;</span> + step +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 继续加油~~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS--水管工游戏</title>
      <link href="/2021/10/20/DFS-%E6%B0%B4%E7%AE%A1%E5%B7%A5%E6%B8%B8%E6%88%8F/"/>
      <url>/2021/10/20/DFS-%E6%B0%B4%E7%AE%A1%E5%B7%A5%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="DFS–水管工游戏"><a href="#DFS–水管工游戏" class="headerlink" title="DFS–水管工游戏"></a>DFS–水管工游戏</h1><h2 id="规则简介"><a href="#规则简介" class="headerlink" title="规则简介"></a>规则简介</h2><p>游戏的大致规则是这样的。一块矩形土地被分为N * M的单位正方形，现在这块土地上已经埋设有一些水管，水管将从坐标为(1,1)左上角左部边缘，延伸到(N,M)右下角右部边缘。水管只有2种，如下图所示</p><p> <img src="/articleImg/30_article/image1.png" alt="image1"></p><p>每种管道将占据一个单位正方形土地。你现在可以旋转这些管道，使得构成一个管道系统，即创造一条从(1,1)到(N,M)的连通管道。标有树木的方格表示这里没有管道。比如一个4*5的土地中(4,2)处有一个树木。我们可以旋转其中的一些管道，使之构成一个连通的管道系统，如下图。</p><p> <img src="/articleImg/30_article/image2.png" alt="image2"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>水管游戏就相当于是一个有条件的迷宫游戏，进水管的方向，连接点的水管类型就是这个迷宫的行走条件</li><li>从进水口到出水口，通过旋转中间水管零件的方向，来打通水管</li><li>我在写这道题的时候，是先判断入水口的方向，在判断连接点的水管类型</li><li>当然这题也可以，先判断连接点的水管类型，在判断入水口的方向。</li></ul><p>根据上述思路我们做出以下设定，并写出模拟矩阵：</p><p> <img src="/articleImg/30_article/image3.png" alt="image3"></p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="comment">//水管游戏就相当于是一个有条件的迷宫游戏，进水管的方向，连接点的水管类型就是这个迷宫的行走条件</span></span><br><span class="line"><span class="comment">//从进水口到出水口，通过旋转中间水管零件的方向，来打通水管</span></span><br><span class="line"><span class="comment">//我在写这道题的时候，是先判断入水口的方向，在判断连接点的水管类型</span></span><br><span class="line"><span class="comment">//当然这题也可以，先判断连接点的水管类型，在判断入水口的方向</span></span><br><span class="line"><span class="comment">//用矩阵模拟</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaterPipe</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [][]map = &#123;&#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">0</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>&#125;,&#123;<span class="number">6</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>&#125;,&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [][]mark = &#123;&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WaterPipe waterPipe = <span class="keyword">new</span> WaterPipe();</span><br><span class="line">        waterPipe.DFS(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y, <span class="keyword">int</span> flag, <span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">4</span> &amp;&amp; y == <span class="number">4</span>)&#123; <span class="comment">//表示已经找到最末端的出水口</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : <span class="keyword">this</span>.mark) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%3d&quot;</span>,anInt);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>||x&gt;<span class="number">4</span>||y&lt;<span class="number">0</span>||y&gt;<span class="number">3</span>||<span class="keyword">this</span>.mark[x][y] == <span class="number">1</span>)&#123; <span class="comment">//越界，或则该点水管已被使用过</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123; <span class="comment">//进水口在左边</span></span><br><span class="line">            <span class="keyword">if</span>((<span class="keyword">this</span>.map[x][y] == <span class="number">5</span> || <span class="keyword">this</span>.map[x][y] == <span class="number">6</span>)&amp;&amp;<span class="keyword">this</span>.mark[x][y] == <span class="number">0</span>)&#123; <span class="comment">//对接点是直管</span></span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">1</span>;</span><br><span class="line">                DFS(x,y+<span class="number">1</span>,<span class="number">1</span>,step+<span class="number">1</span>);</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.map[x][y] &gt;= <span class="number">1</span> &amp;&amp; <span class="keyword">this</span>.map[x][y] &lt;= <span class="number">4</span>&amp;&amp;<span class="keyword">this</span>.mark[x][y] == <span class="number">0</span>)&#123; <span class="comment">//对接点是弯管</span></span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">1</span>;</span><br><span class="line">                DFS(x+<span class="number">1</span>,y,<span class="number">4</span>,step+<span class="number">1</span>);</span><br><span class="line">                DFS(x-<span class="number">1</span>,y,<span class="number">2</span>,step+<span class="number">1</span>);</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">2</span>)&#123; <span class="comment">//进水口在下边</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.map[x][y] == <span class="number">5</span> || <span class="keyword">this</span>.map[x][y] == <span class="number">6</span>&amp;&amp;<span class="keyword">this</span>.mark[x][y] == <span class="number">0</span>)&#123; <span class="comment">//对接点是直管</span></span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">1</span>;</span><br><span class="line">                DFS(x-<span class="number">1</span>,y,<span class="number">2</span>,step+<span class="number">1</span>);</span><br><span class="line">                flag = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.map[x][y] &gt;= <span class="number">1</span> &amp;&amp; <span class="keyword">this</span>.map[x][y] &lt;= <span class="number">4</span>&amp;&amp;<span class="keyword">this</span>.mark[x][y] == <span class="number">0</span>)&#123; <span class="comment">//对接点是弯管</span></span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">1</span>;</span><br><span class="line">                DFS(x,y+<span class="number">1</span>,<span class="number">1</span>,step+<span class="number">1</span>);</span><br><span class="line">                DFS(x,y-<span class="number">1</span>,<span class="number">3</span>,step+<span class="number">1</span>);</span><br><span class="line">                flag = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">3</span>)&#123; <span class="comment">//进水口在右边</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.map[x][y] == <span class="number">5</span> || <span class="keyword">this</span>.map[x][y] == <span class="number">6</span>&amp;&amp;<span class="keyword">this</span>.mark[x][y] == <span class="number">0</span>)&#123; <span class="comment">//对接点是直管</span></span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">1</span>;</span><br><span class="line">                DFS(x,y-<span class="number">1</span>,<span class="number">3</span>,step+<span class="number">1</span>);</span><br><span class="line">                flag = <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.map[x][y] &gt;= <span class="number">1</span> &amp;&amp; <span class="keyword">this</span>.map[x][y] &lt;= <span class="number">4</span>&amp;&amp;<span class="keyword">this</span>.mark[x][y] == <span class="number">0</span>)&#123; <span class="comment">//对接点是弯管</span></span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">1</span>;</span><br><span class="line">                DFS(x+<span class="number">1</span>,y,<span class="number">4</span>,step+<span class="number">1</span>);</span><br><span class="line">                DFS(x-<span class="number">1</span>,y,<span class="number">2</span>,step+<span class="number">1</span>);</span><br><span class="line">                flag = <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">4</span>)&#123; <span class="comment">//进水口在上边</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.map[x][y] == <span class="number">5</span> || <span class="keyword">this</span>.map[x][y] == <span class="number">6</span>&amp;&amp;<span class="keyword">this</span>.mark[x][y] == <span class="number">0</span>)&#123; <span class="comment">//对接点是直管</span></span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">1</span>;</span><br><span class="line">                DFS(x+<span class="number">1</span>,y,<span class="number">4</span>,step+<span class="number">1</span>);</span><br><span class="line">                flag = <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.map[x][y] &gt;= <span class="number">1</span> &amp;&amp; <span class="keyword">this</span>.map[x][y] &lt;= <span class="number">4</span>&amp;&amp;<span class="keyword">this</span>.mark[x][y] == <span class="number">0</span>)&#123; <span class="comment">//对接点是弯管</span></span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">1</span>;</span><br><span class="line">                DFS(x,y+<span class="number">1</span>,<span class="number">1</span>,step+<span class="number">1</span>);</span><br><span class="line">                DFS(x,y-<span class="number">1</span>,<span class="number">3</span>,step+<span class="number">1</span>);</span><br><span class="line">                flag = <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的代码也可以先判断水管类型，再判断进水口方向。</p><p>DFS一定要注意当前这一步需要做什么，然后在考虑下一步怎么走。</p><p>继续加油~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 有条件的迷宫求解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS--方格填数</title>
      <link href="/2021/10/18/DFS-%E6%96%B9%E6%A0%BC%E5%A1%AB%E6%95%B0/"/>
      <url>/2021/10/18/DFS-%E6%96%B9%E6%A0%BC%E5%A1%AB%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="DFS–方格填数"><a href="#DFS–方格填数" class="headerlink" title="DFS–方格填数"></a>DFS–方格填数</h2><h2 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h2><p>如下的10个格子</p><p> <img src="/articleImg/29_article/image1.png" alt="image1"></p><p>填入0~9的数字。要求：连续的两个数字不能相邻。（左右、上下、对角都算相邻）</p><p>一共有多少种可能的填数方案？</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>用全排列,求出0~9十个数的全排列。全排列的思路和代码在前面几篇中已给出。这里就不在贴出。</li><li>将一维全排列填入到方格中，这里要注意边界条件（1，第一个格子与最后一个格子缺失。2，数组是否越界）</li><li>然后再利用for循环判断每个位置处周围的数是否满足条件。这里要注意边界条件。</li></ul><h2 id="第一个版本代码（暴力）"><a href="#第一个版本代码（暴力）" class="headerlink" title="第一个版本代码（暴力）"></a>第一个版本代码（暴力）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FillNumber</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> [][]dir = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;&#125;;    <span class="comment">//周围相邻的八个元素</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> [][]grid = &#123;&#123;-<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>&#125;,&#123;-<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>&#125;,&#123;-<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            Permutation&lt;Integer&gt; integerPermutation = <span class="keyword">new</span> Permutation&lt;&gt;();</span><br><span class="line">            FillNumber fillNumber = <span class="keyword">new</span> FillNumber();</span><br><span class="line"></span><br><span class="line">            Integer []numSet = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">            integerPermutation.permutation(numSet,<span class="number">0</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;全排列的种类：&quot;</span>+integerPermutation.count);</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (Integer[] integers : integerPermutation.arrayList) &#123; <span class="comment">//遍历该全排列</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; integers.length; i++) &#123; <span class="comment">//将全排列中的数值，写入到二维数组中</span></span><br><span class="line">                    fillNumber.grid[(i+<span class="number">1</span>)/<span class="number">4</span>][(i+<span class="number">1</span>)%<span class="number">4</span>] = integers[i];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(fillNumber.grid[i][j] == -<span class="number">1</span>)</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++) &#123; <span class="comment">//判断该点八个方向上有没有相邻元素</span></span><br><span class="line">                            <span class="keyword">int</span> temp;</span><br><span class="line">                            <span class="keyword">int</span> check_x,check_y;</span><br><span class="line">                            check_x = i+fillNumber.dir[k][<span class="number">0</span>];</span><br><span class="line">                            check_y = j+fillNumber.dir[k][<span class="number">1</span>]; <span class="comment">//这里刚开始携程了 i+fillNumber.dir[k][1],泪目了，这加出来的坐标怎么能对呢</span></span><br><span class="line">                            <span class="keyword">if</span>(check_x&lt;<span class="number">0</span>||check_x&gt;<span class="number">2</span>||check_y&lt;<span class="number">0</span>||check_y&gt;<span class="number">3</span>||(check_x == <span class="number">0</span>&amp;&amp; check_y ==<span class="number">0</span>)||(check_x == <span class="number">2</span>&amp;&amp; check_y ==<span class="number">3</span>)) <span class="comment">//存在越界</span></span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            <span class="keyword">if</span>(Math.abs(fillNumber.grid[check_x][check_y] - fillNumber.grid[i][j]) == <span class="number">1</span>)&#123; <span class="comment">//说明该排列中存在相邻元素</span></span><br><span class="line">                                flag = <span class="keyword">false</span>; <span class="comment">//结束该次判断</span></span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(!flag)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(!flag)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag)</span><br><span class="line">                    fillNumber.ans++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;符合要求的填数方式：&quot;</span>+fillNumber.ans);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>简单来看这就是一个放数问题，和求全排列，解八皇后问题，是差不多的。只不过这里在放数的时候，有一定的条件：即连续的两个数字不能相邻。</p><p>在把握好这个条件的前提下，利用DFS做解答。</p><ul><li>这这个DFS里面条件判断有两个，条件①该数是否已被放置过；条件② 连续的两个数字不能相邻</li></ul><h2 id="第二个版本代码（DFS）"><a href="#第二个版本代码（DFS）" class="headerlink" title="第二个版本代码（DFS）"></a>第二个版本代码（DFS）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FillNumber</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer []numSet = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> Integer []mark = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [][]grid = &#123;&#123;-<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>&#125;,&#123;-<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>&#125;,&#123;-<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>&#125;&#125;; <span class="comment">//注：这里的初值千万不能赋值为 -1，否则回溯的时候 -1-0= 1，会少很多计数值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [][]dir = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;&#125;;    <span class="comment">//周围相邻的八个元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ans  = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FillNumber fillNumber = <span class="keyword">new</span> FillNumber();</span><br><span class="line">        fillNumber.DFS(<span class="number">0</span>);</span><br><span class="line">        System.out.println(fillNumber.ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(step == <span class="number">10</span>)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.numSet.length; i++) &#123; <span class="comment">//这里产生多路递归</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>; <span class="comment">//用来标志该点放置的数是否符合条件              条件①</span></span><br><span class="line">            <span class="keyword">if</span>(mark[i]==<span class="number">0</span>)&#123; <span class="comment">//判断该数有没有被使用过（有没有被放置过）</span></span><br><span class="line">                <span class="keyword">this</span>.grid[(step+<span class="number">1</span>)/<span class="number">4</span>][(step+<span class="number">1</span>)%<span class="number">4</span>] = i;</span><br><span class="line">                mark[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++) &#123; <span class="comment">//判断该点八个方向上有没有相邻元素  条件②</span></span><br><span class="line">                <span class="keyword">int</span> temp;</span><br><span class="line">                <span class="keyword">int</span> check_x,check_y;</span><br><span class="line">                check_x = (step+<span class="number">1</span>)/<span class="number">4</span>+<span class="keyword">this</span>.dir[k][<span class="number">0</span>];</span><br><span class="line">                check_y = (step+<span class="number">1</span>)%<span class="number">4</span>+<span class="keyword">this</span>.dir[k][<span class="number">1</span>]; <span class="comment">//这里刚开始携程了 i+fillNumber.dir[k][1],泪目了，这加出来的坐标怎么能对呢</span></span><br><span class="line">                <span class="keyword">if</span>(check_x&lt;<span class="number">0</span>||check_x&gt;<span class="number">2</span>||check_y&lt;<span class="number">0</span>||check_y&gt;<span class="number">3</span>||(check_x == <span class="number">0</span>&amp;&amp; check_y ==<span class="number">0</span>)||(check_x == <span class="number">2</span>&amp;&amp; check_y ==<span class="number">3</span>)) <span class="comment">//存在越界</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(Math.abs(<span class="keyword">this</span>.grid[check_x][check_y] - <span class="keyword">this</span>.grid[(step+<span class="number">1</span>)/<span class="number">4</span>][(step+<span class="number">1</span>)%<span class="number">4</span>]) == <span class="number">1</span>)&#123; <span class="comment">//说明该排列中存在相邻元素</span></span><br><span class="line">                    flag = <span class="keyword">false</span>; <span class="comment">//结束该次判断</span></span><br><span class="line">                    <span class="keyword">this</span>.grid[(step+<span class="number">1</span>)/<span class="number">4</span>][(step+<span class="number">1</span>)%<span class="number">4</span>] = -<span class="number">2</span>;</span><br><span class="line">                    mark[i] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            DFS(step+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">this</span>.grid[(step+<span class="number">1</span>)/<span class="number">4</span>][(step+<span class="number">1</span>)%<span class="number">4</span>] = -<span class="number">2</span>;</span><br><span class="line">            mark[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接续加油~~~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 有条件的全排列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS--剪邮票</title>
      <link href="/2021/10/18/DFS-%E5%89%AA%E9%82%AE%E7%A5%A8/"/>
      <url>/2021/10/18/DFS-%E5%89%AA%E9%82%AE%E7%A5%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="DFS–剪邮票"><a href="#DFS–剪邮票" class="headerlink" title="DFS–剪邮票"></a>DFS–剪邮票</h1><h2 id="问题简介"><a href="#问题简介" class="headerlink" title="问题简介"></a>问题简介</h2><p> 有12张连在一起的12生肖的邮票。现在你要从中剪下5张来，要求必须是连着的。（仅仅连接一个角不算相连）比如，图中，粉红色所示部分就是合格的剪取。</p><p> <img src="/articleImg/28_article/image1.png" alt="image1"></p><p>请你计算，一共有多少种不同的剪取方法。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li><p>定义一个1*12的一维数组[]numberSet编上{1,1,1,1,1,1,1,0,0,0,0,0}，其中0代表该位置被剪了下来。对numberSet数组进行<strong>去重</strong>全排列，全排列很简单，关键是去重！！关于去重部分的思路我在前面的博客，已单独列出。</p></li><li><p>得到去重全排列之后，将一维数组转化成对应的3*4二维数组，进行连通性检测就可以了，如果联通则本次剪裁可以纳入answer。连通性检测用到的回溯的思想，注意这题的DFS没有用到for。其实也可以给改成用for。4个方向嘛。</p></li><li><p>第一个版本代码，是我用迷宫求解中的代码，改编的得到的测试连通性代码。因为可以把剪下来把减下来的邮票（0）当成可走路径，把未被减下来的邮票（1）当成墙。重点是我不设置出口重点，也就是说，通过递归之后，会将减下来的邮票（该连通域下所有可走路径）都置为3，且回到起点startx，starty。当回到起点时，我只需要判断map中是否还有没走的路径（0）即可~</p></li></ul><h2 id="第一个版本代码"><a href="#第一个版本代码" class="headerlink" title="第一个版本代码"></a>第一个版本代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">package com.zhanglei;</span><br><span class="line"></span><br><span class="line">//蓝桥杯真题 剪邮票</span><br><span class="line">public class Cut_the_stamps &#123;</span><br><span class="line">    private int [][] num_matrix = new int[3][4]; //存放1~12</span><br><span class="line">    private int [][] stamp_matrix = new int[3][4]; //存放这次减下来的邮票，1代表未剪下，0代表被剪下</span><br><span class="line">    private int[][]dir= &#123;&#123;0,1&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;,&#123;1,0&#125;&#125;; //每个位置都可以走四个方向</span><br><span class="line">    private int ans = 0;</span><br><span class="line"></span><br><span class="line">//核心算法在这里</span><br><span class="line">public boolean setWay(int x,int y,int startx, int starty)&#123;//x y 代表此次开始的坐标</span><br><span class="line"></span><br><span class="line">        if(x&lt;0||x&gt;2||y&lt;0||y&gt;3)&#123;  //发生越界</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(stamp_matrix[x][y]==0)&#123;  //表明该点还么有走过，可以进行寻路递归</span><br><span class="line"></span><br><span class="line">            //首先将该点标记为2（已走标记）</span><br><span class="line">            stamp_matrix[x][y]=2;</span><br><span class="line"></span><br><span class="line">            if(setWay(x+1,y,startx,starty))&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(setWay(x,y-1,startx,starty))&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(setWay(x-1,y,startx,starty))&#123;  //没找到路径，因为这里写成i+1</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(setWay(x,y+1,startx,starty))&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                if(x==startx&amp;&amp;y==starty)&#123; //说明递归回到了起点</span><br><span class="line">                    int count = 0;//记录矩阵中有多少个3</span><br><span class="line">                    for (int m = 0; m &lt; 3; m++) &#123;</span><br><span class="line">                        for (int n = 0; n &lt; 4; n++) &#123;</span><br><span class="line">                           if(stamp_matrix[m][n] == 3)</span><br><span class="line">                               count++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(count == 5)</span><br><span class="line">                        return true;</span><br><span class="line">                    else</span><br><span class="line">                        return false;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;//表明这个点不能再走，可能是1（墙），2（已走过），3（死路）</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Permutation &lt;Integer&gt;permutation = new &lt;Integer&gt;Permutation(); //创建一个可以进行全排列的类</span><br><span class="line">        Cut_the_stamps cut_the_stamps = new Cut_the_stamps();</span><br><span class="line">        Integer []numberSet = &#123;1,1,1,1,1,1,1,0,0,0,0,0&#125;;</span><br><span class="line">        //初始化 num_matrix</span><br><span class="line">        int k = 1;</span><br><span class="line">        for (int[] num_matrix : cut_the_stamps.num_matrix) &#123;</span><br><span class="line">            for (int i = 0; i &lt; num_matrix.length; i++) &#123;</span><br><span class="line">                num_matrix[i] = k;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; 4; j++) &#123;</span><br><span class="line">                cut_the_stamps.stamp_matrix[i][j] = numberSet[i*4+j];</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        permutation.permutation(numberSet,0);</span><br><span class="line">        //System.out.println(&quot;arrayList的大小为：&quot;+permutation.arrayList.size());</span><br><span class="line">        int startx = -1,starty = -1;</span><br><span class="line">        for (Integer[] integers : permutation.arrayList) &#123;</span><br><span class="line">            startx = -1;</span><br><span class="line">            starty = -1;</span><br><span class="line">            for (int i = 0; i &lt; numberSet.length; i++) &#123;</span><br><span class="line">                numberSet[i] = integers[i];</span><br><span class="line">                if(integers[i]==0&amp;&amp; startx==-1)&#123;</span><br><span class="line">                    startx = i/4;</span><br><span class="line">                    starty = i%4;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //为stamp_matrix 重新附上0 1 初值，相当于重新减一次邮票</span><br><span class="line">            for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">                for (int j = 0; j &lt; 4; j++) &#123;</span><br><span class="line">                    cut_the_stamps.stamp_matrix[i][j] = numberSet[i*4+j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;--------------------&quot;);</span><br><span class="line">            boolean check = cut_the_stamps.setWay(startx, starty, startx, starty); //第一个版本代码</span><br><span class="line"></span><br><span class="line">//            cut_the_stamps.dfs(startx,starty);  //第二个版本代码</span><br><span class="line">//            boolean check = cut_the_stamps.IsContain2(cut_the_stamps.stamp_matrix, 0); //第二个版本代码</span><br><span class="line"></span><br><span class="line">            if(check)</span><br><span class="line">                cut_the_stamps.ans++;</span><br><span class="line">            //System.out.println(&quot;是否连通：&quot;+ check);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;不重复剪邮票的方式共有：&quot;+permutation.count);</span><br><span class="line">        System.out.println(&quot;可以连通，符合题意的种类共有：&quot;+cut_the_stamps.ans);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //获取numberSet的非重复全排列</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean IsContain(int[]arr,int num)&#123;</span><br><span class="line">        for (int m : arr) &#123;</span><br><span class="line">            if(m == num)</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;//不包含</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第二个版本代码"><a href="#第二个版本代码" class="headerlink" title="第二个版本代码"></a>第二个版本代码</h2><ul><li>这个版本★处的代码，可以用for循环生成这四路递归。main函数和第一个版本的一样，这里就不再贴一次了</li><li>这个直接在边多路递归，边将走过的路径置为墙，算法效率更高。相比之下，第一个版本的代码就有点画蛇添足。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.zhanglei;</span><br><span class="line"></span><br><span class="line">//蓝桥杯真题 剪邮票</span><br><span class="line">public class Cut_the_stamps &#123;</span><br><span class="line">   </span><br><span class="line">   //整个函数返回代表，该连通域下已全部为墙，无路可走！</span><br><span class="line">    void dfs(int x,int y)&#123;  //DFS之后判断里面是不是纯1，代表联通</span><br><span class="line">        if(x&gt;2||x&lt;0||y&gt;3||y&lt;0) return ;</span><br><span class="line">        //运行到这里，说明已经越界了，则需要返回上一级的dfs()，然后换个方向继续寻找</span><br><span class="line">        if(stamp_matrix[x][y]==1) return ;</span><br><span class="line">        //这里，就是这个点不是需要剪的位置，则返回上一级的dfs()函数，</span><br><span class="line">        //继续执行未完成的dfs()函数，也就是换个方向继续找</span><br><span class="line">        stamp_matrix[x][y]=1;    //找到了，则将这个点标记</span><br><span class="line">        dfs(x+1,y); //★</span><br><span class="line">        dfs(x,y+1);//★</span><br><span class="line">        dfs(x-1,y);//★</span><br><span class="line">        dfs(x,y-1);//★</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean IsContain2(int[][]arr,int num)&#123;</span><br><span class="line">        for (int[] ints : arr) &#123;</span><br><span class="line">            for (int anInt : ints) &#123;</span><br><span class="line">                if(anInt == num)</span><br><span class="line">                    return false;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        return true;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>继续加油~~~！！！！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 连通性检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS--八皇后问题</title>
      <link href="/2021/10/18/DFS-%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"/>
      <url>/2021/10/18/DFS-%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="DFS–八皇后问题"><a href="#DFS–八皇后问题" class="headerlink" title="DFS–八皇后问题"></a>DFS–八皇后问题</h1><h2 id="问题简介"><a href="#问题简介" class="headerlink" title="问题简介"></a>问题简介</h2><p>八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出:在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即:任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法(92)。</p><p>这里列出一种结果，如下图：</p><p> <img src="/articleImg/27_article/image1.png" alt="image1"></p><h2 id="第一个版本思路及代码"><a href="#第一个版本思路及代码" class="headerlink" title="第一个版本思路及代码"></a>第一个版本思路及代码</h2><p><strong>思路</strong>：当我写八皇后题目的时候很自然的就想到了DFS，</p><ul><li>利用一个for，循环八次，产生八路递归，为什么是八次呢？因为是一个8*8的方格，所以每一行会有一个皇后，每一个皇后在每一行上可以有八种位置选择（这里选择的是列数）。</li><li>DFS函数传入step，代表递归深度，我在这里也就吧step，当成每次放皇后的行数。当step == 8的时候，递归基成立，返回结果！</li><li>这里的check_around函数写的比较暴力，第二个版本的较为巧妙</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解决八皇后排列问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Eight_queen</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][]mark = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Eight_queen eight_queen = <span class="keyword">new</span> Eight_queen();</span><br><span class="line">        eight_queen.DFS(<span class="number">0</span>,eight_queen.mark);</span><br><span class="line">        System.out.println(<span class="string">&quot;八皇后走法一共有：&quot;</span>+eight_queen.count+<span class="string">&quot;种&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 核心算法在这里</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> step,<span class="keyword">int</span> [][]mark)</span></span>&#123; <span class="comment">//这里的step还是挺关键的</span></span><br><span class="line">        <span class="keyword">if</span>(step == <span class="number">8</span>)&#123; <span class="comment">//说明已经全部走完</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">//step从0~7</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.check_around(mark,step,i))&#123; <span class="comment">//代表周围ok，可以放一个皇后</span></span><br><span class="line">                mark[step][i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">this</span>.DFS(step+<span class="number">1</span>,mark);</span><br><span class="line">                <span class="comment">//当走到这一步的时候说明死路了</span></span><br><span class="line">                <span class="comment">//收回</span></span><br><span class="line">                mark[step][i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//返回上一级DFS</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check_around</span><span class="params">(<span class="keyword">int</span>[][]arr,<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span></span>&#123; <span class="comment">//row，col代表要检查元素的位置</span></span><br><span class="line">        <span class="keyword">int</span> length = <span class="keyword">this</span>.get_length(arr);</span><br><span class="line">        <span class="keyword">int</span> height = <span class="keyword">this</span>.get_height(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查同一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][col] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row; i &lt;height ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][col] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里进行说明，其实没有必要去检查同一行，因为八皇后，每个皇后都在不同行</span></span><br><span class="line">        <span class="comment">//这一点再for 循环下的多路递归种，利用step进行不同行的区分</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//检查左斜线 \</span></span><br><span class="line">        <span class="keyword">int</span> temp1 = col;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row; i &lt; height; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=height||temp1&gt;=length||i&lt;<span class="number">0</span>||temp1&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][temp1] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp1++;</span><br><span class="line">        &#125;</span><br><span class="line">        temp1 = col;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=height||temp1&gt;=length||i&lt;<span class="number">0</span>||temp1&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][temp1] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp1--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查右斜线 /</span></span><br><span class="line">        <span class="keyword">int</span> temp2 = col;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row; i &lt; height; i++,temp2--) &#123; <span class="comment">//★ 注意这个for</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=height||temp2&gt;=length||i&lt;<span class="number">0</span>||temp2&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][temp2] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//temp2--;</span></span><br><span class="line">        &#125;</span><br><span class="line">        temp2 = col;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=height||temp2&gt;=length||i&lt;<span class="number">0</span>||temp2&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][temp2] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get_height</span><span class="params">(<span class="keyword">int</span>[][]map)</span></span>&#123; <span class="comment">//返回二维数组有多少行</span></span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : map) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : row) &#123;</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get_length</span><span class="params">(<span class="keyword">int</span>[][]map)</span></span>&#123; <span class="comment">//返回二维数组每一行有多少元素</span></span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : map) &#123;</span><br><span class="line">            temp++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第二个版本代码"><a href="#第二个版本代码" class="headerlink" title="第二个版本代码"></a>第二个版本代码</h2><p>这里主要修改了check_around()函数，修改的地方主要有：</p><ul><li>用array[8]数组记录每个皇后的左边，下标i对应行数，值array[i]对应皇后所在的列数。（如果不用一个一维数组去记录皇后的位置的话，后面在利用斜率判断是否同一斜线时，还要去遍历整个map，去寻找已放置的皇后，这个复杂度就上去了，不推荐）</li><li>利用斜率判断皇后们是不是同处一条斜线</li><li>直接利用array[i]判断是不是同处一列</li><li>核心思想还是DFS</li><li>★★★用斜率判断是否同一斜线中的*1.0非常重要，不加的话会变成整型数字进行除，一定要转换为浮点数的除法★★★</li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解决八皇后排列问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Eight_queen</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Eight_queen eight_queen = <span class="keyword">new</span> Eight_queen();</span><br><span class="line">        eight_queen.DFS(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;八皇后走法一共有：&quot;</span>+eight_queen.count+<span class="string">&quot;种&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> step)</span></span>&#123; <span class="comment">//这里的step还是挺关键的</span></span><br><span class="line">        <span class="keyword">if</span>(step == <span class="number">8</span>)&#123; <span class="comment">//说明已经全部走完</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">//step从0~7</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span> ; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.check_around2(step,i))&#123; <span class="comment">//代表周围ok，可以放一个皇后</span></span><br><span class="line">                <span class="keyword">if</span>(array[<span class="number">0</span>] == <span class="number">0</span> &amp;&amp;  array[<span class="number">1</span>] == <span class="number">4</span>)&#123;</span><br><span class="line">                    System.out.println();</span><br><span class="line">                &#125;</span><br><span class="line">                array[step] = i;</span><br><span class="line">              </span><br><span class="line">                <span class="keyword">this</span>.DFS(step+<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//当走到这一步的时候说明死路了</span></span><br><span class="line">                <span class="comment">//收回</span></span><br><span class="line">                array[step] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//返回上一级DFS</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check_around2</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="keyword">this</span>.get_length(arr);</span><br><span class="line">        <span class="keyword">int</span> height = <span class="keyword">this</span>.get_height(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//利用斜率检查同一斜线</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="comment">//★★★这里的的*1.0非常重要，不加的话会变成整型数字进行除★★★</span></span><br><span class="line">            <span class="comment">// 比如会出现 5/3 = 1的情况，所以这里要转换为浮点数的触发~</span></span><br><span class="line">            <span class="keyword">if</span>(Math.abs((array[i]-col)*<span class="number">1.0</span>/(i-row)) == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查同一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(col == array[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查同一行</span></span><br><span class="line">        <span class="comment">//多路递归中，每次都根据step的值从下一行开始的，所以在在这里并不需要考虑同一行是否有多个皇后</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可见第二个版本的代码简化了很多，也巧妙很多，回头看看自己的一手代码，真的不忍直视，泪目~~</p><p>自己还要多加油努力啊，成为一个代码风格优美的程序员！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 迷宫求解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS--迷宫求解</title>
      <link href="/2021/10/17/DFS-%E8%BF%B7%E5%AE%AB%E6%B1%82%E8%A7%A3/"/>
      <url>/2021/10/17/DFS-%E8%BF%B7%E5%AE%AB%E6%B1%82%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="DFS–迷宫求解"><a href="#DFS–迷宫求解" class="headerlink" title="DFS–迷宫求解"></a>DFS–迷宫求解</h1><p>迷宫求解问题分为，1：求出一条路径即可。2：求出所有路径并求出最短路径。下面我对这两种情况都做出记录说明~</p><h2 id="只求一条路径"><a href="#只求一条路径" class="headerlink" title="只求一条路径"></a>只求一条路径</h2><p><strong>思路</strong>：这个函数里是采用的事递归回溯的思想。每走一步都可以选择四个方向。直到找到终点，所有压栈的递归方法逐个进行return。这里需要关注的地方是，map [ i ] [ j ]置为三的时刻，为死路，将当前的标志2置为3，而不是直接由0置为3的。</p><p>这段程序中有一个setway(),和一个setway2()。区别就是setway()可以将死路置为标志位3，因为这里面用的是if判断。setway2()的话则不可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"><span class="comment">//        1 1 1 1 1 1 1</span></span><br><span class="line"><span class="comment">// map    1 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">//        1 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">//        1 1 1 0 0 0 1</span></span><br><span class="line"><span class="comment">//        1 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">//        1 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">//        1 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">//        1 1 1 1 1 1 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mazeSolving</span> </span>&#123;</span><br><span class="line">    <span class="comment">//核心算法在这里</span></span><br><span class="line">    <span class="comment">//使用递归回溯来给小球找路</span></span><br><span class="line">    <span class="comment">//说明</span></span><br><span class="line">    <span class="comment">//1. map 表示地图</span></span><br><span class="line">    <span class="comment">//2. i,j 表示从地图的哪个位置开始出发 (1,1)</span></span><br><span class="line">    <span class="comment">//3. 如果小球能到 map[6][5] 位置， 则说明通路找到.</span></span><br><span class="line">    <span class="comment">//4. 约定： 当 map[i][j] 为 0 表示该点没有走过 当为 1 表示墙 ； 2 表示通路可以走 ； 3 表示该点已经走过， 但是走不通</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setWay</span><span class="params">(<span class="keyword">int</span>[][]map,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="keyword">this</span>.get_length(map)-<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> height = <span class="keyword">this</span>.get_height(map)-<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(map[height][length]==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//★如果map[i][j]!=0 就直接return,表明该点是墙1、已走路径2、死路3★</span></span><br><span class="line">            <span class="keyword">if</span>(map[i][j]==<span class="number">0</span>)&#123;  <span class="comment">//表明该点还么有走过，可以进行寻路递归</span></span><br><span class="line">                <span class="comment">//首先将该点标记为2（已走标记）</span></span><br><span class="line">                map[i][j]=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(setWay(map,i+<span class="number">1</span>,j))&#123;  <span class="comment">//★最核心的就是这四句话★</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(setWay(map,i,j-<span class="number">1</span>))&#123; <span class="comment">//★最核心的就是这四句话★</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(setWay(map,i-<span class="number">1</span>,j))&#123;  <span class="comment">//★最核心的就是这四句话★</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(setWay(map,i,j+<span class="number">1</span>))&#123; <span class="comment">//★最核心的就是这四句话★</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    map[i][j] = <span class="number">3</span>;  <span class="comment">////★这里表示该点的四个方向都没通过判断，为死路，则置为3★</span></span><br><span class="line">                    <span class="comment">//这里的置3只是为了好看，其实这里不写置3也会的一个答案</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//表明这个点不能再走，可能是1（墙），2（已走过），3（死路）</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setWay2</span><span class="params">(<span class="keyword">int</span>[][]map,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = <span class="keyword">this</span>.get_length(map)-<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> height = <span class="keyword">this</span>.get_height(map)-<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(map[height][length]==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(map[i][j]==<span class="number">0</span>)&#123;  <span class="comment">//表明该点还么有走过，可以进行寻路递归</span></span><br><span class="line">                map[i][j]=<span class="number">2</span>;</span><br><span class="line">                setWay(map,i,j+<span class="number">1</span>);</span><br><span class="line">                setWay(map,i+<span class="number">1</span>,j);</span><br><span class="line">                setWay(map,i,j-<span class="number">1</span>);</span><br><span class="line">                setWay(map,i-<span class="number">1</span>,j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//表明这个点不能再走，可能是1（墙），2（已走过），3（死路）</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get_length</span><span class="params">(<span class="keyword">int</span>[][]map)</span></span>&#123; <span class="comment">//返回二维数组的长度</span></span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : map) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : row) &#123;</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get_height</span><span class="params">(<span class="keyword">int</span>[][]map)</span></span>&#123; <span class="comment">//返回二维数组的高度</span></span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : map) &#123;</span><br><span class="line">                temp++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="遍历出迷宫中所有路径，并求出最短路径"><a href="#遍历出迷宫中所有路径，并求出最短路径" class="headerlink" title="遍历出迷宫中所有路径，并求出最短路径"></a>遍历出迷宫中所有路径，并求出最短路径</h2><p><strong>思路</strong>：一般需要遍历出所有的可能情况，就需要用到DFS了，也就是利用for循环才生多路递归。这里一定要深刻理解这里面的多路到底指的是哪方面的多路。如迷宫求解的4路递归，指的就是4个方向的选择；如八皇后的8路递归，指的就是每一行八个方格的选择。</p><p>其实我个人觉得DFS就相当于是一个求全排列的过程，它一定会把每一个点的所有情况都考虑到。</p><p>这里给出求迷宫所有路径的方法，求最短路径的思路也很简单。只需要比较step的大小即可~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        1 1 1 1 1 1 1</span></span><br><span class="line"><span class="comment">// map    1 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">//        1 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">//        1 1 1 0 0 0 1</span></span><br><span class="line"><span class="comment">//        1 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">//        1 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">//        1 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">//        1 1 1 1 1 1 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mazeSolving</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span>  min = <span class="number">999</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][]dir= &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;; <span class="comment">//每个位置都可以走四个方向</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] short_path = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> step,<span class="keyword">int</span>[][]map,<span class="keyword">int</span>[][]mark)</span></span>&#123; <span class="comment">//x,y为当前位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tx,ty;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">6</span>&amp;&amp;y==<span class="number">5</span>)&#123;  <span class="comment">//表明已找到出口</span></span><br><span class="line">            <span class="keyword">if</span>(step&lt;min)&#123;</span><br><span class="line">                min = step;</span><br><span class="line">                short_path = mark;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//返回</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//主要想法就是遍历出所有的可能性</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;=<span class="number">3</span> ; i++) &#123; <span class="comment">//利用for循环产生多路递归！</span></span><br><span class="line">            tx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">            ty = y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(map[tx][ty]==<span class="number">1</span>)&#123; <span class="comment">//表明该点是墙</span></span><br><span class="line">                <span class="keyword">continue</span>;  <span class="comment">//刚开始这里写成了 return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(map[tx][ty] == <span class="number">0</span> &amp;&amp; mark[tx][ty] == <span class="number">0</span>)&#123;</span><br><span class="line">                mark[tx][ty] = <span class="number">2</span>; <span class="comment">//标记该点已经走过</span></span><br><span class="line">                <span class="keyword">this</span>.DFS(tx,ty,step+<span class="number">1</span>,map,mark); <span class="comment">//注意这里用到了mark数组，且传入step+1;</span></span><br><span class="line">                mark[tx][ty] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">//执行到这里，这层dfs()函数已经结束，则要回到上一层dfs()函数</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几天由于集中刷题，自我感觉对DFS的理解还是很深刻的，可以灵活运用解出一些题目。希望自己后面能多多复习，巩固这个概念！</p><p>继续加油~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 迷宫求解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS求数组元素的全排列</title>
      <link href="/2021/10/15/DFS%E6%B1%82%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97/"/>
      <url>/2021/10/15/DFS%E6%B1%82%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="基于交换元素（选择首元素）的全排列"><a href="#基于交换元素（选择首元素）的全排列" class="headerlink" title="基于交换元素（选择首元素）的全排列"></a>基于交换元素（选择首元素）的全排列</h1><p>这里例如求数集{0，1，2，3}的全排列。使用DFS+回溯的方式解决。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>针对这种全排列的问题，一般都是用多路递归的方式，不同于之前接触的单路分支，多路分支一般都使用一个for循环创建多路，在这里，就是先将0，1，2，3每个数字都遍历到，每个取出来轮流当第一个元素，每一个分支都负责把剩下的三个元素进行再次的全排列。</p><p>比如第一个取出的数字一定是0，那么剩下的数字就是1，2，3。这里就创建了第二个分支，在这个分支里面，我们第一个取出的一定是1，当我们取出1之后，我们还剩下两个数字，2，3，这里我们又创建了第三个分支，在第三个分支里面，我们第一个取出的就是2，2之后我们就只剩下一个元素3了，当我们到了第四个分支，也就是只有一个节点的分支的时候，我们创建的分支数目和全排列出的结果的长度一致，都是4。那么我们就进行第一次输出。</p><p>接下来，我们要做的就是回到上一个分支，看看3这个节点有没有兄弟节点，若没有，跳回上一层节点，看看2这个节点有没有兄弟节点。</p><p>当然，这里想要实现各种排列输出，我们就需要一个基本动作就是交换元素之间的顺序，比如0132，对于数组0123我们就需要把[2]和[3]这两个下标的元素进行一个交换。<strong>交换的意思就是</strong>，<strong>在这个分支里面，我想要让下标为[3]的元素当一次首元素，然后对这个元素进行分支</strong>。最后进行输出。输出完事儿之后跳回上一个分支，如果这个分支有兄弟节点，就进入，否则，再跳回上一个分支。下面就是第一个分支进入0开头的排列的情况</p><p> <img src="/articleImg/25_article/image1.png" alt="image1"></p><h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><p>这里的全排列是基于交换的，选取首元素，进行回溯递归的思想。可以对任意的数组进行递归。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Permutation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> []arr = &#123;<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>&#125;;</span><br><span class="line">        Permutation permutation = <span class="keyword">new</span> Permutation();</span><br><span class="line">        permutation.permutation(arr,<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;计数种类：&quot;</span>+permutation.count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="keyword">char</span>[] chs, <span class="keyword">int</span> step )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(step==chs.length-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">                System.out.print(chs[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">//Arrays.toString(chs);</span></span><br><span class="line">            <span class="comment">//如果已经到了数组的最后一个元素，前面的元素已经排好，输出。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=step;i&lt;=chs.length-<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//把第一个元素分别与后面的元素进行交换，递归的调用其子数组进行排序</span></span><br><span class="line">            Swap(chs,i,step);</span><br><span class="line">            permutation(chs,step+<span class="number">1</span>);</span><br><span class="line">            Swap(chs,i,step);</span><br><span class="line">            <span class="comment">//子数组排序返回后要将第一个元素交换回来。</span></span><br><span class="line">            <span class="comment">//如果不交换回来会出错，比如说第一次1、2交换，第一个位置为2，子数组排序返回后如果不将1、2</span></span><br><span class="line">            <span class="comment">//交换回来第二次交换的时候就会将2、3交换，因此必须将1、2交换使1还是在第一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">char</span> chs[],<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp;</span><br><span class="line">        temp = chs[i];</span><br><span class="line">        chs[i] = chs[j];</span><br><span class="line">        chs[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对程序中 step = 0,i = 3时，进行手写记录。思路就是回溯递归！</p><p> <img src="/articleImg/25_article/image2.png" alt="image2"></p><h2 id="基于标记数组辅助的全排列"><a href="#基于标记数组辅助的全排列" class="headerlink" title="基于标记数组辅助的全排列"></a>基于标记数组辅助的全排列</h2><p>这里给出代码，这个代码时DFS的基础模板，建议深刻理解。</p><p>具体理解看标记出的注释即可，自我感觉，下面这份代码属于基础代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fullPermutation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] mark = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] box = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        fullPermutation fullPermutation = <span class="keyword">new</span> fullPermutation();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            fullPermutation.mark[i] = <span class="number">0</span>;</span><br><span class="line">            fullPermutation.box[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fullPermutation.dfs(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;总数&quot;</span>+fullPermutation.count);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//核心代码在这里</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(step == num+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//注意这个return在if判断里面</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123; <span class="comment">//遍历看哪个号码还没有使用</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.mark[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.mark[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">this</span>.box[step] = i; <span class="comment">//这里的i可以换成数组元素，数组的维度一定要与mark[]数组的维度一致！</span></span><br><span class="line">                <span class="keyword">this</span>.dfs(step+<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//重新尝试，退回到上一个点的位置</span></span><br><span class="line">                <span class="keyword">this</span>.mark[i] = <span class="number">0</span>;  <span class="comment">//注意这里是什么时候重新赋值为0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <img src="/articleImg/25_article/image3.png" alt="image3"></p><h1 id="注"><a href="#注" class="headerlink" title="注"></a>注</h1><p>这里的全排列并没有考虑重复的情况。这里简单的考虑为：先将全排列后的结果放在一个集合中，若后续全排列出来的结果，在集合中已经存在，则不加入这次排列结果。</p><p>若后续有复杂度更低的想法，会在这里进行更新补充。</p><p>继续加油~</p><p>——————————————————2021.10.16 22.40分  更新——————————————————</p><p>今天做了一题剪邮票，12位数的全排列好像有6亿多种，晕(((φ(◎ロ◎;)φ)))，用Hashset去重时，可把电脑累的够呛。这里我在网上检索到了一种去重方式，感觉设计的很巧妙。我自己也理解了好一会，才搞懂。而且网上很多的人对这句代码并没有太多的解释。。。难道是大家都默认这是句代码没难度吗，呜呜呜。。。</p><p>这里我给出去重代码，并附上自己的理解思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSwap</span><span class="params">(T[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; j; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[j] == array[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这个函数的主要作用是判断：从start（step）元素开始，到将要被交换元素的前一个位置，这个区间中有没有与值与即将被交换元素的值相等的元素</strong></p><p>也就是说：全排列中去掉重复的规则——去重的全排列就是从第一个数字起每个数分别与它后面非重复出现的数字交换。</p><p>那么如何去理解这句话呢，我是这么分析的，如果step~(n-1)位置上如果有值与n位置上值相等的元素。那么step与n位置处的交换值，就是毫无意义的，因为，此时这个排列<strong>属于</strong>当step和特殊位置（指与n对应的值相等）的交换后的全排列的子集。即会产生重复！！！</p><p><img src="/articleImg/25_article/image4.png" alt="image4"></p><p>重新给出去重后的全排列代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">permutation</span><span class="params">(T[] chs, <span class="keyword">int</span> step )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(step==chs.length-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Integer[] chs_copy = <span class="keyword">new</span> Integer[<span class="number">12</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">                chs_copy[i] = (Integer) chs[i];</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=step;i&lt;=chs.length-<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//把第一个元素分别与后面的元素进行交换，递归的调用其子数组进行排序</span></span><br><span class="line">            <span class="keyword">if</span>(isSwap(chs,step,i))&#123;</span><br><span class="line">                Swap(chs,i,step);</span><br><span class="line">                permutation(chs,step+<span class="number">1</span>);</span><br><span class="line">                Swap(chs,i,step);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//子数组排序返回后要将第一个元素交换回来。</span></span><br><span class="line">            <span class="comment">//如果不交换回来会出错，比如说第一次1、2交换，第一个位置为2，子数组排序返回后如果不将1、2</span></span><br><span class="line">            <span class="comment">//交换回来第二次交换的时候就会将2、3交换，因此必须将1、2交换使1还是在第一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>再给出一个举例分析:</p><p>去掉重复的全排列由于全排列就是从第一个数字起每个数分别与它后面的数字交换。我们先尝试加个这样的判断——如果一个数与后面的数字相同那么这二个数就不交换了。如122，第一个数与后面交换得212、221。然后122中第二数就不用与第三个数交换了，但对212，它第二个数与第三个数是不相同的，交换之后得到221。与由122中第一个数与第三个数交换所得的221重复了。所以这个方法不行。</p><p>换种思维，对122，第一个数1与第二个数2交换得到212，然后考虑第一个数1与第三个数2交换，此时由于第三个数等于第二个数，所以第一个数不再与第三个数交换。再考虑212，它的第二个数与第三个数交换可以得到解决221。此时全排列生成完毕。<br>这样我们也得到了在全排列中去掉重复的规则——去重的全排列就是从第一个数字起每个数分别与它后面非重复出现的数字交换。</p><p>继续加油~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS-数组全排列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>由八皇后问题引出----判断矩阵元素是否在同一斜线上</title>
      <link href="/2021/10/14/%E7%94%B1%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E5%BC%95%E5%87%BA-%E5%88%A4%E6%96%AD%E7%9F%A9%E9%98%B5%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E5%90%8C%E4%B8%80%E6%96%9C%E7%BA%BF%E4%B8%8A/"/>
      <url>/2021/10/14/%E7%94%B1%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E5%BC%95%E5%87%BA-%E5%88%A4%E6%96%AD%E7%9F%A9%E9%98%B5%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E5%90%8C%E4%B8%80%E6%96%9C%E7%BA%BF%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="由八皇后问题引出—-判断矩阵元素是否在同一斜线上"><a href="#由八皇后问题引出—-判断矩阵元素是否在同一斜线上" class="headerlink" title="由八皇后问题引出—-判断矩阵元素是否在同一斜线上"></a>由八皇后问题引出—-判断矩阵元素是否在同一斜线上</h1><h2 id="图1"><a href="#图1" class="headerlink" title="图1"></a>图1</h2><p> <img src="/articleImg/24_article/graph.png" alt="graph"></p><h2 id="图2"><a href="#图2" class="headerlink" title="图2"></a>图2</h2><p> <img src="/articleImg/24_article/graph2.png" alt="graph2"></p><p>如果该判断方法在八皇后中应用时，最好定义一个array[8]数组，存放以放置的皇后，在array数组中下标代表行数，数组值代表皇后所在列数。这样遍历起来会更方便。否则还要去遍历mark[][] [8] [8]二维数组。直接用array数组中对应的信息，去做判断效率很高！</p><p>用于其他算法，就直接使用即可~</p><p>继续加油！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 判断矩阵元素是否在同一斜线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Jetson上融合yolov5目标检测与双目摄像头测距</title>
      <link href="/2021/10/13/%E5%9C%A8Jetson%E4%B8%8A%E8%9E%8D%E5%90%88yolov5%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%8F%8C%E7%9B%AE%E6%91%84%E5%83%8F%E5%A4%B4%E6%B5%8B%E8%B7%9D/"/>
      <url>/2021/10/13/%E5%9C%A8Jetson%E4%B8%8A%E8%9E%8D%E5%90%88yolov5%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%8F%8C%E7%9B%AE%E6%91%84%E5%83%8F%E5%A4%B4%E6%B5%8B%E8%B7%9D/</url>
      
        <content type="html"><![CDATA[<h1 id="在Jetson上融合yolov5目标检测与双目摄像头测距"><a href="#在Jetson上融合yolov5目标检测与双目摄像头测距" class="headerlink" title="在Jetson上融合yolov5目标检测与双目摄像头测距"></a>在Jetson上融合yolov5目标检测与双目摄像头测距</h1><p>这几天都在做摄像头双目测距与yolov5识别的内容。主要想实现的功能是，将yolov5识别的物体，标注出距离左右摄像头的距离。到今天下午，已经可以实时处理USB双目摄像头采集的图像。在这里将相关的过程记录下来，以免遗忘。</p><h2 id="双目测距过程"><a href="#双目测距过程" class="headerlink" title="双目测距过程"></a>双目测距过程</h2><h3 id="使用Matlab进行双目标定"><a href="#使用Matlab进行双目标定" class="headerlink" title="使用Matlab进行双目标定"></a>使用Matlab进行双目标定</h3><h4 id="双目摄像头"><a href="#双目摄像头" class="headerlink" title="双目摄像头"></a>双目摄像头</h4><p>用的摄像头的uvc免驱的摄像头，这是非常爽的，插在nano的USB口上就可以使用，驱动yoloV5之后，效果如图</p><p><img src="/articleImg/18_article/yolo.png" alt="yolo"></p><ul><li><p>插入摄像头之后查看信息所需要的相关命令：<br/></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># shell 窗口下输入</span></span><br><span class="line">lsusb    <span class="comment"># 查看已存在的USB设备资源</span></span><br><span class="line">cat /dev/video*  <span class="comment"># 查看有几个摄像头设备 /dev/video0 代表0号摄像头   /dev/video1 代表1号摄像头 </span></span><br><span class="line"><span class="comment"># 主要也就是这两条命令来确认你的uvc免驱摄像头能不能使用</span></span><br></pre></td></tr></table></figure></li><li><p>确认可以使用后，肯定要驱动显示图像才好啊，下面给出我用的摄像头驱动显示代码<br/></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">AUTO = <span class="literal">False</span>  <span class="comment"># 自动拍照，或手动按s键拍照</span></span><br><span class="line">INTERVAL = <span class="number">2</span> <span class="comment"># 自动拍照间隔</span></span><br><span class="line"> </span><br><span class="line">cv2.namedWindow(<span class="string">&quot;left&quot;</span>)</span><br><span class="line">cv2.namedWindow(<span class="string">&quot;right&quot;</span>)</span><br><span class="line">camera = cv2.VideoCapture(<span class="number">0</span>)  <span class="comment"># 用几号摄像头就设置为几</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 设置分辨率 左右摄像机同一频率，同一设备ID；左右摄像机总分辨率1280x480；分割为两个640x480、640x480</span></span><br><span class="line">camera.<span class="built_in">set</span>(cv2.CAP_PROP_FRAME_WIDTH,<span class="number">1280</span>)</span><br><span class="line">camera.<span class="built_in">set</span>(cv2.CAP_PROP_FRAME_HEIGHT,<span class="number">480</span>)</span><br><span class="line"> </span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line">utc = time.time()</span><br><span class="line">folder = <span class="string">&quot;./SaveImage/&quot;</span> <span class="comment"># 拍照文件目录</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shot</span>(<span class="params">pos, frame</span>):</span></span><br><span class="line">    <span class="keyword">global</span> counter</span><br><span class="line">    path = folder + pos + <span class="string">&quot;_&quot;</span> + <span class="built_in">str</span>(counter) + <span class="string">&quot;.jpg&quot;</span></span><br><span class="line"> </span><br><span class="line">    cv2.imwrite(path, frame)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;snapshot saved into: &quot;</span> + path)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, frame = camera.read()</span><br><span class="line">    <span class="comment"># 裁剪坐标为[y0:y1, x0:x1] HEIGHT*WIDTH</span></span><br><span class="line">    left_frame = frame[<span class="number">0</span>:<span class="number">480</span>, <span class="number">0</span>:<span class="number">640</span>]</span><br><span class="line">    right_frame = frame[<span class="number">0</span>:<span class="number">480</span>, <span class="number">640</span>:<span class="number">1280</span>]</span><br><span class="line"> </span><br><span class="line">    cv2.imshow(<span class="string">&quot;left&quot;</span>, left_frame)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;right&quot;</span>, right_frame)</span><br><span class="line"> </span><br><span class="line">    now = time.time()</span><br><span class="line">    <span class="keyword">if</span> AUTO <span class="keyword">and</span> now - utc &gt;= INTERVAL:</span><br><span class="line">        shot(<span class="string">&quot;left&quot;</span>, left_frame)</span><br><span class="line">        shot(<span class="string">&quot;right&quot;</span>, right_frame)</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">        utc = now</span><br><span class="line"> </span><br><span class="line">    key = cv2.waitKey(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> key == <span class="built_in">ord</span>(<span class="string">&quot;q&quot;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">elif</span> key == <span class="built_in">ord</span>(<span class="string">&quot;s&quot;</span>):</span><br><span class="line">        shot(<span class="string">&quot;left&quot;</span>, left_frame)</span><br><span class="line">        shot(<span class="string">&quot;right&quot;</span>, right_frame)</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">camera.release()</span><br><span class="line">cv2.destroyWindow(<span class="string">&quot;left&quot;</span>)</span><br><span class="line">cv2.destroyWindow(<span class="string">&quot;right&quot;</span>)</span><br></pre></td></tr></table></figure><p>对双目摄像头的测试就到此为止了。</p></li></ul><h4 id="双目测距基本流程"><a href="#双目测距基本流程" class="headerlink" title="双目测距基本流程"></a><strong>双目测距基本流程</strong></h4><p>主要参考自 CSDN博主 ： <a href="https://blog.csdn.net/dulingwen">dulingwen</a></p><p>结起来，双目测距的大致流程如下：</p><p><img src="/articleImg/18_article/biaoding.png" alt="biaoding"></p><p>  在这里贴出代码，由于PCL库比较难装，这里将博主代码中的点云部分全部注释<br/></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> stereo.dianyuntu_yolo <span class="keyword">import</span> preprocess, undistortion, getRectifyTransform, draw_line, rectifyImage,\</span><br><span class="line">     stereoMatchSGBM, hw3ToN3</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> stereo <span class="keyword">import</span> stereoconfig_040_2</span><br><span class="line"></span><br><span class="line">image_width = <span class="number">1280</span> / <span class="number">2</span></span><br><span class="line">image_height = <span class="number">480</span></span><br><span class="line">skip_flag = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">detect():</span><br><span class="line">    <span class="comment"># .......将该段代码放在yolo代码中的 # Add bbox to image下</span></span><br><span class="line">     <span class="comment"># -----------------------------------------------------zl 9.15</span></span><br><span class="line">                        <span class="comment"># 识别框上中点坐标</span></span><br><span class="line">                        x = (xyxy[<span class="number">0</span>] + xyxy[<span class="number">2</span>]) / <span class="number">2</span></span><br><span class="line">                        y = (xyxy[<span class="number">1</span>] + xyxy[<span class="number">3</span>]) / <span class="number">2</span></span><br><span class="line">                        <span class="comment">#print(&quot; %s is  x: %d y: %d &quot; %(label,x,y) )</span></span><br><span class="line">                        skip_flag = <span class="literal">False</span></span><br><span class="line">                        <span class="keyword">if</span> (x &lt;= <span class="number">1280</span>):</span><br><span class="line">                            t3 = time_synchronized()</span><br><span class="line">    </span><br><span class="line">                            <span class="comment">################################</span></span><br><span class="line">                            <span class="comment">#stereo code</span></span><br><span class="line">                            p = <span class="string">&quot;test&quot;</span></span><br><span class="line">                            string = <span class="string">&#x27;&#x27;</span></span><br><span class="line">                            <span class="comment">#print(&quot;P is %d&quot; %p )</span></span><br><span class="line">                            <span class="comment"># 读取数据集的图片</span></span><br><span class="line">                            <span class="comment">#iml = cv2.imread(&#x27;./stereo/yolo/zuo/%szuo%d.bmp&#x27; %(string,p) )  # 左图</span></span><br><span class="line">                            <span class="comment">#imr = cv2.imread(&#x27;./stereo/yolo/you/%syou%d.bmp&#x27; %(string,p) )  # 右图</span></span><br><span class="line"></span><br><span class="line">                            <span class="comment">#iml = cv2.imread(&#x27;./stereo/yolo/zuo/%szuo%d.bmp&#x27; %(string,p) )  # 左图</span></span><br><span class="line">                            <span class="comment">#imr = cv2.imread(&#x27;./stereo/yolo/you/%syou%d.bmp&#x27; %(string,p) )  # 右图</span></span><br><span class="line">                            </span><br><span class="line">                            height_0, width_0 = im0.shape[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">                            <span class="comment">#print(&quot;width_0 =  %d &quot;  % width_0)</span></span><br><span class="line">                            <span class="comment">#print(&quot;height_0 = %d &quot;  % height_0)</span></span><br><span class="line"></span><br><span class="line">                            width_1 = width_0/<span class="number">2</span></span><br><span class="line">                            iml = im0[<span class="number">0</span>:<span class="built_in">int</span>(height_0), <span class="number">0</span>:<span class="built_in">int</span>(width_0/<span class="number">2</span>)]</span><br><span class="line">                            imr = im0[<span class="number">0</span>:<span class="built_in">int</span>(height_0), <span class="built_in">int</span>(width_0/<span class="number">2</span>):<span class="built_in">int</span>(width_0) ]</span><br><span class="line"></span><br><span class="line">                            height, width = iml.shape[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">                            <span class="comment">#cv2.imshow(&quot;iml&quot;,iml)</span></span><br><span class="line">                            <span class="comment">#cv2.imshow(&quot;imr&quot;,im0)</span></span><br><span class="line">                            <span class="comment">#cv2.waitKey(0)</span></span><br><span class="line"></span><br><span class="line">                            <span class="comment">#print(&quot;width =  %d &quot;  % width)</span></span><br><span class="line">                            <span class="comment">#print(&quot;height = %d &quot;  % height)</span></span><br><span class="line"></span><br><span class="line">                            <span class="comment"># 读取相机内参和外参</span></span><br><span class="line">                            config = stereoconfig_040_2.stereoCamera()</span><br><span class="line"></span><br><span class="line">                            <span class="comment"># 立体校正</span></span><br><span class="line">                            map1x, map1y, map2x, map2y, Q = getRectifyTransform(height, width, config)  <span class="comment"># 获取用于畸变校正和立体校正的映射矩阵以及用于计算像素空间坐标的重投影矩阵</span></span><br><span class="line">                            <span class="comment">#print(&quot;Print Q!&quot;)</span></span><br><span class="line">                            <span class="comment">#print(&quot;Q[2,3]:%.3f&quot;%Q[2,3])</span></span><br><span class="line">                            iml_rectified, imr_rectified = rectifyImage(iml, imr, map1x, map1y, map2x, map2y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                </span><br><span class="line">                            <span class="comment"># 绘制等间距平行线，检查立体校正的效果</span></span><br><span class="line">                            line = draw_line(iml_rectified, imr_rectified)</span><br><span class="line">                            <span class="comment">#cv2.imwrite(&#x27;./yolo/%s检验%d.png&#x27; %(string,p), line)</span></span><br><span class="line"></span><br><span class="line">                            <span class="comment"># 消除畸变</span></span><br><span class="line">                            iml = undistortion(iml, config.cam_matrix_left, config.distortion_l)</span><br><span class="line">                            imr = undistortion(imr, config.cam_matrix_right, config.distortion_r)</span><br><span class="line">                        </span><br><span class="line">                            <span class="comment"># 立体匹配</span></span><br><span class="line">                            iml_, imr_ = preprocess(iml, imr)  <span class="comment"># 预处理，一般可以削弱光照不均的影响，不做也可以</span></span><br><span class="line"></span><br><span class="line">                            iml_rectified_l, imr_rectified_r = rectifyImage(iml_, imr_, map1x, map1y, map2x, map2y)</span><br><span class="line">                            </span><br><span class="line">                            disp, _ = stereoMatchSGBM(iml_rectified_l, imr_rectified_r, <span class="literal">True</span>) </span><br><span class="line">                            <span class="comment">#cv2.imwrite(&#x27;./yolo/%s视差%d.png&#x27; %(string,p), disp)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            <span class="comment"># 计算像素点的3D坐标（左相机坐标系下）</span></span><br><span class="line">                            points_3d = cv2.reprojectImageTo3D(disp, Q)  <span class="comment"># 可以使用上文的stereo_config.py给出的参数</span></span><br><span class="line"></span><br><span class="line">                            <span class="comment">#points_3d = points_3d</span></span><br><span class="line"></span><br><span class="line">                            <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">                            #print(&quot;x is :%.3f&quot; %points_3d[int(y), int(x), 0] )</span></span><br><span class="line"><span class="string">                                print(&#x27;点 (%d, %d) 的三维坐标 (x:%.3fcm, y:%.3fcm, z:%.3fcm)&#x27; % (int(x), int(y), </span></span><br><span class="line"><span class="string">                                points_3d[int(y), int(x), 0]/10, </span></span><br><span class="line"><span class="string">                                points_3d[int(y), int(x), 1]/10, </span></span><br><span class="line"><span class="string">                                points_3d[int(y), int(x), 2]/10) )</span></span><br><span class="line"><span class="string">                            &#x27;&#x27;&#x27;</span></span><br><span class="line">                            count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            <span class="comment">#try:  暂时关闭</span></span><br><span class="line">                            <span class="comment"># points_3d = points_3d.numpy()</span></span><br><span class="line">                            <span class="built_in">print</span>(points_3d.shape)</span><br><span class="line">                            <span class="comment"># print(&quot;x的值为：&quot;,x , &quot;  y的值为：&quot;, y)</span></span><br><span class="line">                            <span class="keyword">if</span>(x &lt; image_width <span class="keyword">and</span> x &gt;= <span class="number">0</span> <span class="keyword">and</span> y&lt; image_height <span class="keyword">and</span> y&gt;=<span class="number">0</span>):</span><br><span class="line">                                <span class="keyword">while</span>( (points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">2</span>] &lt; <span class="number">0</span>) | (points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">2</span>] &gt; <span class="number">2500</span>) ):</span><br><span class="line"></span><br><span class="line">                                    <span class="comment"># print(&quot;x的值为：&quot;,x , &quot;  y的值为：&quot;, y)</span></span><br><span class="line"></span><br><span class="line">                                    count += <span class="number">1</span></span><br><span class="line">                                    x += count</span><br><span class="line"></span><br><span class="line">                                    <span class="comment"># 个人添加判断程序，x y的值一旦发生更新就需要进行判断</span></span><br><span class="line">                                    <span class="keyword">if</span>(x &gt;= image_width <span class="keyword">or</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> y&gt;= image_height <span class="keyword">or</span> y&lt;<span class="number">0</span>):</span><br><span class="line">                                        skip_flag = <span class="literal">True</span></span><br><span class="line">                                        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">if</span>( <span class="number">0</span> &lt; points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">2</span>] &lt; <span class="number">2300</span> ):</span><br><span class="line">                                        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                                    y += count</span><br><span class="line"></span><br><span class="line">                                    <span class="comment"># 个人添加判断程序，x y的值一旦发生更新就需要进行判断</span></span><br><span class="line">                                    <span class="keyword">if</span>(x &gt;= image_width <span class="keyword">or</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> y&gt;= image_height <span class="keyword">or</span> y&lt;<span class="number">0</span>):</span><br><span class="line">                                        skip_flag = <span class="literal">True</span></span><br><span class="line">                                        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">if</span>( <span class="number">0</span> &lt; points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">2</span>] &lt; <span class="number">2300</span> ):</span><br><span class="line">                                        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                                    count += <span class="number">1</span></span><br><span class="line">                                    x -= count</span><br><span class="line"></span><br><span class="line">                                    <span class="comment"># 个人添加判断程序，x y的值一旦发生更新就需要进行判断</span></span><br><span class="line">                                    <span class="keyword">if</span>(x &gt;= image_width <span class="keyword">or</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> y&gt;= image_height <span class="keyword">or</span> y&lt;<span class="number">0</span>):</span><br><span class="line">                                        skip_flag = <span class="literal">True</span></span><br><span class="line">                                        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">if</span>( <span class="number">0</span> &lt; points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">2</span>] &lt; <span class="number">2300</span> ):</span><br><span class="line">                                        <span class="keyword">break</span></span><br><span class="line">                                    y -= count</span><br><span class="line"></span><br><span class="line">                                    <span class="comment"># 个人添加判断程序，x y的值一旦发生更新就需要进行判断</span></span><br><span class="line">                                    <span class="keyword">if</span>(x &gt;= image_width <span class="keyword">or</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> y&gt;= image_height <span class="keyword">or</span> y&lt;<span class="number">0</span>):</span><br><span class="line">                                        skip_flag = <span class="literal">True</span></span><br><span class="line">                                        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">if</span>( <span class="number">0</span> &lt; points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">2</span>] &lt; <span class="number">2300</span> ):</span><br><span class="line">                                        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                                    <span class="comment">#if(count%2==1):</span></span><br><span class="line">                                     <span class="comment">#   x += 1</span></span><br><span class="line">                                    <span class="comment">#else:</span></span><br><span class="line">                                    <span class="comment">#    y += 1</span></span><br><span class="line"></span><br><span class="line">                                </span><br><span class="line">        </span><br><span class="line">                                <span class="keyword">if</span>(~skip_flag):</span><br><span class="line">                                    text_cxy = <span class="string">&quot;*&quot;</span></span><br><span class="line">                                    cv2.putText(im0, text_cxy, (<span class="built_in">int</span>(x), <span class="built_in">int</span>(y)) ,  cv2.FONT_ITALIC, <span class="number">1.2</span>, (<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">#tl = round(0.02 * (img.shape[0] + img.shape[1]) / 2) + 1  # line/font thickness</span></span><br><span class="line">                                    <span class="comment">#tf = max(tl - 1, 1)  # font thickness</span></span><br><span class="line">                                    <span class="comment">#cv2.putText(im0, text_cxy,  (int(x), int(y)), 0, tl / 3, [0, 0, 255], thickness=tf, lineType=cv2.LINE_AA)</span></span><br><span class="line">                                    </span><br><span class="line">                                    <span class="comment">#print(&quot;count is %d&quot; %count)</span></span><br><span class="line">                                    <span class="built_in">print</span>(<span class="string">&#x27;点 (%d, %d) 的三维坐标 (x:%.1fcm, y:%.1fcm, z:%.1fcm)&#x27;</span> % (<span class="built_in">int</span>(x), <span class="built_in">int</span>(y), </span><br><span class="line">                                        points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">0</span>]/<span class="number">10</span>, </span><br><span class="line">                                        points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">1</span>]/<span class="number">10</span>, </span><br><span class="line">                                        points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">2</span>]/<span class="number">10</span>) )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                    dis = ( (points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">0</span>] ** <span class="number">2</span> + points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">1</span>] ** <span class="number">2</span> + points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">2</span>] **<span class="number">2</span>) ** <span class="number">0.5</span> ) / <span class="number">10</span></span><br><span class="line">                                    <span class="built_in">print</span>(<span class="string">&#x27;点 (%d, %d) 的 %s 距离左摄像头的相对距离为 %0.1f cm&#x27;</span> %(x, y,label, dis) )</span><br><span class="line">                                </span><br><span class="line">                                    <span class="comment">#label = f&#x27;&#123;names[int(cls)]&#125; &#123;conf:.2f&#125; &#x27;</span></span><br><span class="line">                                    <span class="comment">#plot_one_box(xyxy, im0, label=label+ &#x27;x:%.2f y:%.2f z:%.2f&#x27; </span></span><br><span class="line">                                    <span class="comment">#                           %(points_3d[int(y), int(x), 0]/10, </span></span><br><span class="line">                                    <span class="comment">#                             points_3d[int(y), int(x), 1]/10 ,  </span></span><br><span class="line">                                    <span class="comment">#                             points_3d[int(y), int(x), 2]/10) , </span></span><br><span class="line">                                    <span class="comment">#                             color=colors[int(cls)], line_thickness=3)</span></span><br><span class="line"></span><br><span class="line">                                    text_x = <span class="string">&quot;x:%.1fcm&quot;</span> %(points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">0</span>]/<span class="number">10</span>)</span><br><span class="line">                                    text_y = <span class="string">&quot;y:%.1fcm&quot;</span> %(points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">1</span>]/<span class="number">10</span>)</span><br><span class="line">                                    text_z = <span class="string">&quot;z:%.1fcm&quot;</span> %(points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">2</span>]/<span class="number">10</span>)</span><br><span class="line">                                    text_dis = <span class="string">&quot;dis:%.1fcm&quot;</span> %dis</span><br><span class="line"></span><br><span class="line">                                    cv2.rectangle(im0,(<span class="built_in">int</span>(xyxy[<span class="number">0</span>]+(xyxy[<span class="number">2</span>]-xyxy[<span class="number">0</span>])),<span class="built_in">int</span>(xyxy[<span class="number">1</span>])),(<span class="built_in">int</span>(xyxy[<span class="number">0</span>]+(xyxy[<span class="number">2</span>]-xyxy[<span class="number">0</span>])+<span class="number">5</span>+<span class="number">220</span>),<span class="built_in">int</span>(xyxy[<span class="number">1</span>]+<span class="number">150</span>)),colors[<span class="built_in">int</span>(cls)],-<span class="number">1</span>);</span><br><span class="line">                                    cv2.putText(im0, text_x, (<span class="built_in">int</span>(xyxy[<span class="number">0</span>]+(xyxy[<span class="number">2</span>]-xyxy[<span class="number">0</span>])+<span class="number">5</span>), <span class="built_in">int</span>(xyxy[<span class="number">1</span>]+<span class="number">30</span>)),  cv2.FONT_ITALIC, <span class="number">1.2</span>, (<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>), <span class="number">3</span>)</span><br><span class="line">                                    cv2.putText(im0, text_y, (<span class="built_in">int</span>(xyxy[<span class="number">0</span>]+(xyxy[<span class="number">2</span>]-xyxy[<span class="number">0</span>])+<span class="number">5</span>), <span class="built_in">int</span>(xyxy[<span class="number">1</span>]+<span class="number">65</span>)),  cv2.FONT_ITALIC, <span class="number">1.2</span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">3</span>)</span><br><span class="line">                                    cv2.putText(im0, text_z, (<span class="built_in">int</span>(xyxy[<span class="number">0</span>]+(xyxy[<span class="number">2</span>]-xyxy[<span class="number">0</span>])+<span class="number">5</span>), <span class="built_in">int</span>(xyxy[<span class="number">1</span>]+<span class="number">100</span>)), cv2.FONT_ITALIC, <span class="number">1.2</span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">3</span>)</span><br><span class="line">                                    cv2.putText(im0, text_dis, (<span class="built_in">int</span>(xyxy[<span class="number">0</span>]+(xyxy[<span class="number">2</span>]-xyxy[<span class="number">0</span>])+<span class="number">5</span>), <span class="built_in">int</span>(xyxy[<span class="number">1</span>]+<span class="number">145</span>)), cv2.FONT_ITALIC, <span class="number">1.2</span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">#cv2.putText(im0, text_x, (xyxy[0]+(xyxy[2]-xyxy[0])+5, xyxy[1]+30),  cv2.FONT_ITALIC, 1, (102, 80, 250), 3)</span></span><br><span class="line">                                    <span class="comment">#cv2.putText(im0, text_y, (xyxy[0]+(xyxy[2]-xyxy[0])+5, xyxy[1]+65),  cv2.FONT_ITALIC, 1, (102, 80, 250), 3)</span></span><br><span class="line">                                    <span class="comment">#cv2.putText(im0, text_z, (xyxy[0]+(xyxy[2]-xyxy[0])+5, xyxy[1]+100), cv2.FONT_ITALIC, 1, (102, 80, 250), 3)</span></span><br><span class="line">                                    <span class="comment">#cv2.putText(im0, text_dis, (xyxy[0]+(xyxy[2]-xyxy[0])+5, xyxy[1]+145), cv2.FONT_ITALIC, 1, (102, 80, 250), 3)</span></span><br><span class="line"></span><br><span class="line">                                    <span class="comment"># cv2.imshow(&quot;img&amp;coor&quot;, im0)</span></span><br><span class="line">                                    <span class="comment"># 鼠标点击事件</span></span><br><span class="line">                                    <span class="comment">#def onMouse(event, x, y, flags, param):</span></span><br><span class="line">                                    <span class="comment">#    if event == cv2.EVENT_LBUTTONDOWN:</span></span><br><span class="line">                                    <span class="comment">#        print(&#x27;点 (%d, %d) 的三维坐标 (x:%.3fm, y:%.3fm, z:%.3fm)&#x27; % (x, y, points_3d[y, x, 0]/1000, points_3d[y, x, 1]/1000, points_3d[y, x, 2]/1000))</span></span><br><span class="line">                                    <span class="comment">#        dis = ( (points_3d[y, x, 0] ** 2 + points_3d[y, x, 1] ** 2 + points_3d[y, x, 2] **2) ** 0.5) / 1000</span></span><br><span class="line">                                    <span class="comment">#        print(&#x27;点 (%d, %d) 距离左摄像头的相对距离为 %0.3f m&#x27; %(x, y, dis) )</span></span><br><span class="line"></span><br><span class="line">                                    <span class="comment"># 显示图片</span></span><br><span class="line">                                    <span class="comment">#cv2.namedWindow(&quot;disparity&quot;,0)</span></span><br><span class="line">                                    <span class="comment">#cv2.imshow(&quot;disparity&quot;, disp)</span></span><br><span class="line">                                    <span class="comment">#cv2.setMouseCallback(&quot;disparity&quot;, onMouse, 0)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                    <span class="comment"># 构建点云--Point_XYZRGBA格式</span></span><br><span class="line">                                    <span class="comment">#pointcloud = DepthColor2Cloud(points_3d, iml)</span></span><br><span class="line"></span><br><span class="line">                                    <span class="comment"># 显示点云</span></span><br><span class="line">                                    <span class="comment">#view_cloud(pointcloud)</span></span><br><span class="line"></span><br><span class="line">                                    <span class="comment">#cv2.waitKey(0)</span></span><br><span class="line">                                    <span class="comment">#cv2.destroyAllWindows()</span></span><br><span class="line">                                <span class="comment">#except:</span></span><br><span class="line">                                    </span><br><span class="line">                                <span class="comment">#   print(&quot;next!&quot;)</span></span><br><span class="line">                                    t4 = time_synchronized()</span><br><span class="line">                                    <span class="built_in">print</span>(<span class="string">f&#x27;Done. (<span class="subst">&#123;t4 - t3:<span class="number">.3</span>f&#125;</span>s)&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码就会计算出双目测距的距离。注意该段代码需要导入matlab标定的相关参数。以及根据相关参数对图像进行修正的函数</p><p>这里给出整体代码的百度云链接。</p><p>链接：<a href="https://pan.baidu.com/s/1FUHlaKRHsZCxj6lS8il3Jw">https://pan.baidu.com/s/1FUHlaKRHsZCxj6lS8il3Jw</a><br>提取码：i2q5 </p><p>最后便可得出测试效果，如下图。</p><p><img src="/articleImg/18_article/distance.png" alt="distance"></p><h2 id="测试总结"><a href="#测试总结" class="headerlink" title="测试总结"></a>测试总结</h2><ul><li>单独在Jetson Nano上运行yolov5进行实时的目标检测还是挺快的</li><li>进行实时检测时需要指定摄像头数据 –source 0</li><li>在程序中可以设置摄像头的相关数据（双目摄像头需要设置分辨率，不设置的话只会有一个摄像头工作）</li><li>进行视频离线处理视频测距 OK</li><li>进行实时双目测距过程时，由于YOLOV5网络在处理实时数据，会resize图像，导致图像大小发生变化，因此经常会发生数组越界问题</li><li>总体来说，个人觉得测距精度不是很高，后续在进行相关的优化吧~</li></ul>]]></content>
      
      
      <categories>
          
          <category> JetsonNano </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双目测距 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常规表达式转逆波兰表达式</title>
      <link href="/2021/10/09/%E5%B8%B8%E8%A7%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2021/10/09/%E5%B8%B8%E8%A7%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="常规表达式转逆波兰表达式"><a href="#常规表达式转逆波兰表达式" class="headerlink" title="常规表达式转逆波兰表达式"></a>常规表达式转逆波兰表达式</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看到这个题目的时候，我在想，应该不难。这逆波兰表达式的计算顺序，和普通表达式计算的顺序是差不多的，那我在普通计算器实现程序的compute</p><p>函数中做一些改变，看能不能实现这个题目的想法。最后做完发现不太行，程序不够general，遇到一些特殊情况就gg了。主要原因是：普通计算器计算完中中间结果，会将中间结果压栈。在我修改过程中发现，我难以分辨出，本次出栈的结果中是否含有中间结果。因为如果是两个原生数（表达式中的数），就需要全部输出。</p><p>下面给出参考网上的实现思路，并给出自己的实现代码。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p> <img src="/articleImg/23_article/graph.png" alt="graph"></p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"><span class="comment">//将中缀表达式转化为后缀表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferExpression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TransferExpression transferExpression = <span class="keyword">new</span> TransferExpression();</span><br><span class="line">        List&lt;String&gt; strings = transferExpression.fun1(<span class="string">&quot;1+((2+3)×4)-5&quot;</span>);</span><br><span class="line">        List&lt;String&gt; strings1 = transferExpression.fun2(strings);</span><br><span class="line">        System.out.println(<span class="string">&quot;测试完毕&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;String&gt;fun2(List&lt;String&gt; S)&#123;</span><br><span class="line">        <span class="comment">//将分解好的因式，传入，开始进行中缀转后缀的转换</span></span><br><span class="line">        Stack&lt;String&gt; sign_stack = <span class="keyword">new</span> Stack&lt;&gt;(); <span class="comment">//作为运算符的符号栈</span></span><br><span class="line">        ArrayList&lt;String&gt; post_expression = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">//作为数字栈，这里用ArrayList模拟栈的存储，因为这里并不需要出栈</span></span><br><span class="line">        <span class="keyword">for</span> (String item : S) &#123;</span><br><span class="line">            <span class="keyword">if</span>(item.matches(<span class="string">&quot;\\d+&quot;</span>))&#123; <span class="comment">//正则表达式匹配，如果是数</span></span><br><span class="line">                post_expression.add(item);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">//元素为符号</span></span><br><span class="line">                <span class="keyword">char</span> temp = item.charAt(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(sign_stack.isEmpty())&#123;</span><br><span class="line">                    sign_stack.push(item);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(temp == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(!sign_stack.peek().equals(<span class="string">&quot;&quot;</span>+<span class="string">&#x27;(&#x27;</span>))&#123; <span class="comment">//直至扫描找到 （  ，扫描过程中一直出符号栈</span></span><br><span class="line">                        String pop_item = sign_stack.pop();</span><br><span class="line">                        post_expression.add(pop_item);</span><br><span class="line">                    &#125;</span><br><span class="line">                    sign_stack.pop(); <span class="comment">//把符号栈顶&#x27;(&#x27;出栈</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sign_stack.peek().equals(<span class="string">&quot;&quot;</span>+<span class="string">&#x27;(&#x27;</span>))&#123;</span><br><span class="line">                    sign_stack.push(item);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.Sign_priority(temp)&gt;<span class="keyword">this</span>.Sign_priority(sign_stack.peek().charAt(<span class="number">0</span>)))&#123;</span><br><span class="line">                    sign_stack.push(item);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123; <span class="comment">//说明temp符号的优先级小于栈顶符号的优先级,将栈顶元素出栈，再将temp符号压栈</span></span><br><span class="line">                    <span class="comment">//此时的符号肯定是正常的加减乘除</span></span><br><span class="line">                    String pop_item = sign_stack.pop();</span><br><span class="line">                    post_expression.add(pop_item);</span><br><span class="line">                    sign_stack.push(item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!sign_stack.isEmpty())&#123;</span><br><span class="line">            String pop_item = sign_stack.pop();</span><br><span class="line">            post_expression.add(pop_item);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(post_expression);</span><br><span class="line">        <span class="keyword">return</span> post_expression;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fun1</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        String str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c-<span class="string">&#x27;0&#x27;</span>&gt;=<span class="number">0</span>&amp;&amp;c-<span class="string">&#x27;0&#x27;</span>&lt;=<span class="number">9</span>)&#123; <span class="comment">//这里考虑多位数</span></span><br><span class="line">                str = str+c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!str.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">                    strings.add(str);</span><br><span class="line">                    strings.add(<span class="string">&quot;&quot;</span>+s.charAt(i));</span><br><span class="line">                    str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    strings.add(<span class="string">&quot;&quot;</span>+s.charAt(i));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!str.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">            strings.add(str);</span><br><span class="line">            str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(strings);</span><br><span class="line">        <span class="keyword">return</span> strings;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">Sign_priority</span><span class="params">(<span class="keyword">char</span> Sign)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> priority = -<span class="number">1</span>; <span class="comment">//数字大代表优先级大</span></span><br><span class="line">        <span class="keyword">if</span>(Sign == <span class="string">&#x27;+&#x27;</span>||Sign==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            priority = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Sign == <span class="string">&#x27;*&#x27;</span>||Sign==<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">            priority = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Sign == <span class="string">&#x27;&#123;&#x27;</span>||Sign==<span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">            priority = <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Sign == <span class="string">&#x27;[&#x27;</span>||Sign==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">            priority = <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Sign == <span class="string">&#x27;(&#x27;</span>||Sign==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            priority = <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> priority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>继续加油吧~</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中缀转后缀表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python处理excel之修改数据</title>
      <link href="/2021/10/09/python%E5%A4%84%E7%90%86excel%E4%B9%8B%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE/"/>
      <url>/2021/10/09/python%E5%A4%84%E7%90%86excel%E4%B9%8B%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="python处理excel之修改数据"><a href="#python处理excel之修改数据" class="headerlink" title="python处理excel之修改数据"></a>python处理excel之修改数据</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前两天在调试雷达传感器进行数据采集时，得到了一个复数矩阵，但是每个复数都是带着小括号的，这样的数据是没有办法导入到matlab中进行处理的。因为小括号在matlab中表示取某矩阵的元素。于是自己花了40分钟写了一个遍历excel数据，并修改数据的程序，这里记录一下，说不定以后还要用，省的自己再去找读取excel的函数。</p><h2 id="对应代码"><a href="#对应代码" class="headerlink" title="对应代码"></a>对应代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> scipy.io</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">filename=<span class="string">r&quot;C:\Users\zhanglei\Desktop\data\2.csv&quot;</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line">new_data_list = []</span><br><span class="line">row = <span class="number">0</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f:</span><br><span class="line">    reader=csv.reader(f) <span class="comment"># 获取reader对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        row = row+<span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;本次row为&quot;</span>,row)</span><br><span class="line">        header_row=<span class="built_in">next</span>(reader)  <span class="comment"># 获取可迭代对象</span></span><br><span class="line">        <span class="comment"># print(header_row[0])</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(header_row)):   <span class="comment"># 进行遍历</span></span><br><span class="line">            <span class="comment">#print(i)</span></span><br><span class="line">            <span class="keyword">if</span> row == <span class="number">287</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;这里报错&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(header_row[<span class="number">81</span>],header_row[<span class="number">82</span>],header_row[<span class="number">83</span>],header_row[<span class="number">84</span>])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># if header_row[i][0]</span></span><br><span class="line">            <span class="comment">#print(&quot;是否查找到(&quot;,header_row[i].rfind(&#x27;(&#x27;))</span></span><br><span class="line">            <span class="keyword">if</span> header_row[i].find(<span class="string">&#x27;(&#x27;</span>)!=-<span class="number">1</span>:</span><br><span class="line">                header_row[i] = header_row[i].split(<span class="string">&#x27;(&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># print(&quot;是否查找到)&quot;,header_row[i].rfind(&#x27;)&#x27;))</span></span><br><span class="line">            <span class="keyword">if</span> header_row[i].rfind(<span class="string">&#x27;)&#x27;</span>) != -<span class="number">1</span>:</span><br><span class="line">                header_row[i] = header_row[i].split(<span class="string">&#x27;)&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># print(header_row)</span></span><br><span class="line">        new_data_list.append(header_row)</span><br><span class="line"></span><br><span class="line">        count+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count==<span class="number">1080</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment">#print(len(header_row))</span></span><br><span class="line">        <span class="comment">#print(header_row)</span></span><br><span class="line">    <span class="built_in">print</span>(count)</span><br><span class="line">    <span class="comment">#print(new_data_list.shape)</span></span><br><span class="line"></span><br><span class="line">    list_shape = np.array(new_data_list).shape</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;转换后的维度&quot;</span>,list_shape)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;C:\Users\zhanglei\Desktop\data\Transfer2.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">        writer = csv.writer(csvfile)</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> new_data_list:</span><br><span class="line">            writer.writerow(row)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    scipy.io.savemat(<span class="string">&#x27;filename.mat&#x27;</span>,&#123;<span class="string">&#x27;my_data&#x27;</span>: new_data_list&#125;) <span class="comment"># 这里Sava为mat文件出现乱码，当时直接又转存为CSV，所以也没深究，后续再看</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>去除括号之前</p><p> <img src="/articleImg/19_article/data1.png" alt="data1"></p><p>去除之后</p><p> <img src="/articleImg/19_article/data2.png" alt="data2"></p><p>继续加油~</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 遍历修改excel数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆波兰表达式</title>
      <link href="/2021/10/08/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2021/10/08/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="逆波兰表达式"><a href="#逆波兰表达式" class="headerlink" title="逆波兰表达式"></a>逆波兰表达式</h2><h2 id="逆波兰表达式的解释"><a href="#逆波兰表达式的解释" class="headerlink" title="逆波兰表达式的解释"></a>逆波兰表达式的解释</h2><p>逆波兰记法中，操作符置于操作数的后面。例如表达“三加四”时，写作“3 4 + ”，而不是“3 + 4”。如果有多个操作符，操作符置于第二个操作数的后面，所以常规中缀记法的“3 - 4 + 5”在逆波兰记法中写作“3 4 - 5 + ”：先3减去4，再加上5。使用逆波兰记法的一个好处是不需要使用括号。例如中缀记法中“3 - 4 * 5”与“（3 - 4）*5”不相同，但后缀记法中前者写做“3 4 5 * - ”，无歧义地表示“3 (4 5 *) -”；后者写做“3 4 - 5 * ”。</p><p>逆波兰表达式的<a href="https://zh.wikipedia.org/wiki/%E8%A7%A3%E9%87%8A%E5%99%A8">解释器</a>一般是基于<a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88">堆栈</a>的。解释过程一般是：操作数入栈；遇到操作符时，操作数出栈，求值，将结果入栈；当一遍后，栈顶就是表达式的值。因此逆波兰表达式的求值使用堆栈结构很容易实现，并且能很快求值。</p><p>注意：逆波兰记法并不是简单的<a href="https://zh.wikipedia.org/wiki/%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">波兰表达式</a>的反转。因为对于不满足<a href="https://zh.wikipedia.org/wiki/%E4%BA%A4%E6%8D%A2%E5%BE%8B">交换律</a>的操作符，它的操作数写法仍然是常规顺序，如，波兰记法“/ 6 3”的逆波兰记法是“6 3 /”而不是“3 6 /”；数字的数位写法也是常规顺序。</p><h2 id="逆波兰计算器栈的实现思路"><a href="#逆波兰计算器栈的实现思路" class="headerlink" title="逆波兰计算器栈的实现思路"></a>逆波兰计算器栈的实现思路</h2><p> <img src="/articleImg/22_article/graph.png" alt="graph"></p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolandNotation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先定义给逆波兰表达式</span></span><br><span class="line">        <span class="comment">//(30+4)× 5-6 =&gt; 30 4 + 5 × 6 - =&gt; 164</span></span><br><span class="line">        String suffixExpression = <span class="string">&quot;4 5 * 8 - 60 + 8 2 / +&quot;</span>; <span class="comment">// 76</span></span><br><span class="line">        List&lt;String&gt; list = getListString(suffixExpression);</span><br><span class="line">        System.out.println(<span class="string">&quot;rpnList=&quot;</span> + list);</span><br><span class="line">        <span class="keyword">int</span> res = calculate(list);</span><br><span class="line">        System.out.println(<span class="string">&quot;计算的结果是=&quot;</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getListString</span><span class="params">(String suffixExpression)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将 suffixExpression 分割</span></span><br><span class="line">        String[] split = suffixExpression.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String ele : split) &#123;</span><br><span class="line">            list.add(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(List&lt;String&gt; ls)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建给栈, 只需要一个栈即可</span></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line">    <span class="comment">// 遍历 ls</span></span><br><span class="line">        <span class="keyword">for</span> (String item : ls) &#123;</span><br><span class="line">    <span class="comment">// 这里使用正则表达式来取出数</span></span><br><span class="line">            <span class="keyword">if</span> (item.matches(<span class="string">&quot;\\d+&quot;</span>)) &#123; <span class="comment">// 匹配的是多位数</span></span><br><span class="line">            <span class="comment">// 入栈</span></span><br><span class="line">                stack.push(item);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// pop 出两个数， 并运算， 再入栈</span></span><br><span class="line">                <span class="keyword">int</span> num2 = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> num1 = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (item.equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 + num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 - num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 * num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 / num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;运算符有误&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//把 res 入栈</span></span><br><span class="line">                stack.push(<span class="string">&quot;&quot;</span> + res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后留在 stack 中的数据是运算结果</span></span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>继续加油！！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆波兰表达式计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈实现综合计算器</title>
      <link href="/2021/10/08/%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
      <url>/2021/10/08/%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="栈实现综合计算器"><a href="#栈实现综合计算器" class="headerlink" title="栈实现综合计算器"></a>栈实现综合计算器</h1><p>这个其实在本科的时候，自己做过一遍，用的时C，当时理解还挺深刻的，没想到过了几年，自己又忘得差不多了哈哈哈，想到这里，我记得当时去解老师讲的迷宫求解，真的死了很多脑细胞，看来自己还是不属于天才型选手，那就多多努力吧。</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>这次给出java的实现代码，并简单记录实现的关键思路。以防后续遗忘。&lt;切记：这是一个边扫描，边入栈，边出栈，边计算，边入栈的过程&gt;</p><p> <img src="/articleImg/21_article/graph.png" alt="graph"></p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>在这里给出实现的代码，实测可正常运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中缀表达式求值，其实就是平时常见的多项式求值</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">calculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CharStack signStack; <span class="comment">//存放计算符号的栈</span></span><br><span class="line">    <span class="keyword">private</span> ArrayStack numStack; <span class="comment">//存放数字的栈</span></span><br><span class="line">    <span class="keyword">private</span>  CharStack checkBracketStack; <span class="comment">//检查表达式中括号是否合法的栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">calculator</span><span class="params">()</span></span>&#123;</span><br><span class="line">         signStack = <span class="keyword">new</span> CharStack(<span class="number">100</span>,<span class="string">&quot;signStack&quot;</span>);</span><br><span class="line">         numStack = <span class="keyword">new</span> ArrayStack(<span class="number">100</span>,<span class="string">&quot;numStack&quot;</span>);</span><br><span class="line">         checkBracketStack = <span class="keyword">new</span> CharStack(<span class="number">100</span>,<span class="string">&quot;checkBracketStack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修改支持多位数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculator_fun</span><span class="params">(String expression)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> value;</span><br><span class="line">        <span class="keyword">boolean</span> isdigit;</span><br><span class="line">        <span class="keyword">char</span> sign;</span><br><span class="line">        <span class="keyword">int</span> num1;</span><br><span class="line">        <span class="keyword">int</span> num2;</span><br><span class="line">        <span class="keyword">int</span> result;</span><br><span class="line">        <span class="keyword">boolean</span> numbers_flag = <span class="keyword">false</span>;</span><br><span class="line">        System.out.println(expression);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.check_expression(expression))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;表达式合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;表达式不合法，请确认后再次输入！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(expression);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; expression.length(); index++) &#123;</span><br><span class="line">            value = expression.charAt(index);</span><br><span class="line">            isdigit = Character.isDigit(value); <span class="comment">//判断一个字符是不是数字</span></span><br><span class="line">            <span class="keyword">if</span>(isdigit)&#123;</span><br><span class="line">                <span class="keyword">if</span>(numbers_flag)&#123;</span><br><span class="line">                    <span class="keyword">int</span> pop = <span class="keyword">this</span>.numStack.pop();</span><br><span class="line">                    <span class="keyword">this</span>.numStack.push(pop*<span class="number">10</span> + value-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">this</span>.numStack.push(value-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                numbers_flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                numbers_flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.signStack.isEmpty())&#123;</span><br><span class="line">                    <span class="comment">//符号栈为空时，直接压栈</span></span><br><span class="line">                    <span class="keyword">this</span>.signStack.push(value);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123; <span class="comment">//符号栈中已有元素</span></span><br><span class="line">                    <span class="keyword">if</span>(Sign_priority(value)&lt;=Sign_priority(<span class="keyword">this</span>.signStack.get_top())&amp;&amp;<span class="keyword">this</span>.signStack.get_top()!=<span class="string">&#x27;(&#x27;</span>&amp;&amp;<span class="keyword">this</span>.signStack.get_top()!=<span class="string">&#x27;[&#x27;</span>&amp;&amp;<span class="keyword">this</span>.signStack.get_top()!=<span class="string">&#x27;&#123;&#x27;</span>)&#123;  <span class="comment">//遍历到的符号与栈中符号比较优先级</span></span><br><span class="line">                        <span class="comment">//先出栈符号栈一个元素，再出栈符号栈两个元素，进行运算</span></span><br><span class="line">                         sign = <span class="keyword">this</span>.signStack.pop();</span><br><span class="line">                         num1 = <span class="keyword">this</span>.numStack.pop();</span><br><span class="line">                         num2 = <span class="keyword">this</span>.numStack.pop();</span><br><span class="line">                         result = <span class="keyword">this</span>.compute(num2,num1,sign);</span><br><span class="line">                        <span class="comment">//将所得结果压入数字栈</span></span><br><span class="line">                        <span class="keyword">this</span>.numStack.push(result);</span><br><span class="line">                        <span class="comment">//将当前遍历到的符号压入符号栈</span></span><br><span class="line">                        <span class="keyword">this</span>.signStack.push(value);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123; <span class="comment">//若优先级较大，则将该符号插入符号队列 “在这里可以处理添加括号优先级”</span></span><br><span class="line">                        <span class="keyword">if</span>(value == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                            <span class="keyword">this</span>.bracket_express_compute(value);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(value == <span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                            <span class="keyword">this</span>.bracket_express_compute(value);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(value == <span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">                            <span class="keyword">this</span>.bracket_express_compute(value);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="comment">//遍历到的符号优先级大于栈中符号，则入栈</span></span><br><span class="line">                            <span class="keyword">this</span>.signStack.push(value);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当经历for循环之后，符号栈可能不止一个元素  如表达式：2+6/2</span></span><br><span class="line">        <span class="comment">//尤其注意这里还有一个★循环★</span></span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="keyword">this</span>.signStack.isEmpty())&#123;</span><br><span class="line">            sign = <span class="keyword">this</span>.signStack.pop();</span><br><span class="line">            num1 = <span class="keyword">this</span>.numStack.pop();</span><br><span class="line">            num2 = <span class="keyword">this</span>.numStack.pop();</span><br><span class="line">            result = <span class="keyword">this</span>.compute(num2,num1,sign);</span><br><span class="line">            <span class="keyword">this</span>.numStack.push(result);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;最终的结果是:&quot;</span>+ <span class="keyword">this</span>.numStack.pop());</span><br><span class="line">        <span class="comment">//System.out.println(&quot;数字栈是否为空：&quot;+this.numStack.isEmpty());</span></span><br><span class="line">        <span class="comment">//System.out.println(&quot;符号栈是否为空：&quot;+this.signStack.isEmpty());</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">Sign_priority</span><span class="params">(<span class="keyword">char</span> Sign)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> priority = -<span class="number">1</span>; <span class="comment">//数字大代表优先级大</span></span><br><span class="line">        <span class="keyword">if</span>(Sign == <span class="string">&#x27;+&#x27;</span>||Sign==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            priority = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Sign == <span class="string">&#x27;*&#x27;</span>||Sign==<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">            priority = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Sign == <span class="string">&#x27;&#123;&#x27;</span>||Sign==<span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">            priority = <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Sign == <span class="string">&#x27;[&#x27;</span>||Sign==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">            priority = <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Sign == <span class="string">&#x27;(&#x27;</span>||Sign==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            priority = <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> priority;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2, <span class="keyword">char</span> sign)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=-<span class="number">999</span>;</span><br><span class="line">        <span class="keyword">switch</span>(sign)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                result = num1+num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                result = num1-num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                result = num1*num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                result = num1/num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bracket_express_compute</span><span class="params">(<span class="keyword">char</span> sign)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> anti_sign = <span class="keyword">this</span>.get_anti_bracket(sign);</span><br><span class="line">        <span class="keyword">while</span>(anti_sign != <span class="keyword">this</span>.signStack.get_top())&#123;</span><br><span class="line">            <span class="keyword">char</span> compute_sign = <span class="keyword">this</span>.signStack.pop();</span><br><span class="line">            <span class="keyword">int</span> num1 = <span class="keyword">this</span>.numStack.pop();</span><br><span class="line">            <span class="keyword">int</span> num2 = <span class="keyword">this</span>.numStack.pop();</span><br><span class="line">            <span class="keyword">int</span> result = <span class="keyword">this</span>.compute(num2,num1,compute_sign);</span><br><span class="line">            <span class="keyword">this</span>.numStack.push(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.signStack.pop(); <span class="comment">//将符号栈顶部的值为anti_sign的符号出栈</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">char</span> <span class="title">get_anti_bracket</span><span class="params">(<span class="keyword">char</span> sign)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> anti_sign;</span><br><span class="line">        <span class="keyword">switch</span>(sign)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">                anti_sign = <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                anti_sign = <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                anti_sign = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unexpected value: &quot;</span> + sign);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> anti_sign;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check_expression</span><span class="params">(String expression)</span></span>&#123;  <span class="comment">//检查表达式的合法性，这里面可能会有很多中可能性，本次只检查括号是否对应</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; expression.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> value = expression.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(value==<span class="string">&#x27;&#123;&#x27;</span>||value==<span class="string">&#x27;[&#x27;</span>||value==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.checkBracketStack.push(value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(value==<span class="string">&#x27;&#125;&#x27;</span>||value==<span class="string">&#x27;]&#x27;</span>||value==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">char</span> anti_value = <span class="keyword">this</span>.get_anti_bracket(value);</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.checkBracketStack.get_top()==anti_value)&#123;</span><br><span class="line">                    <span class="keyword">this</span>.checkBracketStack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.checkBracketStack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>继续加油吧！！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 综合计算器的实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈—后进先出</title>
      <link href="/2021/10/05/%E6%A0%88%E2%80%94%E5%90%8E%E8%BF%9B%E5%85%88%E5%87%BA/"/>
      <url>/2021/10/05/%E6%A0%88%E2%80%94%E5%90%8E%E8%BF%9B%E5%85%88%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="栈—后进先出"><a href="#栈—后进先出" class="headerlink" title="栈—后进先出"></a>栈—后进先出</h1><p>个人觉得栈、队列、链表、数组这些线性结构不算难，也容易理解，难点还是在树和图那里，之前学过一遍，感觉现在忘得很快，慢慢来，总有一天会全部熟练的。</p><p>这里简单的给出栈的示意图，及java的实现代码（自己实现）。</p><p>示意图如下：</p><p> <img src="/articleImg/20_article/zhan.png" alt="zhan"></p><p>java实现代码(其他类型代码实现也都大同小异)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize; <span class="comment">// 栈的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] stack; <span class="comment">// 数组， 数组模拟栈， 数据就放在该数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top = -<span class="number">1</span>;<span class="comment">// top 表示栈顶， 初始化为-1</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> maxSize,String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈-push</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先判断栈是否满</span></span><br><span class="line">        <span class="keyword">if</span>(isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈满&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">///出栈-pop, 将栈顶的数据返回</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先判断栈是否空</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">    <span class="comment">//抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="keyword">this</span>.name+<span class="string">&quot;栈空， 没有数据~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示栈的情况[遍历栈]， 遍历时， 需要从栈顶开始显示数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈空， 没有数据~~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="comment">//</span></span><br><span class="line">        <span class="comment">//需要从栈顶开始显示数据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = top; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;stack[%d]=%d\n&quot;</span>, i, stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其实在java的JDK中已经给出了栈的相关API引入的过程为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;  <span class="comment">//引入stack包</span></span><br><span class="line"></span><br><span class="line">Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">stack.push(item); <span class="comment">//压栈</span></span><br><span class="line">stack.pop();<span class="comment">//出栈，栈顶指针发生变化</span></span><br><span class="line">stack.peak(); <span class="comment">//获取栈顶指针，但是，栈顶指针指向不发生变化</span></span><br></pre></td></tr></table></figure><p>这一篇就简单给出栈的实现，对应的算法题，在后面几篇给出</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表及相关题目</title>
      <link href="/2021/09/28/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
      <url>/2021/09/28/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="单链表及相关题目"><a href="#单链表及相关题目" class="headerlink" title="单链表及相关题目"></a>单链表及相关题目</h1><p>今天复习的是数据结构中的单链表，整体感觉在自己能力范围之内，感觉自己的薄弱点还是在二叉树和回溯递归那一部分。慢慢来吧，感觉自己最近的学习状态还是不错的，鼓励一下自己！下面废话不多说，对今天学习的知识进行总结：</p><h2 id="单链表结构初始化"><a href="#单链表结构初始化" class="headerlink" title="单链表结构初始化"></a>单链表结构初始化</h2><p>java中的数据结构都是写在类中，这与C语言中的结构体是对应着的知识点，下面给出单链表的结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;  <span class="comment">//这个类就相当于链表中节点的结构，也就相当于C语言中的struct   //根据这个HeroNode，就直接可以慢慢创建出链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next; <span class="comment">//指向下一个节点</span></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对该结构简单分析：其实前三个变量都是无所谓的，你可以随便定义任何信息，最重要的是<strong>HeroNode next;</strong> 这个是链表中的核心，就是因为next节点的存在，才搭建出整个单链表。</p><h2 id="单链表算法流程"><a href="#单链表算法流程" class="headerlink" title="单链表算法流程"></a>单链表算法流程</h2><p> <img src="/articleImg/17_article/linked_list.png" alt="linked_list"></p><h2 id="单链表中必备的函数"><a href="#单链表中必备的函数" class="headerlink" title="单链表中必备的函数"></a>单链表中必备的函数</h2><p>在链表操作的过程中必备的函数有：<strong>数据的有序插入</strong>、<strong>返回头部元素</strong>、<strong>显示链表</strong>、<strong>更新链表中节点的信息</strong>、<strong>删除链表中的元素</strong>、<strong>尾插</strong>、<strong>头插</strong>等，下面给出类的实现：这些所有的方法都写在SingleLinkedList这个类中，如下</p><h3 id="SingleLinkedList类"><a href="#SingleLinkedList类" class="headerlink" title="SingleLinkedList类"></a>SingleLinkedList类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HeroNode head; <span class="comment">//属性</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SingleLinkedList</span><span class="params">()</span> </span>&#123; <span class="comment">//构造方法</span></span><br><span class="line">        head = <span class="keyword">new</span> HeroNode(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回头部元素"><a href="#返回头部元素" class="headerlink" title="返回头部元素"></a>返回头部元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据的有序插入"><a href="#数据的有序插入" class="headerlink" title="数据的有序插入"></a>数据的有序插入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(HeroNode hero1)</span> </span>&#123; <span class="comment">//根据节点信息中的编号，进行数据的插入</span></span><br><span class="line">    <span class="comment">//根据节点信息中的编号，升序插入</span></span><br><span class="line">    HeroNode temp = head;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//temp = temp.next;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(temp == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.head_add(hero1);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(temp.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.next.no&gt;=hero1.no)&#123;</span><br><span class="line">            <span class="comment">//找到该元素</span></span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        hero1.next = temp.next; <span class="comment">//进行插入</span></span><br><span class="line">        temp.next = hero1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tail_add(hero1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="显示链表"><a href="#显示链表" class="headerlink" title="显示链表"></a>显示链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123; <span class="comment">//显示链表</span></span><br><span class="line">    HeroNode temp = head;</span><br><span class="line">    temp = temp.next;</span><br><span class="line">    <span class="keyword">while</span>(temp != <span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.println(temp);</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更新链表中节点的信息"><a href="#更新链表中节点的信息" class="headerlink" title="更新链表中节点的信息"></a>更新链表中节点的信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode newHeroNode)</span> </span>&#123; <span class="comment">//更新链表中节点的信息</span></span><br><span class="line">    <span class="comment">//在本次更新节点过程中，节点的编号是不能更新的，因此可以根据节点的编号去索引节点位置</span></span><br><span class="line">    HeroNode temp = head.next;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(temp.no == newHeroNode.no)&#123;</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flag)&#123; <span class="comment">//表明找到,则更新信息</span></span><br><span class="line">        temp.name = newHeroNode.name;</span><br><span class="line">        temp.nickname = newHeroNode.nickname;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="comment">//没有找到该表好下的元素，进行头插</span></span><br><span class="line">        <span class="keyword">this</span>.addByOrder(newHeroNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="头插"><a href="#头插" class="headerlink" title="头插"></a>头插</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">head_add</span><span class="params">(HeroNode hero1)</span></span>&#123; <span class="comment">//头插</span></span><br><span class="line">    HeroNode temp = head;</span><br><span class="line">    hero1.next = temp.next;</span><br><span class="line">    temp.next = hero1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关题目的实现"><a href="#相关题目的实现" class="headerlink" title="相关题目的实现"></a>相关题目的实现</h2><p>本次的几个算法题目函数都写在LinkedListExercise一个类中</p><h3 id="求单链表中的节点个数"><a href="#求单链表中的节点个数" class="headerlink" title="求单链表中的节点个数"></a>求单链表中的节点个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fun1</span><span class="params">(SingleLinkedList singleLinkedList)</span></span>&#123; <span class="comment">//求单链表中的节点个数</span></span><br><span class="line">    HeroNode head = singleLinkedList.getHead(); <span class="comment">//获取该链表的头节点</span></span><br><span class="line">    HeroNode temp = head.next;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;<span class="comment">//记录链表中的节点个数</span></span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        num++;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找链表中的倒数第K个节点"><a href="#查找链表中的倒数第K个节点" class="headerlink" title="查找链表中的倒数第K个节点"></a>查找链表中的倒数第K个节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fun1</span><span class="params">(SingleLinkedList singleLinkedList)</span></span>&#123; <span class="comment">//求单链表中的节点个数</span></span><br><span class="line">    HeroNode head = singleLinkedList.getHead(); <span class="comment">//获取该链表的头节点</span></span><br><span class="line">    HeroNode temp = head.next;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;<span class="comment">//记录链表中的节点个数</span></span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        num++;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反转一个链表，并返回"><a href="#反转一个链表，并返回" class="headerlink" title="反转一个链表，并返回"></a>反转一个链表，并返回</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//网上写的代码写的挺不错的，多学习一下别人的优秀代码，有空自己吧这个函数修改一下</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SingleLinkedList <span class="title">fun3</span><span class="params">(SingleLinkedList LinkedList)</span></span>&#123;  <span class="comment">//反转一个链表，并返回</span></span><br><span class="line">    SingleLinkedList ReversedLinkedList = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line">    HeroNode head = LinkedList.getHead();</span><br><span class="line">    HeroNode temp = head.next;</span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        ReversedLinkedList.head_add(<span class="keyword">new</span> HeroNode(temp.no,temp.name,temp.nickname));  <span class="comment">//在debug的时候，这里如果不创建新节点保存数据，就会污染原始链表，导致无法遍历</span></span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ReversedLinkedList; <span class="comment">//返回反转后的新链表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="倒序打印单链表"><a href="#倒序打印单链表" class="headerlink" title="倒序打印单链表"></a>倒序打印单链表</h3><p>方式1：利用类中的反转函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun4</span><span class="params">(SingleLinkedList Linkedlist)</span></span>&#123; <span class="comment">//倒序打印单链表, 方式一：利用类中的反转函数</span></span><br><span class="line">    SingleLinkedList ReversedSingleLinkedList = <span class="keyword">this</span>.fun3(Linkedlist);</span><br><span class="line">    <span class="comment">//逆序打印</span></span><br><span class="line">    System.out.println(<span class="string">&quot;逆序打印&quot;</span>);</span><br><span class="line">    ReversedSingleLinkedList.list();</span><br><span class="line">    <span class="comment">//打印原链表</span></span><br><span class="line">    System.out.println(<span class="string">&quot;打印原链表&quot;</span>);</span><br><span class="line">    Linkedlist.list();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式2：反向遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun5</span><span class="params">(SingleLinkedList Linkedlist)</span></span>&#123; <span class="comment">//倒序打印单链表, 方式二：反向遍历</span></span><br><span class="line"></span><br><span class="line">    HeroNode temp = Linkedlist.getHead();</span><br><span class="line">    <span class="keyword">int</span> num = <span class="keyword">this</span>.fun1(Linkedlist);</span><br><span class="line">    <span class="keyword">int</span> k = num;</span><br><span class="line">    System.out.println(<span class="string">&quot;反向遍历打印链表&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(temp);</span><br><span class="line">        k = num-i-<span class="number">1</span>; <span class="comment">//计数k重新赋值</span></span><br><span class="line">        temp = Linkedlist.getHead(); <span class="comment">//temp重新拿到链表的头指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当然倒序打印还有方式三：利用栈保存元素，因为栈是后进先出，既满足倒序打印的需求</span></span><br><span class="line">    <span class="comment">//但是我还没复习到栈，这个需求留到后面再做吧</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式三：利用栈(由于java提供了stack包，这里我也给出相应的实现)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun7</span><span class="params">(SingleLinkedList Linkedlist)</span></span>&#123; <span class="comment">//利用栈逆序打印一个链表</span></span><br><span class="line"></span><br><span class="line">    Stack&lt;HeroNode&gt; stack = <span class="keyword">new</span> Stack&lt;HeroNode&gt;();<span class="comment">//创建一个栈</span></span><br><span class="line">    HeroNode head = Linkedlist.getHead();</span><br><span class="line">    HeroNode temp = head.next;</span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(temp);</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;开始出栈并逆序打印&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(!stack.empty())&#123;</span><br><span class="line">        HeroNode pop = stack.pop();</span><br><span class="line">        System.out.println(pop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两个有序链表进行有序合并"><a href="#两个有序链表进行有序合并" class="headerlink" title="两个有序链表进行有序合并"></a>两个有序链表进行有序合并</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SingleLinkedList <span class="title">fun6</span><span class="params">(SingleLinkedList Linkedlist1,SingleLinkedList Linkedlist2)</span></span>&#123;</span><br><span class="line">    <span class="comment">//这里合并两个有序链表，我个人觉得比较简单，直接调用addByOrder函即可</span></span><br><span class="line">    SingleLinkedList CombineSortedLinkedlist = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line">    HeroNode temp1 = Linkedlist1.getHead();</span><br><span class="line">    HeroNode temp2 = Linkedlist2.getHead();</span><br><span class="line">    <span class="keyword">while</span>(temp1.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//这里仍然需要创建新的HeroNode节点，去保存temp1.next节点中的信息，并被插入到CombineSortedLinkedlist中去</span></span><br><span class="line">        CombineSortedLinkedlist.addByOrder(<span class="keyword">new</span> HeroNode(temp1.next.no,temp1.next.name,temp1.next.nickname));</span><br><span class="line">        temp1 = temp1.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(temp2.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//这里仍然需要创建新的HeroNode节点，去保存temp1.next节点中的信息，并被插入到CombineSortedLinkedlist中去</span></span><br><span class="line">        CombineSortedLinkedlist.addByOrder(<span class="keyword">new</span> HeroNode(temp2.next.no,temp2.next.name,temp2.next.nickname));</span><br><span class="line">        temp2 = temp2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//合并后的新链表</span></span><br><span class="line">    System.out.println(<span class="string">&quot;合并后的新链表&quot;</span>);</span><br><span class="line">    CombineSortedLinkedlist.list();</span><br><span class="line">    <span class="keyword">return</span>  CombineSortedLinkedlist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结束语：继续加油~ fighting，希望自己能够坚持住！</p><ul><li>补充：单链表如果想删除元素的话，必须通过遍历的到被删除元素的前一个元素，在遍历的过程中用本片博客图片1中左边的遍历方式。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多个对象引用</title>
      <link href="/2021/09/26/%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8/"/>
      <url>/2021/09/26/%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="java中多个对象引用"><a href="#java中多个对象引用" class="headerlink" title="java中多个对象引用"></a>java中多个对象引用</h1><p>在堆中new出一个对象之后，对应栈中可以有多个地址指向该对象，也就是多个对象引用。</p><p>这些对象引用在调用对象方法时，实际上始终都是在调用堆中那个对象的方法。</p><p><strong>换个简单点的说法也就是，你这个对象可以有很多名字，但是最终不管通过哪一个名字来操作，影响的始终都是那一个对象！</strong></p><p>插个图吧：</p><p> <img src="/articleImg/16_article/object_reference.png" alt="object_reference"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多个对象引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>循环队列</title>
      <link href="/2021/09/25/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/"/>
      <url>/2021/09/25/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h1><h2 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h2><p>由于循环队列是普通队列的升级版本，使用效率更高，如果可以实现循环队列的话，那你实现普通队列应该也就没什么问题。</p><p>本次实现是用数组模拟队列，当然使用链队也是可以的。</p><p>下面简单的对循环队列做出简要说明，以备后期复习使用：</p><ul><li>因为队列的输出、 输入是分别从前后端来处理， 因此需要两个变量 front 及 rear 分别记录队列前后端的下标，front 会随着数据输出而改变， 而 rear 则是随着数据输入而改变， 如图所示  </li></ul><p> <img src="/articleImg/15_article/queue.png" alt="queue"></p><ul><li>循环队列中的元素个数，可以直接公式给出，当然 可以通过头尾节点的位置，通过遍历整个队列，也可得到队列中元素的个数。下面给出推导过程</li></ul><p><img src="/articleImg/15_article/count_num.png" alt="count_num"></p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p> <img src="/articleImg/15_article/process.png" alt="process"></p><h2 id="附上本次java代码"><a href="#附上本次java代码" class="headerlink" title="附上本次java代码"></a>附上本次java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircularArrayQueue</span></span>&#123;  <span class="comment">//这里实现循环队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize; <span class="comment">// 表示数组的最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front; <span class="comment">// 队列头</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear; <span class="comment">// 队列尾(********切记*************该循环队列中rear指示的是队列尾部的&quot;下一个空位置&quot;)</span></span><br><span class="line">    <span class="comment">//(也就是说rear对应的位置上没有元素的储存)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr; <span class="comment">// 该数据用于存放数据, 模拟队列</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircularArrayQueue</span><span class="params">(<span class="keyword">int</span> maxSize)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 队列头</span></span><br><span class="line">        front = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 队列尾</span></span><br><span class="line">        rear = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 该数据用于存放数据, 模拟队列</span></span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isfull</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = (rear+maxSize-front)%maxSize; <span class="comment">//在数组中队列中的元素可以通过该公式直接算出</span></span><br><span class="line">        <span class="comment">//博客中会解释该公式的由来</span></span><br><span class="line">        <span class="comment">//当然 可以通过头尾节点的位置，通过遍历整个队列，也可得到队列中元素的个数</span></span><br><span class="line">        <span class="keyword">return</span> num == maxSize-<span class="number">1</span>;  <span class="comment">//切记这里返回的是maxSize-1，因为rear位置上并没有储存数据</span></span><br><span class="line">        <span class="comment">//所以该队列的使用率为 maxSize-1</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isempty</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rear==front; <span class="comment">//当头尾标号相等时，队列为空，返回真</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isfull())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;该队列元素已满&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[rear] = value;</span><br><span class="line">        rear = (rear+<span class="number">1</span>)%maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span> </span>&#123; <span class="comment">//获取队头元素，队列是属于先进先出，取队头</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isempty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;该队列已空，无法取出数据&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[front];</span><br><span class="line">        front = (front+<span class="number">1</span>)%maxSize;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span> </span>&#123; <span class="comment">//查看队头元素，不用出队</span></span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> copy_front = front;  <span class="comment">//这里不可以直接使用front，否则毁坏队列</span></span><br><span class="line">        <span class="keyword">if</span>(isempty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列中无元素&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;开始打印该队列：队头-&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(copy_front != rear) &#123;</span><br><span class="line">            System.out.print(arr[copy_front]);</span><br><span class="line">            System.out.print(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            copy_front = (copy_front+<span class="number">1</span>)%maxSize;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;队尾&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用链队在思想上也是一样的，继续加油~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 循环队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>稀疏矩阵</title>
      <link href="/2021/09/24/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5/"/>
      <url>/2021/09/24/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h1><p>从今天开始简单记录一下自己用java写一些数据结构的过程吧，之前用C语言学习数据结构的时候，没有用心去记录，导致自己遗忘的很快，很是后悔。这次好好学，好好记~</p><p>由于稀疏矩阵较为简单，这里插入算法流图，并附上代码，以备后期复习用。</p><p> <img src="/articleImg/14_article/img1.png" alt="img1"></p><p>代码如下，代码中也有相关的注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"><span class="keyword">import</span> jdk.nashorn.api.scripting.ScriptObjectMirror;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//压缩后的矩阵第一行三个数的含义分别是  ： 原始数组的长度、原始数组的宽度、原始数组中非零数字的个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseMatrix</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] chessarray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        SparseMatrix sparseMatrix = <span class="keyword">new</span> SparseMatrix();</span><br><span class="line">        <span class="keyword">int</span>[][] compression = sparseMatrix.Compression();</span><br><span class="line">        sparseMatrix.recover();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] Compression()&#123;  <span class="comment">//压缩矩阵</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//记录有多少非0值</span></span><br><span class="line">        <span class="keyword">int</span> row_length=<span class="number">0</span>;<span class="comment">//chessarray长度</span></span><br><span class="line">        <span class="keyword">int</span> column_width=<span class="number">0</span>;<span class="comment">//chessarray宽度</span></span><br><span class="line">        <span class="comment">//初始化随便赋值几个非零值</span></span><br><span class="line">        chessarray[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        chessarray[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//打印该原始矩阵</span></span><br><span class="line">        System.out.println(<span class="string">&quot;原矩阵打印&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] rows : chessarray) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> temp : rows) &#123;</span><br><span class="line">                <span class="keyword">if</span>(rows==chessarray[<span class="number">0</span>])</span><br><span class="line">                    row_length++;</span><br><span class="line">                <span class="keyword">if</span>(temp!=<span class="number">0</span>)</span><br><span class="line">                    count++;</span><br><span class="line">                System.out.print(temp+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            column_width++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(row_length);</span></span><br><span class="line">        <span class="comment">//System.out.println(column_width);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始进行压缩矩阵的数据存储  （稀疏矩阵的核心就在这里吧）</span></span><br><span class="line">        <span class="keyword">int</span> [][]Compression_matrix = <span class="keyword">new</span> <span class="keyword">int</span>[count+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        Compression_matrix[<span class="number">0</span>][<span class="number">0</span>] = row_length;</span><br><span class="line">        Compression_matrix[<span class="number">0</span>][<span class="number">1</span>] = column_width;</span><br><span class="line">        Compression_matrix[<span class="number">0</span>][<span class="number">2</span>] = count;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(chessarray[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    Compression_matrix[index][<span class="number">0</span>] = i;</span><br><span class="line">                    Compression_matrix[index][<span class="number">1</span>] = j;</span><br><span class="line">                    Compression_matrix[index][<span class="number">2</span>] = chessarray[i][j];</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;压缩矩阵打印&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] compression_matrix : Compression_matrix) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> compressionMatrix : compression_matrix) &#123;</span><br><span class="line">                System.out.print(compressionMatrix+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将压缩后的矩阵存储到data文件中</span></span><br><span class="line">        BufferedWriter out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            out = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;F:\\Algorithm\\java\\稀疏矩阵\\matrix.data&quot;</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : Compression_matrix) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                    out.write(anInt+<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                out.newLine();</span><br><span class="line">            &#125;</span><br><span class="line">            out.flush();</span><br><span class="line">            out.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Compression_matrix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recover</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;  <span class="comment">//还原矩阵</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//从data文件中取出相关数据</span></span><br><span class="line">        BufferedReader in;</span><br><span class="line">        in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;F:\\Algorithm\\java\\稀疏矩阵\\matrix.data&quot;</span>));</span><br><span class="line">        String line = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> rows = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cols = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//读取第一行的值,获得原始数组几行几列，几个有效值</span></span><br><span class="line">        line = in.readLine();</span><br><span class="line">        String[] strings = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        rows = Integer.parseInt(strings[<span class="number">0</span>]);</span><br><span class="line">        cols = Integer.parseInt(strings[<span class="number">1</span>]);</span><br><span class="line">        sum = Integer.parseInt(strings[<span class="number">2</span>]);</span><br><span class="line">        <span class="comment">//初始化原始数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] ori = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((line = in.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            start++;</span><br><span class="line">            <span class="keyword">if</span>(start&lt;=sum)&#123; <span class="comment">//判断非零数字是否读取完毕</span></span><br><span class="line">                String[] split = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                ori[Integer.parseInt(split[<span class="number">0</span>])][Integer.parseInt(split[<span class="number">1</span>])] = Integer.parseInt(split[<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印还原后的矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : ori) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.print(anInt+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>后续加油！！！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 稀疏矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器中的三个域对象</title>
      <link href="/2021/09/23/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E7%9A%84%E4%B8%89%E4%B8%AA%E5%9F%9F%E5%AF%B9%E8%B1%A1/"/>
      <url>/2021/09/23/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E7%9A%84%E4%B8%89%E4%B8%AA%E5%9F%9F%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="tomcat中的三个域对象"><a href="#tomcat中的三个域对象" class="headerlink" title="tomcat中的三个域对象"></a>tomcat中的三个域对象</h1><table><thead><tr><th>域对象</th><th align="left">创建</th><th>销毁</th><th>作用范围</th><th>应用场景</th></tr></thead><tbody><tr><td>ServletContext</td><td align="left">服务器启动（每个服务器只有一个）</td><td>服务器正常关闭/项目从服务器移除</td><td>整个项目</td><td>记录网站访问次数,聊天室</td></tr><tr><td>HttpSession</td><td align="left">没有JSESSIONID这个cookie的时候，调 用request.getSession()方法（每个浏览器一个）</td><td>session过期（默认闲置30分钟），或者调用session对象的invalidate(）方法，或者服务器<strong>异常</strong>关闭</td><td>会话(多次请求)</td><td>验证码校验, <strong>保存用户登录状态</strong>等</td></tr><tr><td>HttpServletRequest</td><td align="left">来了请求（每次请求一个）</td><td>响应这个请求(或者请求已经接收了)</td><td>一次请求</td><td>servletA和jsp（servletB）之间数据传递(转发的时候存数据)</td></tr></tbody></table><h2 id="三个域对象如何选择"><a href="#三个域对象如何选择" class="headerlink" title="三个域对象如何选择"></a>三个域对象如何选择</h2><p>​    一般情况下, 最小的可以解决就用最小的.</p><p>​    但是需要根据情况(eg: 重定向, 多次请求, 会话范围, 用session;  如果是转发,一般选择request)</p><h2 id="ServletContext相关API"><a href="#ServletContext相关API" class="headerlink" title="ServletContext相关API"></a>ServletContext相关API</h2><ul><li>获取ServletContext对象                              ServletContext servletContext = getServletContext();</li><li>往容器ServletContext中存值                      servletContext.setAttribute(“name”,name);</li><li>从容器ServletContext中获取数据               String name = (String) servletContext.getAttribute(“name”);</li><li>获得文件mime-type                                     String mimeType01 = getServletContext().getMimeType(file01);</li><li>获得全局初始化参数                                     String getInitParameter(String name) ; //根据配置文件中的key得到value; </li><li>获取Web资源路径                                        String  getRealPath(String path);根据资源名称得到资源的绝对路径.</li><li>获取Web资源路径                                        getResourceAsStream(String path) ;返回制定路径文件的流</li></ul><h2 id="HttpSession相关API"><a href="#HttpSession相关API" class="headerlink" title="HttpSession相关API"></a>HttpSession相关API</h2><p>session是服务器端的技术, 数据保存在服务器端的</p><ul><li>获取session      requet.getSession()  只有在服务器端调用了该API，才有session产生</li><li>session基于cookie的<ul><li>创建session的同时 生成sessionId, 服务器自动通过Cookie的方式写给浏览器, 浏览器自己保存</li><li>下次的话 浏览器携带cookie(SessionId)找到对应的session使用了</li></ul></li><li>Object getAttribute(String name) ;获取值</li><li>void setAttribute(String name, Object value) ;存储值</li><li>void removeAttribute(String name)  ;移除</li></ul><h2 id="HttpServletRequest-相关知识"><a href="#HttpServletRequest-相关知识" class="headerlink" title="HttpServletRequest 相关知识"></a>HttpServletRequest 相关知识</h2><h3 id="request作用"><a href="#request作用" class="headerlink" title="request作用"></a>request作用</h3><ul><li><strong>操作请求三部分(行,头,体)</strong><ul><li>获取请求行的信息<ul><li>获取请求方式:getMethod() </li><li>获取请求的客户端的ip地址:getRemoteAddr()</li><li>获取项目部署的路径:getContextPath() </li><li>获取uri:统一资源标识符</li></ul></li><li>获取请求头的信息:getHeader(name)</li><li>获取请求参数（全部要掌握，最重要）<ul><li>getParameter(name)</li><li>getParameterValues(name)</li><li>getParameterMap()</li></ul></li><li>使用BeanUtils将map中的数据存储到JavaBean对象中（需要引入相关jar包）<ul><li>map的key要和JavaBean的属性名保持一致，如果不一致那么该字段的值就无法存储</li><li>BeanUtils中默认内置一些基本类型的转换器（如果map中的数据是string类型，JavaBean的属性还是int类型那么会自动转换）</li></ul></li></ul></li></ul><ul><li><strong>请求转发</strong>：request.getRequestDispatcher(“转发的路径”).forward(request,response); <ul><li>跳转操作是由服务器执行的，所以客户端地址栏不会发生变化</li><li>跳转操作不会发起新的请求</li><li>可以跳转到WEB-INF中的资源，但是不能跳转到其它项目的资源</li></ul></li></ul><ul><li><strong>作为”域对象“存数据</strong>  （一般会与请求转发一起使用）<ul><li>Object getAttribute(String name) ;  取</li><li>void setAttribute(String name,Object object)  ; 存</li><li>void removeAttribute(String name)  ; 移除</li></ul></li></ul><h3 id="response相关作用"><a href="#response相关作用" class="headerlink" title="response相关作用"></a>response相关作用</h3><ul><li>设置响应状态码:setStatus()</li><li>设置响应头:setHeader(name,value)<ul><li>refresh响应头，用于隔几秒钟之后跳转到某个页面</li><li>location响应头，用于重定向到某个页面</li></ul></li><li><strong>重定向</strong>的写法: sendRedirect(地址)</li><li>设置响应体的内容<ul><li>使用字符输出流输出文本内容<ul><li>response.getWriter()获取字符输出流</li><li>writer.write()/print()输出字符串</li><li>解决响应数据的中文乱码:response.setContentType(“text/html;charset=UTF-8”)</li></ul></li><li>使用字节输出流输出文件<ul><li>response.getOutputStream()获取字节输出流</li></ul></li></ul></li><li>使用IO流的框架进行边读边写</li></ul><h3 id="request中的请求转发与response中的重定向的区别"><a href="#request中的请求转发与response中的重定向的区别" class="headerlink" title="request中的请求转发与response中的重定向的区别"></a>request中的请求转发与response中的重定向的区别</h3><ul><li><strong>重定向特点</strong><ol><li>重定向的跳转是由浏览器发起的，在这个过程中浏览器会发起两次请求</li><li>定向跳转可以跳转到任意服务</li><li>无法跳转到WEB-INF中的资源，浏览器访问不到的，重定向也访问不到</li><li>重定向跳转不能和request域对象一起使用</li><li>重定向跳转浏览器的地址栏中的地址会变成跳转到的路径</li></ol></li><li><strong>请求转发特点</strong><ol><li>请求转发的跳转是由服务器发起的，在这个过程中浏览器只会发起一次请求</li><li>请求转发只能跳转到本项目的资源，但是可以跳转到WEB-INF中的资源</li><li>请求转发可以和request域对象一起使用</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器域对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java栈、堆、方法区</title>
      <link href="/2021/09/17/java%E6%A0%88%E3%80%81%E5%A0%86%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA/"/>
      <url>/2021/09/17/java%E6%A0%88%E3%80%81%E5%A0%86%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="java-堆、栈、方法区"><a href="#java-堆、栈、方法区" class="headerlink" title="java 堆、栈、方法区"></a>java 堆、栈、方法区</h1><h2 id="三个区的不同之处"><a href="#三个区的不同之处" class="headerlink" title="三个区的不同之处"></a>三个区的不同之处</h2><ul><li><h3 id="堆区"><a href="#堆区" class="headerlink" title="堆区:"></a>堆区:</h3><p>1.<strong>存储的全部是对象</strong>，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令)<br>2.jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，<strong>只存放对象本身</strong> 。</p></li><li><h3 id="栈区"><a href="#栈区" class="headerlink" title="栈区:"></a>栈区:</h3><p>1.每个线程包含一个栈区，栈中只保存<strong>基础数据类型的值</strong>和<strong>对象引用以及基础数据的引用</strong><br>2.每个栈中的数据(基础数据类型和对象引用)都是私有的，其他栈不能访问。<br>3.栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。 </p></li><li><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区:"></a>方法区:</h3><p>1.又叫静态区，跟堆一样，被所有的线程共享。<strong>方法区包含所有的class和static变量</strong>。<br>2.方法区中<strong>包含的都是在整个程序中永远唯一的元素</strong>，如class，static变量。 </p></li></ul><p> <img src="/articleImg/11_article/img1.png" alt="img1"></p><h3 id="什么是栈区的对象引用"><a href="#什么是栈区的对象引用" class="headerlink" title="什么是栈区的对象引用"></a>什么是栈区的对象引用</h3><p><strong>对象</strong>，就是类的一个实例化，把一个抽象不好理解的类举出一个实体来，例如人类是一个类，会吃喝拉撒，实例化出一个小明这个具体的人。 对象引用，就是得给这个人取个名字来指代他，跟c++的指针一样，指向这个人，可以给他一个名字王小明，王小明就是<strong>对象引用</strong>。我们想到这个人的时候就会用王小明去代替他，例如 王小明今天吃了什么，王小明多高，多重，是这个人的属性，用编程语言就是 print（王小明.身高）<br>那么在内存上有什么区别呢，当我 用人这个类实例化出王小明时，电脑是这样识别的 （人 王小明），王小明=new 人（185，60），先给出一个对象引用，此时王小明这个代号可以指向任何人，你也可以叫王小明，他也可以，然后我实例化出一个人，我把王小明这个代号指向了这个人，这个人的内存是在堆内存里的，而王小明这个对象引用是在栈内存里的</p><p>说白了对象引用就是实例对象的名字！</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆栈方法区 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java之对象之间的强制类型转换</title>
      <link href="/2021/09/17/java%E4%B9%8B%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/2021/09/17/java%E4%B9%8B%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="java之对象之间的强制类型转换"><a href="#java之对象之间的强制类型转换" class="headerlink" title="java之对象之间的强制类型转换"></a>java之对象之间的强制类型转换</h1><p>先定义一个父类，一个子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">father</span></span>&#123;  <span class="comment">//父类</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">son</span> <span class="keyword">extends</span> <span class="title">father</span></span>&#123;   <span class="comment">//子类</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>子类对象可以声明为父类类型，父类对象不可以声明为子类类型<br/></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test a=<span class="keyword">new</span> TestExtend();   <span class="comment">//正确</span></span><br><span class="line">TestExtend b=<span class="keyword">new</span> Test();   <span class="comment">//错误</span></span><br></pre></td></tr></table></figure></li><li><p>在子类对象声明为父类类型后，可以通过强制转型，转型回来<br/></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test a=<span class="keyword">new</span> TestExtend();</span><br><span class="line">TestExtend a=(TestExtend) b;         <span class="comment">//正确</span></span><br></pre></td></tr></table></figure></li><li><p>而父类对象声明为父类类型之后，并不能执行强制类型转化<br/></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test a=<span class="keyword">new</span> Test();</span><br><span class="line">TestExtend a=(TestExtend) a;                  <span class="comment">//错误</span></span><br></pre></td></tr></table></figure></li></ul><p>总结：因为在子类对象声明为父类类型后，其实对象的真实意义还是子类对象</p><p>转自 CSDN博主：LookUpMan</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强制类型转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中初始化块和静态初始化块的区别</title>
      <link href="/2021/09/15/Java%E4%B8%AD%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97%E5%92%8C%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2021/09/15/Java%E4%B8%AD%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97%E5%92%8C%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="Java中初始化块和静态初始化块的区别"><a href="#Java中初始化块和静态初始化块的区别" class="headerlink" title="Java中初始化块和静态初始化块的区别"></a>Java中初始化块和静态初始化块的区别</h1><h2 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h2><p>在Java中,有两种初始化块:<strong>静态初始化块</strong>和<strong>非静态初始化块</strong>.</p><ul><li><p><strong>静态初始化块</strong>:使用static定义,当类装载到系统时执行一次.若在静态初始化块中想初始化变量,那仅能初始化类变量,即static修饰的数据成员.</p></li><li><p><strong>非静态初始化块</strong>:在每个对象生成时都会被执行一次,可以初始化类的实例变量.</p><p>非静态初始化块会在构造函数执行时,且在构造函数主体代码执行之前被运行.</p><p>括号里的是初始化块(非静态初始化块)，这里面的代码在创建java对象时执行，而且在构造器之前执行！</p><p>其实初始化块就是构造器的补充，<strong>初始化块是不能接收任何参数的</strong>，定义的一些<strong>所有对象共有的属性、方法等内容时就可以用初始化块了初始化</strong>！！</p></li></ul><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>下面给出卷一中的示例代码<br/></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates object construction,</span></span><br><span class="line"><span class="comment"> * Aversion 1.01 2004-02-19</span></span><br><span class="line"><span class="comment"> * ©author Cay Horstmann</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorTest</span></span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">        <span class="comment">// fill the staff array with three Employee objects</span></span><br><span class="line">        Employee[] staff = <span class="keyword">new</span> Employee[<span class="number">3</span>]:</span><br><span class="line">        staff[<span class="number">0</span>] = <span class="keyword">new</span> Employee(<span class="string">&quot;Harry&quot;</span>, <span class="number">40000</span>);</span><br><span class="line">        staff[<span class="number">1</span>] = <span class="keyword">new</span> Employee(<span class="number">60000</span>);</span><br><span class="line">        staff[<span class="number">2</span>] = <span class="keyword">new</span> Employee();</span><br><span class="line">        <span class="comment">// print out information about all Employee objects</span></span><br><span class="line">        <span class="keyword">for</span> (Employee e : staff)</span><br><span class="line">        System,out.println(<span class="string">&quot;name=&quot;</span> + e.getNameO + <span class="string">&quot;,id=&quot;</span> + e.getldO + <span class="string">&quot;,salary:&quot;</span></span><br><span class="line">        + e.getSalary());</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextld;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">     <span class="keyword">private</span> String name = <span class="comment">// instance field initialization</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// static initialization block  </span></span><br><span class="line">     <span class="comment">//该类一被加载，就会执行该静态代码块，且只在加载类时执行一次</span></span><br><span class="line">      <span class="keyword">static</span></span><br><span class="line">      &#123;</span><br><span class="line">       Random generator = <span class="keyword">new</span> Random();</span><br><span class="line">       <span class="comment">// set nextld to a random number between 0 and 9999</span></span><br><span class="line">       nextld = generator.nextlnt(<span class="number">10000</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// object initialization block</span></span><br><span class="line">    <span class="comment">//初始代码块，在每次创造对象时，就会优于构造函数一步，执行</span></span><br><span class="line">        &#123;</span><br><span class="line">        id = nextld;</span><br><span class="line">        nextld++;</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="comment">// three overloaded constructors</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String n, <span class="keyword">double</span> s)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">     name = n;</span><br><span class="line">     salary = s;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">double</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// calls the Employee(String, double) constructor</span></span><br><span class="line">      ★★★  <span class="keyword">this</span>(<span class="string">&quot;Employee #&quot;</span> + nextld, s);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">        <span class="comment">// name initialized to &quot;&quot; see above</span></span><br><span class="line">        <span class="comment">// salary not explicitly set initialized to 0</span></span><br><span class="line">        <span class="comment">// id initialized in initialization block    </span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSalary</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getld</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对this顺便记录下"><a href="#对this顺便记录下" class="headerlink" title="对this顺便记录下"></a>对this顺便记录下</h2><p>在上述的代码中★★★处有个this，我对this的第二个功能理解的不太好，就是在构造函数中调用其他构造函数，这里简要也记录一下this<br/></p><ul><li><p>this作为隐式参数，也就是被构造的对象，我们以this.实例域的方式来访问实例域。<br/></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name,<span class="keyword">double</span> salary)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name=name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.salary=salary;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>this的另一个作用是调用自己同一个类的其他构造器，形式为this(…)<br/></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">double</span> s)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//调用Employee(String,double)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>(<span class="string">&quot;Employe#&quot;</span>+nextId,s);</span><br><span class="line"></span><br><span class="line">nextId++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当我们调用new Employee(6000）的时候，Employee（double）构造器将调用Employee(String,double)构造器。</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 初始化块和静态初始化块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法参数:Java中如何交换两个对象</title>
      <link href="/2021/09/09/%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0-Java%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1/"/>
      <url>/2021/09/09/%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0-Java%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="方法参数：Java中如何交换两个对象"><a href="#方法参数：Java中如何交换两个对象" class="headerlink" title="方法参数：Java中如何交换两个对象"></a>方法参数：Java中如何交换两个对象</h1><h2 id="方法参数传递的几种形式"><a href="#方法参数传递的几种形式" class="headerlink" title="方法参数传递的几种形式"></a>方法参数传递的几种形式</h2><p>java中只有值传递，基本类型传递的是值的副本，引用类型传递的是引用的副本。</p><p>在核心卷一中一共有三种情况，</p><ol><li><p>基本数据类型作为方法参数<br/></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> percent = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tripieValue</span><span class="params">(<span class="keyword">double</span> x)</span> <span class="comment">// doesn&#x27;t work</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x = <span class="number">3</span> * x;</span><br><span class="line">&#125;</span><br><span class="line">然后调用这个方法：</span><br><span class="line"><span class="keyword">double</span> percent = <span class="number">10</span>;</span><br><span class="line">tripieValue(percent);</span><br><span class="line"></span><br><span class="line">在方法调用之后， percent 的值还是 <span class="number">10</span>。</span><br></pre></td></tr></table></figure><p>对于基本数据类型总结来说就是：一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）  </p></li><li><p>对象作为方法参数<br/></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> tri pi eSal <span class="title">ary</span><span class="params">(Employee x)</span> <span class="comment">// works</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x.raiseSa1ary(<span class="number">200</span>) ;</span><br><span class="line">&#125;</span><br><span class="line">当调用</span><br><span class="line">harry = <span class="keyword">new</span> Employee(. . .) ;</span><br><span class="line">tripieValue(harry) ; <span class="comment">// 注意这里是传入的对象，对该对象进行了浅拷贝</span></span><br><span class="line"><span class="comment">// 最后 方法结束后，参数变量 x 不再使用。当然，对象变量 harry 继续引用那个薪金增至3倍的雇员对象</span></span><br></pre></td></tr></table></figure><p>对于这一点也就是说：一个方法可以改变一个对象参数的状态  </p></li><li><p>如果要交换两个对象，在Java方法中是行不通的，虽然做了浅拷贝，但改变副本的地址，对原本的实参没有影响。<br/>若想解决该问题，达到对象互换的效果，就应该借助第2点的思想“一个方法可以改变一个对象参数的状态”<br/>利用封装类的思想，把对象当作另一个类的成员变量。<br/></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Java program to demonstrate that we can use wrapper</span></span><br><span class="line"><span class="comment">// classes to swap to objects</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A car with model and no.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> model, no;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructor</span></span><br><span class="line">    Car(<span class="keyword">int</span> model, <span class="keyword">int</span> no)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.model = model;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Utility method to print object details</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;no = &quot;</span> + no + </span><br><span class="line">                           <span class="string">&quot;, model = &quot;</span> + model);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A Wrapper over class that is used for swapping</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarWrapper</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   Car c;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Constructor</span></span><br><span class="line">   CarWrapper(Car c)   &#123;<span class="keyword">this</span>.c = c;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A Class that use Car and swaps objects of Car</span></span><br><span class="line"><span class="comment">// using CarWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// This method swaps car objects in wrappers</span></span><br><span class="line">    <span class="comment">// cw1 and cw2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(CarWrapper cw1, </span></span></span><br><span class="line"><span class="params"><span class="function">                            CarWrapper cw2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Car temp = cw1.c;</span><br><span class="line">        cw1.c = cw2.c;</span><br><span class="line">        cw2.c = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Driver method</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Car c1 = <span class="keyword">new</span> Car(<span class="number">101</span>, <span class="number">1</span>);</span><br><span class="line">        Car c2 = <span class="keyword">new</span> Car(<span class="number">202</span>, <span class="number">2</span>);</span><br><span class="line">        CarWrapper cw1 = <span class="keyword">new</span> CarWrapper(c1);</span><br><span class="line">        CarWrapper cw2 = <span class="keyword">new</span> CarWrapper(c2);</span><br><span class="line">        swap(cw1, cw2);</span><br><span class="line">        cw1.c.print();</span><br><span class="line">        cw2.c.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">no = <span class="number">2</span>, model = <span class="number">202</span></span><br><span class="line">no = <span class="number">1</span>, model = <span class="number">101</span></span><br></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>Java中只有值传递，基本类型传递的是值的副本，引用类型传递的是引用的副本。</p><p>所以如果用户类不能访问到被交换的类的成员的时候，封装类可以解决这个问题。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法参数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通配符和正则表达式</title>
      <link href="/2021/09/09/%E9%80%9A%E9%85%8D%E7%AC%A6%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2021/09/09/%E9%80%9A%E9%85%8D%E7%AC%A6%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="通配符和正则表达式"><a href="#通配符和正则表达式" class="headerlink" title="通配符和正则表达式"></a>通配符和正则表达式</h1><p>今晚学了一会linux，记录一下吧，我觉得这个知识点是不是的就会出现，比如爬虫解析网页时也会需要到~</p><h2 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h2><ol><li>通配符代表的是bash的一个功能。一般只用于文件名匹配，它是由shell解析的，比如find，ls，cp，mv等。</li><li>正则表达式是一种字符串处理的方式。针对文件内容的文本过滤工具里，大都用到正则表达式，如vi，grep，awk，sed等</li><li>可以简单的理解为通配符只有*,?,[],{}这4种，而正则表达式复杂多了</li><li>在通配符中*可以匹配任意的0个或多个字符，而在正则表达式中他是重复之前的一个或者多个字符，不能独立使用的</li></ol><p>下面对这两个东西进行简要的记录。</p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="常用标识"><a href="#常用标识" class="headerlink" title="常用标识"></a>常用标识</h3><table><thead><tr><th>符号”.”</th><th>符号”*”</th><th>符号”[]”，总之就是取其中的一个</th></tr></thead><tbody><tr><td>匹配任意一个字符，除了换行符。类似shell通配符中的”?”，匹配一个任意字符。</td><td>“ * “表示前边字符有0个或多个。”.*”表示任意一个字符有0个或多个，也就是能匹配任意的字符。类似shell通配符中的”  * “，可以匹配任意字符。</td><td>“[ ]”中括号中可以包含表示字符集的表达式。使用方法大概有如下几种。<br/>[a-z]：表示a-z字符中的一个，也就是小写字母。<br/>[0-9]：表示0-9字符中的一个，也就是表示数字。<br/>[A-Z]：表示大写字母。<br/>[a-zA-Z]：表示字符集为小写字母或者大写字母。<br/>[a-zA-Z0-9]：表示普通字符，包括大小写字母和数字。<br/>[abc]：表示字符a或者字符b或者字符c。<br/>[ ^ 0-9 ]：表示非数字类型的字符，^表示取反意思，只能放在中括号的开始处才有意义。</td></tr></tbody></table><h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><table><thead><tr><th>字符</th><th align="center">含义</th></tr></thead><tbody><tr><td>^</td><td align="center">指向一行的开头<br/>这里要注意^符号需要放到 ^[]外面，才会代表行首的意思，否者放在里面，就表示取反了</td></tr><tr><td>$</td><td align="center">指向一行的结尾</td></tr><tr><td>.</td><td align="center">任意单个字符</td></tr><tr><td>\</td><td align="center">表示是转义字符</td></tr><tr><td>{}</td><td align="center">表示前边字符的数量范围，但是必须注意要加上转义字符” \ “<br/>eg:{2,9}：表示前边字符的重复次数大于2但小于9</td></tr></tbody></table><h3 id="拓展正则表达式"><a href="#拓展正则表达式" class="headerlink" title="拓展正则表达式"></a>拓展正则表达式</h3><p>扩展正则表达式是在基本正则表达式中扩展出来的，频率上可能没有基本正则表达式那么高</p><table><thead><tr><th>字符</th><th align="center">含义</th></tr></thead><tbody><tr><td>？</td><td align="center">表示前置字符有0个或1个</td></tr><tr><td>+</td><td align="center">表示前置字符有1个或多个</td></tr><tr><td>|</td><td align="center">表示指明两项之间的一个选择。<br/>abc|ABC：表示可以匹配abc或者ABC<br/>（需要注意在bash中他还表示管道，即上一条命令的输出作为下一条命令的参数）</td></tr><tr><td>()</td><td align="center">表示分组<br/> (a|b)b：表示可以匹配ab或者bb字串<br/>([0-9]) | ( [ 0 ] [0 - 9]):表示匹配0-9或者00-09</td></tr></tbody></table><p>特殊匹配模式</p><table><thead><tr><th>匹配模式</th><th>含义</th></tr></thead><tbody><tr><td>[:alnum:]</td><td>字母与数字字符,如grep[[:alnum:]] words.txt</td></tr><tr><td>[:alpha:]</td><td>字母</td></tr><tr><td>[:ascii:]</td><td>ASCII字符</td></tr><tr><td>[:blank:]</td><td>空格或制表符</td></tr><tr><td>[:cntrl:]</td><td>ASCII控制字符</td></tr><tr><td>[:digit:]</td><td>数字</td></tr><tr><td>[:graph:]</td><td>非控制、非空格字符</td></tr><tr><td>[:lower:]</td><td>小写字母</td></tr><tr><td>[:print:]</td><td>可打印字符</td></tr><tr><td>[:punct:]</td><td>标点符号字符</td></tr><tr><td>[:space:]</td><td>空白字符，包括垂直制表符</td></tr><tr><td>[:upper:]</td><td>大写字母</td></tr><tr><td>[:xdigit:]</td><td>十六进制数字</td></tr></tbody></table><p>下面简单记录以下通配符</p><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><h3 id="常见通配符"><a href="#常见通配符" class="headerlink" title="常见通配符"></a>常见通配符</h3><table><thead><tr><th><strong>通配符</strong></th><th><strong>含义</strong></th><th><strong>实例</strong></th></tr></thead><tbody><tr><td>*</td><td>匹配 0 或多个字符</td><td>a*b a与b之间可以有任意长度的任意字符, 也可以一个也没有, 如aabcb, axyzb, a012b, ab。</td></tr><tr><td>?</td><td>匹配任意一个字符</td><td>a?b a与b之间必须也只能有一个字符, 可以是任意字符, 如aab, abb, acb, a0b。</td></tr><tr><td>[list]</td><td>匹配 list 中的任意单一字符</td><td>a[xyz]b  a与b之间必须也只能有一个字符, 但只能是 x 或 y 或 z, 如: axb, ayb, azb。</td></tr><tr><td>[!list]或[ ^ list]</td><td>匹配 除list 中的任意单一字符</td><td>a[!0-9]b a与b之间必须也只能有一个字符, 但不能是阿拉伯数字, 如axb, aab, a-b。</td></tr><tr><td>[c1-c2]</td><td>匹配 c1-c2 中的任意单一字符 如：[0-9] [a-z]</td><td>a[0-9]b 0与9之间必须也只能有一个字符 如a0b, a1b… a9b。</td></tr><tr><td>[!c1-c2]或[ ^ c1-c2]</td><td>匹配不在c1-c2的任意字符</td><td>a[!0-9]b 如acb adb</td></tr><tr><td>{string1,string2,…}</td><td>匹配 sring1 或 string2 (或更多)其一字符串</td><td>a{abc,xyz,123}b 列出aabcb,axyzb,a123b</td></tr></tbody></table><h3 id="shell-元字符"><a href="#shell-元字符" class="headerlink" title="shell 元字符"></a>shell 元字符</h3><table><thead><tr><th>字符</th><th>说明</th></tr></thead><tbody><tr><td>IFS</td><td>由 <space> 或 <tab> 或 <enter> 三者之一组成(我们常用 space )</td></tr><tr><td>CR</td><td>由 <enter> 产生</td></tr><tr><td>=</td><td>设定变量</td></tr><tr><td>$</td><td>取变量值或取运算值</td></tr><tr><td>&gt;</td><td>重定向 stdout</td></tr><tr><td>&lt;</td><td>重定向 stdin</td></tr><tr><td>|</td><td>管道符号                 《注意这里与正则表达式的区别》</td></tr><tr><td>&amp;</td><td>重导向 file descriptor ，或将命令置于背景执行</td></tr><tr><td>( )</td><td>将其内的命令置于 nested subshell 执行，或用于运算或命令替换</td></tr><tr><td>{ }</td><td>将其内的命令置于 non-named function 中执行，或用在变量替换的界定范围</td></tr><tr><td>;</td><td>在前一个命令结束时，而忽略其返回值，继续执行下一个命令</td></tr><tr><td>&amp;&amp;</td><td>在前一个命令结束时，若返回值为 true，继续执行下一个命令</td></tr><tr><td>||</td><td>在前一个命令结束时，若返回值为 false，继续执行下一个命令</td></tr><tr><td>!</td><td>运算意义上的非（not）的意思</td></tr><tr><td>#</td><td>注释，常用在脚本中</td></tr><tr><td>\</td><td>转移字符，去除其后紧跟的元字符或通配符的特殊意义</td></tr></tbody></table><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>这里注意shell中单引号与双引号转义时的区别</p><table><thead><tr><th>字符</th><th>说明</th></tr></thead><tbody><tr><td>‘’(单引号)</td><td>硬转义，其内部所有的shell 元字符、通配符都会被关掉。</td></tr><tr><td>“”(双引号)</td><td>软转义，其内部只允许出现特定的shell 元字符：$用于参数替换 `(反单引号，esc键下面)用于命令替换</td></tr><tr><td>(反斜杠)</td><td>又叫转义，去除其后紧跟的元字符或通配符的特殊意义</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>就这样吧，先总结到这里，后续如果有什么需要补充的地方，再来修改吧~  该进行其他知识的学习了~</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通配符和正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在JestonNano上跑yoloV5</title>
      <link href="/2021/09/06/%E5%9C%A8JestonNano%E4%B8%8A%E8%B7%91yoloV5/"/>
      <url>/2021/09/06/%E5%9C%A8JestonNano%E4%B8%8A%E8%B7%91yoloV5/</url>
      
        <content type="html"><![CDATA[<h1 id="在Jeston-Nano上跑yoloV5"><a href="#在Jeston-Nano上跑yoloV5" class="headerlink" title="在Jeston Nano上跑yoloV5"></a>在Jeston Nano上跑yoloV5</h1><p>网上有很多教程都是讲如何在原生NANO上yoloV5，自己手上的Nano小车装有ros操作系统，我想把yolov5跑在ros中，这样就可以订阅摄像头话题了。</p><p>下面记录这两天解决这个问题的过程吧。</p><h2 id="CUDA确认"><a href="#CUDA确认" class="headerlink" title="CUDA确认"></a>CUDA确认</h2><p>jetson-nano的系统镜像中已经自带了cuda、cudnn、TensorRT等组件</p><ul><li><p>检查CUDA 开始时输入如下的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvcc -V  </span><br></pre></td></tr></table></figure></li><li><p>若没有发现cuda， 需要进行如下的配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit  ~/.bashrc</span><br><span class="line"></span><br><span class="line"># 在这个配置文件的最后写入如下的内容。</span><br><span class="line">export CUDA_HOME=/usr/local/cuda-10.2</span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/cuda-10.2/lib64:$LD_LIBRARY_PATH</span><br><span class="line">export PATH=/usr/local/cuda-10.2/bin:$PATH</span><br></pre></td></tr></table></figure></li><li><p>再次验证 nvcc -V  成功</p></li></ul><h2 id="Archiconda-构建python环境"><a href="#Archiconda-构建python环境" class="headerlink" title="Archiconda 构建python环境"></a>Archiconda 构建python环境</h2><p>首先Nano上安装Archiconda，注意这里不是Anaconda，Nano的cpu架构和window的不一样，属于aarch64的架构，所以在构建各个环境的时候需要格外注意这一点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">附上安装包 ：  https://github.com/Archiconda/build-tools/releases</span><br></pre></td></tr></table></figure><p>下载之后就和普通的anaconda一模一样。直接执行安装，会装一个基本的环境。但真正用的时候还是会conda create -n py36 python=3.6 这样创建环境，然后source activate py36 激活并使用。</p><p>安装完conda，可以用conda -V查看是否安装成功，若没成功，可自行百度各种答案。</p><p>下面进行介绍搭建环境顺序步骤</p><ul><li><p>创建python3.6 ，这里切记后续安装的环境都在这里env里进行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n py36 python=3.6</span><br></pre></td></tr></table></figure></li><li><p>安装torch</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 去英伟达官网下载相应的安装包（匹配jetson-nano）</span><br><span class="line"># 这里附上链接地址</span><br><span class="line">https://forums.developer.nvidia.com/t/pytorch-for-jetson-version-1-9-0-now-available/72048</span><br><span class="line"></span><br><span class="line"># 下载后，通过FileZilla传送到Nano中，安装命令如下</span><br><span class="line">pip install torch-1.6.0-cp36-cp36m-linux_aarch64.whl -i http://pypi.mirrors.ustc.edu.cn/simple/</span><br></pre></td></tr></table></figure></li><li><p>安装torchvision</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 不得不说这个玩意卡了我大半天，不然这个工作早就完成了~ 在英伟达官网上找不到与torch1.6匹配的torchvision0.7.0</span><br><span class="line"># 如果换用其它版本的torchvision，就会报以下错误</span><br><span class="line">RuntimeError: No such operator torchvision::nms </span><br><span class="line"></span><br><span class="line">#于是在网上科普答案，最终得解</span><br><span class="line">sudo apt-get install libjpeg-dev zlib1g-dev</span><br><span class="line">git clone --branch v0.7.0 https://gitee.com/zero-one-game/vision torchvision   </span><br><span class="line"># 鉴于国内网络环境，博主提供gitee码云加速下载，直接使用github会因出现网络问题而无法进行</span><br><span class="line">#这行命令是将源代码下载到了用户目录下的torchvision，如果torchvision已经存在，需要删除，如果提示permission denied</span><br><span class="line">#命令行使用sudo su 进入管理员模式，  执行 rm -r torchvision ,或者也可以自行查找更安全的删除方法</span><br><span class="line"></span><br><span class="line">cd torchvision   </span><br><span class="line"></span><br><span class="line">#进入用户目录下的torchvision，执行源代码编译工作，需要一定的时间，大概十多分钟</span><br><span class="line">sudo python3 setup.py install</span><br><span class="line"></span><br><span class="line">cd ../  # attempting to load torchvision from build dir will result in import error</span><br><span class="line">pip3 install &#x27;pillow&lt;7&#x27; # always needed for Python 2.7, not needed torchvision v0.5.0+ with Python 3.6</span><br><span class="line"></span><br><span class="line">-- 这里摘自CSDN博主「零壹博弈」</span><br></pre></td></tr></table></figure></li></ul><p>到这里yoloV5所需要的运行环境就算是做好了</p><h2 id="拉取yoloV5-ROS代码"><a href="#拉取yoloV5-ROS代码" class="headerlink" title="拉取yoloV5 ROS代码"></a>拉取yoloV5 ROS代码</h2><p>拉取地址如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/qianmin/yolov5_ROS</span><br></pre></td></tr></table></figure><p>在运行之前，需要做以下的工作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1:复制这个包(ros_yolo)到你的catkin_ws/src  </span><br><span class="line">2: catkin_make  </span><br><span class="line">3：在final_yolo.py中，你需要改变image_topic到你自己的相机输入主题  </span><br></pre></td></tr></table></figure><p>之后就可以开心的运行yoloV5啦</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1:roscore2:roslaunch robot_vision robot_camera.launch   # 在移动机器人端使用启动摄像头3:conda activate py36                               #进入相应python环境4:rosrun ros_yolo final_yolo.py             # 起飞~</span><br></pre></td></tr></table></figure><h2 id="运行结果示意图"><a href="#运行结果示意图" class="headerlink" title="运行结果示意图"></a>运行结果示意图</h2><p>摄像头运行</p><p><img src="/articleImg/6_article/image1.png">  </p><p>采集并识别处理后的结果</p><p><img src="/articleImg/6_article/image2.png"> </p><h2 id="未完成任务"><a href="#未完成任务" class="headerlink" title="未完成任务"></a>未完成任务</h2><p>1：感觉FPS还是有点低，虽然已经用了nano的自带gpu，我看网上有的说TensorRT还可以加速，后续可以再看一下。</p><p>2：之后打算问一下老师需不需要做一个自己的数据集，去训练参数并识别。</p><p>3：开始理解雷达成像算法</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python安装相关工具包时极慢</title>
      <link href="/2021/09/06/python%E5%AE%89%E8%A3%85%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E5%8C%85%E6%97%B6%E6%9E%81%E6%85%A2/"/>
      <url>/2021/09/06/python%E5%AE%89%E8%A3%85%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E5%8C%85%E6%97%B6%E6%9E%81%E6%85%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="python安装相关工具包时极慢"><a href="#python安装相关工具包时极慢" class="headerlink" title="python安装相关工具包时极慢"></a>python安装相关工具包时极慢</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARNING: Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None))</span><br></pre></td></tr></table></figure><p>当出现这个警告时代表着你安装时使用的源不太行，我当时的电脑已经配置了清华源（修改配置文件可自行百度），在已经配置清华源的情况下，我的下载还是感觉有点慢，感觉耽误很多时间啊，有没有！</p><p>解决方案也很简单，重新指定下载源。如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install 包名  -i http://pypi.mirrors.ustc.edu.cn/simple/</span><br></pre></td></tr></table></figure><p>如果出现报错，在后面再加上信任后缀</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--trusted-host pypi.mirrors.ustc.edu.cn</span><br></pre></td></tr></table></figure><p>这里也一并附上国内其他的下载源（u1s1我感觉中科大的最好用）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">阿里云 http://mirrors.aliyun.com/pypi/simple/</span><br><span class="line"></span><br><span class="line">中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/</span><br><span class="line"></span><br><span class="line">豆瓣(douban) http://pypi.douban.com/simple/</span><br><span class="line"></span><br><span class="line">清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>由于开代理导致python环境搭建失败</title>
      <link href="/2021/09/04/%E7%94%B1%E4%BA%8E%E5%BC%80%E4%BB%A3%E7%90%86%E5%AF%BC%E8%87%B4python%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%A4%B1%E8%B4%A5/"/>
      <url>/2021/09/04/%E7%94%B1%E4%BA%8E%E5%BC%80%E4%BB%A3%E7%90%86%E5%AF%BC%E8%87%B4python%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%A4%B1%E8%B4%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="由于开代理导致python环境搭建失败"><a href="#由于开代理导致python环境搭建失败" class="headerlink" title="由于开代理导致python环境搭建失败"></a>由于开代理导致python环境搭建失败</h1><p>以前用ssr翻墙也没遇到这种情况，现在改用clash（价格便宜10块钱80g）翻墙之后，在搭建环境的时候遇到以下两种情况。</p><ol><li><p>安装或运行时时报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">raise</span> ValueError(<span class="string">&quot;check_hostname requires server_hostname&quot;</span>)</span><br><span class="line">ValueError: check_hostname requires server_hostname</span><br></pre></td></tr></table></figure></li><li><p>安装包时报以下错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collecting package metadata (current_repodata.json): failed</span><br><span class="line"></span><br><span class="line">An unexpected error has occurred. Conda has prepared the above report.</span><br><span class="line"></span><br><span class="line">If submitted, this report will be used by core maintainers to improve</span><br><span class="line">future releases of conda.</span><br><span class="line">Would you like conda to send this report to the core maintainers?</span><br></pre></td></tr></table></figure></li></ol><p>遇到这样的情况，一般是由两种原因造成，并附上解决方案</p><ul><li><p>每次使用 pip install 命令下载插件的时候，下载的都是最新的版本，导致版本较高，可通过一下方式降级</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install 插件名称  -i http://mirrors.aliyun.com/pypi/simple</span><br></pre></td></tr></table></figure></li><li><p>极可能是开了代理，关闭代理之后，就可以运行或则是安装相应的python环境</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我们慢慢开始长大了</title>
      <link href="/2021/08/15/%E6%88%91%E4%BB%AC%E6%85%A2%E6%85%A2%E5%BC%80%E5%A7%8B%E9%95%BF%E5%A4%A7%E4%BA%86/"/>
      <url>/2021/08/15/%E6%88%91%E4%BB%AC%E6%85%A2%E6%85%A2%E5%BC%80%E5%A7%8B%E9%95%BF%E5%A4%A7%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<h1 id="长大"><a href="#长大" class="headerlink" title="长大"></a><strong>长大</strong></h1><p>​        我是1997年出生的一个小毛孩，不，现在不能说是小毛孩了。现在都已经24岁了，今天还穿着本命年该穿的红裤衩。最近一直有一个隐形的声音在我耳旁一直呼唤到“张磊，你已经长大了，父母开始变老了，该你来撑起这个家了”。我思绪万千，不得不承认自己长大了。如果还不想承认的话，那就看看自己身份证上的年龄吧，它是最诚实的。</p><h1 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a><strong>感悟</strong></h1><p>​        我无法避免长大，妹妹今年也都高三了。我想在这个关键的时间段，对自己做出一些改变。我想让自己在一年后找到一份好工作，在两年后顺利毕业。这是我人生中重要的一步。</p><h1 id="怎样做"><a href="#怎样做" class="headerlink" title="怎样做"></a><strong>怎样做</strong></h1>]]></content>
      
      
      <categories>
          
          <category> 个人感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 成长 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客搭建流程</title>
      <link href="/2021/08/14/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/"/>
      <url>/2021/08/14/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo博客搭建流程"><a href="#hexo博客搭建流程" class="headerlink" title="hexo博客搭建流程"></a><strong>hexo博客搭建流程</strong></h1><p>历经三天，我的博客终于达到了能接受的程度，还是挺开心的，因为一直都想写写博客的，一来呢：是为了记录一下自己学习的内容，做好分类。过去的几年自己确实学了不少东西，单片机啊，高数啊，JAVA基础啊，MySQL基础啊，python，数据结构…… 但都因为没有好好的整理与复习，导致自己容易遗忘，实属可惜。趁着暑假这个机会，我铁了心的想搭个博客。二来呢：为了找工作做准备，听说写博客是一个不错的个人名片。</p><p>废话少说，我把这次搭建博客的流程附上（本次安装在window10下操作，linux也差不多）：</p><h1 id="第一大块"><a href="#第一大块" class="headerlink" title="第一大块"></a><strong>第一大块</strong></h1><h2 id="安装hexo模板"><a href="#安装hexo模板" class="headerlink" title="安装hexo模板"></a><a href="https://www.bilibili.com/video/BV1Yb411a7ty">安装hexo模板</a></h2><ol><li><p>安装git工具   <a href="https://git-scm.com/">附上链接</a></p></li><li><p>安装<a href="https://nodejs.org/en/">Nodejs</a></p></li><li><p>创建一个文件夹（blog），在该文件夹下右键，选择git bash.</p><p><img src="/articleImg/second_article/image1.png"></p></li></ol><p>​            4.在git bash中进行如下安装操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">node -v#查看node版本</span><br><span class="line">npm -v#查看npm版本</span><br><span class="line">npm install -g cnpm --registry=http://registry.npm.taobao.org#安装淘宝的cnpm 管理器</span><br><span class="line">cnpm -v#查看cnpm版本</span><br><span class="line">cnpm install -g hexo-cli    #安装hexo框架</span><br><span class="line">hexo -v#查看hexo版本</span><br><span class="line">mkdir blog#创建blog目录</span><br><span class="line">cd blog #进入blog目录</span><br><span class="line">sudo hexo init #生成博客 初始化博客</span><br><span class="line">hexo s#启动本地博客服务</span><br><span class="line">http://localhost:4000/#本地访问地址</span><br><span class="line">hexo n 我的第一篇文章 #创建新的文章 </span><br><span class="line">#返回blog目录</span><br><span class="line">hexo clean #清理</span><br><span class="line">hexo g #生成</span><br><span class="line">#Github创建一个新的仓库 YourGithubName.github.io</span><br><span class="line">cnpm install --save hexo-deployer-git #在blog目录下安装git部署插件</span><br></pre></td></tr></table></figure><h2 id="配置本地hexo"><a href="#配置本地hexo" class="headerlink" title="配置本地hexo"></a>配置本地hexo</h2><p>这里其实改动的地方也不是很多。</p><p>​        1，配置_config.yml </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line"> repo: https://github.com/YourGithubName/YourGithubName.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>​        2，git bash中下载一个自己喜欢的主题，这里我下载的是butterfly</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 下载主题</span><br><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br><span class="line"># 解决报错 。如果沒有 pug 以及 stylus 的渲染器，还需要下载，否则在项目运行时会报错：</span><br><span class="line">cnpm install hexo-renderer-pug hexo-renderer-stylus --save</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        3，若想让自己的主题生效，还得配置博客根目录下的config.yml文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">修改source\categories文件夹下index.md文件为下面的代码</span><br><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2020-03-04 17:18:32</span><br><span class="line">type: categories</span><br><span class="line">layout: categories   #注意此行不添加则点击不会显示分类结果</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h1 id="第二大块"><a href="#第二大块" class="headerlink" title="第二大块"></a><strong>第二大块</strong></h1><h2 id="butterfly的美化"><a href="#butterfly的美化" class="headerlink" title="butterfly的美化"></a>butterfly的美化</h2><p>下面就是butterfly的美化了（主要修改主题文件夹下的config.yml文件），看着别人做的博客，确实很眼馋，自己改了又改，总觉得不满意，有那么一两个钟，我总是和一个样式美化不显示过不去，最后自己用尽对比、排除的方法，都没得到很好的解决。最终发现原来是浏览器没有清理缓存。这里提一句hexo clean 与 hexo c效果不一样,我在这个命令上吃了大亏，不要图省事就输入简写。</p><p>下面推荐几个我使用过的主题美化网站，这里面的博主写的都挺详细的，我在这里也就不重复了。嘻嘻</p><ol><li>首当其冲的肯定是GitHub上该主题的博主，在500多个closed issue中肯定能找到你想要的解决样式问题的答案。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/jerryc127/hexo-theme-butterfly/issues</span><br></pre></td></tr></table></figure><p>​            2.  下面几个网址都是关于美化博客，其他博主写的文章，写的都蛮详细的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 该网址在最下方贴出了很多了美化博客的传递门，可以上车</span><br><span class="line">https://butterfly.js.org/posts/7670b080/</span><br><span class="line"></span><br><span class="line"># 美化主题</span><br><span class="line">https://www.cnblogs.com/MoYu-zc/p/14395965.html</span><br><span class="line"></span><br><span class="line"># 美化主题</span><br><span class="line">https://blog.imzjw.cn/posts/b74f504f/</span><br></pre></td></tr></table></figure><p>​             3.给博客添加一些小功能            </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 添加评论系统</span><br><span class="line">https://blog.csdn.net/qq_35117024/article/details/107248047</span><br><span class="line"></span><br><span class="line">#添加分类雷达、日历图等数据统计</span><br><span class="line">https://guole.fun/posts/18158/</span><br></pre></td></tr></table></figure><p>​             4.这里记录几个比较好看的博客地址，以后有时间，自己在仿照魔改一下，哈哈</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">博主 : 花猪のBlog </span><br><span class="line">https://cnhuazhu.gitee.io/</span><br></pre></td></tr></table></figure><h2 id="第三大块"><a href="#第三大块" class="headerlink" title="第三大块"></a>第三大块</h2><p>这个大块简单记录一些些小问题，以后可能会用到。</p><p>Number one : 首先记录几个命令，每次调试的时候都很实用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 这两个把clean,生成，运行放在一起，省的自己每次要在git bash中输入三次命令。</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s -p 3999</span><br><span class="line"></span><br><span class="line">#这两是创建新的分区时使用</span><br><span class="line">hexo new page tags</span><br><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><p>这里创建之后有两个问题需要注意，不然你的目录，和分类不会显示！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1：修改source\categories文件夹下index.md文件为下面的代码</span><br><span class="line">        ---</span><br><span class="line">        title: 分类</span><br><span class="line">        date: 2020-03-04 17:18:32</span><br><span class="line">        type: categories</span><br><span class="line">        layout: categories   #注意此行不添加则点击不会显示分类结果</span><br><span class="line">        ---</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2：修改编辑scaffolds/post.md</span><br><span class="line">        ---</span><br><span class="line">        title: &#123;&#123; title &#125;&#125;</span><br><span class="line">        date: &#123;&#123; date &#125;&#125;</span><br><span class="line">        tags: &#123;&#123; tags &#125;&#125;</span><br><span class="line">        ---</span><br><span class="line">scaffolds/draft.md    scaffolds/pages.md 同理</span><br></pre></td></tr></table></figure><p>Number two: 当你不想用https进行 git传送时，可以通过下面的链接更改为SSH传送，我个人感觉SSH传送更稳定。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/qq_43768946/article/details/90411154?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control</span><br><span class="line"># 脑大 ，这个url怎么这么长....</span><br></pre></td></tr></table></figure><p>Number two: 当你hexo d传送不成功，可能是你的局域网问题吧，在windows -&gt; 控制面板 -&gt; 网络和Internet -&gt; Internet选项 -&gt; 连接 -&gt; 局域网设置  : 在这里取消代理服务器，更改位自动检测。</p><p>​    我就在自动检测和代理服务器这里切换切换，就上传了，大概就是应为传送时被墙的原因。</p><p>暂时先更新到这里吧~ 后面如果有相关优化，我会持续更新</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是Linux挂载？</title>
      <link href="/2021/08/13/%E4%BB%80%E4%B9%88%E6%98%AFLinux%E6%8C%82%E8%BD%BD%EF%BC%9F/"/>
      <url>/2021/08/13/%E4%BB%80%E4%B9%88%E6%98%AFLinux%E6%8C%82%E8%BD%BD%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是挂载？mount的用处在哪？"><a href="#什么是挂载？mount的用处在哪？" class="headerlink" title="什么是挂载？mount的用处在哪？"></a>什么是挂载？mount的用处在哪？</h1><p>1.提一句Windows下，mount挂载，就是给磁盘分区提供一个盘符（C,D,E,…）。比如插入U盘后系统自动分配给了它I:盘符其实就是挂载，退优盘的时候进行安全弹出，其实就是卸载unmount。</p><p>2.Linux下，不像Windows可以有C,D,E,多个目录，Linux只有一个根目录/。在装系统时，我们分配给linux的所有区都在/下的某个位置，比如/home等等。</p><p>3.提问者插入了新硬盘，分了新磁盘区sdb1。它现在还不属于/。</p><p>4.我们虽然可以在一些图形桌面系统里找到他的位置，浏览管理里面的文件，但在命令行却不知怎么访问它的目录，比如无法使用cd或者ls。也无法在编程时指定一个目录对它操作。</p><p>5.这时提问者使用了 mount /dev/sdb1 <del>/Share/ ，把新硬盘的区sdb1挂载到工作目录的</del>/Share/文件夹下，之后访问这个~/Share/文件夹就相当于访问这个硬盘2的sdb1分区了。对/Share/的任何操作，都相当于对sdb1里文件的操作。</p><p>6.所以Linux下，<span style='color:fuchsia'>mount挂载的作用，就是将一个设备（通常是存储设备）挂接到一个已存在的目录上。访问这个目录就是访问该存储设备。</span></p><p>7.linux将整个计算机的资源都整合成一个大的文件目录。我们要访问存储设备中的文件，必须将文件所在的分区挂载到一个已存在的目录上，然后通过访问这个目录来访问存储设备。<span style='color:fuchsia'>挂载就是把设备放在一个目录下，让系统知道怎么管理这个设备里的文件，了解这个存储设备的可读写特性之类的过程。</span></p><p>8.我们不是有/dev/sdb1 吗，直接对它操作不就行了？这不是它的目录吗？</p><p>9.这不是它的目录。虽然/dev是个目录，但/dev/sdb1不是目录。可以发现ls/dev/sdb1无法执行。/dev/sdb1，是一个类似指针的东西，指向这个分区的原始数据块。mount前，系统并不知道这个数据块哪部分数据代表文件，如何对它们操作。</p><p>10.插入CD，系统其实自动执行了 mount /dev/cdrom /media/cdrom。所以可以直接在/media/cdrom中对CD中的内容进行管理。</p><p>总结来说：挂载就是把设备（如U盘）加入到linux现有目录下，进而可以进行相应的管理。</p><p style='color:fuchsia'>不挂载的话久会造成无法使用cd或者ls等一系列命令。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mount </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
