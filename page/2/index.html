<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>blog</title><meta name="author" content="张磊"><meta name="copyright" content="张磊"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="website">
<meta property="og:title" content="blog">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="blog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/profile.png">
<meta property="article:author" content="张磊">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/profile.png"><link rel="shortcut icon" href="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/favicon.jpg"><link rel="canonical" href="http://example.com/page/2/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-right"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'blog',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2022-09-06 11:32:11'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/profile.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">112</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">88</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 所有文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url('https://zblogimage.oss-cn-shenzhen.aliyuncs.com/index2.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 所有文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">blog</h1><div id="site-subtitle"><span id="subtitle"></span></div><div id="site_social_icons"><a class="social-icon" href="mailto:zhanglei.szu@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2022/08/02/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/" title="单调队列">     <img class="post_bg" src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/Snipaste_2022-08-02_14-43-55.jpg" onerror="this.onerror=null;this.src='https://zblogimage.oss-cn-shenzhen.aliyuncs.com/404.jpg'" alt="单调队列"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/08/02/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/" title="单调队列">单调队列</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-08-02T06:38:33.000Z" title="发表于 2022-08-02 14:38:33">2022-08-02</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="content">题目是这样的复习完单调栈之后，再看思考单调队列的设计，你会发现这不就是同一种思路的东西吗。也就是在添加数据那里做了些文章，通过while循环保证了队列元素的单调性，单调队列需要保证的是队头元素是最大值，单调栈需要保证的是栈底是最大值，唯一不一样的是单调队列从队头出队元素，也就刚好满足239题的意思，求解滑动窗口的最大值，当左侧left移出的元素为单调队列最大值时，单调队列就要将队头元素删除。
反之单调栈是在栈顶出栈元素，栈顶是单调栈中最小的元素，当然这里是单调递减栈，单调递增栈则反之。
239题的具体代码实现和需要注意的细节问题，已在注释中写清楚了。希望自己能把这类结构转化为长期记忆。
 
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;    public int[] maxSlidingWindow(int[] nums, int k) &#123;        int len = nums.length;       ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2022/08/01/%E5%8D%95%E8%B0%83%E6%A0%88/" title="单调栈">     <img class="post_bg" src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/Snipaste_2022-08-01_16-15-45.jpg" onerror="this.onerror=null;this.src='https://zblogimage.oss-cn-shenzhen.aliyuncs.com/404.jpg'" alt="单调栈"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/08/01/%E5%8D%95%E8%B0%83%E6%A0%88/" title="单调栈">单调栈</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-08-01T08:13:08.000Z" title="发表于 2022-08-01 16:13:08">2022-08-01</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="content">今天来复习单调栈​    闭上眼睛想一下，单调栈确实没什么复杂的。闭上眼睛想一想，就是一组数，通过一定的条件添加进栈中。为什么叫单调呢？主要是在元素加入栈，条件判断时使用的时while, 而我们需要的ans就在这个单调的添加元素的过程中产生，比如我们需要知道每个元素的下一个最大元素、比如我们需要知道环形数组的下一个最大元素。抑或是我想在这个单调添加元素的过程中获取一些其他的信息，比如下一个最大元素的位置？这就需要我们往栈里不仅存上元素的值，还需要存上元素的下标。
​    一般来说下一个最大元素的求解方法，是从数组的末尾进行单调添加，因为倒着入栈便是正着出栈。但我们需要注意单调栈在其他题目中，变形、存储数据的变化、添加数据的方向的变化等。
单调栈的模板程序123456789101112131415161718int[] nextGreaterElement(int[] nums) &#123;    int n = nums.length;    // 存放答案的数组    int[] res = new int[n];    Stack&lt;Integer&gt; s = new  ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2022/07/31/java8%E6%96%B0%E7%89%B9%E6%80%A7/" title="java8新特性">     <img class="post_bg" src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/Snipaste_2022-07-31_08-29-13.jpg" onerror="this.onerror=null;this.src='https://zblogimage.oss-cn-shenzhen.aliyuncs.com/404.jpg'" alt="java8新特性"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/07/31/java8%E6%96%B0%E7%89%B9%E6%80%A7/" title="java8新特性">java8新特性</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-07-31T13:51:06.000Z" title="发表于 2022-07-31 21:51:06">2022-07-31</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">Lambda表达式Lambda表达式的基本语法：
12//Lambda表达式的写法   Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; Integer.compare(o1,o2);



1.举例： (o1,o2) -&gt; Integer.compare(o1,o2);
2.格式：

-&gt; :  lambda操作符 或 箭头操作符

-&gt;左边：lambda形参列表 （其实就是接口中的抽象方法的形参列表)

-&gt;右边：lambda体 （其实就是重写的抽象方法的方法体

函数式接口的使用说明,只有函数式接口才可以用lambda表达式

如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。我们可以在一个接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口。Lambda表达式的本质：作为函数式接口的实例



使用：分为六种情况 
 
总结六种情况：
12345/*-&gt;左边：lambda形参列表的参数类型可以省略(类型推断)；如果lambda形参列表只一个参数，其 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2022/07/30/hello-world/" title="Hello World">     <img class="post_bg" src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/default.png" onerror="this.onerror=null;this.src='https://zblogimage.oss-cn-shenzhen.aliyuncs.com/404.jpg'" alt="Hello World"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/07/30/hello-world/" title="Hello World">Hello World</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-07-30T07:56:04.194Z" title="发表于 2022-07-30 15:56:04">2022-07-30</time></span></div><div class="content">Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.
Quick StartCreate a new post1$ hexo new &quot;My New Post&quot;

More info: Writing
Run server1$ hexo server

More info: Server
Generate static files1$ hexo generate

More info: Generating
Deploy to remote sites1$ hexo deploy

More info: Deployment
</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2022/06/10/groupBy%E7%94%A8%E6%B3%95%E5%92%8C%E5%8E%9F%E7%90%86/" title="groupBy用法和原理">     <img class="post_bg" src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/boy.png" onerror="this.onerror=null;this.src='https://zblogimage.oss-cn-shenzhen.aliyuncs.com/404.jpg'" alt="groupBy用法和原理"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/06/10/groupBy%E7%94%A8%E6%B3%95%E5%92%8C%E5%8E%9F%E7%90%86/" title="groupBy用法和原理">groupBy用法和原理</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-06-10T08:58:53.000Z" title="发表于 2022-06-10 16:58:53">2022-06-10</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Mysql/">Mysql</a></span></div><div class="content">关于group by的用法 原理摘自 —燕山八音
先来看下表1，表名为test：
 
执行如下SQL语句：
12SELECT  name  FROM  testGROUP  BY  name


可是为了能够更好的理解“group by”多个列“和”聚合函数“的应用，我建议在思考的过程中，由表1到表2的过程中，增加一个虚构的中间表：虚拟表3。下面说说如何来思考上面SQL语句执行情况：
1.FROM test：该句执行后，应该结果和表1一样，就是原来的表。
2.FROM test Group BY name：该句执行后，我们想象生成了虚拟表3，如下所图所示，生成过程是这样的：group by name，那么找name那一列，具有相同name值的行，合并成一行，如对于name值为aa的，那么&lt;1 aa 2&gt;与&lt;2 aa 3&gt;两行合并成1行，所有的id值和number值写到一个单元格里面。

3.接下来就要针对虚拟表3执行Select语句了：
（1）如果执行select *的话，那么返回的结果应该是虚拟表3，可是id和number中有的单元格里面的内容是多个值的，而关 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2022/06/06/%E5%86%85%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%8C%BA%E5%88%AB/" title="内连接与子查询的区别">     <img class="post_bg" src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/Snipaste_2022-08-06_10-01-50.jpg" onerror="this.onerror=null;this.src='https://zblogimage.oss-cn-shenzhen.aliyuncs.com/404.jpg'" alt="内连接与子查询的区别"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/06/06/%E5%86%85%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%8C%BA%E5%88%AB/" title="内连接与子查询的区别">内连接与子查询的区别</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-06-06T01:59:09.000Z" title="发表于 2022-06-06 09:59:09">2022-06-06</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Mysql/">Mysql</a></span></div><div class="content">内连接和子查询的区别一 子查询1 MySQL从4.1版本开始支持子查询，使用子查询进行SELECT语句嵌套查询，可以一次完成很多逻辑上需要多个步骤才能完成的SQL操作
2 子查询虽然很灵活，但是执行效率并不高
3 执行子查询时，SQL语句中进行嵌套了SQL语句, 这就类似于循环了
4 例如有两张表, 我先查一张表,查一次, 然后拿这个结果去筛选查另一张表,查两次（增加了回表操作!!!）
二 连接查询(join)1 可以使用连接查询(JOIN)代替子查询，连接查询需要建立临时表，,但因为联表操作不需要查询数据, 只需要在联表成新表之后查询一次, 因此其速度比子查询快
2 表关联是可以利用两个表的索引的，如果是用子查询，至少第二次查询是没有办法使用索引的
3 例如两张表, 我先把两张表拼在一起, 不查, 再查拼起来的新表, 查一次
总结：​    两者不存在谁优于谁的说法，只是那种更适应某种环境。一般要看你是什么用途，如果数据量少的话可以子查询，或者经常用的数据就使用子查询，不经常用的就连接查询，适习惯而定，当然是指数据量少的情况下。
 一般来讲连接查询效率更高，因为子查询会多次遍历数据， ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2022/06/01/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E4%BD%8D%E6%95%B0/" title="数据流中位数">     <img class="post_bg" src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/gril.png" onerror="this.onerror=null;this.src='https://zblogimage.oss-cn-shenzhen.aliyuncs.com/404.jpg'" alt="数据流中位数"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/06/01/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E4%BD%8D%E6%95%B0/" title="数据流中位数">数据流中位数</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-06-01T07:03:05.000Z" title="发表于 2022-06-01 15:03:05">2022-06-01</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="content">数据流的中位数题目如下，是一道困难题，但是只要思路掌握了还是比较好做的。
 
题目分析数据流可以随意增加，那我们如何在O（1）的时间复杂度内获取到中位数呢。肯定是要借助于构建相关的数据结构。
构建想法：将数据流分为两半，前一半和后一半，前一半保存在大顶堆里，这样它最大数就暴露的出来；后一半保存在小顶堆里这样它的最小数就暴露了出来；我们需要的中位数，就是在这两个数之间产生。在添加数据的时候要保证小数(small)的所有数都比大数的要大，且两个堆的数字个数差值不超过1
重要代码结构获取中位数的代码findMedian比较好些，而添加数据流的addNum则颇具技巧，需要自己掌握！
当我们需要往大顶堆里添加数据时，我们像将其添加到小顶堆里，在将小顶堆中最小的数取出来，放在大顶堆中；
当我们需要往小顶堆里添加数据时，我们像将其添加到大顶堆里，在将大顶堆中最小的数取出来，放在小顶堆中；
这样以来就满足了我们的题目设定 要保证小数(small)的所有数都比大数的要大，且两个堆的数字个数差值不超过1
123456789public void addNum(int num) &#123;       i ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2022/06/01/%E5%86%85%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%AD%90%E6%9F%A5%E8%AF%A2%E5%8C%BA%E5%88%AB/" title="内连接与子查询区别">     <img class="post_bg" src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/fasfaef.jpg" onerror="this.onerror=null;this.src='https://zblogimage.oss-cn-shenzhen.aliyuncs.com/404.jpg'" alt="内连接与子查询区别"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/06/01/%E5%86%85%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%AD%90%E6%9F%A5%E8%AF%A2%E5%8C%BA%E5%88%AB/" title="内连接与子查询区别">内连接与子查询区别</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-06-01T02:33:13.000Z" title="发表于 2022-06-01 10:33:13">2022-06-01</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Mysql/">Mysql</a></span></div><div class="content">内连接和子查询的区别一 子查询1 MySQL从4.1版本开始支持子查询，使用子查询进行SELECT语句嵌套查询，可以一次完成很多逻辑上需要多个步骤才能完成的SQL操作
2 子查询虽然很灵活，但是执行效率并不高
3 执行子查询时，SQL语句中进行嵌套了SQL语句, 这就类似于循环了
4 例如有两张表, 我先查一张表,查一次, 然后拿这个结果去筛选查另一张表,查两次（增加了回表操作!!!）
二 连接查询(join)1 可以使用连接查询(JOIN)代替子查询，连接查询需要建立临时表，,但因为联表操作不需要查询数据, 只需要在联表成新表之后查询一次, 因此其速度比子查询快
2 表关联是可以利用两个表的索引的，如果是用子查询，至少第二次查询是没有办法使用索引的
3 例如两张表, 我先把两张表拼在一起, 不查, 再查拼起来的新表, 查一次
总结：​    两者不存在谁优于谁的说法，只是那种更适应某种环境。一般要看你是什么用途，如果数据量少的话可以子查询，或者经常用的数据就使用子查询，不经常用的就连接查询，适习惯而定，当然是指数据量少的情况下。
 一般来讲连接查询效率更高，因为子查询会多次遍历数据， ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2022/05/30/java%E5%8F%8D%E5%B0%84/" title="java反射">     <img class="post_bg" src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/awsome3.jpg" onerror="this.onerror=null;this.src='https://zblogimage.oss-cn-shenzhen.aliyuncs.com/404.jpg'" alt="java反射"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/05/30/java%E5%8F%8D%E5%B0%84/" title="java反射">java反射</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-05-30T13:44:45.000Z" title="发表于 2022-05-30 21:44:45">2022-05-30</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">java反射反射主要用于当程序编译时，无法确定创建一个什么样的对象，需要在运行期间确定！
 
Java反射机制提供的功能

在运行时判断任意一个对象所属的类
在运行时构造任意一个类的对象
在运行时判断任意一个类所具有的成员变量和方法
在运行时获取泛型信息
在运行时调用任意一个对象的成员变量和方法
在运行时处理注解
生成动态代理  

Class 类123456789101112 哪些类型可以有Class对象？ （1）外部类， 成员(成员内部类， 静态内部类)， 局部内部类， 匿名内部类（2） interface： 接口（3） []：数组（4） enum：枚举（5） annotation：注解@interface（6） primitive type：基本数据类型（7） void/*Class类的理解1.类的加载过程：程序经过javac.exe命令以后，会生成一个或多个字节码文件(.class结尾)。接着我们使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。此过程就称为类的加载。加载到内存中的类，我们就称为运行时类，此运行时类，就作为Class的一个 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2022/05/15/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%86%8D%E7%90%86%E8%A7%A3/" title="归并排序与快速排序再理解">     <img class="post_bg" src="/articleImg/leetcode/algorithm3.png" onerror="this.onerror=null;this.src='https://zblogimage.oss-cn-shenzhen.aliyuncs.com/404.jpg'" alt="归并排序与快速排序再理解"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/05/15/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%86%8D%E7%90%86%E8%A7%A3/" title="归并排序与快速排序再理解">归并排序与快速排序再理解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-05-15T08:10:55.000Z" title="发表于 2022-05-15 16:10:55">2022-05-15</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="content">归并排序与快速排序归并排序归并排序就是先把左半边数组排好序，再把右半边数组排好序，然后把两半数组合并，和二叉树的后序遍历很像。
借用大佬的示例图片

附上这个思路的代码
这里要注意temp数组的使用！
temp 数组的作用，是一次归并排序的辅助数组，原数组根据temp数组的本次记录值，来进行本次的归并排序，归并排序的起始点是lo 与 mid+1。排序分为四段：1 左半段已走完    2右半段走完      3 temp[i]&gt;temp[j]    4 else
1234567891011121314151617181920212223242526272829303132333435class Solution &#123;    private static int[]temp;    public int[] sortArray(int[] nums) &#123;        temp = new int[nums.length];        sort(nums,0,nums.length-1);        return nums;    &#125;    pri ...</div></div></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fas fa-chevron-left fa-fw"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/#content-inner">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/#content-inner">12</a><a class="extend next" rel="next" href="/page/3/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/profile.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">张磊</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">112</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">88</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://leetcode.cn/u/vRIkXGwZl4/"><i class="fab fa-github"></i><span>My-Leetcode</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:zhanglei.szu@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/09/06/%E7%8A%B6%E6%80%81%E6%9C%BA%E8%AE%BE%E8%AE%A1%E5%8F%8A%E4%BB%BF%E7%9C%9F/" title="状态机设计及仿真"><img src="https://zblogimage.oss-cn-shenzhen.aliyuncs.com/Snipaste_2022-08-01_16-15-45.jpg" onerror="this.onerror=null;this.src='https://zblogimage.oss-cn-shenzhen.aliyuncs.com/404.jpg'" alt="状态机设计及仿真"/></a><div class="content"><a class="title" href="/2022/09/06/%E7%8A%B6%E6%80%81%E6%9C%BA%E8%AE%BE%E8%AE%A1%E5%8F%8A%E4%BB%BF%E7%9C%9F/" title="状态机设计及仿真">状态机设计及仿真</a><time datetime="2022-09-06T03:29:25.000Z" title="发表于 2022-09-06 11:29:25">2022-09-06</time></div></div></div></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">112</div></div><div class="webinfo-item"><div class="item-name">本站总字数 :</div><div class="item-count">120.6k</div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2022-09-06T03:32:10.347Z"></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 张磊</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function subtitleType () {
  if (true) { 
    var typed = new Typed("#subtitle", {
      strings: "欢迎来到张磊的博客~,这一年，将会是我蜕变的一年！".split(","),
      startDelay: 300,
      typeSpeed: 150,
      loop: true,
      backSpeed: 50
    })
  } else {
    document.getElementById("subtitle").innerHTML = '欢迎来到张磊的博客~'
  }
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.jsdelivr.net/npm/typed.js/lib/typed.min.js').then(subtitleType)
  }
} else {
  subtitleType()
}</script></div><script type="text/javascript" src="/js/cursor.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>