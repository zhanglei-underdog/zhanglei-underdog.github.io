<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>21天刷题计划（13）二分图判定算法</title>
      <link href="/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%8813%EF%BC%89%E4%BA%8C%E5%88%86%E5%9B%BE%E5%88%A4%E5%AE%9A%E7%AE%97%E6%B3%95/"/>
      <url>/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%8813%EF%BC%89%E4%BA%8C%E5%88%86%E5%9B%BE%E5%88%A4%E5%AE%9A%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="判断二分图"><a href="#判断二分图" class="headerlink" title="判断二分图"></a>判断二分图</h1><p><img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/36.jpg" alt="36"></p><p><strong>思路整理</strong></p><ul><li>判定的主要思路在于traverse 函数一边遍历节点，一边给节点染色，尝试让每对相邻节点的颜色都不一样。</li><li>若在遍历的过程中，发现子节点已经遍历过，且子节点的颜色标记与父节点的颜色标记一致，那么判定不是二分图</li><li><strong>也要注意图是否联通的问题，所以我们在调用traverse函数的时候需要，对每一个未遍历过的节点进行判断操作</strong></li><li>其他就没有要整理的问题了，主要就是图的遍历问题DFS、BFS。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//BFS做这道题更形象，DFS也是可以的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> []visited; <span class="comment">//用于记录已经遍历过的节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> ok;       <span class="comment">//用于返回最后的结果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> []color; <span class="comment">//用于给节点染色</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        ok  = <span class="keyword">true</span>;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[graph.length];</span><br><span class="line">        color = <span class="keyword">new</span> <span class="keyword">boolean</span>[graph.length];</span><br><span class="line">        Arrays.fill(visited,<span class="keyword">false</span>);</span><br><span class="line">        Arrays.fill(color,<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">int</span> n=graph.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;   </span><br><span class="line">            <span class="keyword">if</span>(!visited[i])  <span class="comment">//解决图是否联通的问题</span></span><br><span class="line">                traverse(graph,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ok;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(<span class="keyword">int</span> [][]graph,<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!ok)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        visited[s] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> item : graph[s])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[item])&#123;</span><br><span class="line">                visited[item] = <span class="keyword">true</span>;</span><br><span class="line">                color[item] = !color[s];</span><br><span class="line">                traverse(graph,item);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(color[item] == color[s])</span><br><span class="line">                    ok = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="可能的二分法"><a href="#可能的二分法" class="headerlink" title="可能的二分法"></a>可能的二分法</h1><p><img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/37.jpg" alt="37"></p><p><strong>思路整理</strong></p><ul><li><strong>二分图的判定主要思想还是染色法，巧妙利用visited数组和color数组</strong>，达到染色的操作和判断</li><li>对于图的创建，对于邻接表数据结构的定义我们一定要清楚，下方有我的记录</li><li>图创建完毕后，就是一个图遍历的过程DFS、BFS。</li></ul><p><strong>无权图的邻接表形式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 图节点编号为 1...n</span><br><span class="line">List&lt;Integer&gt;[] graph = new LinkedList[n + 1];</span><br><span class="line">for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">    graph[i] = new LinkedList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>带权图的邻接表形式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// graph[x] 存储 x 的所有邻居节点以及对应的权重</span></span><br><span class="line">List&lt;<span class="keyword">int</span>[]&gt;[] graph;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    graph[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt;[]graph;</span><br><span class="line">    <span class="comment">// 记录图中节点的颜色，false 和 true 代表两种不同颜色</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] color;</span><br><span class="line">    <span class="comment">// 记录图中节点是否被访问过</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] visited;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> ok;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">possibleBipartition</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] dislikes)</span> </span>&#123;</span><br><span class="line">        color =  <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">        visited =  <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">        ok = <span class="keyword">true</span>;</span><br><span class="line">        graph = <span class="keyword">new</span> LinkedList[n+<span class="number">1</span>]; <span class="comment">//这里多申请一个节点，为的是与编号数从1开始进行对应</span></span><br><span class="line">        createGraph(graph,dislikes,n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])</span><br><span class="line">                BFS(graph,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ok;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createGraph</span><span class="params">(LinkedList&lt;Integer&gt;[]graph,<span class="keyword">int</span>[][]dislikes,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">//这里就像是在为每一个数组节点进行malloc</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> []edge : dislikes)&#123;</span><br><span class="line">            <span class="keyword">int</span> w = edge[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> v = edge[<span class="number">1</span>];</span><br><span class="line">            graph[w].add(v);</span><br><span class="line">            graph[v].add(w);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 21天刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21天刷题计划（12）图的算法基础</title>
      <link href="/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%8812%EF%BC%89%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%8812%EF%BC%89%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="所有可能的路径"><a href="#所有可能的路径" class="headerlink" title="所有可能的路径"></a>所有可能的路径</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/35.jpg" alt="35"></p><p><strong>思路整理</strong></p><ul><li>对于这道题本身没有什么难度，我们既可以采用深度优先遍历，也可以采用广度优先遍历。我今天主要想总结的是在深度优先遍历中「做选择」和「撤销选择」这两句代码放置的位置。</li></ul><ol><li>常规方法 ： <strong>「做选择」和「撤销选择」都放在for循环内</strong>，这样我们是没有办法将头节点的路径加入到整个path中的，如果我们想要完整的path，必须在调用DFS之前，在path中加入头节点，代码如下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt;path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    path.add(<span class="number">0</span>);                       <span class="comment">//  ★「做选择」和「撤销选择」都放在for循环内的前提，</span></span><br><span class="line">    traverse(graph,<span class="number">0</span>,path,visited);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(<span class="keyword">int</span>[][]graph,<span class="keyword">int</span> s,LinkedList&lt;Integer&gt;path, <span class="keyword">boolean</span> []visited)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(递归基)</span><br><span class="line">        <span class="function">pass</span></span><br><span class="line"><span class="function">    <span class="title">for</span><span class="params">(<span class="keyword">int</span> item:graph[s])</span></span>&#123;  </span><br><span class="line">        path.addLast(item); <span class="comment">//且加入的数据是传入节点s的子节点</span></span><br><span class="line">        traverse(graph,item,path,visited);</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>今天新巩固的方法： <strong>「做选择」和「撤销选择」都放在for循环外</strong>。我们可以直接得到完整的路径，这是因为头节点在传入的时候，就直接被加入到了path中。代码如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt;path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    traverse(graph,<span class="number">0</span>,path,visited);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(<span class="keyword">int</span>[][]graph,<span class="keyword">int</span> s,LinkedList&lt;Integer&gt;path, <span class="keyword">boolean</span> []visited)</span></span>&#123;</span><br><span class="line">    path.addLast(s);  <span class="comment">//  ★「做选择」和「撤销选择」都放在for循环外，加入数据一定要放到递归基之前，且加入的数据是传入节点s</span></span><br><span class="line">    <span class="keyword">if</span>(递归基)</span><br><span class="line">        <span class="function">pass</span></span><br><span class="line"><span class="function">    <span class="title">for</span><span class="params">(<span class="keyword">int</span> item:graph[s])</span></span>&#123;  </span><br><span class="line">        traverse(graph,item,path,visited);</span><br><span class="line">    &#125;</span><br><span class="line">    path.removeLast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>「做选择」和「撤销选择」也可以在for循环的内外进行交叉，但是一定要注意，是对谁进行add操作，和对谁进行remove</li></ol><p><strong>下面的写法本道题目的标准写法，加入了visited数组放置回路，不论是有没有回路都可以解决。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录所有路径</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt;path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> []visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[graph.length]; <span class="comment">//如果图结构中含有环，那么我们需要添加一个visited数组，防止重复遍历</span></span><br><span class="line">        Arrays.fill(visited,<span class="keyword">false</span>);</span><br><span class="line">        traverse(graph,<span class="number">0</span>,path,visited);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(<span class="keyword">int</span>[][]graph,<span class="keyword">int</span> s,LinkedList&lt;Integer&gt;path, <span class="keyword">boolean</span> []visited)</span></span>&#123;</span><br><span class="line">        path.addLast(s); </span><br><span class="line">        visited[s] = <span class="keyword">true</span>;  </span><br><span class="line">        <span class="keyword">if</span>(s == graph.length-<span class="number">1</span>)</span><br><span class="line">         &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(path));   <span class="comment">//return; //如果「做选择」和「撤销选择」放在外面，这里就不能写return</span></span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> item:graph[s])&#123;  </span><br><span class="line">            <span class="keyword">if</span>(visited[item])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            traverse(graph,item,path,visited);</span><br><span class="line">        &#125;</span><br><span class="line">        visited[s] = <span class="keyword">false</span>;</span><br><span class="line">        path.removeLast();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>由于题目中明确说明没有回路，我们就不用加visited数组了</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt;path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    path.addLast(<span class="number">0</span>);</span><br><span class="line">    traverse(graph,<span class="number">0</span>,path);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(<span class="keyword">int</span>[][]graph,<span class="keyword">int</span> s,LinkedList&lt;Integer&gt;path)</span></span>&#123;</span><br><span class="line">    <span class="comment">//添加节点s到路径</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(s == graph.length-<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(path));</span><br><span class="line">        <span class="comment">//return; //如果「做选择」和「撤销选择」放在外面，这里就不能写return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> item:graph[s])&#123;</span><br><span class="line">        path.addLast(item); </span><br><span class="line">        traverse(graph,item,path);</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 21天刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21天刷题计划（11）二叉搜索树的基础操作</title>
      <link href="/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%8811%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%8811%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h1><p><img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/31.jpg" alt="31"></p><p><strong>思路整理</strong></p><ul><li>一旦涉及「改」，函数就要返回 TreeNode 类型，并且对递归调用的返回值进行接收。</li><li>对于二叉搜索树的判断，我们<strong>必须把 root 的约束传递给左右子树</strong>。也就是root节点需要大于哪个数，小于哪个数<strong>。这里我们在参数列表中，增加函数参数列表，在参数中携带额外信息</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root,TreeNode min,TreeNode max)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (min != <span class="keyword">null</span> &amp;&amp; root.val &lt;= min.val) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//不满足root节点的约束</span></span><br><span class="line">        <span class="keyword">if</span> (max != <span class="keyword">null</span> &amp;&amp; root.val &gt;= max.val) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//不满足root节点的约束</span></span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.left,min,root)&amp;&amp;isValidBST(root.right,root,max); <span class="comment">//把 BST 这个「左小右大」的特性用上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉搜索树的插入操作"><a href="#二叉搜索树的插入操作" class="headerlink" title="二叉搜索树的插入操作"></a>二叉搜索树的插入操作</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/32.jpg" alt="32"></p><p><strong>思路整理</strong></p><ul><li>这题涉及插入操作，我们需要将节点进行返回</li><li>我们要在<strong>root等于null的时候进行插入</strong>，这个时候是合适时机，满足二叉搜索树的数据大小的约束</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span>(root.val&gt;val)</span><br><span class="line">            root.left = insertIntoBST(root.left,val);</span><br><span class="line">        <span class="keyword">if</span>(root.val&lt;val)</span><br><span class="line">            root.right = insertIntoBST(root.right,val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉搜索树的搜索"><a href="#二叉搜索树的搜索" class="headerlink" title="二叉搜索树的搜索"></a>二叉搜索树的搜索</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/33.jpg" alt="33"></p><p><strong>思路整理</strong></p><ul><li>搜索的话，根据二叉搜索树的结构特点，我们<strong>通过if判断来进行剪枝操作</strong>，形成二叉搜索树的模板</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; val)</span><br><span class="line">            <span class="keyword">return</span> searchBST(root.left,val);</span><br><span class="line">        <span class="keyword">if</span>(root.val&lt;val)</span><br><span class="line">            <span class="keyword">return</span> searchBST(root.right,val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="删除二叉搜索树中的节点"><a href="#删除二叉搜索树中的节点" class="headerlink" title="删除二叉搜索树中的节点"></a>删除二叉搜索树中的节点</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/34.jpg" alt="34"></p><p><strong>思路整理</strong></p><ul><li><strong>这里涉及删除，所以我们要将节点进行返回</strong></li><li>这道题需要注意的是，<strong>当找到节点进行删除的时候，我们要分三种情况进行讨论</strong></li><li>①当<strong>root.left == null</strong>时，我们返回root.right</li><li>②当<strong>root.right == null</strong>时，我们返回root.left</li><li>③当<strong>root.left、root.right都不为null</strong>时，我们有两种方案进行选择，要么将左子树中最大的节点换上来，要么将右子树中最小的节点换上来</li><li>换上来的节点，需要在删除后，才进行对root的替换</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt;key)</span><br><span class="line">            root.left = deleteNode(root.left,key);</span><br><span class="line">        <span class="keyword">if</span>(root.val&lt;key)</span><br><span class="line">            root.right = deleteNode(root.right,key);</span><br><span class="line">        <span class="keyword">if</span>(root.val == key)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            <span class="keyword">if</span>(root.right == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line">            TreeNode leftMax = <span class="keyword">new</span> TreeNode(-<span class="number">1</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">            TreeNode node = root.left;</span><br><span class="line">            <span class="keyword">while</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">                node = node.right;</span><br><span class="line">            root.left = deleteNode(root.left,node.val);  <span class="comment">//换上来的节点，需要在删除后，才进行对root的替换</span></span><br><span class="line">            leftMax.val = node.val;</span><br><span class="line">            leftMax.left = root.left;</span><br><span class="line">            leftMax.right = root.right;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">return</span> leftMax;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 21天刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉搜索树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21天刷题计划（10）二叉树算法入门</title>
      <link href="/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"/>
      <url>/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="反转二叉树"><a href="#反转二叉树" class="headerlink" title="反转二叉树"></a>反转二叉树</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/28.jpg" alt="28"></p><p><strong>思路总结</strong></p><ol><li>写递归函数要推算出当前节点在干嘛，然后再相信自己对该递归函数的定义。</li><li><strong>一定要有递归基，即递归返回条件</strong>！</li><li>二叉树题目的一个难点就是，<strong>如何把题目的要求细化成每个节点需要做的事情。</strong></li><li>对于该题：我们发现只要把二叉树上的每一个节点的左右子节点进行交换，最后的结果就是完全翻转之后的二叉树。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode node = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = node;</span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="填充每个节点的下一个右侧节点指针"><a href="#填充每个节点的下一个右侧节点指针" class="headerlink" title="填充每个节点的下一个右侧节点指针"></a>填充每个节点的下一个右侧节点指针</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/29.jpg" alt="29"></p><p>第一种思路：</p><ul><li>利用题目的性质：每个父节点都有两个子节点</li><li>传入两个节点，这样就可以将node1的right节点，与node2的left节点进行连接了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        connect(root.left,root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(Node node1,Node node2)</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span>(node1 == <span class="keyword">null</span>||node2 == <span class="keyword">null</span>) <span class="comment">//这样子去写递归基是因为，每个父节点都有两个子节点</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        node1.next = node2;</span><br><span class="line"></span><br><span class="line">        connect(node1.left,node1.right);</span><br><span class="line">        connect(node2.left,node2.right);</span><br><span class="line">        connect(node1.right,node2.left); <span class="comment">//node1的right节点,与node2的left节点传入递归函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种思路：</p><ul><li>充分利用root.next思想，理解root.next其实指的就是root的右边的兄弟节点</li><li>如果想连接node1的right节点与node2的left节点，只需要在满足相关节点不为null的条件下：node.right.next = node.next.left;</li><li>如果采用这种思路，就必须使用前序遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二思路：在前序遍历中，利用next指针，来进行指向操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="comment">//这两句代码要放到最前面，因为当root为null时，就不能去索引root.left,root.right</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>((root.left == <span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>))</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root.next == <span class="keyword">null</span>)</span><br><span class="line">            root.right.next=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            root.right.next = root.next.left; <span class="comment">//连接node1的right节点与node2的left节点</span></span><br><span class="line">        root.left.next = root.right;  <span class="comment">//连接root的本身的两个节点</span></span><br><span class="line">        connect(root.left);</span><br><span class="line">        connect(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a>二叉树展开为链表</h1><p><img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/30.jpg" alt="30"></p><p>二叉树题目的一个难点就是，如何把题目的要求细化成每个节点需要做的事情<br><strong>思路整理</strong></p><ul><li>这题难在原地修改，仅用二叉树的right的指针，将二叉树展开为一个链表</li><li>每个节点所要做的事：<ol><li><strong>首先将当前节点的left和right进行记录</strong></li><li>将root.right指向left,将root.left指向null</li><li>使用临时变量p指向root，进行链表操作，即p=p.right找到表尾</li><li>找到表尾后，将最开始记录的right,放置到p.right</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        flatten(root.left);</span><br><span class="line">        flatten(root.right);</span><br><span class="line">        TreeNode left = root.left;</span><br><span class="line">        TreeNode right = root.right;</span><br><span class="line">        root.right = left;</span><br><span class="line">        root.left = <span class="keyword">null</span>;</span><br><span class="line">        TreeNode p = root;</span><br><span class="line">        <span class="keyword">while</span>(p.right!=<span class="keyword">null</span>)</span><br><span class="line">        p = p.right;</span><br><span class="line">        p.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 21天刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21天刷题计划（9）LRU数据结构的设计</title>
      <link href="/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%889%EF%BC%89LRU%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%889%EF%BC%89LRU%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h1><p><img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/27.jpg" alt="27"></p><p><strong>思路分析</strong></p><p><strong>在思考：如何在双向链表里以O（1）的复杂度进行get,解决方案就用HashMap&lt;key,Node&gt;,这个思路和数组以O（1）的复杂度删除是一样的思路。</strong></p><p>注意: 数组可以保证以O(1)获取，双向链表可以保证以0（1）进行删除，我们需要用HashMap与双向链表进行结合。这样既保证了双线链表0（1）删除，也保证了O（1）时间获取。</p><ul><li>当调用LRUCache的get方法时：该节点在双向链表里需要调整到最后一个位置</li><li>当调用LRUCache的put方法时：若该节点存在，则更新该节点val,并将其移动到最后一个节点。若该节点不存在，判断是否已到达最大容量，若已到达最大容量，删除头节点，并删除map中对应的key；最后将该节点插入到尾部，并在map中加入相关的key；</li></ul><p><img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/26.jpg" alt="26"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line">    HashMap&lt;Integer,Node&gt;map;</span><br><span class="line">    DoubleList dblist;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        cap = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        dblist = <span class="keyword">new</span> DoubleList();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(key))&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> makeNow(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(key,value);</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            Node temp = map.get(key);</span><br><span class="line">            dblist.remove(temp);</span><br><span class="line">            temp.val = value;</span><br><span class="line">            dblist.addLast(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dblist.size() == cap)&#123;</span><br><span class="line">            Node first = dblist.removeFirst();</span><br><span class="line">            map.remove(first.key);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(key,node);</span><br><span class="line">        dblist.addLast(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">makeNow</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node node = map.get(key);</span><br><span class="line">        <span class="keyword">int</span> val = node.val;</span><br><span class="line">        dblist.remove(node);</span><br><span class="line">        dblist.addLast(node);</span><br><span class="line">        <span class="keyword">return</span> node.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> key,val;</span><br><span class="line">    <span class="keyword">public</span> Node next,pre;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = k;</span><br><span class="line">        <span class="keyword">this</span>.val = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleList</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node head,tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">removeFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next == tail)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node first = head.next;</span><br><span class="line">        head.next = first.next;</span><br><span class="line">        first.next.pre = head;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        node.pre = tail.pre;</span><br><span class="line">        node.next = tail;</span><br><span class="line">        tail.pre.next = node;</span><br><span class="line">        tail.pre = node;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        node.pre.next = node.next;</span><br><span class="line">        node.next.pre = node.pre;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 21天刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LRU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21天刷题计划（8）如何在数组中以O（1）删除元素</title>
      <link href="/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%888%EF%BC%89%E5%A6%82%E4%BD%95%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E4%BB%A5O%EF%BC%881%EF%BC%89%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0/"/>
      <url>/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%888%EF%BC%89%E5%A6%82%E4%BD%95%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E4%BB%A5O%EF%BC%881%EF%BC%89%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="常数时间插入、删除和获取元素"><a href="#常数时间插入、删除和获取元素" class="headerlink" title="常数时间插入、删除和获取元素"></a>常数时间插入、删除和获取元素</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/24.jpg" alt="24"></p><p><strong>思路整理</strong></p><ul><li>常数时间进行获取元素一定是连续数组，<strong>要么实际就是连续数组</strong>，<strong>要么通过HashMap构造成逻辑上连续的数组</strong></li><li><strong>通过HashMap存储 数值-下标映射</strong></li><li>需要一个<strong>变量arraySize，记录数组实际的大小</strong>，用于删除数据，插入数据</li><li>删除操作 ： 先拿到 val 的索引，将最后一个元素对应在map中的索引修改为 index，交换 val 和最后一个元素，arraySize–，最后在map中删除元素 val 对应的索引</li><li>插入操作：val 不存在，根据arraySize插入到 nums 尾部</li><li>获取操作：注意通过上述的操作，整个数组已经是连续的了，所以我直接通过random生成[0,arraysize-1]的索引即可</li><li>注意 <strong>random.nextInt(0,arraysize);才表示生成[0,arraysize-1]区间的数</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> []array;</span><br><span class="line">    <span class="keyword">int</span> arraySize;</span><br><span class="line">    HashMap &lt;Integer,Integer&gt;valToIndex;</span><br><span class="line">    Random random;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomizedSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2000001</span>];</span><br><span class="line">        arraySize = <span class="number">0</span>;</span><br><span class="line">        valToIndex = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        random = <span class="keyword">new</span> Random();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(valToIndex.containsKey(val))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        array[arraySize] = val;</span><br><span class="line">        valToIndex.put(val,arraySize);</span><br><span class="line">        arraySize++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!valToIndex.containsKey(val))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> index = valToIndex.get(val);</span><br><span class="line">        <span class="keyword">int</span> temp = array[arraySize -<span class="number">1</span>];</span><br><span class="line">        array[arraySize -<span class="number">1</span>] = array[index];</span><br><span class="line">        array[index] = temp;</span><br><span class="line"></span><br><span class="line">        valToIndex.put(temp,index); <span class="comment">//这一步一定要修改！！数组的值调换之后，hashMap上对应的键值对也要一并修改，而且这一步必须要在下一句的前面，以免删除的元素，就是数组的最后一个元素</span></span><br><span class="line">        valToIndex.remove(val);</span><br><span class="line">        </span><br><span class="line">        arraySize--;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arraySize&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = random.nextInt(arraySize);</span><br><span class="line">        <span class="keyword">return</span> array[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="黑名单中的随机数"><a href="#黑名单中的随机数" class="headerlink" title="黑名单中的随机数"></a>黑名单中的随机数</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/25.jpg" alt="25"></p><p><strong>思路整理</strong></p><ol><li>本题的核心思想是将数组根据有效长度为阈值，划分前后数组</li><li>将前部分数组中的黑名单元素通过HashMap映射到后半部分数组的有效值</li><li>后半部分的遍历通过一个last下标变量进行辅助遍历，遍历的时候，要判断当前last坐标值是否为黑名单，若是黑名单就不要映射，直接last–;</li><li>切记一点：如果想高效地，等概率地随机获取元素，就要使用数组作为底层容器。</li></ol><ul><li>如果要保持数组元素的紧凑性，可以把待删除元素换到最后，然后 pop 掉末尾的元素，这样时间复杂度就是 O(1) 了。当然，我们需要额外的哈希表记录值到索引的映射。</li><li>对于第二题，数组中含有「空洞」（黑名单数字），也可以利用哈希表巧妙处理映射关系，让数组在逻辑上是紧凑的，方便随机取元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">//用于映射黑名单</span></span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] blacklist)</span> </span>&#123;</span><br><span class="line">        size = n - blacklist.length; <span class="comment">//以size进行划分 逻辑分割线</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> item:blacklist)&#123;</span><br><span class="line">            map.put(item,-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> last = n -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> item:blacklist)&#123;</span><br><span class="line">            <span class="keyword">if</span>(item&gt;=size)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span>(map.containsKey(last))&#123;</span><br><span class="line">                last--;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(item,last);</span><br><span class="line">            last--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        Integer res =random.nextInt(size);</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(res))</span><br><span class="line">            <span class="keyword">return</span> map.get(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 21天刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> O(1)复杂度删除元素 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21天刷题计划（7）递归反转链表</title>
      <link href="/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%887%EF%BC%89%E9%80%92%E5%BD%92%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%887%EF%BC%89%E9%80%92%E5%BD%92%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/21.jpg" alt="21"></p><p><strong>思路整理</strong></p><ul><li>首先通过递归返回链表的最后一个节点，由于递归函数的写法为reverseList(head.next)，所以此时的head为倒数第二个节点。</li><li>head.next.next = head; 开始改变指向</li><li>再通过递归栈的逐步释放，是的链表反转完毕</li></ul><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/20.jpg" alt="20"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode last = reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="反转链表2"><a href="#反转链表2" class="headerlink" title="反转链表2"></a>反转链表2</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/23.jpg" alt="23"></p><p>方案1，采用递归进行反转<br><strong>思路整理</strong></p><ul><li>通过第一层递归找到，反转链表的起始位置</li><li>第二层递归式反转right - left + 1个节点，相当于reverseN(head,right-left +1)</li><li>再通过第一次的递归栈释放，将反转后的节点进行返回连接</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ListNode successor = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> reverseN(head,right);</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = reverseBetween(head.next,left-<span class="number">1</span>,right-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseN</span><span class="params">(ListNode head,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            successor = head.next;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode last = reverseN(head.next,n-<span class="number">1</span>);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = successor;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案2，采用头插法进行反转，这时候一定要设立一个虚拟头节点dummy这样可以避免很多特殊情况的套路</p><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/22.jpg" alt="22"></p><p>使用三个指针变量 pre、curr、next 来记录反转的过程中需要的变量，它们的意义如下：</p><ul><li>curr：指向待反转区域的第一个节点 left；</li><li>next：永远指向 curr 的下一个节点，循环过程中，curr 变化以后 next 会变化；</li><li>pre：永远指向待反转区域的第一个节点 left 的前一个节点，在循环过程中不变。</li><li>先将 curr 的下一个节点记录为 next；</li><li>把 curr 的下一个节点指向 next 的下一个节点；</li><li>把 next 的下一个节点指向 pre 的下一个节点；</li><li>把 pre 的下一个节点指向 next。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; right - left; i++) &#123;  <span class="comment">//注意i从0开始，遍历结束条件为 i&lt;right-left   若i从1开始，则变成 i&lt;right-left +1</span></span><br><span class="line">    next = cur.next;</span><br><span class="line">    cur.next = next.next;</span><br><span class="line">    next.next = pre.next;</span><br><span class="line">    pre.next = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dummyNode.next;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 21天刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归反转链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21天刷题计划（6）二分查找</title>
      <link href="/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%886%EF%BC%89%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%886%EF%BC%89%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/18.jpg" alt="18"></p><p><strong>思路整理</strong><br>1：搜索区间很重要： 搜索区间的范围由while循环确定，<strong>若while(left&lt;=right)，区间为[left,right]</strong>,<strong>若while(left&lt;right)，区间为[left,right)</strong><br>2: 缩小搜索边界很重要：<strong>缩小边界范围</strong>，<strong>主要在nums[mid] == target时确定，当区间统一为闭区间时，我们在缩小边界时就要right = mid - 1 或 left = mid+1</strong><br>3. <strong>最终返回谁也很重要</strong>：根据边界缩小的条件，进行判断选择返回谁，若寻找左边界，需要返回left，并且在最后返回之前需要判断位置的合法性，因为数组中可能没有该元素，所以一定要进行合法性检测。</p><p><strong>确定左边界举例****：我们选取闭区间进行查找，所以当nums[mid] == target时，我们left不动，然后让right = mid - 1,当while循环结束时，left是大于right的,也就是</strong>left = right+1, 注意：因为我们之前left不动，然后让right = mid - 1，最后情况下mid就是左边界，所以我们应该返回left，也可以是right+1</p><p>*<em>返回值判断举例</em>***：如果是左边界，我们选择返回left，那么就要考虑两个极端情况</p><ul><li>当target 不存在时，且target小于数组中的所有值，那就应该判断 nums[left]==target</li><li>当target 不存在时，且target大于数组中的所有值，就需要判断 left是否大于nums.length</li><li>当存在时，直接返回left或right + 1即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> []ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> left = leftBound(nums,target);</span><br><span class="line">        <span class="keyword">int</span> right = rightBound(nums,target);</span><br><span class="line">        ans[<span class="number">0</span>] = left;</span><br><span class="line">        ans[<span class="number">1</span>] = right; </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leftBound</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">                right = mid - <span class="number">1</span>; <span class="comment">//根据缩小边界的条件，确定最后返回谁</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= nums.length || nums[left]!=target)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rightBound</span><span class="params">(<span class="keyword">int</span> []nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">                left = mid + <span class="number">1</span>; <span class="comment">//根据这一句，再根据循环结束条件为left &gt; right 即left-1= right.可知我们最终需要返回right或则left-1 </span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">                right = mid -<span class="number">1</span>;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right &lt; <span class="number">0</span>|| nums[right]!=target)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常规二分查找"><a href="#常规二分查找" class="headerlink" title="常规二分查找"></a>常规二分查找</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/19.jpg" alt="19"></p><p><strong>思路整理</strong></p><ul><li>这个是常规的二分查找，查找左右边界的题目请见34题</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int search(int[] nums, int target) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = nums.length-1;</span><br><span class="line">        while(left &lt;= right)&#123;</span><br><span class="line">            int mid = (left+right)/2;</span><br><span class="line">            if(nums[mid] == target)</span><br><span class="line">                return mid;</span><br><span class="line">            else if(nums[mid] &gt; target)</span><br><span class="line">                right = mid -1;</span><br><span class="line">            else if(nums[mid] &lt; target)</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 21天刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21天刷题计划（5）滑动窗口</title>
      <link href="/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%885%EF%BC%89%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
      <url>/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%885%EF%BC%89%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="无重复的最长字串"><a href="#无重复的最长字串" class="headerlink" title="无重复的最长字串"></a>无重复的最长字串</h1><p><img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/17.jpg" alt="17"></p><p><strong>思路总结：</strong></p><ol><li>很典型的滑动窗口问题</li><li>只不过这里不需要两个map了，只需要一个window map即可，在遍历的过程中查重即可</li><li>这种情况下，right也需要遍历到字符串的最右端</li><li>重点还是掌握left 与 right的闭开区间设置，这个技巧很关键</li><li>我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引左闭右开区间 [left, right) 称为一个「窗口」，理论上你可以设计两端都开或者两端都闭的区间，但设计为左闭右开区间是最方便处理的。因为这样初始化 left = right = 0 时区间 [0, 0) 中没有元素，但只要让 right 向右移动一位，区间 [0, 1) 就包含一个元素 0 了。如果你设置为两端都开的区间，那么让 right 向右移动一位后开区间 (0, 1) 仍然没有元素；如果你设置为两端都闭的区间，那么初始区间 [0, 0] 就包含了一个元素。这两种情况都会给边界处理带来不必要的麻烦。</li><li>当我们将left,right初始化0时，需要先取rc = s.charAt(right) , 然后直接right++</li><li>程序的滑动窗口结束条件为right&lt;s.length()</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(s.length()&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> s.length();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        HashMap &lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(right&lt;s.length())&#123;</span><br><span class="line">            Character c = s.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line">            map.put(c,map.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(map.get(c)&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                map.put(s.charAt(left),map.get(s.charAt(left))-<span class="number">1</span>);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans,right-left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h1><p><img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/14.jpg" alt="14"></p><p><strong>思路总结</strong></p><p>边界注意事项：</p><ol><li>我们在字符串 S 中使用双指针中的左右指针技巧，<strong>初始化 left = right = 0，把索引左闭右开区间 [left, right) 称为一个「窗口」</strong></li><li>理论上你可以设计两端都开或者两端都闭的区间，但设计为左闭右开区间是最方便处理的。因为这样初始化 left = right = 0 时区间 [0, 0) 中没有元素，但只要让 right 向右移动一位，区间 [0, 1) 就包含一个元素 0 了。如果你设置为两端都开的区间，那么让 right 向右移动一位后开区间 (0, 1) 仍然没有元素；如果你设置为两端都闭的区间，那么初始区间 [0, 0] 就包含了一个元素。<strong>这两种情况都会给边界处理带来不必要的麻烦。</strong></li></ol><p>HashMap注意事项：</p><ol><li>need map是用来确定题目需要的字符种类及个数</li><li>windows map是用来确定窗口内的字符种类及个数</li><li>我们需要设立一个变量valid来确定window窗口内满足条件的个数，valid的值更新也有讲究，分别在if(wcount == needCount) if(lcount == need.get(lc)-1)</li></ol><p>遍历注意事项：</p><ol><li>我们先不断地增加 right 指针扩大窗口 [left, right)，<strong>直到窗口中的字符串符合要求</strong>（包含了 T 中的所有字符）</li><li><strong>此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right)，直到窗口中的字符串不再符合要求</strong>（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。</li><li>重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        String ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> ansRight = s.length()+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ansLeft = <span class="number">0</span>;</span><br><span class="line">        HashMap &lt;Character,Integer&gt;need = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        HashMap &lt;Character,Integer&gt;windows = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//初始化窗口</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t.length();i++)&#123;</span><br><span class="line">            need.put(t.charAt(i),need.getOrDefault(t.charAt(i),<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            windows.put(t.charAt(i),<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;s.length())&#123;</span><br><span class="line">            <span class="keyword">char</span> rc = s.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span>(windows.containsKey(rc))&#123;</span><br><span class="line">                <span class="keyword">int</span> wcount = windows.get(rc)+<span class="number">1</span>;</span><br><span class="line">                windows.put(rc,wcount);</span><br><span class="line">                <span class="keyword">int</span> needCount = need.get(rc);</span><br><span class="line">                <span class="keyword">if</span>(wcount == needCount)</span><br><span class="line">                    valid++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若满足条件，则进行窗口的缩小</span></span><br><span class="line">            <span class="keyword">while</span>(valid == need.size())&#123;</span><br><span class="line">                <span class="keyword">if</span>(ansRight - ansLeft &gt; right - left)</span><br><span class="line">                &#123;</span><br><span class="line">                    ansRight = right;</span><br><span class="line">                    ansLeft = left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">char</span> lc = s.charAt(left);</span><br><span class="line">                left++;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(windows.containsKey(lc))&#123;</span><br><span class="line">                    <span class="keyword">int</span> lcount = windows.get(lc)-<span class="number">1</span>;</span><br><span class="line">                    windows.put(lc,lcount);</span><br><span class="line">                    <span class="keyword">if</span>(lcount == need.get(lc)-<span class="number">1</span>)</span><br><span class="line">                        valid--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ansRight == s.length()+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=ansLeft;i&lt;ansRight;i++)&#123;</span><br><span class="line">            ans += s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/15.jpg" alt="15"></p><p><strong>思路总结</strong></p><ol><li>总体思想采用的76题的滑动窗口</li><li><strong>这里只需要注意左边界需要缩小的时刻为 right-left&gt;=s1.length()，因为这里求的是子串</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        HashMap &lt;Character,Integer&gt;need = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        HashMap &lt;Character,Integer&gt;windows = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//初始化窗口</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s1.length();i++)&#123;</span><br><span class="line">            need.put(s1.charAt(i),need.getOrDefault(s1.charAt(i),<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            windows.put(s1.charAt(i),<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;s2.length())&#123;</span><br><span class="line">            <span class="keyword">char</span> rc = s2.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span>(windows.containsKey(rc))&#123;</span><br><span class="line">                <span class="keyword">int</span> wcount = windows.get(rc)+<span class="number">1</span>;</span><br><span class="line">                windows.put(rc,wcount);</span><br><span class="line">                <span class="keyword">int</span> needCount = need.get(rc);</span><br><span class="line">                <span class="keyword">if</span>(wcount == needCount)</span><br><span class="line">                    valid++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若满足条件，则进行窗口的缩小</span></span><br><span class="line">            <span class="keyword">if</span>(right-left&gt;=s1.length())&#123;</span><br><span class="line">               <span class="keyword">if</span>(valid == need.size())</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">char</span> lc = s2.charAt(left);</span><br><span class="line">                left++;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(windows.containsKey(lc))&#123;</span><br><span class="line">                    <span class="keyword">int</span> lcount = windows.get(lc)-<span class="number">1</span>;</span><br><span class="line">                    windows.put(lc,lcount);</span><br><span class="line">                    <span class="keyword">if</span>(lcount == need.get(lc)-<span class="number">1</span>)</span><br><span class="line">                        valid--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a>找到字符串中所有字母异位词</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/16.jpg" alt="16"></p><p><strong>思路总结</strong></p><ol><li>总体思想采用的76题的滑动窗口</li><li>这里只需要注意左边界需要缩小的时刻为 right-left&gt;=s1.length()</li><li>因为这里求的是所有子串，所以right必须遍历到字符串的最右端，且需要一个List来存储这个过程中的所有可行解</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        HashMap &lt;Character,Integer&gt;need = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        HashMap &lt;Character,Integer&gt;windows = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//初始化窗口</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;p.length();i++)&#123;</span><br><span class="line">            need.put(p.charAt(i),need.getOrDefault(p.charAt(i),<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            windows.put(p.charAt(i),<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;s.length())&#123;</span><br><span class="line">            <span class="keyword">char</span> rc = s.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span>(windows.containsKey(rc))&#123;</span><br><span class="line">                <span class="keyword">int</span> wcount = windows.get(rc)+<span class="number">1</span>;</span><br><span class="line">                windows.put(rc,wcount);</span><br><span class="line">                <span class="keyword">int</span> needCount = need.get(rc);</span><br><span class="line">                <span class="keyword">if</span>(wcount == needCount)</span><br><span class="line">                    valid++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若满足条件，则进行窗口的缩小</span></span><br><span class="line">            <span class="keyword">if</span>(right-left&gt;=p.length())&#123;</span><br><span class="line">               <span class="keyword">if</span>(valid == need.size())</span><br><span class="line">                   ans.add(left);</span><br><span class="line">                <span class="keyword">char</span> lc = s.charAt(left);</span><br><span class="line">                left++;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(windows.containsKey(lc))&#123;</span><br><span class="line">                    <span class="keyword">int</span> lcount = windows.get(lc)-<span class="number">1</span>;</span><br><span class="line">                    windows.put(lc,lcount);</span><br><span class="line">                    <span class="keyword">if</span>(lcount == need.get(lc)-<span class="number">1</span>)</span><br><span class="line">                        valid--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 21天刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21天刷题计划（4）二维数组花式遍历技巧</title>
      <link href="/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%884%EF%BC%89%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E8%8A%B1%E5%BC%8F%E9%81%8D%E5%8E%86%E6%8A%80%E5%B7%A7/"/>
      <url>/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%884%EF%BC%89%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E8%8A%B1%E5%BC%8F%E9%81%8D%E5%8E%86%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/10.jpg" alt="10"></p><p><strong>思路整理</strong></p><ol><li>遇到矩阵旋转题目，需要往转置，翻转上去考虑</li><li>需要考虑是逆时针旋转90，还是顺时针旋转90°，因为这个决定矩阵沿着哪条对角线进行转置</li><li>最后沿着中垂线reverse</li></ol><p>总的来说涉及旋转图像就两个操作，先决定以哪个对角线进行转置，最后沿着中垂线reverse反转即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//沿对角线转置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;matrix[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将每一行进行reverse</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">            reverse(matrix[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=arr.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/11.jpg" alt="11"></p><p><strong>思路整理</strong></p><ol><li>本题之前在剑指offer上做过一次，当时自己只用四个for循环，做的效果很不好，拆了东墙补西墙。</li><li>本次借鉴今天学习的思想，设立四个边界，即：<strong>上边界、右边界、下边界、左边界</strong></li><li>注意的时在遍历的过程当中，四个边界的灵活运用以及<strong>状态更新</strong>，以及<strong>利用边界确定遍历范围以及遍历的合法性</strong></li></ol><p>边界定义如下，仔细理解这四个边界的含义！</p><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/12.jpg" alt="12"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//该题目最好的方式就是去圈定4个顶点</span></span><br><span class="line">        List&lt;Integer&gt;ansList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> upperEdge = <span class="number">0</span>,rightEdge = matrix[<span class="number">0</span>].length-<span class="number">1</span>,lowEdge = matrix.length-<span class="number">1</span>,leftEdge = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>; <span class="comment">//记录已经遍历的元素</span></span><br><span class="line">        <span class="keyword">int</span> totalElement = matrix[<span class="number">0</span>].length*matrix.length;</span><br><span class="line">        <span class="keyword">while</span>(res&lt;totalElement)&#123;</span><br><span class="line">            <span class="keyword">if</span>(upperEdge&lt;=lowEdge)&#123; ** <span class="comment">// 遍历的合法性**</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=leftEdge;i&lt;=rightEdge;i++)&#123; ** <span class="comment">//确定遍历范围**</span></span><br><span class="line">                    ansList.add(matrix[upperEdge][i]);</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">                upperEdge++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(rightEdge&gt;=leftEdge)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=upperEdge;i&lt;=lowEdge;i++)&#123;</span><br><span class="line">                    ansList.add(matrix[i][rightEdge]);</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">                rightEdge--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(lowEdge&gt;=upperEdge) &#123;</span><br><span class="line">                 <span class="keyword">for</span>(<span class="keyword">int</span> i=rightEdge;i&gt;=leftEdge;i--)&#123;</span><br><span class="line">                    ansList.add(matrix[lowEdge][i]);</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">                lowEdge--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(leftEdge&lt;=rightEdge)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=lowEdge;i&gt;=upperEdge;i--)&#123;</span><br><span class="line">                ansList.add(matrix[i][leftEdge]);</span><br><span class="line">                res++;</span><br><span class="line">                &#125;</span><br><span class="line">                leftEdge++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ansList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="螺旋矩阵2"><a href="#螺旋矩阵2" class="headerlink" title="螺旋矩阵2"></a>螺旋矩阵2</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/13.jpg" alt="13"></p><p><strong>思路整理</strong></p><ol><li>直接创建一个n*n的矩阵，进行螺旋遍历，遍历的时候，给矩阵进行重新赋值即可</li><li>遍历的方案参照第54题螺旋矩阵的遍历思路，创建4个边界</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span> [][]matrix = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">         <span class="comment">//该题目最好的方式就是去圈定4个顶点</span></span><br><span class="line">        <span class="keyword">int</span> upperEdge = <span class="number">0</span>,rightEdge = matrix[<span class="number">0</span>].length-<span class="number">1</span>,lowEdge = matrix.length-<span class="number">1</span>,leftEdge = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>; <span class="comment">//记录已经遍历的元素</span></span><br><span class="line">        <span class="keyword">int</span> totalElement = matrix[<span class="number">0</span>].length*matrix.length;</span><br><span class="line">        <span class="keyword">while</span>(res&lt;totalElement)&#123;</span><br><span class="line">            <span class="keyword">if</span>(upperEdge&lt;=lowEdge)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=leftEdge;i&lt;=rightEdge;i++)&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    matrix[upperEdge][i] = res;</span><br><span class="line">                &#125;</span><br><span class="line">                upperEdge++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(rightEdge&gt;=leftEdge)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=upperEdge;i&lt;=lowEdge;i++)&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    matrix[i][rightEdge] = res;</span><br><span class="line">                &#125;</span><br><span class="line">                rightEdge--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(lowEdge&gt;=upperEdge) &#123;</span><br><span class="line">                 <span class="keyword">for</span>(<span class="keyword">int</span> i=rightEdge;i&gt;=leftEdge;i--)&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    matrix[lowEdge][i] = res;</span><br><span class="line">                &#125;</span><br><span class="line">                lowEdge--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(leftEdge&lt;=rightEdge)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=lowEdge;i&gt;=upperEdge;i--)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                matrix[i][leftEdge] = res;</span><br><span class="line">                &#125;</span><br><span class="line">                leftEdge++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 21天刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二维数组花式遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21天刷题计划（3）差分数组</title>
      <link href="/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%883%EF%BC%89%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"/>
      <url>/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%883%EF%BC%89%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p><strong>前缀和主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和</strong>。</p><p><strong>差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减</strong></p><h1 id="区间加法"><a href="#区间加法" class="headerlink" title="区间加法"></a>区间加法</h1><p><img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/7.jpg" alt="7"></p><p><strong>思路整理</strong></p><ol><li>对 nums 数组构造一个 diff 差分数组，<strong>diff[i] 就是 nums[i] 和 nums[i-1] 之差：</strong></li><li><strong>diff差分数组是可以反推出原始数组 nums的，res[i] = res[i - 1] + diff[i]</strong>,尤其注意这里，一旦diff[i]+1了，就会对i之后包括i的所有元素产生影响，这是一个串联的过程;</li><li><strong>如果你想对区间 nums[i..j] 的元素全部加3，那么只需要让 diff[i] += 3，然后再让 diff[j+1]-= 3 即可</strong>，这样才能区间操作。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] getModifiedArray(int length, int[][] updates) &#123;</span><br><span class="line">        Difference d = new Difference(length);</span><br><span class="line">        for(int i=0;i&lt;updates.length;i++)&#123;</span><br><span class="line">            </span><br><span class="line">                d.increase(updates[i][0],updates[i][1],updates[i][2]);</span><br><span class="line">        &#125;</span><br><span class="line">         return d.primary();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Difference&#123;</span><br><span class="line">    int []diff;</span><br><span class="line">    public Difference(int length)&#123;</span><br><span class="line">        diff = new int[length];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void increase(int i,int j,int inc)</span><br><span class="line">    &#123;</span><br><span class="line">        this.diff[i] = this.diff[i]+inc;</span><br><span class="line">        if(j+1&lt;diff.length) //这里进行边界判断</span><br><span class="line">            this.diff[j+1] = this.diff[j+1] - inc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int[]primary()&#123;</span><br><span class="line">        int []arr = new int[this.diff.length];</span><br><span class="line">        arr[0] = diff[0];</span><br><span class="line">        for(int i=1;i&lt;this.diff.length;i++)&#123;</span><br><span class="line">            arr[i] = arr[i-1] + diff[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="航班预订统计"><a href="#航班预订统计" class="headerlink" title="航班预订统计"></a>航班预订统计</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/8.jpg" alt="8"></p><p><strong>差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。</strong></p><ol><li>对 nums 数组构造一个 diff 差分数组，diff[i] 就是 nums[i] 和 nums[i-1] 之差：</li><li>diff差分数组是可以反推出原始数组 nums的，res[i] = res[i - 1] + diff[i],尤其注意这里，一旦diff[i]+1了，就会对i之后包括i的所有元素产生影响，这是一个串联的过程;</li><li>如果你想对区间 nums[i..j] 的元素全部加3，那么只需要让 diff[i] += 3，然后再让 diff[j+1]-= 3 即可，这样才能区间操作。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] corpFlightBookings(<span class="keyword">int</span>[][] bookings, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        Difference d =  <span class="keyword">new</span> Difference(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bookings.length;i++)&#123;</span><br><span class="line">            d.increase(bookings[i][<span class="number">0</span>]-<span class="number">1</span>,bookings[i][<span class="number">1</span>]-<span class="number">1</span>,bookings[i][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d.primary();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Difference</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> []diff;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Difference</span><span class="params">(<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        diff = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> inc)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.diff[i] = <span class="keyword">this</span>.diff[i]+inc;</span><br><span class="line">        <span class="keyword">if</span>(j+<span class="number">1</span>&lt;diff.length)</span><br><span class="line">            <span class="keyword">this</span>.diff[j+<span class="number">1</span>] = <span class="keyword">this</span>.diff[j+<span class="number">1</span>] - inc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[]primary()&#123;</span><br><span class="line">        <span class="keyword">int</span> []arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.diff.length];</span><br><span class="line">        arr[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="keyword">this</span>.diff.length;i++)&#123;</span><br><span class="line">            arr[i] = arr[i-<span class="number">1</span>] + diff[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="拼车"><a href="#拼车" class="headerlink" title="拼车"></a>拼车</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/9.jpg" alt="9"></p><p><strong>思路整理：</strong></p><ol><li><strong>计算出每个时刻车子上的人数，最终比较即可</strong></li><li>由于<strong>场景是频繁对原始数组的某个区间的元素进行增减，所以这里利用差分数组</strong></li><li><strong>由于先下后上原则，所以我们在trips[i][2]-1位置进行下车操作，保证了trips[i][2]位子的容量</strong></li><li>最终遍历每个时刻乘客数量最大值与capability比较即可</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">carPooling</span><span class="params">(<span class="keyword">int</span>[][] trips, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;trips.length;i++)&#123;</span><br><span class="line">            <span class="comment">//遍出区间长度的最大值，当然这里题目给出了最大值为1000，所以我们也可以直接令length = 1001</span></span><br><span class="line">            length = Math.max(length,trips[i][<span class="number">2</span>]); </span><br><span class="line">        &#125;</span><br><span class="line">        Difference d = <span class="keyword">new</span> Difference(length);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;trips.length;i++)&#123;</span><br><span class="line">            d.increase(trips[i][<span class="number">1</span>],trips[i][<span class="number">2</span>]-<span class="number">1</span>,trips[i][<span class="number">0</span>]);  <span class="comment">//注意传入的trips[i][2]-1，表示trips[i][2]已下车。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> []num_passengers = d.primary();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num_passengers.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num_passengers[i]&gt;capacity)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Difference</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> []diff;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Difference</span><span class="params">(<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        diff = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> inc)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.diff[i] = <span class="keyword">this</span>.diff[i]+inc;</span><br><span class="line">        <span class="keyword">if</span>(j+<span class="number">1</span>&lt;diff.length)</span><br><span class="line">            <span class="keyword">this</span>.diff[j+<span class="number">1</span>] = <span class="keyword">this</span>.diff[j+<span class="number">1</span>] - inc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[]primary()&#123;</span><br><span class="line">        <span class="keyword">int</span> []arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.diff.length];</span><br><span class="line">        arr[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="keyword">this</span>.diff.length;i++)&#123;</span><br><span class="line">            arr[i] = arr[i-<span class="number">1</span>] + diff[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 21天刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 差分数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21天刷题计划（2）前缀和数组技巧</title>
      <link href="/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%882%EF%BC%89%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84%E6%8A%80%E5%B7%A7/"/>
      <url>/2022/03/22/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%882%EF%BC%89%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303. 区域和检索 - 数组不可变"></a>303. 区域和检索 - 数组不可变</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/4.jpg" alt="4"></p><p><strong>思路整理</strong></p><ol><li>新建一个数组，这个数组要多建立一维，方便我们的边界处理，每个位置存放前i个数的和</li><li>区间和为preSum[right+1] - preSum[left]</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前缀和数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] preSum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 输入一个数组，构造前缀和 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// preSum[0] = 0，便于计算累加和</span></span><br><span class="line">        preSum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 计算 nums 的累加和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; preSum.length; i++) &#123;</span><br><span class="line">            preSum[i] = preSum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 查询闭区间 [left, right] 的累加和 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> preSum[right + <span class="number">1</span>] - preSum[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二维区域和检索-矩阵不可变"><a href="#二维区域和检索-矩阵不可变" class="headerlink" title="二维区域和检索 - 矩阵不可变"></a>二维区域和检索 - 矩阵不可变</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/5.jpg" alt="5"></p><p><strong>思路总结</strong></p><ol><li><strong>就像是一个求面积的问题，多退少补</strong></li><li>preSum的定义很有讲究，如果不多加一个维度进行辅助，会导致面积加减很不方便，还要考虑有没有多减的问题</li><li><strong>以后遇到前缀和的问题，辅助数组就多定义一维</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> [][] preSum;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.preSum = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length+<span class="number">1</span>][matrix[<span class="number">0</span>].length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;preSum.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;preSum[<span class="number">0</span>].length;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                preSum[i][j] = preSum[i-<span class="number">1</span>][j] + preSum[i][j-<span class="number">1</span>] - preSum[i-<span class="number">1</span>][j-<span class="number">1</span>] + matrix[i-<span class="number">1</span>][j-<span class="number">1</span>]; <span class="comment">//构造前缀和，往面积上去想，多退少补</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> preSum[row2+<span class="number">1</span>][col2+<span class="number">1</span>] - preSum[row2+<span class="number">1</span>][col1] - preSum[row1][col2+<span class="number">1</span>] + preSum[row1][col1]; <span class="comment">//多退少补</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="和为K的子数组"><a href="#和为K的子数组" class="headerlink" title="和为K的子数组"></a>和为K的子数组</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/6.jpg" alt="6"></p><p><strong>思路总结：</strong></p><ol><li>如果计算出前缀和之后，暴力寻找的话，时间复杂度上升</li><li>通过公式<strong>变换 preSum[i] - preSum[j] = k 转化为寻找preSum[j] = preSum[i] - k</strong></li><li>由于preSum[j] j是小于i的，所以j位置的前缀和肯定已经被计算过了</li><li><strong>通过Hashmap记录之前已经出现过的前缀和，和为key,次数为value</strong></li><li><strong>这样我们在一次遍历当中就可以找出answer</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []preSum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>];</span><br><span class="line">        HashMap &lt;Integer,Integer&gt;map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//注 ： 这里的空间复杂度还可以优化，这里每次只用到 preSum[i-1] 与 preSum[i],所以可以直接利用两个临时变量代替即可</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;preSum.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            preSum[i] = preSum[i-<span class="number">1</span>] + nums[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> find = preSum[i] - k;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(find))</span><br><span class="line">            &#123;</span><br><span class="line">                ans += map.get(find);</span><br><span class="line">            &#125;</span><br><span class="line">                  map.put(preSum[i],map.getOrDefault(preSum[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>前缀和数组的维度要比原数组多定义一维，方便我们进行边界处理</li><li>要注意问题转化，尤其是和为K的子数组，利用hashmap在一次遍历中，就可以得到答案！</li></ul>]]></content>
      
      
      <categories>
          
          <category> 21天刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21天刷题计划（1）单链表解题技巧</title>
      <link href="/2022/03/21/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%881%EF%BC%89%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/"/>
      <url>/2022/03/21/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92%EF%BC%881%EF%BC%89%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="21天刷题计划（1）单链表解题技巧"><a href="#21天刷题计划（1）单链表解题技巧" class="headerlink" title="21天刷题计划（1）单链表解题技巧"></a>21天刷题计划（1）单链表解题技巧</h1><h1 id="合并K个升序链表"><a href="#合并K个升序链表" class="headerlink" title="合并K个升序链表"></a>合并K个升序链表</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/1.jpg" alt="1"></p><p>本题中的k数目很大，如果使用暴力方法直接去接，复杂度肯定无法通过所有测试！<strong>使用优先队列，优先队列向上、向下调整元素的时间复杂度是logN。</strong></p><p><strong>解题思路梳理</strong>：</p><ol><li><p>首先做一些basecase的判断，比如是否有空链表等，将lists中每个链表头节点加入最小堆优先队列，</p></li><li><p>通过while循环，每次取出头节点数值最小的，将取出的头节点加入到我们的dummy链表中，其中temp为其临时遍历节点。</p></li><li><p>将取出的最小头节点加入到我们的新建链表中后，我们需要判断最小头节点的next是否为空，若不为空，我们将head.next继续加入到最小堆优先队列中。</p></li><li><p>while循环的结束条件是优先队列是否为空！</p><p><strong>关键词</strong>：<strong>最小堆、优先队列元素节点为链表头节点</strong></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> len = lists.length;</span><br><span class="line">          <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Comparator&lt;ListNode&gt; cmp = <span class="keyword">new</span> Comparator&lt;ListNode&gt;() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ListNode a, ListNode b)</span> </span>&#123; <span class="comment">//这里是小根堆</span></span><br><span class="line"><span class="keyword">return</span> a.val - b.val; <span class="comment">//第一键值做参考</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">        PriorityQueue&lt;ListNode&gt;priQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(lists.length,cmp);</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//将k个链表的头节点加入优先队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(lists[i] != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                priQueue.add(lists[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode temp = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!priQueue.isEmpty())&#123;</span><br><span class="line">            ListNode head = priQueue.poll();</span><br><span class="line">            temp.next = head;</span><br><span class="line">            head = head.next;</span><br><span class="line">            <span class="keyword">if</span>(head!=<span class="keyword">null</span>)</span><br><span class="line">                priQueue.add(head);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/2.jpg" alt="2"></p><p><strong>解决这个问题的关键是，通过某些方式，让 p1 和 p2 能够同时到达相交节点 c1</strong></p><p>两种思路：</p><ol><li>我们可以让 p1 遍历完链表 A 之后开始遍历链表 B，让 p2 遍历完链表 B 之后开始遍历链表 A</li><li>我们可以让 p1 p2 同时遍历，若p1先遍历完，就让p2剩余的遍历次数k，使得temp2移动k次，这样temp1与temp2就处在同一起跑线<br><strong>显然第一种思路更为巧妙简单</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//labuladong优美解法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode p1 = headA;</span><br><span class="line">        ListNode p2 = headB;</span><br><span class="line">        <span class="keyword">while</span>(p1!=p2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1 != <span class="keyword">null</span>)</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p1 = headB;</span><br><span class="line">            <span class="keyword">if</span>(p2 != <span class="keyword">null</span>)</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                p2 = headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我个人写的代码，冗杂很多！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       ListNode tempA = headA;</span><br><span class="line">       ListNode tempB = headB;</span><br><span class="line">       <span class="keyword">while</span>(tempA != <span class="keyword">null</span> &amp;&amp; tempB!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           tempA = tempA.next;</span><br><span class="line">           tempB = tempB.next;</span><br><span class="line">       &#125;</span><br><span class="line">       ListNode temp1 = headA;</span><br><span class="line">       ListNode temp2 = headB;</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">if</span>(tempA == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">while</span>(tempB != <span class="keyword">null</span>)&#123;</span><br><span class="line">               tempB = tempB.next;</span><br><span class="line">               temp2 = temp2.next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(tempB == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">while</span>(tempA != <span class="keyword">null</span>)&#123;</span><br><span class="line">               tempA = tempA.next;</span><br><span class="line">               temp1 = temp1.next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(temp1!=<span class="keyword">null</span> &amp;&amp; temp2!= <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(temp1 == temp2)</span><br><span class="line">               <span class="keyword">return</span> temp1;</span><br><span class="line">           temp1 = temp1.next;</span><br><span class="line">           temp2 = temp2.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h1><p> <img src="/articleImg/21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/3.jpg" alt="3"></p><p><strong>对于链表题，最常用的就是双指针的技巧了。</strong>比如找链表中点、倒数第k个节点。找倒数第K个节点的思路是让快指针先走K步，然后然两个指针一起走，一直到链表末尾！这样慢指针便是倒数第K个节点。</p><p>对于本题解题思路：</p><p><strong>我的思路</strong></p><ol><li>找出倒数第k个节点</li><li>找出倒数第K+1节点<br>实在是没必要，添加了很多不必要的代码。</li></ol><p><strong>东哥思路</strong></p><ol><li><strong>添加一个虚拟头节点节点dummy</strong> (<strong>这里的添加虚拟头节点，十分有必要，尤其涉及到链表的插入删除，虚拟头节点的作用非常大，节省了很多不必要的代码量</strong>)</li><li>直接利用模板找出倒数第k+1个节点</li><li>删除后，返回dummy.next</li></ol><p>该思路确实整洁巧妙，虚拟节点的作用也十分明显，就算是倒数第K个节点在头节点的位置，也可以直接找出倒数K+1个节点，此时的倒数k+1节点正是dummy~</p><p>东哥代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 虚拟头结点</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="comment">// 删除倒数第 n 个，要先找倒数第 n + 1 个节点</span></span><br><span class="line">    ListNode x = findFromEnd(dummy, n + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 删掉倒数第 n 个节点</span></span><br><span class="line">    x.next = x.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回链表的倒数第 k 个节点</span></span><br><span class="line"><span class="function">ListNode <span class="title">findFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode p1 = head;</span><br><span class="line">    <span class="comment">// p1 先走 k 步</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode p2 = head;</span><br><span class="line">    <span class="comment">// p1 和 p2 同时走 n - k 步</span></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p2 现在指向第 n - k 个节点</span></span><br><span class="line">    <span class="keyword">return</span> p2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>我的代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode p1 = head;</span><br><span class="line">    ListNode p2 = head;</span><br><span class="line">    ListNode p3 = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1 != head)</span><br><span class="line">            p3 = p3.next;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p1 == head)</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    p3.next = p1.next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 21天刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker基础命令学习</title>
      <link href="/2022/03/21/Docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/03/21/Docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-简介"><a href="#Docker-简介" class="headerlink" title="Docker 简介"></a>Docker 简介</h1><p>我在云服务器安装docker，是按照docker官网的说明进行安装的。</p><p>1.传统虚拟机，虚拟出硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件。</p><p>2.Docker容器内的应用直接运行在宿主机的内容，容器是没有自己的内核的，也没有虚拟硬件。</p><p>3.每个容器都是相互隔离的，每个容器都有属于自己的文件系统，互不影响。</p><p><img src="/articleImg/60_article/1.jpg" alt="1"></p><h1 id="Docker基础命令"><a href="#Docker基础命令" class="headerlink" title="Docker基础命令"></a>Docker基础命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker version          #查看docker的版本信息</span><br><span class="line">docker info             #查看docker的系统信息,包括镜像和容器的数量</span><br><span class="line">docker 命令 --help       #帮助命令(可查看可选的参数)</span><br><span class="line">docker COMMAND --help</span><br></pre></td></tr></table></figure><h1 id="Docker镜像命令"><a href="#Docker镜像命令" class="headerlink" title="Docker镜像命令"></a>Docker镜像命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker images # 查看本地主机的所有镜像</span><br><span class="line">docker search 镜像名 # 搜索镜像</span><br><span class="line">docker pull 镜像名[:tag] # 下载镜像 []表示可选参数</span><br><span class="line">docker rmi -f 镜像名 #删除镜像 -f强制删除</span><br></pre></td></tr></table></figure><h1 id="Docker-容器命令"><a href="#Docker-容器命令" class="headerlink" title="Docker 容器命令"></a>Docker 容器命令</h1><p>切记：必须先有镜像，才能运行容器。（打个比喻：镜像就像是软件安装包.apk, 在容器中运行，相当于安装APP）</p><h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos # 拉取centos镜像</span><br><span class="line"><span class="meta">#</span><span class="bash"> 有了镜像之后，我们可以开始运行容器</span></span><br><span class="line">docker run [可选参数] image</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">参数说明</span></span><br><span class="line">--name=&quot;名字&quot;           #指定容器名字</span><br><span class="line">-d                     #后台方式运行</span><br><span class="line">-it                    #使用交互方式运行,进入容器查看内容</span><br><span class="line">-p ip:主机端口:容器端口   #配置主机端口映射到容器端口</span><br></pre></td></tr></table></figure><h2 id="例如运行并进入容器centos"><a href="#例如运行并进入容器centos" class="headerlink" title="例如运行并进入容器centos"></a>例如运行并进入容器centos</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -it centos /bin/bash</span><br><span class="line">exit #退出容器命令</span><br><span class="line">ctrl+p+q #退出容器，容器仍在后台运行</span><br></pre></td></tr></table></figure><h2 id="列出运行过的容器命令"><a href="#列出运行过的容器命令" class="headerlink" title="列出运行过的容器命令"></a>列出运行过的容器命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker ps </span><br><span class="line">-a   # 列出所有容器的运行记录</span><br><span class="line">-n=? # 显示最近创建的n个容器</span><br><span class="line">-q   # 只显示容器的编号</span><br></pre></td></tr></table></figure><h2 id="删除容器命令"><a href="#删除容器命令" class="headerlink" title="删除容器命令"></a>删除容器命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器id                 #删除指定的容器,不能删除正在运行的容器,强制删除使用 rm -f</span><br><span class="line">docker rm -f $(docker ps -aq)   #删除所有的容器</span><br><span class="line">docker ps -a -q|xargs docker rm #删除所有的容器</span><br></pre></td></tr></table></figure><h2 id="启动和停止容器命令"><a href="#启动和停止容器命令" class="headerlink" title="启动和停止容器命令"></a>启动和停止容器命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器id          #启动容器</span><br><span class="line">docker restart 容器id        #重启容器</span><br><span class="line">docker stop 容器id           #停止当前运行的容器</span><br><span class="line">docker kill 容器id           #强制停止当前容器</span><br></pre></td></tr></table></figure><h1 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h1><h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker logs -tf 容器id           </span><br><span class="line">docker logs --tail number 容器id #num为要显示的日志条数  </span><br></pre></td></tr></table></figure><h2 id="查看容器中进程信息"><a href="#查看容器中进程信息" class="headerlink" title="查看容器中进程信息"></a>查看容器中进程信息</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top c703b5b1911f  </span><br></pre></td></tr></table></figure><h2 id="查看容器的元数据"><a href="#查看容器的元数据" class="headerlink" title="查看容器的元数据"></a>查看容器的元数据</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器id</span><br></pre></td></tr></table></figure><h2 id="进入当前正在运行的容器"><a href="#进入当前正在运行的容器" class="headerlink" title="进入当前正在运行的容器"></a>进入当前正在运行的容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it c703b5b1911f /bin/bash # 在容器中新开一个终端</span><br><span class="line">docker attach c703b5b1911f # 进入容器之前的终端</span><br></pre></td></tr></table></figure><h1 id="dockers命令图及命令小结"><a href="#dockers命令图及命令小结" class="headerlink" title="dockers命令图及命令小结"></a>dockers命令图及命令小结</h1><p><img src="/articleImg/60_article/2.jpg" alt="2"></p><p>​       命令下方是对该命令的中文解释</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">attach    Attach to a running container</span><br><span class="line"><span class="meta">#</span><span class="bash">当前she1l 下attach连接指定运行镜像</span></span><br><span class="line">build     Build an image from a Dockerfile</span><br><span class="line"><span class="meta">#</span><span class="bash">通过 Dockerfile定制镜像</span></span><br><span class="line">commit    Create a new image from a container changes</span><br><span class="line"><span class="meta">#</span><span class="bash">提交当前容器为新的镜像</span></span><br><span class="line">cp        copy files/fo lders from the containers filesystem to the host path</span><br><span class="line"><span class="meta">#</span><span class="bash">从容器中拷贝指定文件或者目录到宿主机中</span></span><br><span class="line">create    Create a new container</span><br><span class="line"><span class="meta">#</span><span class="bash">创建一个新的容器，同run，但不启动容器</span></span><br><span class="line">diff      Inspect changes on a container&#x27;s filesystem</span><br><span class="line"><span class="meta">#</span><span class="bash">查看docker容器变化</span></span><br><span class="line">events    Get real time events from the server</span><br><span class="line"><span class="meta">#</span><span class="bash">从docker服务获取容器实时事件</span></span><br><span class="line">exec      Run a command in an existing container</span><br><span class="line"><span class="meta">#</span><span class="bash">  在已存在的容器上运行命令</span></span><br><span class="line">export    Stream the contents of a container as a tar anchive</span><br><span class="line"><span class="meta">#</span><span class="bash">导出容器的内容流作为一个 tar归档文件[对应import]</span></span><br><span class="line">history   show the history of an image</span><br><span class="line"><span class="meta">#</span><span class="bash">展示一个镜像形成历史</span></span><br><span class="line">images    List images</span><br><span class="line"><span class="meta">#</span><span class="bash">列出系统当前镜像</span></span><br><span class="line">import    create a new filesystem image from the contents of a tarball </span><br><span class="line"><span class="meta">#</span><span class="bash">从tar包中的内容创建一个新的文件系统映像[对应<span class="built_in">export</span>]</span></span><br><span class="line">info      Display system-wide information</span><br><span class="line"><span class="meta">#</span><span class="bash">显示系统相关信息</span></span><br><span class="line">inspect   Return low-1evel information on a container</span><br><span class="line"><span class="meta">#</span><span class="bash">查看容器详细信息</span></span><br><span class="line">kill      Kill a running container</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">kill</span>指定docker容器</span></span><br><span class="line">1oad      Load an image from a tar archive</span><br><span class="line"><span class="meta">#</span><span class="bash">从一个tar 包中加载一个镜像[对应save]</span></span><br><span class="line">login     Register or Login to the docker registry server</span><br><span class="line"><span class="meta">#</span><span class="bash">注册或者登陆一个docker源服务器</span></span><br><span class="line">1ogout    Log out from a Docker registry server</span><br><span class="line"><span class="meta">#</span><span class="bash">从当前 Docker registry退出</span></span><br><span class="line">logs      Fetch the logs of a container</span><br><span class="line"><span class="meta">#</span><span class="bash">输出当前容器日志信息</span></span><br><span class="line">port      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT</span><br><span class="line"><span class="meta">#</span><span class="bash">查看映射端口对应的容器内部源端口</span></span><br><span class="line">pause     Pause a11 processes within a container</span><br><span class="line"><span class="meta">#</span><span class="bash">暂停容器</span></span><br><span class="line">ps        List containers</span><br><span class="line"><span class="meta">#</span><span class="bash">列出容器列表</span></span><br><span class="line">pu11      Pu1l an image or a repository from the docker registry server#从docker镜像源服务器拉取指定镜像或者库镜像</span><br><span class="line">push      Push an image or a repository to the docker registry server#推送指定镜像或者库镜像至docker源服务器</span><br><span class="line">restart   Restart a running container</span><br><span class="line"><span class="meta">#</span><span class="bash">重启运行的容器</span></span><br><span class="line">rm        Remove one or more containers</span><br><span class="line"><span class="meta">#</span><span class="bash">移除一个或者多个容器</span></span><br><span class="line">rmi       Remove one or more images</span><br><span class="line"><span class="meta">#</span><span class="bash">移除一个或多个镜像[无容器使用该镜像才可刷除，否则需删除相关容器才可继续或-f强制制除]</span></span><br><span class="line">run       Run a command in a new container</span><br><span class="line"><span class="meta">#</span><span class="bash">创建一个新的容器并运行一个命令</span></span><br><span class="line">save      save an image to a tar archive</span><br><span class="line"><span class="meta">#</span><span class="bash">保存一个镜像为一个tar包[对应1oad]</span></span><br><span class="line">search    Search for an image on the Docker Hub</span><br><span class="line"><span class="meta">#</span><span class="bash">在docker hub中搜素镜像</span></span><br><span class="line">start     start a stopped containers</span><br><span class="line"><span class="meta">#</span><span class="bash">启动容器</span></span><br><span class="line">stop      stop a running containers</span><br><span class="line"><span class="meta">#</span><span class="bash">停止容器</span></span><br><span class="line">tag       Tag an image into a repository</span><br><span class="line"><span class="meta">#</span><span class="bash">结源中镜像打标签</span></span><br><span class="line">top       Lookup the running processes of a container</span><br><span class="line"><span class="meta">#</span><span class="bash">查看容器中运行的进程信息</span></span><br><span class="line">unpause   Unpause a paused container</span><br><span class="line"><span class="meta">#</span><span class="bash">取消暂停容器</span></span><br><span class="line">version   show the docker version information</span><br><span class="line"><span class="meta">#</span><span class="bash">查看docker版本号</span></span><br><span class="line">wait      Block until a container stops，then print its exit code</span><br><span class="line"><span class="meta">#</span><span class="bash">截取容器停止时的退出状态值</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker基础命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String与StringBuilder常用方法总结</title>
      <link href="/2022/03/20/String%E4%B8%8EStringBuilder%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2022/03/20/String%E4%B8%8EStringBuilder%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="String-与StringBuilder常用方法总结"><a href="#String-与StringBuilder常用方法总结" class="headerlink" title="String 与StringBuilder常用方法总结"></a>String 与StringBuilder常用方法总结</h1><p>本周末参加了leetcode的双周赛和周赛，都只是answer了两道题目，自己还算满意吧，毕竟是第一次参加。进步空间还是很大的！在参加比赛的时候，我因为String和StringBuilder的不熟练，导致我在作答题目的时候，耽误了很多时间，写了很多冗余代码，在这里我将这二者的常用方法进行简介！</p><h1 id="二者简介"><a href="#二者简介" class="headerlink" title="二者简介"></a>二者简介</h1><p>在java中String类不可变的，创建一个String对象后不能更改它的值。所以如果需要对原字符串进行一些改动操作，就需要用StringBuilder类或者StringBuffer类，StringBuilder比StringBuffer更快一些，缺点是StringBuilder不是线程安全的，但在算法竞赛中一般我们用不到多线程。所以，主要推荐使用StringBuilder类。</p><h1 id="String类常用方法"><a href="#String类常用方法" class="headerlink" title="String类常用方法"></a>String类常用方法</h1><h3 id="String遍历"><a href="#String遍历" class="headerlink" title="String遍历"></a>String遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String有两种遍历方式，第一种charAt()方法</span><br><span class="line">第二种是先转化为字符数组，再挨个遍历</span><br><span class="line">charAt(<span class="keyword">int</span> i);<span class="comment">//返回索引i处的字符</span></span><br><span class="line">length();<span class="comment">//返回此字符串的长度</span></span><br><span class="line">isEmpty();<span class="comment">//判空 当length()为0时返回true</span></span><br></pre></td></tr></table></figure><h3 id="String转字符数组"><a href="#String转字符数组" class="headerlink" title="String转字符数组"></a>String转字符数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] s1 = <span class="keyword">new</span> <span class="keyword">char</span>[s.length()];  <span class="comment">//这里的字符数组大小要注意</span></span><br><span class="line">s1 = s.toCharArray();</span><br></pre></td></tr></table></figure><h3 id="String间的比较"><a href="#String间的比较" class="headerlink" title="String间的比较"></a>String间的比较</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">切记不能使用 == ,这个会比较内存地址</span><br><span class="line">常用的是：</span><br><span class="line">equals(String anotherString)<span class="comment">//判断两个字符串是否相等，相等返回true否则返回false</span></span><br><span class="line">equalsIgnoreCase(String str)<span class="comment">//同上，不区分大小写。</span></span><br></pre></td></tr></table></figure><h3 id="String检索字串"><a href="#String检索字串" class="headerlink" title="String检索字串"></a>String检索字串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一次出现的位置</span></span><br><span class="line">indexOf(<span class="keyword">int</span> ch);<span class="comment">// 返回指定字符在此字符串中第一次出现的索引</span></span><br><span class="line">indexOf(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromindex); <span class="comment">// 同上， 从指定索引开始搜索</span></span><br><span class="line">indexOf(String str);<span class="comment">//返回子串在此字符串中第一次出现的索引</span></span><br><span class="line">indexOf(String str, <span class="keyword">int</span> fromindex);同上，从指定索引开始搜索</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后一次出现的位置索引</span></span><br><span class="line">lastIndexOf(<span class="keyword">int</span> ch);<span class="comment">//返回指定字符在此字符串最后一次出现的索引</span></span><br><span class="line">lastIndexOf(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromindex);<span class="comment">//同上， 从指定索引开始搜索</span></span><br><span class="line">lastIndexOf(String str);<span class="comment">//返回子串在此字符串最后一次出现的索引</span></span><br><span class="line">lastIndexOf(String str, <span class="keyword">int</span> fromindex);<span class="comment">//同上， 从指定索引开始搜索</span></span><br><span class="line"></span><br><span class="line">以上如果不存在，均返回 -<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="String字符串拆分"><a href="#String字符串拆分" class="headerlink" title="String字符串拆分"></a>String字符串拆分</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">split(String regex); <span class="comment">// 根据正则表达式拆分</span></span><br><span class="line">String s = <span class="string">&quot;ABC DEF&quot;</span>;</span><br><span class="line">String s1[] = s.split(<span class="string">&quot; &quot;</span>);<span class="comment">//根据空格拆分，这里也要注意要使用字符串数组进行接收</span></span><br><span class="line">System.out.println(s1[<span class="number">0</span>]);<span class="comment">// ABC</span></span><br><span class="line">System.out.println(s1[<span class="number">1</span>]);<span class="comment">// DEF</span></span><br></pre></td></tr></table></figure><h3 id="String提取子字符串"><a href="#String提取子字符串" class="headerlink" title="String提取子字符串"></a>String提取子字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">substring(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)；<span class="comment">//返回从begin开始到end结束的子串 ，不包含endIndex</span></span><br><span class="line">substring(<span class="keyword">int</span> beginIndex)； <span class="comment">//返回从起始位置（beginIndex）至字符串末尾的字符串</span></span><br></pre></td></tr></table></figure><h3 id="String转化大小写"><a href="#String转化大小写" class="headerlink" title="String转化大小写"></a>String转化大小写</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">toUpperCase(); <span class="comment">//将此字符串中的所有字母都换为大写</span></span><br><span class="line">toLowerCase()<span class="comment">//将此字符串中的所有字母都换为小写</span></span><br></pre></td></tr></table></figure><h3 id="将其他类型数据转化为String"><a href="#将其他类型数据转化为String" class="headerlink" title="将其他类型数据转化为String"></a>将其他类型数据转化为String</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">valueOf(<span class="keyword">char</span>[] data);<span class="comment">//返回 char数组的字符串表示形式</span></span><br><span class="line">valueOf(<span class="keyword">char</span>[] data,<span class="keyword">int</span> offset, <span class="keyword">int</span> count)<span class="comment">//返回 char 数组参数的特定子数组的字符串表示形式。</span></span><br><span class="line">valueOf(<span class="keyword">int</span> i);<span class="comment">//返回 int 参数的字符串表示形式。</span></span><br></pre></td></tr></table></figure><h1 id="StringBuilder常用方法"><a href="#StringBuilder常用方法" class="headerlink" title="StringBuilder常用方法"></a>StringBuilder常用方法</h1><p>一个可变的字符序列</p><h3 id="StringBuilder构造方法"><a href="#StringBuilder构造方法" class="headerlink" title="StringBuilder构造方法"></a>StringBuilder构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder();<span class="comment">//构建一个空的可变字符串。</span></span><br><span class="line">StringBuilder(String str);<span class="comment">//构建一个值为str的可变字符串。</span></span><br></pre></td></tr></table></figure><h3 id="StringBuilder转String"><a href="#StringBuilder转String" class="headerlink" title="StringBuilder转String"></a>StringBuilder转String</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toString(); //返回一个与构建起或缓冲器内容相同的字符串</span><br></pre></td></tr></table></figure><h3 id="StringBuilder遍历"><a href="#StringBuilder遍历" class="headerlink" title="StringBuilder遍历"></a>StringBuilder遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用下面两个方法即可完成遍历</span></span><br><span class="line">charAt(<span class="keyword">int</span> i);<span class="comment">// 返回索引i位置的字符</span></span><br><span class="line">length();<span class="comment">//返回此字符串的长度</span></span><br></pre></td></tr></table></figure><h3 id="StringBuilder增加和插入字符"><a href="#StringBuilder增加和插入字符" class="headerlink" title="StringBuilder增加和插入字符"></a>StringBuilder增加和插入字符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加字符</span></span><br><span class="line">append(String str);<span class="comment">//在此字符串追加str。</span></span><br><span class="line">append(StringBuilder str);<span class="comment">//在此字符串追加str。</span></span><br><span class="line">append(<span class="keyword">char</span>[] str, <span class="keyword">int</span> offset, <span class="keyword">int</span> len);<span class="comment">//将char的子数组追加到此字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//insert字符</span></span><br><span class="line">insert(<span class="keyword">int</span> offset, String str);<span class="comment">//一定要注意是在该位置之前插入</span></span><br><span class="line">insert(<span class="keyword">int</span> offset, Char c)；<span class="comment">//在指定位置**之前**插入字符(串)</span></span><br></pre></td></tr></table></figure><h3 id="StringBuilder删除字符"><a href="#StringBuilder删除字符" class="headerlink" title="StringBuilder删除字符"></a>StringBuilder删除字符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete(<span class="keyword">int</span> start, <span class="keyword">int</span> end);<span class="comment">//移除此序列从start到end-1的字符串</span></span><br><span class="line">deleteCharAt(<span class="keyword">int</span> index);<span class="comment">//移除指定索引上的char</span></span><br></pre></td></tr></table></figure><h3 id="StringBuilder修改字符"><a href="#StringBuilder修改字符" class="headerlink" title="StringBuilder修改字符"></a>StringBuilder修改字符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setCharAt(<span class="keyword">int</span> index, <span class="keyword">char</span> ch);<span class="comment">//将指定索引处的字符替换为ch</span></span><br></pre></td></tr></table></figure><h3 id="StringBuilder字符串查找"><a href="#StringBuilder字符串查找" class="headerlink" title="StringBuilder字符串查找"></a>StringBuilder字符串查找</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">indexOf(String str);<span class="comment">//返回子字符串第一次出现的索引</span></span><br><span class="line">indexOf(String str, <span class="keyword">int</span> fromIndex);<span class="comment">//同上，从指定位置查找</span></span><br><span class="line"></span><br><span class="line">lastIndexOf(String str);<span class="comment">//返回子字符串最后一次出现的索引</span></span><br><span class="line">lastIndexOf(String str, <span class="keyword">int</span> fromIndex);<span class="comment">//同上，从指定位置查找</span></span><br></pre></td></tr></table></figure><h3 id="StringBuilder反转"><a href="#StringBuilder反转" class="headerlink" title="StringBuilder反转"></a>StringBuilder反转</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reverse();<span class="comment">//将此字符串反转</span></span><br></pre></td></tr></table></figure><h3 id="StringBuilder截取"><a href="#StringBuilder截取" class="headerlink" title="StringBuilder截取"></a>StringBuilder截取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">substring(<span class="keyword">int</span> start);<span class="comment">//返回此字符串从start开始至结束的String</span></span><br><span class="line">substring(<span class="keyword">int</span> start, <span class="keyword">int</span> end);<span class="comment">//返回此字符串从start开始至end结束的String</span></span><br><span class="line">toString();<span class="comment">//返回此序列中的String表示形式。</span></span><br><span class="line">(注意以上方法的返回值都是String而不是StringBuilder)</span><br></pre></td></tr></table></figure><p>本次周赛最终采用的字符串操作方案：将String利用toCharArray转化为char[],然后对字符数组进行原地的修改、遍历操作。如果涉及到字符的插入删除，那么还是使用StringBuilder的相关API比较方便！</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云服务器练习Linux</title>
      <link href="/2022/03/20/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%83%E4%B9%A0Linux/"/>
      <url>/2022/03/20/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%83%E4%B9%A0Linux/</url>
      
        <content type="html"><![CDATA[<h1 id="linux-基础-一切皆文件"><a href="#linux-基础-一切皆文件" class="headerlink" title="linux 基础-一切皆文件"></a>linux 基础-一切皆文件</h1><p>今天购置了一台阿里云服务器，并在上面进行了一些基础练习</p><p><img src="/articleImg/59_article/5.jpg" alt="5"></p><h2 id="软连接与硬链接"><a href="#软连接与硬链接" class="headerlink" title="软连接与硬链接"></a>软连接与硬链接</h2><p>硬链接 ：<strong>相当于是程序语言中多开辟一个指针指向文件</strong>。删除源文件后，硬连接仍然可以访问。<strong>尤其注意这个和文件的复制不是一个概念！</strong></p><p>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p><p>软连接：相当于Windows下的快捷方式，删除源文件，快捷方式也访问不了。</p><p> <img src="/articleImg/59_article/1.jpg" alt="1"></p><h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df -h 列出文件系统的整体磁盘使用量</span><br><span class="line">du -a 检查磁盘空间使用量</span><br></pre></td></tr></table></figure><p> <img src="/articleImg/59_article/2.jpg" alt="2"></p><h3 id="挂载（我遇到的几乎都是自动挂载设备）"><a href="#挂载（我遇到的几乎都是自动挂载设备）" class="headerlink" title="挂载（我遇到的几乎都是自动挂载设备）"></a>挂载（我遇到的几乎都是自动挂载设备）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 装置文件名 挂载点</span><br><span class="line">mount /dev/hdc6 /mnt/hdc6</span><br></pre></td></tr></table></figure><h3 id="卸除"><a href="#卸除" class="headerlink" title="卸除"></a>卸除</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">umount [-fn] 装置文件名或挂载点</span><br><span class="line">umount /dev/hdc6</span><br></pre></td></tr></table></figure><h2 id="进程查看"><a href="#进程查看" class="headerlink" title="进程查看"></a>进程查看</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -aux  # 查看所有进程</span><br><span class="line">ps -aux|grep mysql #过滤进程信息，只查看关于mysql的相关进程</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">进程树：pstree -pu</span><br><span class="line">p是显示父id</span><br><span class="line">u是显示用户组</span><br></pre></td></tr></table></figure><p>​         <img src="/articleImg/59_article/3.jpg" alt="3"></p><p>​        杀死进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 进程id  #和windows的任务管理器是一样的，nohup的进程表示后台进程</span><br></pre></td></tr></table></figure><h2 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h2><p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p><p>添加账号 ： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">选项 :  useradd 选项 用户名</span><br><span class="line"></span><br><span class="line">-c comment 指定一段注释性描述。</span><br><span class="line"></span><br><span class="line">-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。</span><br><span class="line"></span><br><span class="line">-g 用户组 指定用户所属的用户组。 一般在新建用户时，会指定-g参数</span><br><span class="line"></span><br><span class="line">-G 用户组，用户组 指定用户所属的附加组。</span><br><span class="line"></span><br><span class="line">-m　使用者目录如不存在则自动建立。</span><br><span class="line"></span><br><span class="line">-s Shell文件 指定用户的登录Shell。</span><br><span class="line"></span><br><span class="line">-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</span><br><span class="line"></span><br><span class="line">用户名 :</span><br><span class="line"></span><br><span class="line">指定新账号的登录名。</span><br></pre></td></tr></table></figure><p> 创建用户，并设立密码</p><p><img src="/articleImg/59_article/6.png" alt="6"></p><p><strong>/etc/passwd文件是用户管理工作涉及的最重要的一个文件。Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。</strong></p><h2 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h2><p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。</p><p>（1）增加一个新的用户组使用groupadd命令： groupadd 选项 用户组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd -g 101 group2</span><br><span class="line">此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。</span><br></pre></td></tr></table></figure><p>（2）删除一个已有的用户组，使用groupdel命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel group1</span><br></pre></td></tr></table></figure><p>（3）修改用户组的属性使用groupmod命令，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 此命令将组group2的组标识号修改为102。</span><br><span class="line">groupmod -g 102 group2</span><br><span class="line"></span><br><span class="line"># 将组group2的标识号改为10000，组名修改为group3。</span><br><span class="line">groupmod –g 10000 -n group3 group2</span><br></pre></td></tr></table></figure><p>（4）切换组 ：如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newgrp root  用户可以在登录后，使用命令newgrp切换到其他用户组</span><br><span class="line">这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。</span><br></pre></td></tr></table></figure><h1 id="开启Linux的防火墙"><a href="#开启Linux的防火墙" class="headerlink" title="开启Linux的防火墙"></a>开启Linux的防火墙</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 查看firewall服务状态</span><br><span class="line">systemctl status firewalld</span><br><span class="line"></span><br><span class="line"># 开启、重启、关闭、firewalld.service服务</span><br><span class="line"># 开启</span><br><span class="line">service firewalld start</span><br><span class="line"># 重启</span><br><span class="line">service firewalld restart</span><br><span class="line"># 关闭</span><br><span class="line">service firewalld stop</span><br><span class="line"></span><br><span class="line"># 查看防火墙规则</span><br><span class="line">firewall-cmd --list-all    # 查看全部信息</span><br><span class="line">firewall-cmd --list-ports  # 只看端口信息</span><br><span class="line"></span><br><span class="line"># 开启端口</span><br><span class="line">开端口命令：firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line">重启防火墙：systemctl restart firewalld.service</span><br><span class="line"></span><br><span class="line">命令含义：</span><br><span class="line">--zone #作用域</span><br><span class="line">--add-port=80/tcp  #添加端口，格式为：端口/通讯协议</span><br><span class="line">--permanent   #永久生效，没有此参数重启后失效</span><br></pre></td></tr></table></figure><p>如果想要自己的项目在服务器上成功运行一定要确保Linux的防火墙端口是开启的，如果是阿里云，需要保证阿里云的安全组策略是开放的。</p><h1 id="宝塔linux面板"><a href="#宝塔linux面板" class="headerlink" title="宝塔linux面板"></a>宝塔linux面板</h1><p><a href="https://www.bt.cn/new/index.html">https://www.bt.cn/new/index.html</a></p><p>这是一个快速安装远程服务器环境的网站。一键安装。</p><p>我的账号的手机号码</p><p>密码是首字母大写，中间加了一个@</p><p><img src="/articleImg/59_article/4.jpg" alt="4"></p><h1 id="今日份linux学习总结"><a href="#今日份linux学习总结" class="headerlink" title="今日份linux学习总结"></a>今日份linux学习总结</h1><p>昨天晚上购置了一台阿里云服务器。利用该台服务器我复习了linux的相关基础命令。</p><p>利用xshell远程连接，利用xftp进行文件传输，安装了java环境和tomcat环境。从docker的官网配置了centos7的环境。</p><p>继续加油吧~</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阿里云服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM整合</title>
      <link href="/2022/03/17/SSM%E6%95%B4%E5%90%88/"/>
      <url>/2022/03/17/SSM%E6%95%B4%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合</h1><p>SSM : SpringMVC + Spring + Mybatis</p><h1 id="Spring-搭建流程"><a href="#Spring-搭建流程" class="headerlink" title="Spring 搭建流程"></a>Spring 搭建流程</h1><p><img src="/articleImg/58_article/Spring%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.jpg" alt="Spring环境搭建"></p><h2 id="Spring-开启事务"><a href="#Spring-开启事务" class="headerlink" title="Spring 开启事务"></a>Spring 开启事务</h2><p> <img src="/articleImg/58_article/Spring%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1.jpg" alt="Spring开启事务"></p><h2 id="Mybatis原生环境搭建"><a href="#Mybatis原生环境搭建" class="headerlink" title="Mybatis原生环境搭建"></a>Mybatis原生环境搭建</h2><p> <img src="/articleImg/58_article/mybatis%E5%8E%9F%E7%94%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.jpg" alt="mybatis原生环境搭建"></p><h2 id="Spring-整合mybatis"><a href="#Spring-整合mybatis" class="headerlink" title="Spring 整合mybatis"></a>Spring 整合mybatis</h2><p><img src="/articleImg/58_article/Spring%E6%95%B4%E5%90%88mybatis.jpg" alt="Spring整合mybatis"></p><h2 id="spring-MVC简介"><a href="#spring-MVC简介" class="headerlink" title="spring MVC简介"></a>spring MVC简介</h2><p>SpringMVC: 对web层进行的封装,提供了MVC框架。M: model(数据封装)、V: view(视图,形成最终的物理视图、C: Controller(控制器)<br>  三大组件:处理器: 我们自己编写的类<br>        1.处理器映射器: 建立请求路径与方法的对应关系<br>        2.处理器适配器: 适配处理器的实现方式,调用指定的类反射执行方法<br>        3.视图解析器: 根据逻辑视图生成物理视图<br>web层的作用:<br>    接收请求 : @WebServlet(“/路径”)  这个是当时学servlet，学的url映射注解<br>    获取请求携带的数据信息<br>    处理请求 : 调用service处理请求<br>SpringMVC:<br>    接收请求 : <strong>DispatcherServlet</strong>接收所有请求(解析请求携带的一切信息,截取请求路径)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/路径&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">demo1</span><span class="params">(request,Model,ModelAndView)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 响应:</span></span><br><span class="line">    <span class="comment">//同步: </span></span><br><span class="line">    <span class="comment">// 封装返回结果</span></span><br><span class="line">    <span class="comment">// request + String : requestAPI和逻辑视图</span></span><br><span class="line">    <span class="comment">// Model + String</span></span><br><span class="line">    <span class="comment">// ModelAndView</span></span><br><span class="line">    <span class="comment">//请求转发: 直接返回字符串找视图解析器 | forward:/路径</span></span><br><span class="line">    <span class="comment">//重定向: redirect:/路径</span></span><br><span class="line">    <span class="comment">//异步: </span></span><br><span class="line">    <span class="comment">//response.getWriter().print(..);</span></span><br><span class="line">    <span class="comment">//@ResponseBody + String</span></span><br><span class="line">    <span class="comment">//@ResponseBody + 对象 (将对象转成json返回)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">异步:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">(HttpServletResponse response)</span></span>&#123;</span><br><span class="line">    response.getWriter().print(..);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@ResponseBody</span>  <span class="comment">//将对象序列化为字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">demo2</span><span class="params">(<span class="meta">@RequestBody</span> User vo)</span></span>&#123; <span class="comment">//RequestBody将字符串序列化为对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;返回的数据信息&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">demo3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;对象&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-整合-Spring-MVC"><a href="#Spring-整合-Spring-MVC" class="headerlink" title="Spring 整合 Spring MVC"></a>Spring 整合 Spring MVC</h2><p><img src="/articleImg/58_article/Spring%E6%95%B4%E5%90%88springMVC.jpg" alt="Spring整合springMVC"></p><h2 id="SSM实现增删改"><a href="#SSM实现增删改" class="headerlink" title="SSM实现增删改"></a>SSM实现增删改</h2><p><img src="/articleImg/58_article/SSM%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%88%A0%E6%94%B9.jpg" alt="SSM实现增删改"></p>]]></content>
      
      
      <categories>
          
          <category> javaweb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM整合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/03/17/hello-world/"/>
      <url>/2022/03/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java双向队列Deque栈与队列</title>
      <link href="/2021/12/29/Java%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97Deque%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
      <url>/2021/12/29/Java%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97Deque%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java中实际上提供了java.util.Stack来实现栈结构,但官方目前已不推荐使用,而是使用java.util.Deque双端队列来实现队列与栈的各种需求.如下图所示java.util.Deque的实现子类有java.util.LinkedList和java.util.ArrayDeque.顾名思义前者是基于链表,后者基于数据实现的双端队列.</p><p> <img src="/articleImg/56_article/image1.png" alt="image1"></p><h1 id="Deque即可当栈也可当队列"><a href="#Deque即可当栈也可当队列" class="headerlink" title="Deque即可当栈也可当队列"></a>Deque即可当栈也可当队列</h1><p>要讲栈和队列，首先要讲Deque接口。Deque的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。下表列出了Deque与Queue相对应的接口：</p><p> <img src="/articleImg/56_article/image2.png" alt="image2"></p><p>下表列出了Deque与Stack对应的接口：</p><p> <img src="/articleImg/56_article/image3.png" alt="image3"></p><h1 id="声明示例"><a href="#声明示例" class="headerlink" title="声明示例"></a>声明示例</h1><p>普通队列(一端进另一端出):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue queue = <span class="keyword">new</span> LinkedList() 或 Deque deque = <span class="keyword">new</span> LinkedList()</span><br></pre></td></tr></table></figure><p>双端队列(两端都可进出)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Deque deque = <span class="keyword">new</span> LinkedList()</span><br><span class="line">Deque&lt;泛型&gt;deque = <span class="keyword">new</span> LinkedList&lt;&gt;()</span><br></pre></td></tr></table></figure><p>堆栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque deque = <span class="keyword">new</span> LinkedList()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双向队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>替换空格</title>
      <link href="/2021/12/29/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
      <url>/2021/12/29/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h1><p> <img src="/articleImg/55_article/image1.png" alt="image1"></p><p>借助栈来解决问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 本题用栈的思想更为巧妙，自己选用了字符串切片后在拼接，造成自己很多繁琐的讨论~~</span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">    public String replaceSpace(String s) &#123;</span></span><br><span class="line"><span class="comment">        int length = s.length();</span></span><br><span class="line"><span class="comment">        char[] array = new char[length * 3];</span></span><br><span class="line"><span class="comment">        int size = 0;</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; length; i++) &#123;</span></span><br><span class="line"><span class="comment">            char c = s.charAt(i);</span></span><br><span class="line"><span class="comment">            if (c == &#x27; &#x27;) &#123;</span></span><br><span class="line"><span class="comment">                array[size++] = &#x27;%&#x27;;</span></span><br><span class="line"><span class="comment">                array[size++] = &#x27;2&#x27;;</span></span><br><span class="line"><span class="comment">                array[size++] = &#x27;0&#x27;;</span></span><br><span class="line"><span class="comment">            &#125; else &#123;</span></span><br><span class="line"><span class="comment">                array[size++] = c;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        String newStr = new String(array, 0, size);</span></span><br><span class="line"><span class="comment">        return newStr;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        ArrayList&lt;String&gt; ans_list =<span class="keyword">new</span> ArrayList&lt;String&gt; ();</span><br><span class="line">        <span class="keyword">int</span> last_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27; &#x27;</span>)&#123; <span class="comment">//该位置是空格</span></span><br><span class="line">                String temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">if</span>(i == s.length() -<span class="number">1</span>)&#123; <span class="comment">//java中的substring不太好用，取不到最后一个字符</span></span><br><span class="line">                    temp = s.substring(last_index,i);</span><br><span class="line">                    last_index = i+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    temp = s.substring(last_index,i);</span><br><span class="line">                    last_index = i+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans_list.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(s.length()-<span class="number">1</span>)!= <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            String temp = s.substring(last_index);</span><br><span class="line">            ans_list.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(s.length()-<span class="number">1</span>)==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">             ans_list.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历到所有的分段集合，进行合并处理</span></span><br><span class="line">        String ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ans_list.size();i++)&#123;</span><br><span class="line">            ans += ans_list.get(i);</span><br><span class="line">            <span class="keyword">if</span>((ans_list.get(i)==<span class="string">&quot;&quot;</span>&amp;&amp;ans_list.size() == <span class="number">1</span>)||i&lt;ans_list.size() -<span class="number">1</span>)</span><br><span class="line">                ans+=<span class="string">&quot;%20&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>把数组排成最小的数</title>
      <link href="/2021/12/29/%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/"/>
      <url>/2021/12/29/%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h1><p>本题是剑指offer面试题45，核心解决方案是根据题目要求设计一个排序算法。自己设计的比较方法思路并不能通过所有的案例，正确的排序规则应该是 将两个字符串，正反拼接起来，这样得到的两个字符串就时长度一致的，在排序方法中使用compareTo方法即可。</p><h2 id="参考高赞解"><a href="#参考高赞解" class="headerlink" title="参考高赞解"></a>参考高赞解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">            strs[i] = String.valueOf(nums[i]);</span><br><span class="line">        Arrays.sort(strs,<span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1,String o2)</span></span>&#123;</span><br><span class="line">           <span class="keyword">return</span> (o1+o2).compareTo(o2+o1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//Arrays.sort(strs, (x, y) -&gt; (x + y).compareTo(y + x));</span></span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(String s : strs)</span><br><span class="line">            res.append(s);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="个人思路"><a href="#个人思路" class="headerlink" title="个人思路"></a>个人思路</h2><p>不能通过所有案例</p><p> <img src="/articleImg/51_article/image1.png" alt="image1"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String minNumber(int[] nums) &#123;</span><br><span class="line">        if(nums.length == 1)</span><br><span class="line">            return &quot;&quot;+nums[0];</span><br><span class="line">       QuickSort(nums,0,nums.length-1);</span><br><span class="line">       String ans = &quot;&quot;;</span><br><span class="line">       for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">           ans = ans + nums[i];</span><br><span class="line">       &#125;</span><br><span class="line">       return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //根据题意设计出的：两数大小比较法则  判断a元素是否大于等于b元素</span><br><span class="line">    public boolean juageNumSize(int a,int b)&#123;</span><br><span class="line">        String str1 = &quot;&quot;+a;</span><br><span class="line">        String str2 = &quot;&quot;+b;</span><br><span class="line">        int length1 = str1.length();</span><br><span class="line">        int length2 = str2.length();</span><br><span class="line">        int length = length1&lt;length2?length1:length2;</span><br><span class="line">        int i =0;</span><br><span class="line">        //判断共同部分</span><br><span class="line">        for(i=0;i&lt;length;i++)&#123;</span><br><span class="line">            if(str1.charAt(i)&gt;str2.charAt(i)) </span><br><span class="line">                return true;</span><br><span class="line">            else if(str1.charAt(i)&lt;str2.charAt(i)) </span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断多余的部分</span><br><span class="line">        if(length1 == length2)</span><br><span class="line">            return true;</span><br><span class="line">        else if(length1&gt;length2)&#123;</span><br><span class="line">            while(i&lt;length1)&#123;</span><br><span class="line">                if(str1.charAt(i)&lt;str2.charAt(0))</span><br><span class="line">                    return false;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else if(length1&lt;length2)&#123;</span><br><span class="line">            while(i&lt;length2)&#123;</span><br><span class="line">                if(str2.charAt(i)&gt;str1.charAt(0))</span><br><span class="line">                    return false;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //快速排序</span><br><span class="line">    void QuickSort(int[] num, int left, int right) &#123;</span><br><span class="line">//如果left等于right，即数组只有一个元素，直接返回</span><br><span class="line">if(left&gt;=right) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//设置最左边的元素为基准值</span><br><span class="line">int key=num[left];</span><br><span class="line">//数组中比key小的放在左边，比key大的放在右边，key值下标为i</span><br><span class="line">int i=left;</span><br><span class="line">int j=right;</span><br><span class="line">while(i&lt;j)&#123;</span><br><span class="line">//j向左移，直到遇到比key小的值</span><br><span class="line">while(juageNumSize(num[j],key)&amp;&amp; i&lt;j)&#123; //num[j]&gt;=key </span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">//i向右移，直到遇到比key大的值</span><br><span class="line">while(juageNumSize(key,num[i]) &amp;&amp; i&lt;j)&#123; //num[i]&lt;=key</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">//i和j指向的元素交换</span><br><span class="line">if(i&lt;j)&#123;</span><br><span class="line">int temp=num[i];</span><br><span class="line">num[i]=num[j];</span><br><span class="line">num[j]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">num[left]=num[i];</span><br><span class="line">num[i]=key;</span><br><span class="line">//count++;</span><br><span class="line">QuickSort(num,left,i-1);</span><br><span class="line">QuickSort(num,i+1,right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组中的逆序对</title>
      <link href="/2021/12/29/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
      <url>/2021/12/29/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h1><p>本体的核心思想是使用归并排序。</p><div style="background-color:orange">另外本题教育自己在递归中，每次都需要开辟同一大量辅助空间时，一定要放为全局变量。这也是记录这道题的主要原因</div><h2 id="题目描述：剑指offer面试题51"><a href="#题目描述：剑指offer面试题51" class="headerlink" title="题目描述：剑指offer面试题51"></a>题目描述：剑指offer面试题51</h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,5,6,4]</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><p>合并阶段 本质上是 合并两个排序数组 的过程，而每当遇到 左子数组当前元素 &gt; 右子数组当前元素 时，意味着 「左子数组当前元素 至 末尾元素」 与 「右子数组当前元素」 构成了若干 「逆序对」 。</p><p>上面一句话的意思简单来说，就是当在合并的时候，选择的是右边元素时，这时便构成了mid - i  +1 个逆序对，i代表此时左边序列该合并的下标位置。如下图</p><p> <img src="/articleImg/54_aiticle/image1.png" alt="image1"></p><h2 id="代码实现-主要思想是归并排序"><a href="#代码实现-主要思想是归并排序" class="headerlink" title="代码实现  主要思想是归并排序"></a>代码实现  主要思想是归并排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> []tmp;<span class="comment">//辅助数组</span></span><br><span class="line">    <span class="comment">//O(n平方)的解法必然超时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        tmp=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];  <span class="comment">//这里开辟数组空间一定要放为全局变量  ★★★★★★★★★★★★★</span></span><br><span class="line">        mergeSort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两路归并算法，两个排好序的子序列合并为一个子序列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> []a,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">//左边序列是指[left,mid] 右边序列范围[mid+1,right]</span></span><br><span class="line">        <span class="keyword">int</span> p1=left,p2=mid+<span class="number">1</span>,k=left;<span class="comment">//p1、p2是检测指针，k是存放指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p1&lt;=mid &amp;&amp; p2&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[p1]&lt;=a[p2])</span><br><span class="line">                tmp[k++]=a[p1++];</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//在这里说名右边的元素比左边的要小，在这里进行逆序对的统计</span></span><br><span class="line">                ans = ans + (mid-p1+<span class="number">1</span>);</span><br><span class="line">                tmp[k++]=a[p2++];</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p1&lt;=mid) tmp[k++]=a[p1++];<span class="comment">//如果第一个序列未检测完，直接将后面所有元素加到合并的序列中</span></span><br><span class="line">        <span class="keyword">while</span>(p2&lt;=right) tmp[k++]=a[p2++];<span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//复制回原素组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;=right; i++) </span><br><span class="line">            a[i]=tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> [] a,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;  <span class="comment">//这里就像是二叉树的一个后序遍历的过程</span></span><br><span class="line">        <span class="keyword">if</span>(start&lt;end)&#123;<span class="comment">//当子序列中只有一个元素时结束递归</span></span><br><span class="line">            <span class="keyword">int</span> mid=(start+end)/<span class="number">2</span>;<span class="comment">//划分子序列</span></span><br><span class="line">            mergeSort(a, start, mid);<span class="comment">//对左侧子序列进行递归排序</span></span><br><span class="line">            mergeSort(a, mid+<span class="number">1</span>, end);<span class="comment">//对右侧子序列进行递归排序</span></span><br><span class="line">            merge(a, start, mid, end);<span class="comment">//合并</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/2021/12/29/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2021/12/29/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>归并排序是一种概念上最简单的排序算法，与快速排序一样，归并排序也是基于分治法的。归并排序将待排序的元素序列分成两个长度相等的子序列，为每一个子序列排序，然后再将他们合并成一个子序列。合并两个子序列的过程也就是两路归并。</p><p>归并排序是一种稳定的排序算法，归并排序的主要问题在于它需要一个与待排序数组一样大的辅助数组空间。由于归并排序每次划分时两个子序列的长度基本一样，所以归并排序最好、最差和平均时间复杂度都是nlog2n。</p><p>归并排序的过程就像是二叉树的一个后序遍历的过程，</p><p> <img src="/articleImg/53_article/image1.png" alt="image1"></p><p>要将两个排好序的子序列合并为一个子序列的方法：每次都是从未比较的两个子序列的最小值中选出一个更小值。</p><p> <img src="/articleImg/53_article/20180812233124752~2.gif" alt="20180812233124752~2"></p><h2 id="java代码一看便知道归并排序的过程"><a href="#java代码一看便知道归并排序的过程" class="headerlink" title="java代码一看便知道归并排序的过程"></a>java代码一看便知道归并排序的过程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//两路归并算法，两个排好序的子序列合并为一个子序列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> []a,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []tmp=<span class="keyword">new</span> <span class="keyword">int</span>[a.length];<span class="comment">//辅助数组</span></span><br><span class="line">        <span class="comment">//左边序列是指[left,mid] 右边序列范围[mid+1,right]</span></span><br><span class="line">        <span class="keyword">int</span> p1=left,p2=mid+<span class="number">1</span>,k=left;<span class="comment">//p1、p2是检测指针，k是存放指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p1&lt;=mid &amp;&amp; p2&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[p1]&lt;=a[p2])</span><br><span class="line">                tmp[k++]=a[p1++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tmp[k++]=a[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p1&lt;=mid) tmp[k++]=a[p1++];<span class="comment">//如果第一个序列未检测完，直接将后面所有元素加到合并的序列中</span></span><br><span class="line">        <span class="keyword">while</span>(p2&lt;=right) tmp[k++]=a[p2++];<span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//复制回原素组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;=right; i++) </span><br><span class="line">            a[i]=tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> [] a,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;  <span class="comment">//这里就像是二叉树的一个后序遍历的过程</span></span><br><span class="line">        <span class="keyword">if</span>(start&lt;end)&#123;<span class="comment">//当子序列中只有一个元素时结束递归</span></span><br><span class="line">            <span class="keyword">int</span> mid=(start+end)/<span class="number">2</span>;<span class="comment">//划分子序列</span></span><br><span class="line">            mergeSort(a, start, mid);<span class="comment">//对左侧子序列进行递归排序</span></span><br><span class="line">            mergeSort(a, mid+<span class="number">1</span>, end);<span class="comment">//对右侧子序列进行递归排序</span></span><br><span class="line">            merge(a, start, mid, end);<span class="comment">//合并</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123; <span class="number">49</span>, <span class="number">38</span>, <span class="number">65</span>, <span class="number">97</span>, <span class="number">76</span>, <span class="number">13</span>, <span class="number">27</span>, <span class="number">50</span> &#125;;</span><br><span class="line">        mergeSort(a, <span class="number">0</span>, a.length-<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;排好序的数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e : a)</span><br><span class="line">            System.out.print(e+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本篇博客大部分粘贴CSDN博主：<a href="https://blog.csdn.net/qq_36442947">华山派副掌门人</a></p><p>非常感谢他的工作~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>会有重复字符的字符串的排列</title>
      <link href="/2021/12/29/%E4%BC%9A%E6%9C%89%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
      <url>/2021/12/29/%E4%BC%9A%E6%9C%89%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h1><p>注意这里字符可能会有重复的情况，所以需要在交换的过程当中，用一个set去重</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  List&lt;String&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  <span class="keyword">char</span> []c;</span><br><span class="line">  <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">​    c = s.toCharArray();</span><br><span class="line">​    dfs(<span class="number">0</span>);</span><br><span class="line">​    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> String[res.size()]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">​    <span class="keyword">if</span>(x == c.length -<span class="number">1</span>)&#123;</span><br><span class="line">​      res.add(String.valueOf(c));</span><br><span class="line">​      <span class="keyword">return</span>;</span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    HashSet &lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">​    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;c.length;i++)&#123;</span><br><span class="line">​      <span class="keyword">if</span>(set.contains(c[i])) </span><br><span class="line">​      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">​      set.add(c[i]);</span><br><span class="line">​      swap(c,i,x);</span><br><span class="line">​      dfs(x+<span class="number">1</span>);</span><br><span class="line">​      swap(c,i,x);</span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[]c,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">char</span> temp = c[i];</span><br><span class="line">​    c[i] = c[j];</span><br><span class="line">​    c[j] = temp;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 全排列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决maven引入依赖失败</title>
      <link href="/2021/12/29/%E8%A7%A3%E5%86%B3maven%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96%E5%A4%B1%E8%B4%A5/"/>
      <url>/2021/12/29/%E8%A7%A3%E5%86%B3maven%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96%E5%A4%B1%E8%B4%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="解决maven引入依赖失败"><a href="#解决maven引入依赖失败" class="headerlink" title="解决maven引入依赖失败"></a>解决maven引入依赖失败</h1><h2 id="JDK版本需要对应上"><a href="#JDK版本需要对应上" class="headerlink" title="JDK版本需要对应上"></a>JDK版本需要对应上</h2><ul><li>项目JDK</li></ul><p> <img src="/articleImg/50_article/image1.png" alt="image1"></p><ul><li>maven中JDK for Importer 选择 jdk 1.8</li></ul><p> <img src="/articleImg/50_article/image3.png" alt="image3"></p><ul><li>确定自己的maven仓库在IDEA中的配置都是正确的，并且maven的setting.xml 也已经被设置更改好</li></ul><p> <img src="/articleImg/50_article/image4.png" alt="image4"></p><ul><li>lifestle –&gt; clean 之后再reimport</li></ul><p> <img src="/articleImg/50_article/image2.png" alt="image2"></p><p>根据上面的几个步骤大概率是能把问题解决的</p>]]></content>
      
      
      <categories>
          
          <category> javaweb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>丑数</title>
      <link href="/2021/12/29/%E4%B8%91%E6%95%B0/"/>
      <url>/2021/12/29/%E4%B8%91%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h5><p>输入: n = 10<br>输出: 12<br>解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。<br>说明:  </p><p>1 是丑数。<br>n 不超过1690。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>该题目是剑指offer的面试题49，正向解法的话必然无法通过所有的测试用例。需要用到动态规划，找出递推公式。</p><p>丑数Xn+1满足下式：</p><p><img src="/articleImg/52_article/1.png" alt="1"></p><p><strong>丑数递推公式：</strong> 若索引 a,b,c满足以上条件，则下个丑数 Xn+1为三种情况中的 <strong>最小值</strong> ；<br>$$<br>Xn+1 = Math.min(Math.min(Xa, Xb),Xc);<br>$$<br>因此，可设置指针 a,b,c 指向首个丑数，循环根据递推公式得到下个丑数，<strong>并每轮将对应指针执行 +1 即可</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法二：是用动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line">    <span class="keyword">int</span> []dp = <span class="keyword">new</span> <span class="keyword">int</span> [n];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>; <span class="comment">//每次只移动2</span></span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">0</span>; <span class="comment">//每次只移动3</span></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>; <span class="comment">//每次只移动5</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> n1=dp[a] *<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> n2=dp[b]*<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> n3 = dp[c]*<span class="number">5</span>;</span><br><span class="line">        dp[i] = Math.min(Math.min(n1,n2),n3);</span><br><span class="line">        <span class="keyword">if</span>(dp[i] == n1) a++;</span><br><span class="line">        <span class="keyword">if</span>(dp[i] == n2) b++;</span><br><span class="line">        <span class="keyword">if</span>(dp[i] == n3) c++;</span><br><span class="line">        &#125;</span><br><span class="line">   <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="直接暴力正向会超时"><a href="#直接暴力正向会超时" class="headerlink" title="直接暴力正向会超时"></a>直接暴力正向会超时</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//超时 常规的正向解法，虽然加了备忘录，但是人需要判断每个数是不是丑数，所以最后提交的时候超出时间限制</span></span><br><span class="line">    LinkedList&lt;Integer&gt;uglyList = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">//用于已确定的丑数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> number = <span class="number">0</span>; <span class="comment">//递增的数字</span></span><br><span class="line">        <span class="keyword">int</span> uglyFound =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(uglyFound&lt;n)&#123;</span><br><span class="line">            number++;</span><br><span class="line">            <span class="keyword">if</span>(isUgly(number))&#123;</span><br><span class="line">                uglyList.add(number);</span><br><span class="line">                uglyFound++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(num%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(uglyList.contains(num)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            num = num/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">while</span>(num%<span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(uglyList.contains(num)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            num = num/<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">while</span>(num%<span class="number">5</span>==<span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">if</span>(uglyList.contains(num)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            num = num/<span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (num == <span class="number">1</span>)?<span class="keyword">true</span>:<span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字序列中某一位的数字</title>
      <link href="/2021/12/27/%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2021/12/27/%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="数字序列中某一位的数字"><a href="#数字序列中某一位的数字" class="headerlink" title="数字序列中某一位的数字"></a>数字序列中某一位的数字</h1><p>不得不说剑指offer的第五章有很多好题，直接暴力的话效果很不好，需要自己发现规律，在发现规律之后，也要认真思考代码的编写。</p><p>代码编写的过程中，一定要明确变量所对应的含义，这样才可确保万无一失。另外在大数代码失效的情况下，自己要考虑是否发生变量溢出的问题。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p><p>请写一个函数，求任意第n位对应的数字。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p> <img src="/articleImg/49_article/image1.png" alt="image1"></p><h2 id="很经典的两句代码"><a href="#很经典的两句代码" class="headerlink" title="很经典的两句代码"></a>很经典的两句代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//根据高赞解修改后的写法（最经典的就是这两句）                   //变量的意义</span><br><span class="line">   result = (long)Math.pow(10,cur) + ((copyN-1)/(cur+1)); //这里的cur+1就相当于元素的位数，copyN相当于还剩下的位数，这里是从1开始</span><br><span class="line">   return Long.toString(result).charAt((copyN - 1) % (cur+1)) - &#x27;0&#x27;;</span><br></pre></td></tr></table></figure><p>给自己的启示就是：一定要明确变量的含义及作用范围再去编写代码。三思而后码。</p><h2 id="个人解法，经1次参考修改"><a href="#个人解法，经1次参考修改" class="headerlink" title="个人解法，经1次参考修改"></a>个人解法，经1次参考修改</h2><p>数字的位数和个数之间是有对应关系的，是有规律的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">9</span>) <span class="keyword">return</span> n;</span><br><span class="line">        n = n-<span class="number">9</span>;</span><br><span class="line">        <span class="keyword">int</span> cur=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> copyN = n;</span><br><span class="line">        <span class="keyword">long</span> everyWeight=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> start = (<span class="keyword">int</span>)Math.pow(<span class="number">10</span>,cur);</span><br><span class="line">            <span class="keyword">if</span>(cur == <span class="number">0</span>) start = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> end = (<span class="keyword">int</span>)Math.pow(<span class="number">10</span>,cur+<span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">            everyWeight = (<span class="keyword">long</span>)(end - start + <span class="number">1</span>)*(cur+<span class="number">1</span>);  <span class="comment">//int 最大值 2147483647，但是这里数据较大时，会产生溢出</span></span><br><span class="line">            <span class="keyword">long</span> judge = copyN - everyWeight;</span><br><span class="line">            <span class="keyword">if</span>(judge &lt;=<span class="number">0</span>)&#123; <span class="comment">//说明找到，在该区间内</span></span><br><span class="line">                <span class="comment">//根据位数n的值去计算这个数到底是多少</span></span><br><span class="line">                <span class="keyword">int</span> remainder = copyN % (cur+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">int</span> num = copyN/(cur+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//根据高赞解修改后的写法（最经典的就是这两句）                   //变量的意义</span></span><br><span class="line">                result = (<span class="keyword">long</span>)Math.pow(<span class="number">10</span>,cur) + ((copyN-<span class="number">1</span>)/(cur+<span class="number">1</span>)); <span class="comment">//这里的cur+1就相当于元素的位数，copyN相当于还剩下的位数，这里是从1开始</span></span><br><span class="line">                <span class="keyword">return</span> Long.toString(result).charAt((copyN - <span class="number">1</span>) % (cur+<span class="number">1</span>)) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="comment">//第一次写法</span></span><br><span class="line">                <span class="comment">// if(remainder == 0)&#123;</span></span><br><span class="line">                <span class="comment">//     int result = 0;</span></span><br><span class="line">                <span class="comment">//     result = (int)Math.pow(10,cur) + num - 1;</span></span><br><span class="line">                <span class="comment">//     return result%10;</span></span><br><span class="line">                <span class="comment">// &#125;else&#123;</span></span><br><span class="line">                <span class="comment">//     int result = (int)Math.pow(10,cur) + num ;</span></span><br><span class="line">                <span class="comment">//     return (result/(int)Math.pow(10,(cur+1)-remainder))%10;</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur + <span class="number">1</span>;</span><br><span class="line">            copyN -= everyWeight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高赞写法，确实值得自己去学习"><a href="#高赞写法，确实值得自己去学习" class="headerlink" title="高赞写法，确实值得自己去学习"></a>高赞写法，确实值得自己去学习</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//高赞解，要学习的地方真的太多了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> digit = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> start = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> count = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; count) &#123; <span class="comment">// 1.</span></span><br><span class="line">            n -= count;</span><br><span class="line">            digit += <span class="number">1</span>;</span><br><span class="line">            start *= <span class="number">10</span>;</span><br><span class="line">            count = digit * start * <span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对于第二步：这里取n-1的原因是:当n对应num中的最后一位时，不会由于进位，错误的寻找到下一个数字。</span></span><br><span class="line">        <span class="comment">//对于第三步：这里取n-1使得num中各位的位置坐标从左到右从0开始增加，即0,1,....,(digit-1)，更容易理解。</span></span><br><span class="line">        <span class="keyword">long</span> num = start + (n - <span class="number">1</span>) / digit; <span class="comment">// 2.</span></span><br><span class="line">        <span class="keyword">return</span> Long.toString(num).charAt((n - <span class="number">1</span>) % digit) - <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 3.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>继续加油吧！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化时间和空间效率 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据流中的中位数</title>
      <link href="/2021/12/27/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
      <url>/2021/12/27/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="数据流中的中位数"><a href="#数据流中的中位数" class="headerlink" title="数据流中的中位数"></a>数据流中的中位数</h1><p>发这篇博文主要是想对比一下自己的代码和高赞解代码的区别，告诉自己以后写代码真的需要三思而后码，不然自己累得不行才得到跟差不多的效果。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。对应剑指offer41题</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><p>​        void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>​        double findMedian() - 返回目前所有元素的中位数。</p><h2 id="自己的解答"><a href="#自己的解答" class="headerlink" title="自己的解答"></a>自己的解答</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用最大最小堆来解决问题，java中优先队列形同于堆</span></span><br><span class="line">    <span class="comment">//切记一档要确保在插入的过程中：最大堆中的元素必须全部小于最小堆中的元素</span></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    Queue&lt;Integer&gt; maxHeap;</span><br><span class="line">    Queue&lt;Integer&gt; minHeap;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count=<span class="number">0</span>;<span class="comment">//记录元素的总个数</span></span><br><span class="line"></span><br><span class="line">        Comparator&lt;Integer&gt;minCmp = <span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a,Integer b)</span></span>&#123;</span><br><span class="line">                 <span class="keyword">return</span> a-b; <span class="comment">//升序，也就是最小的元素在前面，表示最小堆</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">         Comparator&lt;Integer&gt;maxCmp = <span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a,Integer b)</span></span>&#123;</span><br><span class="line">                 <span class="keyword">return</span> b-a; <span class="comment">//降序，也就是最大的元素在前面，表示最大堆</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化最大堆</span></span><br><span class="line">        maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(maxCmp);</span><br><span class="line">        minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(minCmp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//插入元素的规则： 1 最大堆中的元素必须全部小于最小堆中的元素 2：当元素总数为偶数时，插入最小堆，总数为奇数时，插入最大堆</span></span><br><span class="line">    <span class="comment">//3.当需要插入最小堆的元素比最大堆中的一些元素还要小时，则进行调整，调整规则按1为准</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count%<span class="number">2</span>==<span class="number">0</span>)&#123; <span class="comment">//元素总数为偶数</span></span><br><span class="line">            <span class="keyword">if</span>(!minHeap.isEmpty()&amp;&amp;!maxHeap.isEmpty())&#123;</span><br><span class="line">                <span class="comment">//判断是否与1规则冲突</span></span><br><span class="line">                <span class="keyword">int</span> temp = maxHeap.peek();</span><br><span class="line">                <span class="keyword">if</span>(num&lt;=temp)&#123;</span><br><span class="line">                    maxHeap.add(num);</span><br><span class="line">                    <span class="keyword">int</span> realNum = maxHeap.poll();</span><br><span class="line">                    minHeap.add(realNum);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    minHeap.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                minHeap.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="comment">//元素总数为奇数</span></span><br><span class="line">            <span class="keyword">if</span>(!maxHeap.isEmpty())&#123;</span><br><span class="line">                <span class="comment">//插入maxHeap的元素也要进行筛查</span></span><br><span class="line">                <span class="keyword">int</span> temp = minHeap.peek();</span><br><span class="line">                <span class="keyword">if</span>(temp&gt;num)</span><br><span class="line">                    maxHeap.add(num);</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    temp = minHeap.poll();</span><br><span class="line">                    maxHeap.add(temp);</span><br><span class="line">                    minHeap.add(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = minHeap.peek();</span><br><span class="line">                <span class="keyword">if</span>(temp&gt;num)</span><br><span class="line">                    maxHeap.add(num);</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    temp = minHeap.poll();</span><br><span class="line">                    maxHeap.add(temp);</span><br><span class="line">                    minHeap.add(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count%<span class="number">2</span> == <span class="number">0</span>)&#123; <span class="comment">//总元素为偶数</span></span><br><span class="line">            <span class="keyword">int</span> temp1 = maxHeap.peek();</span><br><span class="line">            <span class="keyword">int</span> temp2 = minHeap.peek();</span><br><span class="line">            <span class="keyword">return</span> (temp1+temp2)*<span class="number">1.0</span>/<span class="number">2</span>; <span class="comment">//这里要注意整数的除法  和  浮点数的除法的不同</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">           <span class="comment">// System.out.print(minHeap.size());</span></span><br><span class="line">            System.out.print(minHeap.peek());</span><br><span class="line">            <span class="keyword">return</span> minHeap.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="高赞解"><a href="#高赞解" class="headerlink" title="高赞解"></a>高赞解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//高赞解法：确实值得自己学习</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; A, B;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A = <span class="keyword">new</span> PriorityQueue&lt;&gt;(); <span class="comment">// 小顶堆，保存较大的一半</span></span><br><span class="line">        B = <span class="keyword">new</span> PriorityQueue&lt;&gt;((x, y) -&gt; (y - x)); <span class="comment">// 大顶堆，保存较小的一半</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//尤其是这两句非常值得学习，对一下自己的if else写了多少句</span></span><br><span class="line">        <span class="keyword">if</span>(A.size() != B.size()) &#123;</span><br><span class="line">            A.add(num);  <span class="comment">//多一次插入操作，确保了每次插入到大顶堆B中的都是最小值</span></span><br><span class="line">            B.add(A.poll());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            B.add(num); <span class="comment">//多一次插入操作，确保了每次插入到大顶堆A中的都是最大值</span></span><br><span class="line">            A.add(B.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> A.size() != B.size() ? A.peek() : (A.peek() + B.peek()) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：vRIkXGwZl4</span><br></pre></td></tr></table></figure><p>对自己的解法真的是降维打击。继续努力吧。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化时间和空间效率 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不同基准元素下的快速排序</title>
      <link href="/2021/12/27/%E4%B8%8D%E5%90%8C%E5%9F%BA%E5%87%86%E5%85%83%E7%B4%A0%E4%B8%8B%E7%9A%84%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2021/12/27/%E4%B8%8D%E5%90%8C%E5%9F%BA%E5%87%86%E5%85%83%E7%B4%A0%E4%B8%8B%E7%9A%84%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="不同基准元素下的快速排序"><a href="#不同基准元素下的快速排序" class="headerlink" title="不同基准元素下的快速排序"></a>不同基准元素下的快速排序</h1><h2 id="快速排序核心思想"><a href="#快速排序核心思想" class="headerlink" title="快速排序核心思想"></a>快速排序核心思想</h2><p>1、快速排序的基本思想：</p><p>​       快速排序使用分治的思想，通过一趟排序将待排序列分割成两部分，其中一部分记录的关键字均比另一部分记录的关键字小。之后分别对这两部分记录继续进行排序，以达到整个序列有序的目的。</p><p>2、快速排序的三个步骤：</p><p>(1)选择基准：在待排序列中，按照某种方式挑出一个元素，作为 “基准”（pivot）</p><p>(2)分割操作：以该基准在序列中的实际位置，把序列分成两个子序列。此时，在基准左边的元素都比该基准小，在基准右边的元素都比基准大</p><p>(3)递归地对两个序列进行快速排序，直到序列为空或者只有一个元素。</p><p>3、选择基准的方式</p><p>​       对于分治算法，当每次划分时，算法若都能分成两个等长的子序列时，那么分治算法效率会达到最大。也就是说，基准的选择是很重要的。选择基准的方式决定了两个分割后两个子序列的长度，进而对整个算法的效率产生决定性影响。</p><p>最理想的方法是，选择的基准恰好能把待排序序列分成两个等长的子序列</p><h2 id="三种选择基准的方法"><a href="#三种选择基准的方法" class="headerlink" title="三种选择基准的方法"></a>三种选择基准的方法</h2><h3 id="方法-1-：固定位置"><a href="#方法-1-：固定位置" class="headerlink" title="方法(1)：固定位置"></a>方法(1)：固定位置</h3><p>思想：取序列的第一个或最后一个元素作为基准</p><p>基本的快速排序，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果left等于right，即数组只有一个元素，直接返回</span></span><br><span class="line"><span class="keyword">if</span>(left&gt;=right) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置最左边的元素为基准值</span></span><br><span class="line"><span class="keyword">int</span> key=num[left];</span><br><span class="line"><span class="comment">//数组中比key小的放在左边，比key大的放在右边，key值下标为i</span></span><br><span class="line"><span class="keyword">int</span> i=left;</span><br><span class="line"><span class="keyword">int</span> j=right;</span><br><span class="line"><span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line"><span class="comment">//j向左移，直到遇到比key小的值</span></span><br><span class="line"><span class="keyword">while</span>(num[j]&gt;=key &amp;&amp; i&lt;j)&#123;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//i向右移，直到遇到比key大的值</span></span><br><span class="line"><span class="keyword">while</span>(num[i]&lt;=key &amp;&amp; i&lt;j)&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//i和j指向的元素交换</span></span><br><span class="line"><span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line"><span class="keyword">int</span> temp=num[i];</span><br><span class="line">num[i]=num[j];</span><br><span class="line">num[j]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">num[left]=num[i];</span><br><span class="line">num[i]=key;</span><br><span class="line">count++;</span><br><span class="line">QuickSort(num,left,i-<span class="number">1</span>);</span><br><span class="line">QuickSort(num,i+<span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法-2-：随机选取基准"><a href="#方法-2-：随机选取基准" class="headerlink" title="方法(2)：随机选取基准"></a>方法(2)：随机选取基准</h2><p>引入的原因：在待排序列是部分有序时，固定选取基准使快排效率底下，要缓解这种情况，就引入了随机选取基准</p><p>代码参照剑指offer80页,回头回顾的时候，认真对待这个解法。可学习的地方还是很多的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//这个函数很有参考意义，实现的主要功能是：以一个随机基准数参考，将比参考值大的数放置在基准数的左边，将比参考值小的数放置在基准数的右边，</span></span><br><span class="line"><span class="comment">//但基准数的左右两边的数是非有序的，并且每次的基准数是操作范围内的随机值</span></span><br><span class="line"><span class="comment">//该函数目前应用在topk、快排等算法中</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> []data,<span class="keyword">int</span> length,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(start&gt;end||length&lt;<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">//数据格式不符合要求</span></span><br><span class="line">     Random r = <span class="keyword">new</span> Random();</span><br><span class="line">     <span class="comment">//rand.nextInt(MAX - MIN + 1) + MIN</span></span><br><span class="line">     <span class="keyword">int</span> index = r.nextInt(end-start+<span class="number">1</span>)+start; <span class="comment">//生成[start,end]之间的随机整数   //随机选取基准</span></span><br><span class="line">     Swap(data,index,end);</span><br><span class="line">     <span class="keyword">int</span> small = start-<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;end;i++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(data[i]&lt;data[end])&#123;</span><br><span class="line">         ++small;</span><br><span class="line">         <span class="keyword">if</span>(small!=i)</span><br><span class="line">         Swap(data,small,i);</span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++small;</span><br><span class="line">        Swap(data,small,end);</span><br><span class="line">        <span class="keyword">return</span> small;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="comment">//下面更具上述的Partition函数，写出快排</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> []data,<span class="keyword">int</span> length,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;  <span class="comment">//起始start是0；起始end是arr.length-1;</span></span><br><span class="line"><span class="keyword">if</span>(start == end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> index = Partition(data,length,start,end);</span><br><span class="line">    <span class="keyword">if</span>(index&gt;start)</span><br><span class="line">        QuickSort(data,length,start,index-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(index&lt;end)</span><br><span class="line">        QuickSort(data,length,index+<span class="number">1</span>,end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速幂和超级次方</title>
      <link href="/2021/12/26/%E5%BF%AB%E9%80%9F%E5%B9%82%E5%92%8C%E8%B6%85%E7%BA%A7%E6%AC%A1%E6%96%B9/"/>
      <url>/2021/12/26/%E5%BF%AB%E9%80%9F%E5%B9%82%E5%92%8C%E8%B6%85%E7%BA%A7%E6%AC%A1%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="快速幂和超级次方"><a href="#快速幂和超级次方" class="headerlink" title="快速幂和超级次方"></a>快速幂和超级次方</h1><p>分别对应leetcode50和leetcode372</p><h2 id="快速幂的思想"><a href="#快速幂的思想" class="headerlink" title="快速幂的思想"></a>快速幂的思想</h2><p>对于 a ^ b来说，若果把 b 写成2 进制，那么b 就可以写成若干二次幂之和，如13 的二进制 1101，于是3 号位 、2号位、0号位就都是1，那么就可以得到13 = 2^3 + 2^2 + 2^1 = 8 + 4 + 1。所以a ^13 = a^8 * a^4 * a^1。</p><p>通过同样的推导，我们可以把任意的a^b 表示成 a^(2^k)……、a^8、a^4、a^2、a^1中若干的乘积。若果二进制的i号位为1.那么想中的a^(2^i)就被选中。于是可以得到计算a^b的大致思路：令i 从0到k枚举b的二进制的每一位，如果为1 那就累计a^(2^i)。注意</p><p>a^(2^k)……、a^8、a^4、a^2、a^1前一项总是等于后一项的平方。</p><p>有了上述的思想，快速幂的编码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> num = n;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123; <span class="comment">//处理负数情况</span></span><br><span class="line">            x = <span class="number">1</span>/x;</span><br><span class="line">            num = -num;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((num&amp;<span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">                ans = ans*x;</span><br><span class="line">            num&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">            x = x*x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="超级次方"><a href="#超级次方" class="headerlink" title="超级次方"></a>超级次方</h2><h4 id="倒序遍历的方法解决该题"><a href="#倒序遍历的方法解决该题" class="headerlink" title="倒序遍历的方法解决该题"></a>倒序遍历的方法解决该题</h4><p>取余规则：ab % k = (a%k)(b%k)%k</p><p>迭代法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOD = <span class="number">1337</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            ans = (<span class="keyword">int</span>) ((<span class="keyword">long</span>) ans * pow(a, b[i]) % MOD);</span><br><span class="line">            a = pow(a, <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                res = (<span class="keyword">int</span>) ((<span class="keyword">long</span>) res * x % MOD);</span><br><span class="line">            &#125;</span><br><span class="line">            x = (<span class="keyword">int</span>) ((<span class="keyword">long</span>) x * x % MOD);</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> base = <span class="number">1337</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt;numList = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b.length;i++)&#123;</span><br><span class="line">            numList.addLast(b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = mysuperPow(a,numList);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mysuperPow</span><span class="params">(<span class="keyword">int</span> a,LinkedList&lt;Integer&gt; numList)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numList.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> last = numList.removeLast();</span><br><span class="line">        <span class="keyword">int</span> part1 = myPow(a,last);</span><br><span class="line">        <span class="keyword">int</span> part2 = myPow(mysuperPow(a,numList),<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> part1*part2%base;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myPow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123; <span class="comment">//这里在快速幂的基础之上加上取余运算</span></span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        x = x%base;</span><br><span class="line">        <span class="keyword">while</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((k&amp;<span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">                ans = ans*x%base;</span><br><span class="line">            k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">            x = x*x%base;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer[二进制中1的个数]</title>
      <link href="/2021/12/26/%E5%89%91%E6%8C%87offer-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
      <url>/2021/12/26/%E5%89%91%E6%8C%87offer-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offer-二进制中1的个数"><a href="#剑指offer-二进制中1的个数" class="headerlink" title="剑指offer[二进制中1的个数]"></a>剑指offer[二进制中1的个数]</h1><p><strong>负数的右移：负数右移的话，由于要保持它是负数，所以负数的二进制的右边补1。如果一直右移的话，最后就就变成0xFFFFFFFF 即-1</strong><br><strong>如： -4&gt;&gt;1 为-2 ；-4&gt;&gt;2为-1</strong> </p><p>负数的左移：跟正整数左移一样，右边补0，一直左移的话，最后就是0啦。-2&lt;&lt;2 为-4 ； -2&lt;&lt;31为0</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 汉明重量).）。</p><p>提示：</p><p>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>这里通过一个flag的位左移动，来查询待查数字二进制1的个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(flag != <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>((n&amp;flag) != <span class="number">0</span>)  <span class="comment">//(n&amp;flag) 这里一定要加括号啊！！</span></span><br><span class="line">                ans++;</span><br><span class="line">            flag&lt;&lt;=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里一定要注意负数的右移的特点。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开题报告</title>
      <link href="/2021/12/26/%E5%BC%80%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
      <url>/2021/12/26/%E5%BC%80%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="开题报告"><a href="#开题报告" class="headerlink" title="开题报告"></a>开题报告</h1><p>上周进行了自己的开题报告答辩，自己的方向实打实的确定了下来，在这里我把自己的开题报告内容进行记录，以作留念。</p><h2 id="选题背景"><a href="#选题背景" class="headerlink" title="选题背景"></a>选题背景</h2><p>​        国内汽车市场的发展越来越快，因此汽车安全技术的研发，也在汽车行业里兴起。汽车的智能化成为其中的一个重点，<strong>要让汽车的行驶能够智能化，就必须要实现车辆目标的有效检测。</strong>车辆目标的有效检测，能够给驾驶员提供目标信息来警示驾驶员前方的路况，也能为进一步的自动驾驶提供研究的基础。</p><p>​        与光学传感器相比，雷达在成像分辨率上不如光学传感器，不过它在测距测速功能和恶劣天气下的工作性能明显更胜一筹，穿透烟、尘、雨、雾的能力非常强，有着全天候、全天时的工作特点。相比之下，摄像头在雨雾、黑暗的环境下就会“失明”，强光和弱光环境它也不能正常工作。虽然光学传感器在恶劣天气下能力受限，但它成像分辨率上依然有优势。可以说每种传感器都有自己的优势也有自己的软肋。若雷达和摄像头感测若能相互搭配，将达到相辅相成的效果，因此在处理器或MCU中加入整合不同讯号的感测融合技术，让处理器能运算多种讯号，成为重要趋势。</p><h2 id="研究思路："><a href="#研究思路：" class="headerlink" title="研究思路："></a><strong>研究思路</strong>：</h2><p>总体框架</p><p> <img src="/articleImg/48_article/image1.png" alt="image1"></p><p><strong>第一</strong>：掌握超宽带雷达的使用方法，理解超宽带雷达X4M03的数据采集原理与基本的雷达成像原理。使用python驱动超宽带雷达在树莓派（Raspberry Pi）端的实时工作。对超宽带雷达采集的数据进行实时成像处理，获取目标的雷达成像信息。</p><p><strong>第二</strong>：驱动深度相机intel D455在嵌入式JetsonNano端的工作，应用yolov5目标识别网络，对深度相机的拍摄内容，进行实时的特定目标识别，得到目标的类别信息；并从相机深度图中获取目标点的距离信息。从而可以达到对目标进行类别与距离的信息标注。</p><p><strong>第三</strong>：将雷达坐标系与摄像头坐标系匹配并校准，设计概率融合算法，完成雷达成像信息与摄像头图像识别信息的融合，当系统运行时，达到对雷达成像中的目标实时标注类别及距离信息的效果。</p><p><strong>第四</strong>：选取实验场景，根据所建立的系统，对场景进行数据采集，进行自动化的雷达图像与摄像头图像的信息标注，建立一个雷达-摄像头融合的目标识别数据集。</p><p><strong>第五</strong>：尝试设计搭建一个摄像头与雷达交叉学习监督的目标识别网络，提高雷达单独成像时的目标识别效果，从而当遇到恶劣天气天气时，只使用雷达进行目标的检测与识别，提升系统工作的可靠性。</p><h2 id="摄像头3D目标识别基本思路"><a href="#摄像头3D目标识别基本思路" class="headerlink" title="摄像头3D目标识别基本思路"></a><strong>摄像头3D目标识别基本思路</strong></h2><p><img src="/articleImg/48_article/image2.png" alt="image2"></p><p>3D目标的识别效果如下图，同时返回类别及深度信息：</p><p> <img src="/articleImg/48_article/camera.gif" alt="camera"></p><h2 id="X4M03雷达实时成像及目标识别基本思路"><a href="#X4M03雷达实时成像及目标识别基本思路" class="headerlink" title="X4M03雷达实时成像及目标识别基本思路"></a>X4M03雷达实时成像及目标识别基本思路</h2><p><img src="/articleImg/48_article/image3.png" alt="image3"></p><p>这里展示的雷达成像效果对应3D目标识别中的实时场景</p><p> <img src="/articleImg/48_article/radar.gif" alt="radar"></p><h1 id="期待研究成果"><a href="#期待研究成果" class="headerlink" title="期待研究成果"></a>期待研究成果</h1><ul><li>边缘端雷达实时成像</li><li>边缘端摄像头3D目标识别</li><li>边缘端雷达与摄像头目标识别信息融合</li><li>建立雷达-摄像头目标识别数据集</li><li>设计深度学习网络单独训练雷达目标识别，最终达到雷达与摄像头的交互感知识别</li></ul><p><strong>非常感激</strong>自己的导师赵博老师和组内的梁承美同学对我这么长一段时间的支持和鼓励！</p>]]></content>
      
      
      <categories>
          
          <category> 深圳大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开题报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yolov5n如何训练自己的参数</title>
      <link href="/2021/12/26/yolov5n%E5%A6%82%E4%BD%95%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8F%82%E6%95%B0/"/>
      <url>/2021/12/26/yolov5n%E5%A6%82%E4%BD%95%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="yolov5n如何训练自己的参数"><a href="#yolov5n如何训练自己的参数" class="headerlink" title="yolov5n如何训练自己的参数"></a>yolov5n如何训练自己的参数</h1><p>自己的项目到了一个很关键的时刻，那就是雷达的信息融合，但是自己手里的Nano识别帧率FPS只能达到5，昨天发现yolo官方又出了一个新的版本yolov5n，首次发布支持移动端的最小化模型YOLOv5n，只有1.9MB，全称为YOLOv5 Nano。</p><p>下面把握如何训练yolov5n的过程记录下来</p><h2 id="1，源码"><a href="#1，源码" class="headerlink" title="1，源码"></a>1，源码</h2><p>yolo官方下载yolov5 - n(6.0)版本代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/ultralytics/yolov5</span><br></pre></td></tr></table></figure><h2 id="2，数据标注"><a href="#2，数据标注" class="headerlink" title="2，数据标注"></a>2，数据标注</h2><p>使用labelImg对自己的数据集进行标注 images、Annotations、 ImageSets、 JPEGImages、labels, 创立这几个文件夹的主要作用是为了后续使用step1.py,step2.py运行时，xml格式数据转VOc数据格式，放置相关训练文件用。</p><h2 id="3，配置文件"><a href="#3，配置文件" class="headerlink" title="3，配置文件"></a>3，配置文件</h2><p>在源码data文件夹下创建如下几个文件夹  </p><p><strong>需要放入自己文件的只有两个：</strong> images内为数据集原始图片，Annotations内为标注的xml文件，并将images内文件复制到JPEGIamges中</p><p>根目录下创建 <em>step1.py</em> 文件，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">trainval_percent = <span class="number">0.1</span></span><br><span class="line">train_percent = <span class="number">0.9</span></span><br><span class="line">xmlfilepath = <span class="string">&#x27;data/Annotations&#x27;</span></span><br><span class="line">txtsavepath = <span class="string">&#x27;data/ImageSets&#x27;</span></span><br><span class="line">total_xml = os.listdir(xmlfilepath)</span><br><span class="line">num = <span class="built_in">len</span>(total_xml)</span><br><span class="line"><span class="built_in">list</span> = <span class="built_in">range</span>(num)</span><br><span class="line">tv = <span class="built_in">int</span>(num * trainval_percent)</span><br><span class="line">tr = <span class="built_in">int</span>(tv * train_percent)</span><br><span class="line">trainval = random.sample(<span class="built_in">list</span>, tv)</span><br><span class="line">train = random.sample(trainval, tr)</span><br><span class="line">ftrainval = <span class="built_in">open</span>(<span class="string">&#x27;data/ImageSets/trainval.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">ftest = <span class="built_in">open</span>(<span class="string">&#x27;data/ImageSets/test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">ftrain = <span class="built_in">open</span>(<span class="string">&#x27;data/ImageSets/train.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">fval = <span class="built_in">open</span>(<span class="string">&#x27;data/ImageSets/val.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">    name = total_xml[i][:-<span class="number">4</span>] + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">in</span> trainval:</span><br><span class="line">        ftrainval.write(name)</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> train:</span><br><span class="line">            ftest.write(name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            fval.write(name)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ftrain.write(name)</span><br><span class="line">ftrainval.close()</span><br><span class="line">ftrain.close()</span><br><span class="line">fval.close()</span><br><span class="line">ftest.close()</span><br></pre></td></tr></table></figure><p>根目录下继续创建 <em>step2.py</em> 文件，运行完这两个文件后，会在你刚才创立的几个文件夹下生成一些文件，这个文件就是等会运行train.py所需要的训练文件,代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> listdir, getcwd</span><br><span class="line"><span class="keyword">from</span> os.path <span class="keyword">import</span> join</span><br><span class="line">sets = [<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;test&#x27;</span>,<span class="string">&#x27;val&#x27;</span>]</span><br><span class="line">classes = [<span class="string">&quot;reflector&quot;</span>, <span class="string">&quot;bicycle&quot;</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert</span>(<span class="params">size, box</span>):</span></span><br><span class="line">    dw = <span class="number">1.</span> / size[<span class="number">0</span>]</span><br><span class="line">    dh = <span class="number">1.</span> / size[<span class="number">1</span>]</span><br><span class="line">    x = (box[<span class="number">0</span>] + box[<span class="number">1</span>]) / <span class="number">2.0</span></span><br><span class="line">    y = (box[<span class="number">2</span>] + box[<span class="number">3</span>]) / <span class="number">2.0</span></span><br><span class="line">    w = box[<span class="number">1</span>] - box[<span class="number">0</span>]</span><br><span class="line">    h = box[<span class="number">3</span>] - box[<span class="number">2</span>]</span><br><span class="line">    x = x * dw</span><br><span class="line">    w = w * dw</span><br><span class="line">    y = y * dh</span><br><span class="line">    h = h * dh</span><br><span class="line">    <span class="keyword">return</span> (x, y, w, h)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_annotation</span>(<span class="params">image_id</span>):</span></span><br><span class="line">    in_file = <span class="built_in">open</span>(<span class="string">&#x27;data/Annotations/%s.xml&#x27;</span> % (image_id))</span><br><span class="line">    out_file = <span class="built_in">open</span>(<span class="string">&#x27;data/labels/%s.txt&#x27;</span> % (image_id), <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    tree = ET.parse(in_file)</span><br><span class="line">    root = tree.getroot()</span><br><span class="line">    size = root.find(<span class="string">&#x27;size&#x27;</span>)</span><br><span class="line">    w = <span class="built_in">int</span>(size.find(<span class="string">&#x27;width&#x27;</span>).text)</span><br><span class="line">    h = <span class="built_in">int</span>(size.find(<span class="string">&#x27;height&#x27;</span>).text)</span><br><span class="line">    <span class="keyword">for</span> obj <span class="keyword">in</span> root.<span class="built_in">iter</span>(<span class="string">&#x27;object&#x27;</span>):</span><br><span class="line">        difficult = obj.find(<span class="string">&#x27;difficult&#x27;</span>).text</span><br><span class="line">        cls = obj.find(<span class="string">&#x27;name&#x27;</span>).text</span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> classes <span class="keyword">or</span> <span class="built_in">int</span>(difficult) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        cls_id = classes.index(cls)</span><br><span class="line">        xmlbox = obj.find(<span class="string">&#x27;bndbox&#x27;</span>)</span><br><span class="line">        b = (<span class="built_in">float</span>(xmlbox.find(<span class="string">&#x27;xmin&#x27;</span>).text), <span class="built_in">float</span>(xmlbox.find(<span class="string">&#x27;xmax&#x27;</span>).text), <span class="built_in">float</span>(xmlbox.find(<span class="string">&#x27;ymin&#x27;</span>).text),</span><br><span class="line">             <span class="built_in">float</span>(xmlbox.find(<span class="string">&#x27;ymax&#x27;</span>).text))</span><br><span class="line">        bb = convert((w, h), b)</span><br><span class="line">        out_file.write(<span class="built_in">str</span>(cls_id) + <span class="string">&quot; &quot;</span> + <span class="string">&quot; &quot;</span>.join([<span class="built_in">str</span>(a) <span class="keyword">for</span> a <span class="keyword">in</span> bb]) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">wd = getcwd()</span><br><span class="line"><span class="built_in">print</span>(wd)</span><br><span class="line"><span class="keyword">for</span> image_set <span class="keyword">in</span> sets:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&#x27;data/labels/&#x27;</span>):</span><br><span class="line">        os.makedirs(<span class="string">&#x27;data/labels/&#x27;</span>)</span><br><span class="line">    image_ids = <span class="built_in">open</span>(<span class="string">&#x27;data/ImageSets/%s.txt&#x27;</span> % (image_set)).read().strip().split()</span><br><span class="line">    list_file = <span class="built_in">open</span>(<span class="string">&#x27;data/%s.txt&#x27;</span> % (image_set), <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> image_id <span class="keyword">in</span> image_ids:</span><br><span class="line">        list_file.write(<span class="string">&#x27;data/images/%s.jpg\n&#x27;</span> % (image_id))</span><br><span class="line">        convert_annotation(image_id)</span><br><span class="line">    list_file.close()</span><br></pre></td></tr></table></figure><p>在data文件夹下新建立radar.yaml,复制以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">train:</span> <span class="string">data/train.txt</span>  <span class="comment"># train images (relative to &#x27;path&#x27;) 118287 images</span></span><br><span class="line"><span class="attr">val:</span> <span class="string">data/val.txt</span>  <span class="comment"># train images (relative to &#x27;path&#x27;) 5000 images</span></span><br><span class="line"><span class="attr">test:</span> <span class="string">data/test.txt</span>  <span class="comment"># 20288 of 40670 images, submit to https://competitions.codalab.org/competitions/20794</span></span><br><span class="line"></span><br><span class="line"><span class="string">需要修改的就只有下面的Classes与names</span></span><br><span class="line"><span class="comment"># Classes</span></span><br><span class="line"><span class="attr">nc:</span> <span class="number">2</span>  <span class="comment"># number of classes   </span></span><br><span class="line"><span class="attr">names:</span> [<span class="string">&quot;reflector&quot;</span>, <span class="string">&quot;bicycle&quot;</span>]  <span class="comment"># class names</span></span><br></pre></td></tr></table></figure><p>修改models下面的yolov5n.yaml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">nc:</span> <span class="number">2</span>  <span class="comment"># number of classes # 就修改这一个文件参数即可</span></span><br></pre></td></tr></table></figure><p>修改train.py的初始化参数设置，就只用改三个地方，如下图</p><p> <img src="/articleImg/47_article/image1.png" alt="image1"></p><p>下面两个文件，也就是刚刚修改过的两个文件，第一个参数文件，在yolo官网下载即可。</p><h1 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h1><p><img src="/articleImg/47_article/image2.png" alt="image2"></p><p>配置好上面的文件，就可以运行训练了，但是前提是在你已经配置好torch和torchvision等相关环境的条件下。</p><p>从上图的训练得到的训练参数大小可以看到，总大小只有3.9M，确实十分的轻量化，这里再给出我识别角反的结果。</p><p><img src="/articleImg/47_article/image3.png" alt="image3"></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis简介</title>
      <link href="/2021/12/18/Redis%E7%AE%80%E4%BB%8B/"/>
      <url>/2021/12/18/Redis%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><h2 id="什么是redis"><a href="#什么是redis" class="headerlink" title="什么是redis"></a>什么是redis</h2><p>Redis是用C语言开发的一个开源的高性能<strong>键值对（key-value）数据库</strong>，<strong>数据是保存在内存里面的</strong></p><p>Redis支持的键值数据类型如下： </p><ul><li>字符串类型 string(最常用)</li><li>散列类型 hash  </li><li>列表类型 list</li><li>集合类型 set   </li><li>有序集合类型 sortedset</li></ul><h3 id="redis的应用场景"><a href="#redis的应用场景" class="headerlink" title="redis的应用场景"></a>redis的应用场景</h3><ul><li><strong>缓存（数据查询、短连接、新闻内容、商品内容等等）</strong></li><li><strong>任务队列。（秒杀、抢购、12306等等）</strong></li><li><strong>数据过期处理（可以精确到毫秒, 短信验证码)</strong>       </li><li><strong>分布式集群架构中的session分离  session 服务器里面</strong></li><li>聊天室的在线好友列表 </li><li>应用排行榜</li><li><strong>网站访问统计</strong></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>Redis: 由C语言编写的一种NoSQL, 以key-value存在, 数据保存在内存里面 性能特别高</li><li>Redis应用场景<ul><li>缓存(eg: 电商项目里面首页的轮播图)</li><li>队列(eg: 秒杀)</li><li>数据过期处理(eg: 短信验证码…)</li><li>分布式集群架构中的session分离</li></ul></li></ol><p> <img src="/articleImg/46_article/redis.png" alt="redis"></p>]]></content>
      
      
      <categories>
          
          <category> javaweb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jquery与Ajax比较有用的API</title>
      <link href="/2021/12/15/Jquery%E4%B8%8EAjax%E6%AF%94%E8%BE%83%E6%9C%89%E7%94%A8%E7%9A%84API/"/>
      <url>/2021/12/15/Jquery%E4%B8%8EAjax%E6%AF%94%E8%BE%83%E6%9C%89%E7%94%A8%E7%9A%84API/</url>
      
        <content type="html"><![CDATA[<h1 id="Jquery与Ajax比较有用的API"><a href="#Jquery与Ajax比较有用的API" class="headerlink" title="Jquery与Ajax比较有用的API"></a>Jquery与Ajax比较有用的API</h1><h2 id="jQuery的概述"><a href="#jQuery的概述" class="headerlink" title="jQuery的概述"></a>jQuery的概述</h2><p>​    说白了: JQ就是js库, 封装了JS常见的操作,我们使用JS起来更加的简单  (特别是dom这块)</p><h2 id="jQuery的作用"><a href="#jQuery的作用" class="headerlink" title="jQuery的作用"></a>jQuery的作用</h2><p>​    jQuery最主要的作用是简化js的Dom树的操作 </p><h2 id="需要记忆的语法"><a href="#需要记忆的语法" class="headerlink" title="需要记忆的语法"></a>需要记忆的语法</h2><ul><li>JS对象转成jQ对象  ： $(js对象)</li><li>JQ对象转成JS对象  ： JQ对象[下标] 或者 JQ对象.get(下标) 下标一般写0</li><li>基本选择器</li></ul><table><thead><tr><th>选择器名称</th><th>语法</th><th>解释</th></tr></thead><tbody><tr><td>标签选择器（元素选择器）</td><td>$(“html标签名”)</td><td>获得所有匹配标签名称的于元素</td></tr><tr><td>id选择器</td><td>$(“#id的属性值”)</td><td>获得与指定id属性值匹配的元素</td></tr><tr><td>类选择器</td><td>$(“.class的属性值”)</td><td>获得与指定的class属性值匹配的元素</td></tr></tbody></table><ul><li>JQ操作样式</li></ul><table><thead><tr><th>API方法</th><th align="left">解释</th></tr></thead><tbody><tr><td>css(name) 使用很少</td><td align="left">获取CSS样式</td></tr><tr><td>css(name,value)</td><td align="left">设置CSS样式</td></tr><tr><td>addClass(类名)</td><td align="left">给标签添加类名</td></tr><tr><td>removeClass(类名)</td><td align="left">删除标签的类名</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">//目标: 鼠标移入输入框的时候，设置输入框的背景色为红色，移出输入框的时候设置输入框的背景色为蓝色</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 获取标签的css样式的方法: css(样式名) 用的很少</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 设置标签的css样式的方法: css(样式名,样式值),该方法其实就是改变了标签的行内样式</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//$(&quot;#ipt&quot;).css(&quot;background-color&quot;,&quot;red&quot;)</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="comment">//给输入框标签添加类名为&quot;redStyle&quot;</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// addClass(类名)添加类名</span></span></span><br><span class="line"><span class="javascript">            $(<span class="string">&quot;#ipt&quot;</span>).addClass(<span class="string">&quot;redStyle&quot;</span>)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 移除blueStyle类名</span></span></span><br><span class="line"><span class="javascript">            $(<span class="string">&quot;#ipt&quot;</span>).removeClass(<span class="string">&quot;blueStyle&quot;</span>)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//$(&quot;#ipt&quot;).css(&quot;background-color&quot;,&quot;blue&quot;)</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="comment">//给输入框标签添加类名为&quot;blueStyle&quot;</span></span></span><br><span class="line"><span class="javascript">            $(<span class="string">&quot;#ipt&quot;</span>).addClass(<span class="string">&quot;blueStyle&quot;</span>)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="comment">//移除redStyle类名</span></span></span><br><span class="line"><span class="javascript">            $(<span class="string">&quot;#ipt&quot;</span>).removeClass(<span class="string">&quot;redStyle&quot;</span>)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>使用JQ操作DOM</p><table><thead><tr><th>API方法</th><th>解释</th></tr></thead><tbody><tr><td>val([value])</td><td>获得/设置标签里面value属性相应的值</td></tr><tr><td>text([value])</td><td>获得/设置元素的文本内容</td></tr><tr><td>html([value])</td><td>获得/设置元素的标签体内容</td></tr></tbody></table></li><li><p>JQ中事件的使用</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jq对象.事件方法名(function()&#123;&#125;);</span><br><span class="line"></span><br><span class="line">eg:点击事件</span><br><span class="line">btn.click(function()&#123;&#125;);</span><br></pre></td></tr></table></figure><ul><li>JQ遍历</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jquery对象.each(function(index,element)&#123;&#125;);</span><br><span class="line"></span><br><span class="line">其中:(参数名字随便取的)</span><br><span class="line">index:就是元素在集合中的索引</span><br><span class="line">element：就是集合中的每一个元素对象</span><br></pre></td></tr></table></figure><ul><li>jquery的全局方法遍历</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$.each(jquery对象,function(index,element)&#123;&#125;);</span><br><span class="line"></span><br><span class="line">其中，</span><br><span class="line">index:就是元素在集合中的索引</span><br><span class="line">element：就是集合中的每一个元素对象</span><br></pre></td></tr></table></figure><p>详细见：<a href="http://www.jquery.com/">http://www.jquery.com</a></p><h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><p>解释 ：   AJax是可以做异步的请求,实现局部刷新一种客户端技术 。 注意关键词 异步~</p><h2 id="JQ的AJAX介绍"><a href="#JQ的AJAX介绍" class="headerlink" title="JQ的AJAX介绍"></a>JQ的AJAX介绍</h2><h4 id="JQuery的Ajax的API"><a href="#JQuery的Ajax的API" class="headerlink" title="JQuery的Ajax的API"></a>JQuery的Ajax的API</h4><table><thead><tr><th>请求方式</th><th>语法</th></tr></thead><tbody><tr><td><strong>GET请求</strong></td><td>$.get(url, <em>[data]</em>, <em>[callback]</em>, <em>[type]</em>)</td></tr><tr><td><strong>POST请求</strong></td><td>$.post(url, <em>[data]</em>, <em>[callback]</em>, <em>[type]</em>)</td></tr><tr><td><strong>AJAX请求</strong></td><td>$.ajax([settings])</td></tr></tbody></table><h4 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h4><ul><li><p>get方式,  语法    <code>$.get(url, [data], [callback], [type]);</code></p><table><thead><tr><th>参数名称</th><th>解释</th></tr></thead><tbody><tr><td>url</td><td>请求的服务器端url地址</td></tr><tr><td>data</td><td>发送给服务器端的请求参数，格式是key=value；get请求的参数可以直接写在url后面</td></tr><tr><td>callback</td><td>当请求成功后的回掉函数，可以在函数体中编写我们的逻辑代码</td></tr><tr><td>type</td><td>预期的返回数据的类型(默认为text)，取值可以是 xml, html, script, json, text, _defaul等   (最常用json)</td></tr></tbody></table></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个方法使用jQuery的ajax发送异步的get请求</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $.get(<span class="string">&quot;/demo01?username=tom&quot;</span>,<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//在这个回调函数中处理响应数据result</span></span><br><span class="line">        <span class="comment">//将响应数据展示在id为msg的div中</span></span><br><span class="line">        $(<span class="string">&quot;#msg&quot;</span>).html(result)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="post"><a href="#post" class="headerlink" title="post()"></a>post()</h4><ul><li>post方式, 语法 <code>$.post(url, [data], [callback], [type])</code></li></ul><table><thead><tr><th>参数名称</th><th>解释</th></tr></thead><tbody><tr><td>url</td><td>请求的服务器端url地址</td></tr><tr><td>data</td><td>发送给服务器端的请求参数，格式是key=value</td></tr><tr><td>callback</td><td>当请求成功后的回掉函数，可以在函数体中编写我们的逻辑代码</td></tr><tr><td>type</td><td>预期的返回数据的类型(默认为text)，取值可以是 xml, html, script, json, text, _defaul等  (最常用json)</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个方法使用jQuery的ajax方法发送异步请求</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn5</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        <span class="attr">url</span>:<span class="string">&quot;/demo01&quot;</span>, <span class="comment">//请求路径</span></span><br><span class="line">        <span class="attr">data</span>:<span class="string">&quot;username=lucy&quot;</span>, <span class="comment">//请求参数</span></span><br><span class="line">        <span class="attr">type</span>:<span class="string">&quot;POST&quot;</span>, <span class="comment">//请求方式</span></span><br><span class="line">        <span class="attr">success</span>:<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">            $(<span class="string">&quot;#msg&quot;</span>).html(result)</span><br><span class="line">        &#125;, <span class="comment">//请求成功时候的回调函数</span></span><br><span class="line">        <span class="attr">error</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            $(<span class="string">&quot;#msg&quot;</span>).html(<span class="string">&quot;服务器异常&quot;</span>)</span><br><span class="line">        &#125; <span class="comment">//请求失败时候的回调函数</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用Ajax之后，服务器端的代码一般的写法"><a href="#使用Ajax之后，服务器端的代码一般的写法" class="headerlink" title="使用Ajax之后，服务器端的代码一般的写法"></a>使用Ajax之后，服务器端的代码一般的写法</h2><p> <img src="/articleImg/45_article/mycode.png" alt="mycode"></p><p>自己学后端起步有点晚了，不过我相信，兴趣决定高度，努力决定程度，加油吧~摩托！</p>]]></content>
      
      
      <categories>
          
          <category> javaweb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsp提交form表单到servlet，但取值全为空？</title>
      <link href="/2021/12/15/jsp%E6%8F%90%E4%BA%A4form%E8%A1%A8%E5%8D%95%E5%88%B0servlet%EF%BC%8C%E4%BD%86%E5%8F%96%E5%80%BC%E5%85%A8%E4%B8%BA%E7%A9%BA%EF%BC%9F/"/>
      <url>/2021/12/15/jsp%E6%8F%90%E4%BA%A4form%E8%A1%A8%E5%8D%95%E5%88%B0servlet%EF%BC%8C%E4%BD%86%E5%8F%96%E5%80%BC%E5%85%A8%E4%B8%BA%E7%A9%BA%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="jsp提交form表单到servlet，但取值全为空？"><a href="#jsp提交form表单到servlet，但取值全为空？" class="headerlink" title="jsp提交form表单到servlet，但取值全为空？"></a>jsp提交form表单到servlet，但取值全为空？</h1><p>1.检查你的jsp页面</p><p>（1）当你提交表单到servlet时，当要获取表单的值是，request.getParameter(“（form表单中的name属性的值）”) 所以form表单提交的数据都用控件的name而不是id来控制的，浏览器会根据name来设定发送到服务器的request。因此如果用id，服务器是无 法得到数据的。 所以你需要检查你的form表单中是否忘记写name属性了？</p><p>3.检查jsp跳转到servlet的过程</p><p>jsp提交的方式是post，但是我却在doGet(HttpServletRequest request, HttpServletResponse response)里写代码 doPost方法里啥都没有 数据怎么可能会过去呢？所以粗心呀</p><p>有两种方法可以解决：</p><ul><li>把doGet方法里面的代码放在doPost里就可以了</li><li>也可以在doGet方法里写代码 但是需要在doPost方法里加一句代码：doGet(request, response);</li></ul><p> <img src="/articleImg/44_article/mecode.png" alt="mecode"></p>]]></content>
      
      
      <categories>
          
          <category> javaweb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JetsonNano配置IntelD455深度相机</title>
      <link href="/2021/11/21/JetsonNano%E9%85%8D%E7%BD%AEIntelD455%E6%B7%B1%E5%BA%A6%E7%9B%B8%E6%9C%BA/"/>
      <url>/2021/11/21/JetsonNano%E9%85%8D%E7%BD%AEIntelD455%E6%B7%B1%E5%BA%A6%E7%9B%B8%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Jetson-Nano配置Intel-D455深度相机"><a href="#Jetson-Nano配置Intel-D455深度相机" class="headerlink" title="Jetson Nano配置Intel D455深度相机"></a>Jetson Nano配置Intel D455深度相机</h1><p>首先我要说明为什么这么耽误时间，4天…</p><p>第一：git clone很慢 （后续已被解决）</p><p>第二：安装失败时，我就重装了NANO的镜像，担心旧文件会对下一次的重新编译产生影响</p><p>第三：编译的速度很慢，每次编译结束都需要两个钟左右！</p><p>第四：自己尝试很多其他方案，最终才works! </p><p>费了老鼻子劲了，才把这这东西配置好，嵌入式工程师不好当啊~</p><p>贴出Nvidia官网的安装指导，我安装官网的方式1，即按包去安装，试了几次，每次都不行，UI界面都出来了，但是就是连接不上D455相机。俺也不知道这是为啥，有可能是D455是一款较新的产品吧，相对于D435。（最后得解，源码编译大法解决问题）</p><p> <img src="/articleImg/43_article/meStereo.gif" alt="meStereo"></p><h2 id="在源码编译的过程中，会遇到git-clone相关包，git不下来的现象（先进行这一步！）"><a href="#在源码编译的过程中，会遇到git-clone相关包，git不下来的现象（先进行这一步！）" class="headerlink" title="在源码编译的过程中，会遇到git clone相关包，git不下来的现象（先进行这一步！）"></a>在源码编译的过程中，会遇到git clone相关包，git不下来的现象（先进行这一步！）</h2><p>自己尝试ssr(shadowsocks)与proxychains为nano开代理去git clone，无奈失败，不知道问题出在哪里，后续有时间了可以再排查一下。时间紧任务重，不能死磕！</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>直接在windows上git cone，把这两个包都放到build文件夹下的third-party文件夹下<strong>（尤其注意文件根目录下也有一个thirty-party文件夹，不要放错了）</strong>。然后再把源码cmakelist中的git  clone都注释掉。</p><p>**pybind11 **：git clone <a href="https://github.com/pybind/pybind11.git">https://github.com/pybind/pybind11.git</a></p><p>注释掉 ~/librealsense/third-party文件夹下的pybind11中cmakelist中的git clone <a href="https://github.com/pybind/pybind11.git">https://github.com/pybind/pybind11.git</a></p><p><strong>libcurl</strong>:<a href="https://github.com/curl/curl"> https://github.com/curl/curl </a></p><p>注释掉 ~/librealsense/CMake 文件下的 external_libcurl.cmake 的 GIT_REPOSITORY “git://github.com/curl/curl.git” 。</p><p>并将提前下载后的 curl.zip 解压后 改名为 <strong>libcurl</strong> ，放入到 ~/librealsense/build/third-party。</p><h2 id="尝试源码编译"><a href="#尝试源码编译" class="headerlink" title="尝试源码编译"></a>尝试源码编译</h2><p>经历了按包安装的失败之后，自己便乖乖的去源码编译了。</p><p>源码地址：<a href="https://github.com/JetsonHacksNano/installLibrealsense">https://github.com/JetsonHacksNano/installLibrealsense</a>  直接下载zip即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>:运行udev脚本</span><br><span class="line">    cd librealsense</span><br><span class="line">    ./scripts/setup_udev_rules.sh</span><br><span class="line">    echo <span class="string">&#x27;hid_sensor_custom&#x27;</span> | sudo tee -a /etc/modules</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>：添加环境变量，也可直接添加到bashrc</span><br><span class="line">    export CUDA_HOME=/usr/local/cuda-<span class="number">10.2</span></span><br><span class="line">    export LD_LIBRARY_PATH=/usr/local/cuda-<span class="number">10.2</span>/lib64:$LD_LIBRARY_PATH</span><br><span class="line">    export PATH=/usr/local/cuda-<span class="number">10.2</span>/<span class="built_in">bin</span>:$PATH</span><br><span class="line">        </span><br><span class="line">    source一下</span><br><span class="line">    </span><br><span class="line"><span class="number">3</span>:编译</span><br><span class="line">    mkdir build</span><br><span class="line">    </span><br><span class="line">    cd build</span><br><span class="line">    </span><br><span class="line">    cmake ../ -DBUILD_PYTHON_BINDINGS:<span class="built_in">bool</span>=true -DPYTHON_EXECUTABLE=/home/bingda/archiconda3/envs/py36/<span class="built_in">bin</span>/python -DBUILD_WITH_CUDA=true  （注意我这里用的python环境是Archiconda中envs的py36）</span><br><span class="line">    </span><br><span class="line">    sudo make uninstall &amp;&amp; make clean</span><br><span class="line">    make -j4   <span class="comment">#多核make的时候会报错，可选择直接单核$make 这里尝试 j2</span></span><br><span class="line">    sudo make install</span><br><span class="line">    </span><br><span class="line"><span class="number">4</span>：添加环境变量 vim ~/.bashrc</span><br><span class="line">export PYTHONPATH=$PYTHONPATH:/usr/local/lib:/usr/local/lib/python3<span class="number">.6</span>/pyrealsense2</span><br></pre></td></tr></table></figure><p>验证是否编译成功：终端运行 realsense-viewer 即有相关的UI界面展示出来。</p><h2 id="源码编译之后，会发现在python环境下无法使用pyrealsense2包"><a href="#源码编译之后，会发现在python环境下无法使用pyrealsense2包" class="headerlink" title="源码编译之后，会发现在python环境下无法使用pyrealsense2包"></a>源码编译之后，会发现在python环境下无法使用pyrealsense2包</h2><p>这个问题也困扰了我一天，这里一共要进行两步解决：</p><p>第一： 在python文件下添加 该句代码，因为pyrealsense2包在该路径下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sys.path.append(&#x27;/usr/local/lib/python3.6/&#x27;)</span><br></pre></td></tr></table></figure><p>经过该步之后，发现可以import pyrealsense2 包了，但是其中的相关API功能均无法使用。</p><p>第二：将下述的三个.so文件，copy到python代码所在的路径（路径，文件名会随着你的环境可能不太一样）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib/python3.6/pyrealsense2/pyrealsense2.cpython-36m-aarch64-linux-gnu.so</span><br><span class="line">/usr/lib/python3.6/pyrealsense2/pyrealsense2.cpython-36m-aarch64-linux-gnu.so.2.49</span><br><span class="line">/usr/lib/python3.6/pyrealsense2/pyrealsense2.cpython-36m-aarch64-linux-gnu.so.2.49.0</span><br></pre></td></tr></table></figure><p>经过上述的两不，便可以正常使用pyrealsense2包的相关功能了~</p><p>终于大功告成！！！！！！！！很多问题也都是靠自己尝试得出的解决方案，在网络上没有百分百切合我问题的答案，所以还是蛮有成就感的~</p>]]></content>
      
      
      <categories>
          
          <category> JetsonNano </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Intel D455 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JetsonNano重装系统</title>
      <link href="/2021/11/21/JetsonNano%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/"/>
      <url>/2021/11/21/JetsonNano%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="Jetson-Nano-重装系统"><a href="#Jetson-Nano-重装系统" class="headerlink" title="Jetson Nano 重装系统"></a>Jetson Nano 重装系统</h1><p>最近在装intel的D455相机到jetson nano，是用的SD卡装系统的。当nano中的ubuntu系统环境被我装乱时，<br>我就想重新装系统，所以遇到需要重新格式化的问题。遇到的问题与下图：</p><p><img src="/articleImg/42_article/U%E7%9B%98.png" alt="U盘"></p><p>根本格式化不过来，只能通过终端操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cmd命令行，依次如下命令：</span><br><span class="line"></span><br><span class="line">diskpart</span><br><span class="line"></span><br><span class="line">list disk</span><br><span class="line"></span><br><span class="line">select disk 2*#一定要选对硬盘设备，要不然....* </span><br><span class="line"></span><br><span class="line">clean</span><br></pre></td></tr></table></figure><p>格式化SD卡之后可以通过，此电脑–管理—磁盘管理  进行对SD卡的从新分配磁盘空间。</p><p>ok~</p>]]></content>
      
      
      <categories>
          
          <category> JetsonNano </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 格式化SD卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以nano为载体的Ubuntu系统的各种下载源配置</title>
      <link href="/2021/11/21/%E4%BB%A5nano%E4%B8%BA%E8%BD%BD%E4%BD%93%E7%9A%84Ubuntu%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%84%E7%A7%8D%E4%B8%8B%E8%BD%BD%E6%BA%90%E9%85%8D%E7%BD%AE/"/>
      <url>/2021/11/21/%E4%BB%A5nano%E4%B8%BA%E8%BD%BD%E4%BD%93%E7%9A%84Ubuntu%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%84%E7%A7%8D%E4%B8%8B%E8%BD%BD%E6%BA%90%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="以nano为载体的Ubuntu系统的各种下载源配置"><a href="#以nano为载体的Ubuntu系统的各种下载源配置" class="headerlink" title="以nano为载体的Ubuntu系统的各种下载源配置"></a>以nano为载体的Ubuntu系统的各种下载源配置</h1><h2 id="安装Archiconda3"><a href="#安装Archiconda3" class="headerlink" title="安装Archiconda3"></a>安装Archiconda3</h2><p>下载地址：<a href="https://github.com/Archiconda/build-tools">https://github.com/Archiconda/build-tools</a></p><p>到release中找对应的版本就可以了</p><h2 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit ~/.bashrc </span><br><span class="line"></span><br><span class="line">export CUDA_HOME=/usr/local/cuda-10.2</span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/cuda-10.2/lib64:$LD_LIBRARY_PATH</span><br><span class="line">export PATH=/usr/local/cuda-10.2/bin:$PATH</span><br><span class="line"></span><br><span class="line">source一下</span><br></pre></td></tr></table></figure><h2 id="启动脚本"><a href="#启动脚本" class="headerlink" title="启动脚本"></a>启动脚本</h2><p>chmod a+x  -xxx.sh<br>./Archiconda-xxx.sh</p><h2 id="再次添加环境变量"><a href="#再次添加环境变量" class="headerlink" title="再次添加环境变量"></a>再次添加环境变量</h2><p>安装conda之后如果找不见，需要添加环境变量，方法如下：</p><p>（1）：sudo gedit~/.bashrc </p><p>（2）：export PATH=~/archiconda3/bin:$PATH</p><h2 id="更换conda源"><a href="#更换conda源" class="headerlink" title="更换conda源"></a>更换conda源</h2><p>conda 换源（清华源只能用http）</p><h3 id="方式1：通过终端添加"><a href="#方式1：通过终端添加" class="headerlink" title="方式1：通过终端添加"></a>方式1：通过终端添加</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/</span><br><span class="line"></span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure><p>如果需要删除某个通道的源，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config –remove channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br></pre></td></tr></table></figure><h3 id="方式二：通过文件写入添加"><a href="#方式二：通过文件写入添加" class="headerlink" title="方式二：通过文件写入添加"></a>方式二：通过文件写入添加</h3><p>sudo gedit ~/.condarc  （实测中该种方法表现并不佳，最终采用的是方式一去添加）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">channels:</span><br><span class="line">  - defaults</span><br><span class="line">show_channel_urls: true</span><br><span class="line">default_channels:</span><br><span class="line">  - http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</span><br><span class="line">  - http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r</span><br><span class="line">  - http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2</span><br><span class="line">custom_channels:</span><br><span class="line">  conda-forge: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  msys2: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  bioconda: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  menpo: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  pytorch: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  simpleitk: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br></pre></td></tr></table></figure><h2 id="更换apt源"><a href="#更换apt源" class="headerlink" title="更换apt源"></a><strong>更换apt源</strong></h2><p>配置文件进行备份</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure><p>如果需要<strong>恢复原来的配置文件</strong>，只需要用备份的配置文件覆盖原来的配置文件即可，命令如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list.bak /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>使用gedit打开source.list文件，命令如下（ubuntu18.04）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/apt/sources.list</span><br><span class="line">粘贴如下内容</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后更软件源，完成配置apt源。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><h2 id="更换pip源"><a href="#更换pip源" class="headerlink" title="更换pip源"></a><strong>更换pip源</strong></h2><p>方法一：在用户路径下创建.pip/pip.conf文件，因为执行pip命令时，会先运行~/.pip/pip.conf文件，命令如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/.pip</span><br><span class="line">sudo gedit ~/.pip/pip.conf</span><br></pre></td></tr></table></figure><p>将下面的命令添加到pip.conf文件中，点击保存，即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = http://pypi.douban.com/simple</span><br><span class="line">trusted-host = pypi.douban.com</span><br></pre></td></tr></table></figure><p>方法二 ：在pip时指定即可 （经常使用该方法）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install 包名  -i http://pypi.mirrors.ustc.edu.cn/simple/  --trusted-host pypi.mirrors.ustc.edu.cn</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JetsonNano </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/2021/10/25/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2021/10/25/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题（即所谓的并、查）。比如说，我们可以用并查集来判断一个森林中有几棵树、某个节点是否属于某棵树等。</p><h2 id="主要构成："><a href="#主要构成：" class="headerlink" title="主要构成："></a>主要构成：</h2><p>并查集主要由一个整型数组pre[ ]和两个函数getFather( )、merge( )构成。<br>数组 pre[ ] 记录了每个点的前驱节点是谁，函数 getFather(x)（路径压缩算法）用于查找指定节点 x 属于哪个集合（即找到当前节点最终的根节点），函数 merge(x,y) 用于合并两个节点 x 和 y 。</p><h2 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h2><p>并查集的主要作用是求连通分支数（如果一个图中所有点都存在可达关系（直接或间接相连），则此图的连通分支数为1；如果此图有两大子图各自全部可达，则此图的连通分支数为2……）</p><h2 id="求犯罪团伙题目"><a href="#求犯罪团伙题目" class="headerlink" title="求犯罪团伙题目"></a>求犯罪团伙题目</h2><h2 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h2><p>现在有10个强盗。<br>1号强盗与2号强盗是同伙。3号强盗与4号强盗是同伙。</p><p>5号强盗与2号强盗是同伙。4号强盗与6号强盗是同伙。</p><p>2号强盗与6号强盗是同伙。8号强盗与7号强盗是同伙。</p><p>9号强盗与7号强盗是同伙。1号强盗与6号强盗是同伙。</p><p>2号强盗与4号强盗是同伙。</p><p>请分析一共有多少个犯罪团伙。</p><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>初始化原则：pre[ ]数组的初始化节点是其本身编号，这很重要，一定要先初始化，在进行后续的操作。</p><p>靠左原则：所给线索中，左边强盗比较强势，让右边强盗归顺左边。</p><p>擒贼先擒王原则：每次需要合并节点时，比较要找到当前节点的根节点，将两个根节点进行合并。另外，在找根的过程中要本着<strong>路径压缩</strong>的思想，即：<strong>把找父过程中，所有的中间点，包括起始点的父都设为最终找到的根节点</strong>。</p><p>路径压缩可以用递归实现，也可以用栈实现。</p><p>java的实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckandSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[]pre = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">12</span>];<span class="comment">//用1~11去表示抓获的11个嫌疑人</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][]clue = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">2</span>&#125;,&#123;<span class="number">4</span>,<span class="number">6</span>&#125;,&#123;<span class="number">2</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">11</span>&#125;,&#123;<span class="number">8</span>,<span class="number">7</span>&#125;,&#123;<span class="number">9</span>,<span class="number">7</span>&#125;,&#123;<span class="number">9</span>,<span class="number">11</span>&#125;,&#123;<span class="number">1</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CheckandSet checkandSet = <span class="keyword">new</span> CheckandSet();</span><br><span class="line">        <span class="comment">//一定要对tree矩阵进行初始化，刚开始忘记了</span></span><br><span class="line">        checkandSet.init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; checkandSet.clue.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> leftF = checkandSet.getFather2(checkandSet.clue[i][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> rightF = checkandSet.getFather2(checkandSet.clue[i][<span class="number">1</span>]);</span><br><span class="line">            checkandSet.merge(leftF,rightF);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(checkandSet.pre));</span><br><span class="line">        System.out.printf(<span class="string">&quot;由上述的结果可得，一共有%d个犯罪团伙&quot;</span>,checkandSet.getAnswer2());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//啊哈算法上的求犯罪团伙的函数为</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getAnswer2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pre.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(pre[i] == i)</span><br><span class="line">                answer++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getAnswer</span><span class="params">()</span></span>&#123; <span class="comment">//从经过并查集算法的数组中，获取一共有多少个犯罪团伙</span></span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; rootStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pre.length; i++) &#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(rootStack.isEmpty())&#123;</span><br><span class="line">                rootStack.push(pre[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> size = rootStack.size();</span><br><span class="line">                <span class="keyword">for</span> (Integer integer : rootStack) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (integer == getFather(i)) &#123;</span><br><span class="line">                        flag = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            rootStack.push(getFather(i));</span><br><span class="line">            answer++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123; <span class="comment">//将两个节点合并，遵循靠左原则</span></span><br><span class="line">        <span class="comment">//i代表左边节点  j代表右边节点</span></span><br><span class="line">        pre[j] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//啊哈算法上的求根部的父节点，在更新中间值时，我用的是栈：先记录，在更新   啊哈算法上用的是递归</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getFather2</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123; <span class="comment">//擒贼先擒王</span></span><br><span class="line">        <span class="keyword">if</span>(pre[num] == num)</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        pre[num] = getFather2(pre[num]);</span><br><span class="line">        <span class="keyword">return</span> pre[num];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getFather</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123; <span class="comment">//擒贼先擒王</span></span><br><span class="line">        Stack&lt;Integer&gt; NumStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> temp = num;</span><br><span class="line">        <span class="keyword">while</span>(pre[temp] != temp)&#123;</span><br><span class="line">            NumStack.add(temp);</span><br><span class="line">            temp = pre[temp];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把找父过程中，所有的中间点，包括起始点的父都设为最终找到的根节点</span></span><br><span class="line">        <span class="keyword">while</span>(!NumStack.isEmpty())&#123;</span><br><span class="line">            Integer pop = NumStack.pop();</span><br><span class="line">            pre[pop] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp; <span class="comment">//返回这轮找到的根父</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pre.length; i++) &#123;</span><br><span class="line">            pre[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的运行结果如下</p><p><img src="/articleImg/40_article/image1.png" alt="image1"></p><p>继续加油~</p><p>最近要准备开题了，希望自己能顺利。锦鲤附体！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集找祖先 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树--堆排序</title>
      <link href="/2021/10/25/%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>/2021/10/25/%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树–堆排序"><a href="#二叉树–堆排序" class="headerlink" title="二叉树–堆排序"></a>二叉树–堆排序</h1><p>二叉树可以用链表表示，也可以用数组去模拟。本次博客实现的算法主要是依赖数组模拟的完全二叉树，去进行堆排序。</p><h2 id="数组模拟完全二叉树的一些特点"><a href="#数组模拟完全二叉树的一些特点" class="headerlink" title="数组模拟完全二叉树的一些特点"></a>数组模拟完全二叉树的一些特点</h2><p> <img src="/articleImg/39_article/image1.png" alt="image1"></p><ul><li><p>通过上图我们发现，如果完全二叉树的一个父结点编号为k，那么它左儿子的编号就是2<em>k，右儿子的编号就是2</em>k+1。如果已知儿子（左儿子或右儿子）的编号是x，那么它父结点的编号就是x/2，注意这里只取商的整数部分。在java、C中，如果除号“”两边都是整数的话，那么商也只有整数部分（即自动向下取整)，即4/2和5/2都是2。</p></li><li><p>另外如果一棵完全二叉树有N个结点，那么这个完全二叉树的高度为logzN，简写为 log N，即最多有 log N层结点。完全二叉树的最典型应用就是——堆。</p></li><li><p>就是所有父结点都比子结点要小 (注意:圆圈里面的数是值，圆圈上面的数是这个结点的编号)。符合这样特点的完全二叉树我们称为最小堆。反之，如果所有父结点都比子结点要大，这样的完全二叉树称为最大堆。那这一特性究竟有什么用呢?下面举例一个最小堆</p></li></ul><p> <img src="/articleImg/39_article/image2.png" alt="image2"></p><h2 id="堆排序思想"><a href="#堆排序思想" class="headerlink" title="堆排序思想"></a>堆排序思想</h2><p><strong>最小堆排序</strong>：每次将根节点的元素值输出，然后将最后一个叶子节点的元素值放到根节点，然后堆节点总数减1，最后向下调整元素。</p><p> <img src="/articleImg/39_article/graph1.png" alt="graph1"></p><p><strong>最大堆排序</strong>：每次将根节点的元素值与最后一个叶子节点的元素值进行互换，然后堆节点总数减1,最后向下调整元素。流程图和最小堆的异曲同工，这里就不画流程图了。</p><h2 id="堆排序代码"><a href="#堆排序代码" class="headerlink" title="堆排序代码"></a>堆排序代码</h2><p>在最小堆排序中需要的函数有：根据数组元素创建最小堆、将节点元素值较大的向下调整位置。</p><p>在最大堆排序中需要的函数有：根据数组元素创建最小堆、将节点元素值较小的向下调整位置。</p><p>另外在创建最小最大堆时，也可以从n/2节点处，向下调整元素，因为我们从最后一个结点开始，依次判断以这个结点为根的子树是否符合最小堆的特性。如果所有的子树都符合最小堆的特性，那么整棵树就是最小堆了。<strong>注意完全二叉树有一个性质:最后一个非叶结点是第n/2个结点。</strong></p><p>相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">heapsort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] binaryTree = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>; <span class="comment">//表示二叉树中的节点个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            heapsort Heapsort = <span class="keyword">new</span> heapsort();</span><br><span class="line">            Heapsort.binaryTree = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,<span class="number">23</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">17</span>,<span class="number">25</span>,<span class="number">19</span>,<span class="number">36</span>,<span class="number">99</span>,<span class="number">22</span>,<span class="number">28</span>,<span class="number">46</span>,<span class="number">92</span>&#125;; <span class="comment">//注意binaryTree是从下表1开始保存数据的，切记这里面有一个-1</span></span><br><span class="line">            Heapsort.num = <span class="number">14</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;排序之前：&quot;</span>+Arrays.toString(Heapsort.binaryTree));</span><br><span class="line">            Heapsort.heapsortFun(Heapsort.binaryTree,Heapsort.num);<span class="comment">//利用最小堆排序</span></span><br><span class="line">            <span class="comment">//Heapsort.heapsortFun2(Heapsort.binaryTree,Heapsort.num); //利用最大堆排序</span></span><br><span class="line">            System.out.println(<span class="string">&quot;排序之后：&quot;</span>+Arrays.toString(Heapsort.binaryTree));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapsortFun2</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> nodeNum)</span></span>&#123; <span class="comment">//堆排序函数，最大堆排序</span></span><br><span class="line">            <span class="keyword">this</span>.BuildMaximumHeap(arr,nodeNum);</span><br><span class="line">            System.out.println(<span class="string">&quot;最大堆：&quot;</span>+Arrays.toString(arr));</span><br><span class="line">            <span class="keyword">int</span> copyNodeNum = nodeNum;</span><br><span class="line">            <span class="keyword">while</span>(copyNodeNum&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.swap(<span class="number">1</span>,copyNodeNum,arr);</span><br><span class="line">                copyNodeNum--; <span class="comment">//先减，因为最后一个叶子节点上的数就是我们想要的排序数，不动它</span></span><br><span class="line">                <span class="keyword">this</span>.siftDownMax(<span class="number">1</span>,arr,copyNodeNum); <span class="comment">//再调整</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapsortFun</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> nodeNum)</span></span>&#123; <span class="comment">//堆排序函数，最小堆排序</span></span><br><span class="line">        <span class="comment">//主要思想：可以先建立最小堆，然后每次删除顶部元素并将顶部元素输出或者放入一个新的数组中，直到堆为空为止。</span></span><br><span class="line">        <span class="comment">// 最终输出的或者存放在新数组中的数就已经是排序好的了。</span></span><br><span class="line">        <span class="keyword">this</span>.BuildMinimumHeap2(); <span class="comment">//将此时的二叉树，转化为最小堆</span></span><br><span class="line">        <span class="keyword">int</span>[] CopyBinaryTree = <span class="keyword">new</span> <span class="keyword">int</span>[nodeNum+<span class="number">1</span>]; <span class="comment">//copy一下最小堆，不然最后转化，会破环原最小堆</span></span><br><span class="line">        System.arraycopy(arr, <span class="number">0</span>, CopyBinaryTree, <span class="number">0</span>, CopyBinaryTree.length);</span><br><span class="line">        System.out.println(<span class="string">&quot;最小堆：&quot;</span>+Arrays.toString(arr));</span><br><span class="line">        <span class="keyword">int</span> copyNum = nodeNum;</span><br><span class="line">        <span class="keyword">while</span>(copyNum&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//System.out.print(CopyBinaryTree[1]+&quot; &quot;);</span></span><br><span class="line">            CopyBinaryTree[<span class="number">1</span>] = CopyBinaryTree[copyNum];</span><br><span class="line">            copyNum--;</span><br><span class="line">            <span class="keyword">this</span>.siftDownMin(<span class="number">1</span>,CopyBinaryTree,copyNum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BuildMaximumHeap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> NodeNum)</span></span>&#123; <span class="comment">//建立最大堆</span></span><br><span class="line">        <span class="comment">//这里也是有两种建立方式，1：边插入元素，边调整元素 2：等元素全部插入完毕，调整节点即可。</span></span><br><span class="line">        <span class="comment">//这里选择第二种方式</span></span><br><span class="line">        <span class="keyword">int</span> copyNum = NodeNum;</span><br><span class="line">        <span class="keyword">while</span>(copyNum&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">            siftUpMax(copyNum,arr);</span><br><span class="line">            copyNum--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BuildMinimumHeap</span><span class="params">()</span></span>&#123; <span class="comment">//建立最小堆</span></span><br><span class="line">        <span class="comment">//每次将元素插入二叉树的末端，然后再把该元素向上调整即可</span></span><br><span class="line">        <span class="keyword">int</span> []standByArray = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">99</span>,<span class="number">5</span>,<span class="number">36</span>,<span class="number">7</span>,<span class="number">22</span>,<span class="number">17</span>,<span class="number">92</span>,<span class="number">12</span>,<span class="number">2</span>,<span class="number">19</span>,<span class="number">25</span>,<span class="number">28</span>,<span class="number">1</span>,<span class="number">46</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; standByArray.length; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.binaryTree[i+<span class="number">1</span>] = standByArray[i];</span><br><span class="line">            <span class="keyword">this</span>.siftUpMin(i+<span class="number">1</span>,<span class="keyword">this</span>.binaryTree);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BuildMinimumHeap2</span><span class="params">()</span></span>&#123; <span class="comment">//建立最小堆</span></span><br><span class="line">        <span class="comment">//我们从最后一个非叶子结点开始，依次判断以这个结点为根的子树是否符合最小堆的特性。</span></span><br><span class="line">        <span class="comment">// 如果所有的子树都符合最小堆的特性，那么整棵树就是最小堆了。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = num/<span class="number">2</span>; i &gt;=<span class="number">1</span> ; i--) &#123;</span><br><span class="line">            siftDownMin(i,binaryTree,<span class="keyword">this</span>.num); <span class="comment">//将binaryTree从num/2节点处开始调整</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最小堆,将上面较大的节点向下调整</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownMin</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span>[]arr,<span class="keyword">int</span> curNum)</span></span>&#123; <span class="comment">//传入一个需要向下调整的节点编号i，最小堆的节点个数，,以及对应的模拟二叉树</span></span><br><span class="line">        <span class="keyword">int</span> temp = i;</span><br><span class="line">        <span class="comment">//注意这里的num可能会变</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">2</span>*i&lt;=curNum)&#123; <span class="comment">//注意binaryTree是从下表1开始保存数据的，所以这里带等于</span></span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;arr[<span class="number">2</span>*i])&#123;</span><br><span class="line">                temp = <span class="number">2</span>*i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">2</span>*i+<span class="number">1</span>&lt;=curNum)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[temp]&gt;arr[<span class="number">2</span>*i+<span class="number">1</span>])</span><br><span class="line">                     temp = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp == i)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">this</span>.swap(i,temp,arr);</span><br><span class="line">            i = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大堆,将上面较小的节点向下调整</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownMax</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span>[]arr,<span class="keyword">int</span> curNum)</span></span>&#123; <span class="comment">//传入一个需要向下调整的节点编号i，最小堆的节点个数，,以及对应的模拟二叉树</span></span><br><span class="line">        <span class="keyword">int</span> temp = i;</span><br><span class="line">        <span class="comment">//注意这里的num可能会变</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">2</span>*i&lt;=curNum)&#123; <span class="comment">//注意binaryTree是从下表1开始保存数据的，所以这里带等于</span></span><br><span class="line">            <span class="keyword">if</span>(arr[i]&lt;arr[<span class="number">2</span>*i])&#123;</span><br><span class="line">                temp = <span class="number">2</span>*i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">2</span>*i+<span class="number">1</span>&lt;=curNum)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[temp]&lt;arr[<span class="number">2</span>*i+<span class="number">1</span>])</span><br><span class="line">                    temp = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp == i)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">this</span>.swap(i,temp,arr);</span><br><span class="line">            i = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最小堆,将下面较小的节点向上调整</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpMin</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span>[] arr)</span></span>&#123; <span class="comment">//传入一个需要向上调整的节点编号，,以及对应的模拟二叉树</span></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            temp = i;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt; arr[i/<span class="number">2</span>])&#123;</span><br><span class="line">                swap(i,i/<span class="number">2</span>,arr);</span><br><span class="line">                i = i/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp == i)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大堆,将下面较大的节点向上调整</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpMax</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span>[] arr)</span></span>&#123; <span class="comment">//传入一个需要向上调整的节点编号，,以及对应的模拟二叉树</span></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            temp = i;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[i/<span class="number">2</span>])&#123;</span><br><span class="line">                swap(i,i/<span class="number">2</span>,arr);</span><br><span class="line">                i = i/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp == i)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j,<span class="keyword">int</span> []arr)</span></span>&#123; <span class="comment">//交换binaryTree中 i 位置 和j 位置的元素,以及对应的模拟二叉树</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面程序的注释也写得蛮清楚的，最重要的还是要理解算法的思想。</p><p>继续加油吧~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图最短路径--贝尔曼福特算法Bellman-Ford</title>
      <link href="/2021/10/25/%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-%E8%B4%9D%E5%B0%94%E6%9B%BC%E7%A6%8F%E7%89%B9%E7%AE%97%E6%B3%95Bellman-Ford/"/>
      <url>/2021/10/25/%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-%E8%B4%9D%E5%B0%94%E6%9B%BC%E7%A6%8F%E7%89%B9%E7%AE%97%E6%B3%95Bellman-Ford/</url>
      
        <content type="html"><![CDATA[<h1 id="图最短路径–贝尔曼福特算法Bellman-Ford"><a href="#图最短路径–贝尔曼福特算法Bellman-Ford" class="headerlink" title="图最短路径–贝尔曼福特算法Bellman-Ford"></a>图最短路径–贝尔曼福特算法Bellman-Ford</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近几天学习算法的状态一般是晚上看算法思想，第二天上午或则下午自己动手实现算法，之后与算法书上的代码进行对比，学习别人优秀简洁的思路，然后整理到博客上。我感觉这样的学习效果还可以。因为这样的话，同一个算法我可以在不同的时间进行回顾。加深了印象~ 在对比代码的时候，确实发现了很多别人优秀的代码，让自己蠢蠢欲动，想要把那种思想吸收到自己身上！这也许就是代码之美吧哈哈哈，来自1024节的快乐~~</p><p>下面我对今天的博客内容进行记录备忘</p><p>对了，最近学习的是《啊哈算法》里面的内容，所以大部分实现的算法都是里面的。</p><h2 id="贝尔曼福特算法思想介绍"><a href="#贝尔曼福特算法思想介绍" class="headerlink" title="贝尔曼福特算法思想介绍"></a>贝尔曼福特算法思想介绍</h2><ul><li><p>Dijkstra算法虽然好，但是它不能解决带有负权边(边的权值为负数)的图。Bellman-Ford算法非常简单，核心代码只有4行，并且可以完美地解决带有负权边的图。</p></li><li><p>贝尔曼福特算法中图的表示用的是邻接表。</p></li></ul><p>核心代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (k=<span class="number">1</span>;k&lt;=n-<span class="number">1</span>;k++) <span class="comment">//只需要进行n-1轮就可以了。因为在一个含有n个顶点的图中，任意两点之间的最短路径最多包含n-1边。</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++) <span class="comment">//m代表边的个数，即枚举每一条边</span></span><br><span class="line"><span class="keyword">if</span>(dis[v[i]] &gt;dis[u[i]] + w[i])</span><br><span class="line">dis[v[i]] = dis [u[i]]+w[i];</span><br><span class="line"><span class="comment">//其中余u、v和w三个数组是用来记录边的信息。例如第i条边存储在u[i]、v[i]和 w[i]中，表示从顶点u[i]到顶点[i]这条边上u[i]到v[i]权值为w[i]。</span></span><br></pre></td></tr></table></figure><ul><li>上面条件判断的两行代码意思是:看看能否通过u[i]→v[ i ] (权值为w[i]）这条边，使得1号顶点到v[i]号顶点的距离变短。即1号顶点到u[i]号顶点的距离（dis[u[i]]）加上u[i]→v[i]这条边（权值为w[i])的值是否会比原先1号顶点到v[i]号顶点的距离(dis[v[i]]）要小。<strong>这一点其实与Dijkstra的“松弛”操作是一样的</strong>。现在我们要把所有的边都松弛一遍，上述的代码是进行了n-1轮松弛操作。</li></ul><h2 id="算法图解"><a href="#算法图解" class="headerlink" title="算法图解"></a>算法图解</h2><p> <img src="/articleImg/38_article/image1.jpg" alt="image1"></p><p>Bellman-Ford算法经常会在未达到n-1轮松弛前就已经计算出最短路，因为n-1其实是最大值。因此可以添加一个一维数组用来备份数组dis。如果在新一轮的松弛中数组dis没有发生变化，则可以提前跳出循环。</p><h2 id="未使用队列优化的代码"><a href="#未使用队列优化的代码" class="headerlink" title="未使用队列优化的代码"></a>未使用队列优化的代码</h2><p>用java实现的算法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//贝尔曼福特算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BellmanFord</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> []first = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>]; <span class="comment">//代表第i个节点的第一条出边</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> []next = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>]; <span class="comment">//代表第j条边的下一条出边, 切记这里的出边仍然是属于第i个节点的出边</span></span><br><span class="line">    <span class="comment">//初始化五个节点，五条边</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] u=&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] v=&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] w=&#123;<span class="number">2</span>,-<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span>[]cost = &#123;<span class="number">0</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>&#125;;<span class="comment">//初始化节点1，到其他节点的最短路径，999模拟无穷大</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BellmanFord bellmanFord = <span class="keyword">new</span> BellmanFord();</span><br><span class="line">        bellmanFord.first = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        bellmanFord.next = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        bellmanFord.bellmanford(<span class="number">5</span>,<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//bellmanFord.bellmanfordQueue(); //使用队列优化贝尔曼福特算法</span></span><br><span class="line">        System.out.println(Arrays.toString(bellmanFord.cost));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bellmanford</span><span class="params">(<span class="keyword">int</span> nodeCount,<span class="keyword">int</span> sideCount)</span></span>&#123; <span class="comment">//未使用队列优化算法</span></span><br><span class="line">        <span class="comment">//可以设立一个标志位，当最小代价数据数值不发生改变的时候，便可以结束整个松弛操作</span></span><br><span class="line">        <span class="keyword">boolean</span> check = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">//用来检测在n-1轮松弛之后，在进行一次松弛操作，来判断是否含有负权回路（判断依据：第n轮松弛是否发生路径代价更新）</span></span><br><span class="line">        <span class="comment">//对每个结点进行n-1轮的松弛，每一轮需要将每一条边都尝试一次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; nodeCount - <span class="number">1</span>; k++) &#123; <span class="comment">//核心算法在这里</span></span><br><span class="line">            check = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sideCount; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.cost[<span class="keyword">this</span>.v[i]-<span class="number">1</span>]&gt;<span class="keyword">this</span>.cost[<span class="keyword">this</span>.u[i]-<span class="number">1</span>]+<span class="keyword">this</span>.w[i] &amp;&amp; <span class="keyword">this</span>.cost[<span class="keyword">this</span>.u[i]-<span class="number">1</span>] != <span class="number">999</span>)&#123;  <span class="comment">//注意这里数组下表是从0开始的，而节点个数是从1开始的，所以需要减1</span></span><br><span class="line">                    <span class="keyword">this</span>.cost[<span class="keyword">this</span>.v[i]-<span class="number">1</span>] = <span class="keyword">this</span>.cost[<span class="keyword">this</span>.u[i]-<span class="number">1</span>]+<span class="keyword">this</span>.w[i];</span><br><span class="line">                    check = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!check)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sideCount; i++) &#123; <span class="comment">//进行第n轮松弛操作，若发生参数更新则说明有负权回路</span></span><br><span class="line">            <span class="keyword">if</span>(cost[<span class="keyword">this</span>.v[i]-<span class="number">1</span>]&gt;cost[<span class="keyword">this</span>.u[i]-<span class="number">1</span>]+w[i] &amp;&amp; cost[<span class="keyword">this</span>.u[i]-<span class="number">1</span>] != <span class="number">999</span>)&#123;  <span class="comment">//注意这里数组下表是从0开始的，而节点个数是从1开始的，所以需要减1</span></span><br><span class="line">                <span class="keyword">this</span>.cost[v[i]-<span class="number">1</span>] = cost[<span class="keyword">this</span>.u[i]-<span class="number">1</span>]+w[i]; <span class="comment">// 因为cost的维度是[5],节点个数是5，first,next数组的维度是[6],从下标1开始，到下标5为止，表示1~5个节点</span></span><br><span class="line">                <span class="comment">//所以这里有减1的操作，如果cost数组维度也是[6],并从1下标开始计数，则可以避免减1的操作</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            System.out.println(<span class="string">&quot;此图中含有负权回路~~~&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用队列优化算法"><a href="#使用队列优化算法" class="headerlink" title="使用队列优化算法"></a>使用队列优化算法</h2><p>Bellman-Ford算法的另一种优化:每次仅对最短路程发生变化了的点的相邻边执行松弛操作。但是如何知道当前哪些点的最短路程发生了变化呢?这里可以用一个队列来维护这些点，算法大致如下。</p><ul><li>每次选取队首顶点u，对顶点u的所有出边进行松弛操作。例如有一条u→v的边，如果通过u→v这条边使得源点到顶点v的最短路程变短(dis[u]+e[u] [v]&lt;dis[v])，且顶点v不在当前的队列中，就将顶点v放入队尾。需要注意的是，同一个顶点同时在队列中出现多次是毫无意义的，所以我们需要一个数组来判重（判断哪些点已经在队列中)。在对顶点u的所有出边松弛完毕后,就将顶点v出队。接下来不断从队列中取出新的队首顶点再进行如上操作，直至队列空为止。</li></ul><h2 id="优化图解"><a href="#优化图解" class="headerlink" title="优化图解"></a>优化图解</h2><p>我们用数组dis来存放1号顶点到其余各个顶点的最短路径。初始时dis[1]为0，其余为无穷大。接下来将1号顶点入队。然后对一号节点的所有出边进行松弛，松弛成功的节点，再加入队列。一直到队列为空结束！</p><p> <img src="/articleImg/38_article/image2.png" alt="image2"></p><h2 id="使用队列优化的代码函数"><a href="#使用队列优化的代码函数" class="headerlink" title="使用队列优化的代码函数"></a>使用队列优化的代码函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用队列优化贝尔曼福特算法的思想就是，每次仅对最短路估计值发生变化了的顶点的所有出边执行松弛操作。</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bellmanfordQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">       <span class="comment">//先用邻接表将所有的边信息进行保存</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">//将所有的边开始读入，并模仿单链表进行存储相关信息</span></span><br><span class="line">           <span class="comment">////这里相当于是一个链表操作，采用头插的方式</span></span><br><span class="line">           <span class="keyword">this</span>.next[i] = <span class="keyword">this</span>.first[<span class="keyword">this</span>.u[i]]; <span class="comment">//将当前节点u[i]中保存的出边，赋值到next[i]</span></span><br><span class="line">           <span class="keyword">this</span>.first[<span class="keyword">this</span>.u[i]] = i; <span class="comment">//将当前是第几条边赋值给first数组当前节点</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       queue.add(<span class="number">1</span>);<span class="comment">//这里模拟的是求1号节点到其他节点的最短路径，所以这里先将节点1入队</span></span><br><span class="line">       <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">           Integer topNode = queue.poll();</span><br><span class="line">           <span class="keyword">int</span> temp = <span class="keyword">this</span>.first[topNode];</span><br><span class="line">           <span class="keyword">while</span>(temp != -<span class="number">1</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span>(<span class="keyword">this</span>.cost[<span class="keyword">this</span>.v[temp]-<span class="number">1</span>]&gt;<span class="keyword">this</span>.cost[<span class="keyword">this</span>.u[temp]-<span class="number">1</span>]+<span class="keyword">this</span>.w[temp] &amp;&amp; <span class="keyword">this</span>.cost[<span class="keyword">this</span>.u[temp]-<span class="number">1</span>]!=<span class="number">999</span>)&#123;</span><br><span class="line">                   <span class="keyword">this</span>.cost[<span class="keyword">this</span>.v[temp]-<span class="number">1</span>] = <span class="keyword">this</span>.cost[<span class="keyword">this</span>.u[temp]-<span class="number">1</span>]+<span class="keyword">this</span>.w[temp];</span><br><span class="line">                   queue.add(<span class="keyword">this</span>.v[temp]);</span><br><span class="line">               &#125;</span><br><span class="line">               temp = <span class="keyword">this</span>.next[temp];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这个算法总结的差不多了，最重要的还是理解算法的思想。写代码就是顺其自然的事了。</p><p>继续加油吧~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bellman-Ford </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图--邻接表的两种实现</title>
      <link href="/2021/10/23/%E5%9B%BE-%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0/"/>
      <url>/2021/10/23/%E5%9B%BE-%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="图–邻接表的两种实现"><a href="#图–邻接表的两种实现" class="headerlink" title="图–邻接表的两种实现"></a>图–邻接表的两种实现</h1><p>图的结构有很多种中的表示方法，邻接矩阵、邻接表表示法、星形表示法、弧表示法、关联矩阵表示法等。这里对邻接表的表示做出记录。</p><p>要表示的图结构如下</p><p> <img src="/articleImg/37_article/image1.png" alt="image1"></p><h2 id="单链表实现邻接表"><a href="#单链表实现邻接表" class="headerlink" title="单链表实现邻接表"></a>单链表实现邻接表</h2><p> <img src="/articleImg/37_article/image2.jpg" alt="image2"></p><p>单链表存储起来还是挺简单的，这里我把每个单链表存在了Arraylist中，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里用链表实现图的邻接表</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">adjaceencyList2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;LinkedList&lt;Integer[]&gt;&gt; linkedLists = <span class="keyword">new</span> ArrayList&lt;LinkedList&lt;Integer[]&gt;&gt;();</span><br><span class="line">    <span class="comment">//这三个数组其实是代表一条边的信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> []u = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>]; <span class="comment">//代表开始节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> []v = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>]; <span class="comment">//代表结束节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> []w = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>]; <span class="comment">//代表这条边的代价</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        adjaceencyList2 adjacencyList = <span class="keyword">new</span> adjaceencyList2();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">5</span> ; i++) &#123; <span class="comment">//初始化链表list,list中的每一个元素是一个单链表</span></span><br><span class="line">            adjacencyList.linkedLists.add(<span class="keyword">new</span> LinkedList&lt;Integer[]&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        adjacencyList.u = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        adjacencyList.v = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        adjacencyList.w = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">5</span> ; i++) &#123; <span class="comment">//初始化链表数组中的相关信息</span></span><br><span class="line">            adjacencyList.linkedLists.get(adjacencyList.u[i]).add(<span class="keyword">new</span> Integer[]&#123;adjacencyList.v[i], adjacencyList.w[i]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//举例显示</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">5</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(adjacencyList.linkedLists.get(i).size() == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;第%d节点没有出边&quot;</span>,i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.printf(<span class="string">&quot;第%d节点：&quot;</span>,i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adjacencyList.linkedLists.get(i).size(); j++) &#123;</span><br><span class="line">                System.out.print(Arrays.toString(adjacencyList.linkedLists.get(i).get(j)));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组模拟实现邻接表"><a href="#数组模拟实现邻接表" class="headerlink" title="数组模拟实现邻接表"></a>数组模拟实现邻接表</h2><p>单链表实现我还挺好懂得，等到了要用数组模拟的时候我卡了一会，啊哈算法上用两个一维数组就把这几个单链表模拟出来了，如果是我来做第一手模拟操作的话，我可能会用一个二维数组去模拟，二维数组的每一行模拟一个单链表。</p><p>下面将模拟过程贴图，方便自己以后复习：</p><p> <img src="/articleImg/37_article/image3.png" alt="image3"></p><p> <img src="/articleImg/37_article/image4.png" alt="image4"></p><p><strong>即 first[u[i]]保存顶点u[i]的第一条边的编号，next[i]存储“编号为i的边”的“下一条边”的编号。</strong></p><p>那么啊哈算法程序中中又是怎么模拟这几个单链表所存储的信息的呢？请看我下面的程序注释。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package com.zhanglei;</span><br><span class="line"></span><br><span class="line">//图的临界表表示方法~ 其实就是用单链表去存储相关信息下</span><br><span class="line"></span><br><span class="line">//但是也可以用数组进行模拟，这里主要讨论的时数组进行模拟，昨天在思考这两句代码时被卡住了</span><br><span class="line">//在这里做出记录~</span><br><span class="line">public class adjacencyList &#123;</span><br><span class="line">    //本次要存储的是一个 4个节点 5条边的图</span><br><span class="line">    private int []first = new int[5]; //代表第i个节点的第一条出边</span><br><span class="line">    private int []next = new int[6]; //代表第j条边的下一条出边, 切记这里的出边仍然是属于第i个节点的出边</span><br><span class="line">    //next数组的作用就是想把第i个节点的所有出边都能索引到</span><br><span class="line"></span><br><span class="line">    //这三个数组其实是代表一条边的信息</span><br><span class="line">    private int []u = new int[6]; //代表开始节点</span><br><span class="line">    private int []v = new int[6]; //代表结束节点</span><br><span class="line">    private int []w = new int[6]; //代表这条边的代价</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        adjacencyList adjacencyList = new adjacencyList();</span><br><span class="line">        adjacencyList.first = new int[]&#123;-1, -1, -1, -1, -1&#125;;</span><br><span class="line">        adjacencyList.next = new int[]&#123;-1, -1, -1, -1, -1,-1&#125;;</span><br><span class="line">        adjacencyList.u = new int[]&#123;1, 4, 1, 2, 1&#125;;</span><br><span class="line">        adjacencyList.v = new int[]&#123;4, 3, 2, 4, 3&#125;;</span><br><span class="line">        adjacencyList.w = new int[]&#123;9, 8, 5, 6, 7&#125;;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123; //将所有的边开始读入，并模仿单链表进行存储相关信息</span><br><span class="line"></span><br><span class="line">            //采用头插的方式   ★关键在这里★</span><br><span class="line">            adjacencyList.next[i] = adjacencyList.first[adjacencyList.u[i]]; //将当前节点u[i]中保存的出边，赋值到next[i]</span><br><span class="line">            adjacencyList.first[adjacencyList.u[i]] = i; //将当前是第几条边赋值给first数组当前节点</span><br><span class="line">            //这里相当于是一个链表操作，</span><br><span class="line">        &#125;</span><br><span class="line">        //经过上述的操作之后，就可以通过节点的一条出边，而访问到该节点的所有出边号</span><br><span class="line">        //比如这里遍历出1号节点的所有出边号</span><br><span class="line">         int k = adjacencyList.first[1];</span><br><span class="line">        while(k!=-1)&#123;</span><br><span class="line">            System.out.printf(&quot;出边号 %d&quot;,k);</span><br><span class="line">            k = adjacencyList.next[k];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面的程序我们可以知道，啊哈算法中的first数组和next数组，都是存储的边号信息，就是存储的这是第几条边，而边对应的信息还需要到u[i]、v[i]、w[i]中去索引。但是上述的两句算法思想还是值得自己去吸收回味的。</p><p>最后的运行结果如下：</p><p> <img src="/articleImg/37_article/image5.png" alt="image5"></p><p>继续加油吧</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图的邻接表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图最短路径--迪杰斯特拉算法Dijkstra</title>
      <link href="/2021/10/23/%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95Dijkstra/"/>
      <url>/2021/10/23/%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95Dijkstra/</url>
      
        <content type="html"><![CDATA[<h1 id="图最短路径–迪杰斯特拉算法Dijkstra"><a href="#图最短路径–迪杰斯特拉算法Dijkstra" class="headerlink" title="图最短路径–迪杰斯特拉算法Dijkstra"></a>图最短路径–迪杰斯特拉算法Dijkstra</h1><h2 id="本次求解的图"><a href="#本次求解的图" class="headerlink" title="本次求解的图"></a>本次求解的图</h2><p> <img src="/articleImg/36_article/image1.png" alt="image1"></p><h2 id="算法思想梳理"><a href="#算法思想梳理" class="headerlink" title="算法思想梳理"></a>算法思想梳理</h2><p> <img src="/articleImg/36_article/image2.png" alt="image2"></p><p>就如上方的算法流程图，那么什么叫代价确定值呢？下面给出解释：</p><p>再图的邻接矩阵表示方法中，我们一般需要用一个一维数组dis来存储1号顶点到其余各个顶点的初始路程，如下：</p><p> <img src="/articleImg/36_article/image3.png" alt="image3"></p><p>既然是求1号顶点到其余各个顶点的最短路程，那就先找一个离1号顶点最近的顶点。通过数组dis可知当前离1号顶点最近的是2号顶点。当选择了2号顶点后，dis[2]的值就已经从“估计值”变为了“确定值”，即1号顶点到2号顶点的最短路程就是当前dis[2]值。为什么呢？ 如下:</p><p>你想啊，目前离1号顶点最近的是2号顶点，并且这个图所有的边都是正数，那么肯定不可能通过第三个顶点中转，使得1号顶点到2号顶点的路程进一步缩短了。</p><h2 id="什么是松弛呢"><a href="#什么是松弛呢" class="headerlink" title="什么是松弛呢"></a>什么是松弛呢</h2><p>这里还以求1号节点到其他节点的最短路径为例：当我们选择确定值对应的2号节点作为中转时，</p><p>我们发现dis[3]=12，dis[2]+e[2] [3]=1+9=10，dis[3]&gt;dis[2]+e[2] [3],因此dis[3]要更新为10。这个过程有个专业术语叫做“<strong>松弛</strong>”，1号顶点到3号顶点的路程即 dis[3]，通过2→3这条边松弛成功。这便是 Dijkstra算法的主要思想:通过“边”来松弛1号顶点到其余各个顶点的路程。</p><p>其中 dis[3]表示1号顶点到3号顶点的路程，e[2] [3]表示2→3这条边。</p><h2 id="给出算法代码及运行结果"><a href="#给出算法代码及运行结果" class="headerlink" title="给出算法代码及运行结果"></a>给出算法代码及运行结果</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图的迪杰斯特拉-单源最短路（一个点到其余各点的最短路径）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dijkstra</span> </span>&#123;</span><br><span class="line">    <span class="comment">//图的邻接矩阵,这里用999表示无穷大值</span></span><br><span class="line">    <span class="comment">//5*6</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [][] map= &#123;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">12</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>&#125;,&#123;<span class="number">999</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">999</span>,<span class="number">999</span>&#125;,&#123;<span class="number">999</span>,<span class="number">999</span>,<span class="number">0</span>,<span class="number">999</span>,<span class="number">5</span>,<span class="number">999</span>&#125;,&#123;<span class="number">999</span>,<span class="number">999</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">13</span>,<span class="number">15</span>&#125;,&#123;<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">0</span>,<span class="number">4</span>&#125;,&#123;<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [][] min_cost= &#123;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">12</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>&#125;,&#123;<span class="number">999</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">999</span>,<span class="number">999</span>&#125;,&#123;<span class="number">999</span>,<span class="number">999</span>,<span class="number">0</span>,<span class="number">999</span>,<span class="number">5</span>,<span class="number">999</span>&#125;,&#123;<span class="number">999</span>,<span class="number">999</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">13</span>,<span class="number">15</span>&#125;,&#123;<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">0</span>,<span class="number">4</span>&#125;,&#123;<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> []mark = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>]; <span class="comment">//来标记“确定值”，也就是该节点处目前已确定的最小值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dijkstra dijkstra = <span class="keyword">new</span> Dijkstra();</span><br><span class="line">        dijkstra.dijkstra();</span><br><span class="line">        System.out.println(<span class="string">&quot;经过迪杰斯特拉算法之后，得到的最小代价矩阵为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : dijkstra.min_cost) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%3d &quot;</span>,anInt);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//先求节点1的单源最短路径</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123; <span class="comment">//这个for是为了求出全部节点的最小代价路径</span></span><br><span class="line">            <span class="keyword">this</span>.zeroMark(<span class="keyword">this</span>.mark);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">this</span>.updateOver(<span class="keyword">this</span>.mark,i))&#123; <span class="comment">//求当前节点的到其他节点的最短路径</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> cur_min_val = <span class="number">999</span>;</span><br><span class="line">                <span class="keyword">int</span> cur_min_pos = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j  &lt; <span class="number">6</span> ; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="keyword">this</span>.min_cost[i][j]!=<span class="number">0</span>&amp;&amp;<span class="keyword">this</span>.min_cost[i][j]!=<span class="number">999</span>&amp;&amp;cur_min_val&gt;<span class="keyword">this</span>.min_cost[i][j]&amp;&amp;<span class="keyword">this</span>.mark[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                        cur_min_val = <span class="keyword">this</span>.min_cost[i][j];</span><br><span class="line">                        cur_min_pos = j; <span class="comment">//当前确定值的坐标</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(cur_min_pos == -<span class="number">1</span>) <span class="comment">//该节点已找出全部的确定最小值</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.mark[cur_min_pos] = <span class="number">1</span>; <span class="comment">//将当前确定值进行标记</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="keyword">this</span>.map[cur_min_pos][j]!=<span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.map[cur_min_pos][j] &lt; <span class="number">999</span>&amp;&amp;j!=<span class="number">0</span>)&#123; <span class="comment">//代表当前确定值，到其他节点有边，那么我们来看看，能不能因此更新代价矩阵</span></span><br><span class="line">                        <span class="keyword">int</span> temp = <span class="keyword">this</span>.min_cost[i][cur_min_pos] + <span class="keyword">this</span>.min_cost[cur_min_pos][j];</span><br><span class="line">                        <span class="keyword">if</span>(<span class="keyword">this</span>.min_cost[i][j] &gt; temp)&#123; <span class="comment">//表示可以更新</span></span><br><span class="line">                            <span class="keyword">this</span>.min_cost[i][j] = temp;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">zeroMark</span><span class="params">(<span class="keyword">int</span>[] mark)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span> ; i++) &#123;</span><br><span class="line">            mark[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">updateOver</span><span class="params">(<span class="keyword">int</span>[] mark,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=j&amp;&amp;mark[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p> <img src="/articleImg/36_article/image4.png" alt="image4"></p><p>附：如果在用迪杰斯特拉算法去求最短路径时，利用临界表去表示图，将会使算法的复杂度下降。</p><p>继续加油吧~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dijkstra最短路径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图最短路径--弗洛伊德算法Floyd</title>
      <link href="/2021/10/23/%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95Floyd/"/>
      <url>/2021/10/23/%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95Floyd/</url>
      
        <content type="html"><![CDATA[<h1 id="图最短路径–弗洛伊德算法Floyd"><a href="#图最短路径–弗洛伊德算法Floyd" class="headerlink" title="图最短路径–弗洛伊德算法Floyd"></a>图最短路径–弗洛伊德算法Floyd</h1><h2 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h2><p> <img src="/articleImg/35_article/image1.png" alt="image1"></p><p>如上图的的图和代价矩阵，我们希望知道任意两个节点间的最短路径。我们当然可以通过DFS遍历出两个节点，如1节点到5节点之间的所有路径，然后比较得出最短路径即可。</p><p>但是后续几篇博客中我将学习几种算法复杂度更低的最短路径算法。</p><h2 id="Floyd算法思想"><a href="#Floyd算法思想" class="headerlink" title="Floyd算法思想"></a>Floyd算法思想</h2><ul><li><p>我们来想一想，根据以往的经验，如果要让任意两点（例如从顶点a到顶点b）之间的路程变短，只能引入第三个点(顶点k)，并通过这个顶点k中转即a→k→b，才可能缩短原来从顶点a到顶点b的路程。那么这个中转的顶点k是1~n中的哪个点呢?甚至有时候不只通过一个点，而是经过两个点或者更多点中转会更短，即 a→k1→k2→b或者a&gt;k1→k2→…ki…→b。我们发现每个顶点都有可能使得另外两个顶点之间的路程变短。<br>当任意两点之间不允许经过第三个点时,这些城市之间的最短路程就是初始路程。</p></li><li><p>假如现在只允许经过1号顶点，求任意两点之间的最短路程，应该如何求呢?<br>只需判断e[i] [1]+e[1] [j]是否比 e[i] [j]要小即可。e[i] [j]表示的是从i号顶点到j号顶点之间的路程。e[i] [1]+e[1] [j]表示的是从i号顶点先到1号顶点，再从1号顶点到j号顶点的路程之和。其中i是1<del>n循环，j也是1</del>n循环，代码实现如下。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在只允许经过1号顶点的情况下,任意两点之间的最短路程更新为:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(j=l;j&lt;=n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i][j] &gt;e[i][<span class="number">1</span>]+e[<span class="number">1</span>][])</span><br><span class="line">e[i][j]=e[i][<span class="number">1</span>] +e[<span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对应代码"><a href="#对应代码" class="headerlink" title="对应代码"></a>对应代码</h2><p>根据上述的算法思想，我们很容易算法推广到允许所有顶点最为中转，去求最短路径，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package com.zhanglei;</span><br><span class="line"></span><br><span class="line">//弗洛伊德算法，求最短路径</span><br><span class="line">public class Floyd &#123;</span><br><span class="line">    private int[][] nodeCost =&#123;&#123;0,2,6,4&#125;,&#123;999,0,3,999&#125;,&#123;7,999,0,1&#125;,&#123;5,999,12,0&#125;&#125;;//原始的代价矩阵4*4</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Floyd floyd = new Floyd();</span><br><span class="line">        floyd.floyd();</span><br><span class="line">        for (int[] ints : floyd.nodeCost) &#123;</span><br><span class="line">            for (int anInt : ints) &#123;</span><br><span class="line">                System.out.printf(&quot;%3d&quot;,anInt);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void floyd()&#123; //弗洛伊德算法</span><br><span class="line">        for (int k = 0; k &lt;4 ; k++) &#123; //k代表以哪个节点为中转节点</span><br><span class="line">            for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">                for (int j = 0; j &lt;4; j++) &#123;</span><br><span class="line">                    if(i == k)</span><br><span class="line">                        break;</span><br><span class="line">                    int temp = this.nodeCost[i][k] + this.nodeCost[k][j];</span><br><span class="line">                    if(this.nodeCost[i][j]&gt;temp)</span><br><span class="line">                        this.nodeCost[i][j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终结果如下：</p><p> <img src="/articleImg/35_article/image2.png" alt="image2"></p><p>继续加油吧~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Floyd最短路径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重装系统后如何恢复hexo博客</title>
      <link href="/2021/10/20/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8Dhexo%E5%8D%9A%E5%AE%A2/"/>
      <url>/2021/10/20/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8Dhexo%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="重装系统后如何恢复hexo博客"><a href="#重装系统后如何恢复hexo博客" class="headerlink" title="重装系统后如何恢复hexo博客"></a>重装系统后如何恢复hexo博客</h1><p>随着博客越写越多，我很担心博客的迁移问题，以后可能会换很多台办公电脑，怎么能保证自己的积累不会前功尽弃呢！这里我特别记录一篇如何迁移恢复hexo博客的文章。</p><h2 id="大前提是自己的本地博客文件都还健在"><a href="#大前提是自己的本地博客文件都还健在" class="headerlink" title="大前提是自己的本地博客文件都还健在~"></a>大前提是自己的本地博客文件都还健在~</h2><p>1.安装Node.js，git，并查看当前软件环境，2021年10月安装的环境版本如下 </p><p> <img src="/articleImg/34_article/image1.png" alt="image1"></p><p>2.配置SSH key</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/. ssh    <span class="comment">//查看C:\Users\用户名.ssh下有无ssh文件夹，没有则创建</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;邮件地址&quot;</span> <span class="comment">//创建key</span></span><br></pre></td></tr></table></figure><p>3.将本地生成的 SSH key配置到github</p><p>4.ssh -T <a href="mailto:&#x67;&#x69;&#116;&#64;&#103;&#105;&#116;&#104;&#x75;&#x62;&#46;&#99;&#111;&#x6d;">&#x67;&#x69;&#116;&#64;&#103;&#105;&#116;&#104;&#x75;&#x62;&#46;&#99;&#111;&#x6d;</a>  测试是否成功</p><p>5.用户名 邮箱配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;zhanglei-underdog&quot;</span><span class="comment">// 你的github用户名，非昵称</span></span><br><span class="line">git config --global user.email  <span class="string">&quot;zhanglei.szu@gmail.com&quot;</span><span class="comment">// 填写你的github注册邮箱</span></span><br></pre></td></tr></table></figure><p>6.进入到博客(pgzxc)文件夹删除<strong>node_modules</strong>   <strong>public</strong>   <strong>.git</strong>   <strong>.deploy_git</strong>文件夹，删除后如下</p><p>  <img src="/articleImg/34_article/image2.png" alt="image2"></p><p>7.关联Github项目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin git<span class="meta">@github</span>.com:PGzxc/PGzxc.github.io.git</span><br></pre></td></tr></table></figure><p>8.运行如下指令”npm install –g hexo ”安装hexo，也可用cnpm,具体参考前面的博客。</p><p>9.<strong>运行如下指令安装项目依赖</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install  </span><br></pre></td></tr></table></figure><p>​    10.hexo -g 生成并本地预览,即可</p><h2 id="顺带记录如何将博客同时推送到GitHub与gitee"><a href="#顺带记录如何将博客同时推送到GitHub与gitee" class="headerlink" title="顺带记录如何将博客同时推送到GitHub与gitee"></a>顺带记录如何将博客同时推送到GitHub与gitee</h2><p>1.查看C:\Users\用户名.ssh下有无ssh文件夹，没有则创建</p><p>2.通过下面的命令，依次生成两个平台的key</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;xxxxxxx@qq.com&quot; -f &quot;github_id_rsa&quot;</span><br><span class="line">$ ssh-keygen -t rsa -C &quot;xxxxxxx@qq.com&quot; -f &quot;gitee_id_rsa&quot;</span><br></pre></td></tr></table></figure><p>3.完成后，.ssh文件夹生成以下文件</p><p> <img src="/articleImg/34_article/image3.png" alt="image3"></p><p>4.打开gitee_id_rsa.pub文件与github_id_rsa.pub文件，将其配置到各自平台的SSH中</p><p>5.在.ssh文件夹下，创建config文件解决ssh冲突（config文件没有后缀名），输入以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># gitee</span><br><span class="line">Host gitee.com</span><br><span class="line">HostName gitee.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/gitee_id_rsa</span><br><span class="line"> </span><br><span class="line"># github</span><br><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/github_id_rsa</span><br></pre></td></tr></table></figure><p>6，测试gitee命令：<strong>ssh -T <a href="mailto:&#103;&#x69;&#116;&#64;&#103;&#105;&#x74;&#101;&#101;&#x2e;&#x63;&#x6f;&#109;">&#103;&#x69;&#116;&#64;&#103;&#105;&#x74;&#101;&#101;&#x2e;&#x63;&#x6f;&#109;</a></strong>        测试GitHub命令：<strong>ssh -T <a href="mailto:&#x67;&#x69;&#x74;&#x40;&#103;&#105;&#116;&#x68;&#x75;&#98;&#x2e;&#x63;&#111;&#109;">&#x67;&#x69;&#x74;&#x40;&#103;&#105;&#116;&#x68;&#x75;&#98;&#x2e;&#x63;&#111;&#109;</a></strong></p><p>今天记录完这个，心里终于踏实了~</p><p>继续加油~</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo博客迁移恢复 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图-DFS求最小代价路径</title>
      <link href="/2021/10/20/%E5%9B%BE-DFS%E6%B1%82%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7%E8%B7%AF%E5%BE%84/"/>
      <url>/2021/10/20/%E5%9B%BE-DFS%E6%B1%82%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h1 id="DFS求图中最小代价路径"><a href="#DFS求图中最小代价路径" class="headerlink" title="DFS求图中最小代价路径"></a>DFS求图中最小代价路径</h1><p> <img src="/articleImg/33_article/image1.png" alt="image1"></p><h2 id="程序说明"><a href="#程序说明" class="headerlink" title="程序说明"></a>程序说明</h2><p>利用DFS，从节点1出发，找出到节点5的最小代价路径。&lt;这里注意时最小代价路径，不是最短路径&gt;</p><ul><li>当每条边的代价相同时，用BFS更优，因为BFS第一次到达目标点的时候，便是最小代价路径。</li><li>当每条边的代价不同时，用DFS更优，期间可以返回代价已经大于min的检索。等所有的可能性都遍历完之后，便会的到一条最小代价路径。</li><li>也就是说BFS只遍历到一条路径答案，而DFS则将所有的可行性路径都遍历了一遍，最终的到最小代价路径。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过DFS遍历，求出图中从起始点到终点的最小代价路径</span></span><br><span class="line"><span class="comment">//当每条边的代价相同时，用BFS更优，因为BFS第一次到达目标点的时候，便是最小代价路径</span></span><br><span class="line"><span class="comment">//当每条边的代价不同时，用DFS更优，期间可以返回代价已经大于min的检索。等所有的可能性都遍历完之后，便会的到一条最小代价路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinimumCost</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][]map=&#123;&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">10</span>&#125;,&#123;<span class="number">999</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">999</span>,<span class="number">7</span>&#125;,&#123;<span class="number">4</span>,<span class="number">999</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">999</span>&#125;,&#123;<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">0</span>,<span class="number">5</span>&#125;,&#123;<span class="number">999</span>,<span class="number">999</span>,<span class="number">3</span>,<span class="number">999</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> min = <span class="number">9999</span>;<span class="comment">//最小代价变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cost;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] markNode = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]; <span class="comment">//用来标记节点是否被遍历过</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MinimumCost minimumCost = <span class="keyword">new</span> MinimumCost();</span><br><span class="line">        minimumCost.markNode[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        minimumCost.DFS(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;最小代价为：&quot;</span>+minimumCost.min);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> step,<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="number">4</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本次cost代价为：&quot;</span>+<span class="keyword">this</span>.cost);</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.cost&lt;<span class="keyword">this</span>.min)</span><br><span class="line">                <span class="keyword">this</span>.min = <span class="keyword">this</span>.cost;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.map[cur][i]!=<span class="number">0</span>&amp;&amp;<span class="keyword">this</span>.map[cur][i]!= <span class="number">999</span> )&#123; <span class="comment">//代表有边</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.markNode[i] == <span class="number">1</span>) <span class="comment">//这里判断的是指向边对应节点是否已被遍历过</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">this</span>.cost = <span class="keyword">this</span>.cost+<span class="keyword">this</span>.map[cur][i];</span><br><span class="line">                <span class="keyword">this</span>.markNode[i] = <span class="number">1</span>; <span class="comment">//这里一定要写成this.markNode[i] = 1，因为这里要去指向边了</span></span><br><span class="line">                DFS(step+<span class="number">1</span>,i);</span><br><span class="line">                <span class="comment">//尤其注意this.cost，this.markNode[i]在这里进行清零，如果不理解为什么，就去看看DFS求全排列</span></span><br><span class="line">                <span class="keyword">this</span>.cost = <span class="keyword">this</span>.cost - <span class="keyword">this</span>.map[cur][i];</span><br><span class="line">                <span class="keyword">this</span>.markNode[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>继续加油吧~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS求最小代价路径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFS-连通域检测</title>
      <link href="/2021/10/20/BFS-%E8%BF%9E%E9%80%9A%E5%9F%9F%E6%A3%80%E6%B5%8B/"/>
      <url>/2021/10/20/BFS-%E8%BF%9E%E9%80%9A%E5%9F%9F%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="BFS连通域检测"><a href="#BFS连通域检测" class="headerlink" title="BFS连通域检测"></a>BFS连通域检测</h1><p>0代表不通，大于0的值代表可走，检测从（6，8）处出发的连通域。矩阵形式如下</p><p> <img src="/articleImg/32_article/image1.png" alt="image1"></p><p>本次实现分别用BFS的思想和DFS的思想去解决该连通域检测问题，里面有一两个需要注意的小细节，已经在代码中的注释中写清楚了。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检索出矩阵中所有的连通域</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionDomain</span> </span>&#123;</span><br><span class="line">    <span class="comment">//该map的起始点在（6，8）处，map的大小是10*10的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [][]map = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">4</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [][]mark = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][<span class="number">10</span>];<span class="comment">//用来标记该点有没有走过</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][]dir= &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;; <span class="comment">//每个位置都可以走四个方向</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConnectionDomain connectionDomain = <span class="keyword">new</span> ConnectionDomain();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : connectionDomain.map) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%3d&quot;</span>,anInt);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------------------&quot;</span>);</span><br><span class="line">        connectionDomain.BFS(<span class="number">6</span>,<span class="number">8</span>);</span><br><span class="line">        <span class="comment">//connectionDomain.DFS(6,8,0);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : connectionDomain.map) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%3d&quot;</span>,anInt);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(connectionDomain.sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123; <span class="comment">//用BFS解连通域问题</span></span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;<span class="keyword">int</span>[]&gt;();<span class="comment">//用一个队列来辅助BFS的遍历</span></span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x,y&#125;);</span><br><span class="line">        sum++;</span><br><span class="line">        <span class="keyword">this</span>.mark[x][y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.map[x][y] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span>[] peek = queue.peek(); <span class="comment">//取队列中的队头元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> tempX = peek[<span class="number">0</span>] + <span class="keyword">this</span>.dir[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> tempY = peek[<span class="number">1</span>] + <span class="keyword">this</span>.dir[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(tempX&lt;<span class="number">0</span>||tempY&lt;<span class="number">0</span>||tempX&gt;<span class="number">9</span>||tempY&gt;<span class="number">9</span>||<span class="keyword">this</span>.mark[tempX][tempY] == <span class="number">1</span>||<span class="keyword">this</span>.map[tempX][tempY] == <span class="number">0</span>) <span class="comment">//越界，或则该点已走过，或则该点为海</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.mark[tempX][tempY] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">this</span>.map[tempX][tempY] = -<span class="number">1</span>;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;tempX,tempY&#125;);</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> step)</span></span>&#123; <span class="comment">//用DFS解决连通域问题</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">4</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tempX = x + <span class="keyword">this</span>.dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> tempY = y + <span class="keyword">this</span>.dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(tempX&lt;<span class="number">0</span>||tempY&lt;<span class="number">0</span>||tempX&gt;<span class="number">9</span>||tempY&gt;<span class="number">9</span>||<span class="keyword">this</span>.mark[tempX][tempY] == <span class="number">1</span>||<span class="keyword">this</span>.map[tempX][tempY] == <span class="number">0</span>) <span class="comment">//越界，或则该点已走过，或则该点为海</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">this</span>.mark[tempX][tempY] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">this</span>.map[tempX][tempY] = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">this</span>.sum++;</span><br><span class="line">            DFS(tempX,tempY,step+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>继续加油~~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFS--迷宫求解得一条最短路径</title>
      <link href="/2021/10/20/BFS-%E8%BF%B7%E5%AE%AB%E6%B1%82%E8%A7%A3%E5%BE%97%E4%B8%80%E6%9D%A1%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
      <url>/2021/10/20/BFS-%E8%BF%B7%E5%AE%AB%E6%B1%82%E8%A7%A3%E5%BE%97%E4%B8%80%E6%9D%A1%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h1 id="BFS–迷宫求解得一条最短路径"><a href="#BFS–迷宫求解得一条最短路径" class="headerlink" title="BFS–迷宫求解得一条最短路径"></a>BFS–迷宫求解得一条最短路径</h1><h2 id="BFS自我思考"><a href="#BFS自我思考" class="headerlink" title="BFS自我思考"></a>BFS自我思考</h2><ul><li>利用广度优先搜索解决迷宫问题</li><li>个人感觉广度优先搜索的核心在于，先把把每个点可以到达的位置都加入到队列中，随着队头移动，推进队尾元素的入队，最终实现遍历的效果（网上称为着色法）</li><li>广度优先算法在搜索到目标点的时候，就会开始结束程序，所以只会找到一条可行路径，但是这条路径却是最短的！</li></ul><p>下面我想截三张图，以便自己能够在以后复习的时候，更快回味BFS，截图来自–《啊哈算法》</p><p><img src="/articleImg/31_article/image1.png" alt="image1"></p><ul><li><strong>其实BFS，也没有用到递归，最重要的思想就是用到队列，记录下了每一次都能着色到的点。这很关键，是整个算法的核心。</strong></li></ul><p>有了这样的思路，我们解决迷宫问题就迎刃而解了，因为总有那么一步，我们能能到达终点。但只会找到一条可行路径，这条路径却是最短的。</p><ul><li><strong>切记如果想打印出最短路径，必须在队列节点数据类型中，加入一个前驱节点属性。并在从后往前遍历最短路径的时候，用栈去记录，这样就可以在打印路径的时候，从前往后打印了。</strong></li></ul><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用广度优先搜索解决迷宫问题</span></span><br><span class="line"><span class="comment">//个人感觉广度优先搜索的核心在于，先把把每个点可以到达的位置都加入到队列中，随着队头移动，推进队尾元素的入队，最终实现遍历的效果（网上称为着色法）</span></span><br><span class="line"><span class="comment">//广度优先算法在搜索到目标点的时候，就会开始结束程序，所以只会找到一条可行路径，但是这条路径却是最短的！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mazeSolving</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] mark = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][]dir= &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;; <span class="comment">//每个位置都可以走四个方向</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> queueElementCount;</span><br><span class="line">    <span class="comment">//迷宫地图</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [][]map=&#123;&#123;<span class="number">1</span>,<span class="number">1</span> ,<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> ,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>, <span class="number">0</span> ,<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> ,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">1</span>&#125;,&#123;<span class="number">1</span> ,<span class="number">0</span> ,<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,&#123;<span class="number">1</span> ,<span class="number">0</span>, <span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span>, <span class="number">1</span>&#125;,&#123;<span class="number">1</span>, <span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">        <span class="comment">//因为只有当遍历到终点的时候，才会知道最短路径，如果利用前驱节点，来记录最短路径的话，就需要从后往前走，这时候用栈来记录比较合适</span></span><br><span class="line">        Stack&lt;<span class="keyword">int</span>[]&gt; pathStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        mazeSolving mazeSolving = <span class="keyword">new</span> mazeSolving();</span><br><span class="line"></span><br><span class="line">        mazeSolving.BFS(<span class="number">1</span>,<span class="number">1</span>,queue);</span><br><span class="line"></span><br><span class="line">        Node pathNode = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            Node peek = queue.peek();</span><br><span class="line">            System.out.println(peek);</span><br><span class="line">            <span class="keyword">if</span>(peek.getX() == <span class="number">6</span> &amp;&amp; peek.getY() == <span class="number">5</span>)&#123;</span><br><span class="line">                pathNode = peek; <span class="comment">//将出口处的队列节点保留</span></span><br><span class="line">            &#125;</span><br><span class="line">            queue.remove();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!(pathNode.getX()==<span class="number">1</span>&amp;&amp;pathNode.getY()==<span class="number">1</span>))&#123;</span><br><span class="line">            pathStack.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;pathNode.getX(), pathNode.getY()&#125;);</span><br><span class="line">            pathNode = pathNode.getPreNode();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pathStack.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pathStack.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span>[] pop = pathStack.pop();</span><br><span class="line">            System.out.println(Arrays.toString(pop));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,Queue&lt;Node&gt; queue)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node();</span><br><span class="line">        node.setX(x);</span><br><span class="line">        node.setY(y);</span><br><span class="line">        node.setStep(step);</span><br><span class="line">        queue.add(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line"></span><br><span class="line">            Node peek = queue.peek();</span><br><span class="line">            step = peek.getStep() + <span class="number">1</span>;<span class="comment">//步数更新</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span> ; i++) &#123;</span><br><span class="line">                <span class="comment">//获取头部元素</span></span><br><span class="line">                Node tempNode  = <span class="keyword">new</span> Node();</span><br><span class="line">                <span class="keyword">int</span> tempX = peek.getX() +<span class="keyword">this</span>.dir[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> tempY = peek.getY()+<span class="keyword">this</span>.dir[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(tempX&lt;<span class="number">0</span>||tempY&lt;<span class="number">0</span>||tempX&gt;<span class="number">7</span>||tempY&gt;<span class="number">6</span>||<span class="keyword">this</span>.mark[tempX][tempY] == <span class="number">1</span>||<span class="keyword">this</span>.map[tempX][tempY] == <span class="number">1</span>) <span class="comment">//越界，或则该点已走过，或则该点为墙</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(mark[tempX][tempY] == <span class="number">0</span>)&#123;</span><br><span class="line">                    mark[tempX][tempY] = <span class="number">1</span>;</span><br><span class="line">                    tempNode.setPreNode(peek);</span><br><span class="line">                    tempNode.setX(tempX);</span><br><span class="line">                    tempNode.setY(tempY);</span><br><span class="line">                    tempNode.setStep(step);</span><br><span class="line">                    queue.add(tempNode);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tempX == <span class="number">6</span> &amp;&amp; tempY == <span class="number">5</span>) <span class="comment">//代表已经找到终点</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            queue.remove(); <span class="comment">//该头节点已尽心尽力，把它能到达的位置，都加到队列里了，所以这里删除该头节点</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123; <span class="comment">//（队列节点）迷宫节点需要记录的信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> step;</span><br><span class="line">    <span class="keyword">private</span> Node PreNode;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPreNode</span><span class="params">(Node preNode)</span> </span>&#123;</span><br><span class="line">        PreNode = preNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getPreNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PreNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStep</span><span class="params">(<span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.step = step;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;x=&quot;</span> + x +</span><br><span class="line">                <span class="string">&quot;, y=&quot;</span> + y +</span><br><span class="line">                <span class="string">&quot;, step=&quot;</span> + step +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 继续加油~~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS--水管工游戏</title>
      <link href="/2021/10/20/DFS-%E6%B0%B4%E7%AE%A1%E5%B7%A5%E6%B8%B8%E6%88%8F/"/>
      <url>/2021/10/20/DFS-%E6%B0%B4%E7%AE%A1%E5%B7%A5%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="DFS–水管工游戏"><a href="#DFS–水管工游戏" class="headerlink" title="DFS–水管工游戏"></a>DFS–水管工游戏</h1><h2 id="规则简介"><a href="#规则简介" class="headerlink" title="规则简介"></a>规则简介</h2><p>游戏的大致规则是这样的。一块矩形土地被分为N * M的单位正方形，现在这块土地上已经埋设有一些水管，水管将从坐标为(1,1)左上角左部边缘，延伸到(N,M)右下角右部边缘。水管只有2种，如下图所示</p><p> <img src="/articleImg/30_article/image1.png" alt="image1"></p><p>每种管道将占据一个单位正方形土地。你现在可以旋转这些管道，使得构成一个管道系统，即创造一条从(1,1)到(N,M)的连通管道。标有树木的方格表示这里没有管道。比如一个4*5的土地中(4,2)处有一个树木。我们可以旋转其中的一些管道，使之构成一个连通的管道系统，如下图。</p><p> <img src="/articleImg/30_article/image2.png" alt="image2"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>水管游戏就相当于是一个有条件的迷宫游戏，进水管的方向，连接点的水管类型就是这个迷宫的行走条件</li><li>从进水口到出水口，通过旋转中间水管零件的方向，来打通水管</li><li>我在写这道题的时候，是先判断入水口的方向，在判断连接点的水管类型</li><li>当然这题也可以，先判断连接点的水管类型，在判断入水口的方向。</li></ul><p>根据上述思路我们做出以下设定，并写出模拟矩阵：</p><p> <img src="/articleImg/30_article/image3.png" alt="image3"></p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="comment">//水管游戏就相当于是一个有条件的迷宫游戏，进水管的方向，连接点的水管类型就是这个迷宫的行走条件</span></span><br><span class="line"><span class="comment">//从进水口到出水口，通过旋转中间水管零件的方向，来打通水管</span></span><br><span class="line"><span class="comment">//我在写这道题的时候，是先判断入水口的方向，在判断连接点的水管类型</span></span><br><span class="line"><span class="comment">//当然这题也可以，先判断连接点的水管类型，在判断入水口的方向</span></span><br><span class="line"><span class="comment">//用矩阵模拟</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaterPipe</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [][]map = &#123;&#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">0</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>&#125;,&#123;<span class="number">6</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>&#125;,&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [][]mark = &#123;&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WaterPipe waterPipe = <span class="keyword">new</span> WaterPipe();</span><br><span class="line">        waterPipe.DFS(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y, <span class="keyword">int</span> flag, <span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">4</span> &amp;&amp; y == <span class="number">4</span>)&#123; <span class="comment">//表示已经找到最末端的出水口</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : <span class="keyword">this</span>.mark) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%3d&quot;</span>,anInt);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>||x&gt;<span class="number">4</span>||y&lt;<span class="number">0</span>||y&gt;<span class="number">3</span>||<span class="keyword">this</span>.mark[x][y] == <span class="number">1</span>)&#123; <span class="comment">//越界，或则该点水管已被使用过</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123; <span class="comment">//进水口在左边</span></span><br><span class="line">            <span class="keyword">if</span>((<span class="keyword">this</span>.map[x][y] == <span class="number">5</span> || <span class="keyword">this</span>.map[x][y] == <span class="number">6</span>)&amp;&amp;<span class="keyword">this</span>.mark[x][y] == <span class="number">0</span>)&#123; <span class="comment">//对接点是直管</span></span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">1</span>;</span><br><span class="line">                DFS(x,y+<span class="number">1</span>,<span class="number">1</span>,step+<span class="number">1</span>);</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.map[x][y] &gt;= <span class="number">1</span> &amp;&amp; <span class="keyword">this</span>.map[x][y] &lt;= <span class="number">4</span>&amp;&amp;<span class="keyword">this</span>.mark[x][y] == <span class="number">0</span>)&#123; <span class="comment">//对接点是弯管</span></span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">1</span>;</span><br><span class="line">                DFS(x+<span class="number">1</span>,y,<span class="number">4</span>,step+<span class="number">1</span>);</span><br><span class="line">                DFS(x-<span class="number">1</span>,y,<span class="number">2</span>,step+<span class="number">1</span>);</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">2</span>)&#123; <span class="comment">//进水口在下边</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.map[x][y] == <span class="number">5</span> || <span class="keyword">this</span>.map[x][y] == <span class="number">6</span>&amp;&amp;<span class="keyword">this</span>.mark[x][y] == <span class="number">0</span>)&#123; <span class="comment">//对接点是直管</span></span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">1</span>;</span><br><span class="line">                DFS(x-<span class="number">1</span>,y,<span class="number">2</span>,step+<span class="number">1</span>);</span><br><span class="line">                flag = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.map[x][y] &gt;= <span class="number">1</span> &amp;&amp; <span class="keyword">this</span>.map[x][y] &lt;= <span class="number">4</span>&amp;&amp;<span class="keyword">this</span>.mark[x][y] == <span class="number">0</span>)&#123; <span class="comment">//对接点是弯管</span></span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">1</span>;</span><br><span class="line">                DFS(x,y+<span class="number">1</span>,<span class="number">1</span>,step+<span class="number">1</span>);</span><br><span class="line">                DFS(x,y-<span class="number">1</span>,<span class="number">3</span>,step+<span class="number">1</span>);</span><br><span class="line">                flag = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">3</span>)&#123; <span class="comment">//进水口在右边</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.map[x][y] == <span class="number">5</span> || <span class="keyword">this</span>.map[x][y] == <span class="number">6</span>&amp;&amp;<span class="keyword">this</span>.mark[x][y] == <span class="number">0</span>)&#123; <span class="comment">//对接点是直管</span></span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">1</span>;</span><br><span class="line">                DFS(x,y-<span class="number">1</span>,<span class="number">3</span>,step+<span class="number">1</span>);</span><br><span class="line">                flag = <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.map[x][y] &gt;= <span class="number">1</span> &amp;&amp; <span class="keyword">this</span>.map[x][y] &lt;= <span class="number">4</span>&amp;&amp;<span class="keyword">this</span>.mark[x][y] == <span class="number">0</span>)&#123; <span class="comment">//对接点是弯管</span></span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">1</span>;</span><br><span class="line">                DFS(x+<span class="number">1</span>,y,<span class="number">4</span>,step+<span class="number">1</span>);</span><br><span class="line">                DFS(x-<span class="number">1</span>,y,<span class="number">2</span>,step+<span class="number">1</span>);</span><br><span class="line">                flag = <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">4</span>)&#123; <span class="comment">//进水口在上边</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.map[x][y] == <span class="number">5</span> || <span class="keyword">this</span>.map[x][y] == <span class="number">6</span>&amp;&amp;<span class="keyword">this</span>.mark[x][y] == <span class="number">0</span>)&#123; <span class="comment">//对接点是直管</span></span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">1</span>;</span><br><span class="line">                DFS(x+<span class="number">1</span>,y,<span class="number">4</span>,step+<span class="number">1</span>);</span><br><span class="line">                flag = <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.map[x][y] &gt;= <span class="number">1</span> &amp;&amp; <span class="keyword">this</span>.map[x][y] &lt;= <span class="number">4</span>&amp;&amp;<span class="keyword">this</span>.mark[x][y] == <span class="number">0</span>)&#123; <span class="comment">//对接点是弯管</span></span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">1</span>;</span><br><span class="line">                DFS(x,y+<span class="number">1</span>,<span class="number">1</span>,step+<span class="number">1</span>);</span><br><span class="line">                DFS(x,y-<span class="number">1</span>,<span class="number">3</span>,step+<span class="number">1</span>);</span><br><span class="line">                flag = <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的代码也可以先判断水管类型，再判断进水口方向。</p><p>DFS一定要注意当前这一步需要做什么，然后在考虑下一步怎么走。</p><p>继续加油~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 有条件的迷宫求解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS--方格填数</title>
      <link href="/2021/10/18/DFS-%E6%96%B9%E6%A0%BC%E5%A1%AB%E6%95%B0/"/>
      <url>/2021/10/18/DFS-%E6%96%B9%E6%A0%BC%E5%A1%AB%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="DFS–方格填数"><a href="#DFS–方格填数" class="headerlink" title="DFS–方格填数"></a>DFS–方格填数</h2><h2 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h2><p>如下的10个格子</p><p> <img src="/articleImg/29_article/image1.png" alt="image1"></p><p>填入0~9的数字。要求：连续的两个数字不能相邻。（左右、上下、对角都算相邻）</p><p>一共有多少种可能的填数方案？</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>用全排列,求出0~9十个数的全排列。全排列的思路和代码在前面几篇中已给出。这里就不在贴出。</li><li>将一维全排列填入到方格中，这里要注意边界条件（1，第一个格子与最后一个格子缺失。2，数组是否越界）</li><li>然后再利用for循环判断每个位置处周围的数是否满足条件。这里要注意边界条件。</li></ul><h2 id="第一个版本代码（暴力）"><a href="#第一个版本代码（暴力）" class="headerlink" title="第一个版本代码（暴力）"></a>第一个版本代码（暴力）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FillNumber</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> [][]dir = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;&#125;;    <span class="comment">//周围相邻的八个元素</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> [][]grid = &#123;&#123;-<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>&#125;,&#123;-<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>&#125;,&#123;-<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            Permutation&lt;Integer&gt; integerPermutation = <span class="keyword">new</span> Permutation&lt;&gt;();</span><br><span class="line">            FillNumber fillNumber = <span class="keyword">new</span> FillNumber();</span><br><span class="line"></span><br><span class="line">            Integer []numSet = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">            integerPermutation.permutation(numSet,<span class="number">0</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;全排列的种类：&quot;</span>+integerPermutation.count);</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (Integer[] integers : integerPermutation.arrayList) &#123; <span class="comment">//遍历该全排列</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; integers.length; i++) &#123; <span class="comment">//将全排列中的数值，写入到二维数组中</span></span><br><span class="line">                    fillNumber.grid[(i+<span class="number">1</span>)/<span class="number">4</span>][(i+<span class="number">1</span>)%<span class="number">4</span>] = integers[i];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(fillNumber.grid[i][j] == -<span class="number">1</span>)</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++) &#123; <span class="comment">//判断该点八个方向上有没有相邻元素</span></span><br><span class="line">                            <span class="keyword">int</span> temp;</span><br><span class="line">                            <span class="keyword">int</span> check_x,check_y;</span><br><span class="line">                            check_x = i+fillNumber.dir[k][<span class="number">0</span>];</span><br><span class="line">                            check_y = j+fillNumber.dir[k][<span class="number">1</span>]; <span class="comment">//这里刚开始携程了 i+fillNumber.dir[k][1],泪目了，这加出来的坐标怎么能对呢</span></span><br><span class="line">                            <span class="keyword">if</span>(check_x&lt;<span class="number">0</span>||check_x&gt;<span class="number">2</span>||check_y&lt;<span class="number">0</span>||check_y&gt;<span class="number">3</span>||(check_x == <span class="number">0</span>&amp;&amp; check_y ==<span class="number">0</span>)||(check_x == <span class="number">2</span>&amp;&amp; check_y ==<span class="number">3</span>)) <span class="comment">//存在越界</span></span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            <span class="keyword">if</span>(Math.abs(fillNumber.grid[check_x][check_y] - fillNumber.grid[i][j]) == <span class="number">1</span>)&#123; <span class="comment">//说明该排列中存在相邻元素</span></span><br><span class="line">                                flag = <span class="keyword">false</span>; <span class="comment">//结束该次判断</span></span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(!flag)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(!flag)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag)</span><br><span class="line">                    fillNumber.ans++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;符合要求的填数方式：&quot;</span>+fillNumber.ans);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>简单来看这就是一个放数问题，和求全排列，解八皇后问题，是差不多的。只不过这里在放数的时候，有一定的条件：即连续的两个数字不能相邻。</p><p>在把握好这个条件的前提下，利用DFS做解答。</p><ul><li>这这个DFS里面条件判断有两个，条件①该数是否已被放置过；条件② 连续的两个数字不能相邻</li></ul><h2 id="第二个版本代码（DFS）"><a href="#第二个版本代码（DFS）" class="headerlink" title="第二个版本代码（DFS）"></a>第二个版本代码（DFS）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FillNumber</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer []numSet = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> Integer []mark = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [][]grid = &#123;&#123;-<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>&#125;,&#123;-<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>&#125;,&#123;-<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>&#125;&#125;; <span class="comment">//注：这里的初值千万不能赋值为 -1，否则回溯的时候 -1-0= 1，会少很多计数值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [][]dir = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;&#125;;    <span class="comment">//周围相邻的八个元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ans  = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FillNumber fillNumber = <span class="keyword">new</span> FillNumber();</span><br><span class="line">        fillNumber.DFS(<span class="number">0</span>);</span><br><span class="line">        System.out.println(fillNumber.ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(step == <span class="number">10</span>)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.numSet.length; i++) &#123; <span class="comment">//这里产生多路递归</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>; <span class="comment">//用来标志该点放置的数是否符合条件              条件①</span></span><br><span class="line">            <span class="keyword">if</span>(mark[i]==<span class="number">0</span>)&#123; <span class="comment">//判断该数有没有被使用过（有没有被放置过）</span></span><br><span class="line">                <span class="keyword">this</span>.grid[(step+<span class="number">1</span>)/<span class="number">4</span>][(step+<span class="number">1</span>)%<span class="number">4</span>] = i;</span><br><span class="line">                mark[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++) &#123; <span class="comment">//判断该点八个方向上有没有相邻元素  条件②</span></span><br><span class="line">                <span class="keyword">int</span> temp;</span><br><span class="line">                <span class="keyword">int</span> check_x,check_y;</span><br><span class="line">                check_x = (step+<span class="number">1</span>)/<span class="number">4</span>+<span class="keyword">this</span>.dir[k][<span class="number">0</span>];</span><br><span class="line">                check_y = (step+<span class="number">1</span>)%<span class="number">4</span>+<span class="keyword">this</span>.dir[k][<span class="number">1</span>]; <span class="comment">//这里刚开始携程了 i+fillNumber.dir[k][1],泪目了，这加出来的坐标怎么能对呢</span></span><br><span class="line">                <span class="keyword">if</span>(check_x&lt;<span class="number">0</span>||check_x&gt;<span class="number">2</span>||check_y&lt;<span class="number">0</span>||check_y&gt;<span class="number">3</span>||(check_x == <span class="number">0</span>&amp;&amp; check_y ==<span class="number">0</span>)||(check_x == <span class="number">2</span>&amp;&amp; check_y ==<span class="number">3</span>)) <span class="comment">//存在越界</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(Math.abs(<span class="keyword">this</span>.grid[check_x][check_y] - <span class="keyword">this</span>.grid[(step+<span class="number">1</span>)/<span class="number">4</span>][(step+<span class="number">1</span>)%<span class="number">4</span>]) == <span class="number">1</span>)&#123; <span class="comment">//说明该排列中存在相邻元素</span></span><br><span class="line">                    flag = <span class="keyword">false</span>; <span class="comment">//结束该次判断</span></span><br><span class="line">                    <span class="keyword">this</span>.grid[(step+<span class="number">1</span>)/<span class="number">4</span>][(step+<span class="number">1</span>)%<span class="number">4</span>] = -<span class="number">2</span>;</span><br><span class="line">                    mark[i] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            DFS(step+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">this</span>.grid[(step+<span class="number">1</span>)/<span class="number">4</span>][(step+<span class="number">1</span>)%<span class="number">4</span>] = -<span class="number">2</span>;</span><br><span class="line">            mark[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接续加油~~~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 有条件的全排列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS--剪邮票</title>
      <link href="/2021/10/18/DFS-%E5%89%AA%E9%82%AE%E7%A5%A8/"/>
      <url>/2021/10/18/DFS-%E5%89%AA%E9%82%AE%E7%A5%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="DFS–剪邮票"><a href="#DFS–剪邮票" class="headerlink" title="DFS–剪邮票"></a>DFS–剪邮票</h1><h2 id="问题简介"><a href="#问题简介" class="headerlink" title="问题简介"></a>问题简介</h2><p> 有12张连在一起的12生肖的邮票。现在你要从中剪下5张来，要求必须是连着的。（仅仅连接一个角不算相连）比如，图中，粉红色所示部分就是合格的剪取。</p><p> <img src="/articleImg/28_article/image1.png" alt="image1"></p><p>请你计算，一共有多少种不同的剪取方法。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li><p>定义一个1*12的一维数组[]numberSet编上{1,1,1,1,1,1,1,0,0,0,0,0}，其中0代表该位置被剪了下来。对numberSet数组进行<strong>去重</strong>全排列，全排列很简单，关键是去重！！关于去重部分的思路我在前面的博客，已单独列出。</p></li><li><p>得到去重全排列之后，将一维数组转化成对应的3*4二维数组，进行连通性检测就可以了，如果联通则本次剪裁可以纳入answer。连通性检测用到的回溯的思想，注意这题的DFS没有用到for。其实也可以给改成用for。4个方向嘛。</p></li><li><p>第一个版本代码，是我用迷宫求解中的代码，改编的得到的测试连通性代码。因为可以把剪下来把减下来的邮票（0）当成可走路径，把未被减下来的邮票（1）当成墙。重点是我不设置出口重点，也就是说，通过递归之后，会将减下来的邮票（该连通域下所有可走路径）都置为3，且回到起点startx，starty。当回到起点时，我只需要判断map中是否还有没走的路径（0）即可~</p></li></ul><h2 id="第一个版本代码"><a href="#第一个版本代码" class="headerlink" title="第一个版本代码"></a>第一个版本代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">package com.zhanglei;</span><br><span class="line"></span><br><span class="line">//蓝桥杯真题 剪邮票</span><br><span class="line">public class Cut_the_stamps &#123;</span><br><span class="line">    private int [][] num_matrix = new int[3][4]; //存放1~12</span><br><span class="line">    private int [][] stamp_matrix = new int[3][4]; //存放这次减下来的邮票，1代表未剪下，0代表被剪下</span><br><span class="line">    private int[][]dir= &#123;&#123;0,1&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;,&#123;1,0&#125;&#125;; //每个位置都可以走四个方向</span><br><span class="line">    private int ans = 0;</span><br><span class="line"></span><br><span class="line">//核心算法在这里</span><br><span class="line">public boolean setWay(int x,int y,int startx, int starty)&#123;//x y 代表此次开始的坐标</span><br><span class="line"></span><br><span class="line">        if(x&lt;0||x&gt;2||y&lt;0||y&gt;3)&#123;  //发生越界</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(stamp_matrix[x][y]==0)&#123;  //表明该点还么有走过，可以进行寻路递归</span><br><span class="line"></span><br><span class="line">            //首先将该点标记为2（已走标记）</span><br><span class="line">            stamp_matrix[x][y]=2;</span><br><span class="line"></span><br><span class="line">            if(setWay(x+1,y,startx,starty))&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(setWay(x,y-1,startx,starty))&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(setWay(x-1,y,startx,starty))&#123;  //没找到路径，因为这里写成i+1</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(setWay(x,y+1,startx,starty))&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                if(x==startx&amp;&amp;y==starty)&#123; //说明递归回到了起点</span><br><span class="line">                    int count = 0;//记录矩阵中有多少个3</span><br><span class="line">                    for (int m = 0; m &lt; 3; m++) &#123;</span><br><span class="line">                        for (int n = 0; n &lt; 4; n++) &#123;</span><br><span class="line">                           if(stamp_matrix[m][n] == 3)</span><br><span class="line">                               count++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(count == 5)</span><br><span class="line">                        return true;</span><br><span class="line">                    else</span><br><span class="line">                        return false;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;//表明这个点不能再走，可能是1（墙），2（已走过），3（死路）</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Permutation &lt;Integer&gt;permutation = new &lt;Integer&gt;Permutation(); //创建一个可以进行全排列的类</span><br><span class="line">        Cut_the_stamps cut_the_stamps = new Cut_the_stamps();</span><br><span class="line">        Integer []numberSet = &#123;1,1,1,1,1,1,1,0,0,0,0,0&#125;;</span><br><span class="line">        //初始化 num_matrix</span><br><span class="line">        int k = 1;</span><br><span class="line">        for (int[] num_matrix : cut_the_stamps.num_matrix) &#123;</span><br><span class="line">            for (int i = 0; i &lt; num_matrix.length; i++) &#123;</span><br><span class="line">                num_matrix[i] = k;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; 4; j++) &#123;</span><br><span class="line">                cut_the_stamps.stamp_matrix[i][j] = numberSet[i*4+j];</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        permutation.permutation(numberSet,0);</span><br><span class="line">        //System.out.println(&quot;arrayList的大小为：&quot;+permutation.arrayList.size());</span><br><span class="line">        int startx = -1,starty = -1;</span><br><span class="line">        for (Integer[] integers : permutation.arrayList) &#123;</span><br><span class="line">            startx = -1;</span><br><span class="line">            starty = -1;</span><br><span class="line">            for (int i = 0; i &lt; numberSet.length; i++) &#123;</span><br><span class="line">                numberSet[i] = integers[i];</span><br><span class="line">                if(integers[i]==0&amp;&amp; startx==-1)&#123;</span><br><span class="line">                    startx = i/4;</span><br><span class="line">                    starty = i%4;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //为stamp_matrix 重新附上0 1 初值，相当于重新减一次邮票</span><br><span class="line">            for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">                for (int j = 0; j &lt; 4; j++) &#123;</span><br><span class="line">                    cut_the_stamps.stamp_matrix[i][j] = numberSet[i*4+j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;--------------------&quot;);</span><br><span class="line">            boolean check = cut_the_stamps.setWay(startx, starty, startx, starty); //第一个版本代码</span><br><span class="line"></span><br><span class="line">//            cut_the_stamps.dfs(startx,starty);  //第二个版本代码</span><br><span class="line">//            boolean check = cut_the_stamps.IsContain2(cut_the_stamps.stamp_matrix, 0); //第二个版本代码</span><br><span class="line"></span><br><span class="line">            if(check)</span><br><span class="line">                cut_the_stamps.ans++;</span><br><span class="line">            //System.out.println(&quot;是否连通：&quot;+ check);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;不重复剪邮票的方式共有：&quot;+permutation.count);</span><br><span class="line">        System.out.println(&quot;可以连通，符合题意的种类共有：&quot;+cut_the_stamps.ans);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //获取numberSet的非重复全排列</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean IsContain(int[]arr,int num)&#123;</span><br><span class="line">        for (int m : arr) &#123;</span><br><span class="line">            if(m == num)</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;//不包含</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第二个版本代码"><a href="#第二个版本代码" class="headerlink" title="第二个版本代码"></a>第二个版本代码</h2><ul><li>这个版本★处的代码，可以用for循环生成这四路递归。main函数和第一个版本的一样，这里就不再贴一次了</li><li>这个直接在边多路递归，边将走过的路径置为墙，算法效率更高。相比之下，第一个版本的代码就有点画蛇添足。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.zhanglei;</span><br><span class="line"></span><br><span class="line">//蓝桥杯真题 剪邮票</span><br><span class="line">public class Cut_the_stamps &#123;</span><br><span class="line">   </span><br><span class="line">   //整个函数返回代表，该连通域下已全部为墙，无路可走！</span><br><span class="line">    void dfs(int x,int y)&#123;  //DFS之后判断里面是不是纯1，代表联通</span><br><span class="line">        if(x&gt;2||x&lt;0||y&gt;3||y&lt;0) return ;</span><br><span class="line">        //运行到这里，说明已经越界了，则需要返回上一级的dfs()，然后换个方向继续寻找</span><br><span class="line">        if(stamp_matrix[x][y]==1) return ;</span><br><span class="line">        //这里，就是这个点不是需要剪的位置，则返回上一级的dfs()函数，</span><br><span class="line">        //继续执行未完成的dfs()函数，也就是换个方向继续找</span><br><span class="line">        stamp_matrix[x][y]=1;    //找到了，则将这个点标记</span><br><span class="line">        dfs(x+1,y); //★</span><br><span class="line">        dfs(x,y+1);//★</span><br><span class="line">        dfs(x-1,y);//★</span><br><span class="line">        dfs(x,y-1);//★</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean IsContain2(int[][]arr,int num)&#123;</span><br><span class="line">        for (int[] ints : arr) &#123;</span><br><span class="line">            for (int anInt : ints) &#123;</span><br><span class="line">                if(anInt == num)</span><br><span class="line">                    return false;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        return true;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>继续加油~~~！！！！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 连通性检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS--八皇后问题</title>
      <link href="/2021/10/18/DFS-%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"/>
      <url>/2021/10/18/DFS-%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="DFS–八皇后问题"><a href="#DFS–八皇后问题" class="headerlink" title="DFS–八皇后问题"></a>DFS–八皇后问题</h1><h2 id="问题简介"><a href="#问题简介" class="headerlink" title="问题简介"></a>问题简介</h2><p>八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出:在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即:任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法(92)。</p><p>这里列出一种结果，如下图：</p><p> <img src="/articleImg/27_article/image1.png" alt="image1"></p><h2 id="第一个版本思路及代码"><a href="#第一个版本思路及代码" class="headerlink" title="第一个版本思路及代码"></a>第一个版本思路及代码</h2><p><strong>思路</strong>：当我写八皇后题目的时候很自然的就想到了DFS，</p><ul><li>利用一个for，循环八次，产生八路递归，为什么是八次呢？因为是一个8*8的方格，所以每一行会有一个皇后，每一个皇后在每一行上可以有八种位置选择（这里选择的是列数）。</li><li>DFS函数传入step，代表递归深度，我在这里也就吧step，当成每次放皇后的行数。当step == 8的时候，递归基成立，返回结果！</li><li>这里的check_around函数写的比较暴力，第二个版本的较为巧妙</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解决八皇后排列问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Eight_queen</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][]mark = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Eight_queen eight_queen = <span class="keyword">new</span> Eight_queen();</span><br><span class="line">        eight_queen.DFS(<span class="number">0</span>,eight_queen.mark);</span><br><span class="line">        System.out.println(<span class="string">&quot;八皇后走法一共有：&quot;</span>+eight_queen.count+<span class="string">&quot;种&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 核心算法在这里</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> step,<span class="keyword">int</span> [][]mark)</span></span>&#123; <span class="comment">//这里的step还是挺关键的</span></span><br><span class="line">        <span class="keyword">if</span>(step == <span class="number">8</span>)&#123; <span class="comment">//说明已经全部走完</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">//step从0~7</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.check_around(mark,step,i))&#123; <span class="comment">//代表周围ok，可以放一个皇后</span></span><br><span class="line">                mark[step][i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">this</span>.DFS(step+<span class="number">1</span>,mark);</span><br><span class="line">                <span class="comment">//当走到这一步的时候说明死路了</span></span><br><span class="line">                <span class="comment">//收回</span></span><br><span class="line">                mark[step][i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//返回上一级DFS</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check_around</span><span class="params">(<span class="keyword">int</span>[][]arr,<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span></span>&#123; <span class="comment">//row，col代表要检查元素的位置</span></span><br><span class="line">        <span class="keyword">int</span> length = <span class="keyword">this</span>.get_length(arr);</span><br><span class="line">        <span class="keyword">int</span> height = <span class="keyword">this</span>.get_height(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查同一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][col] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row; i &lt;height ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][col] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里进行说明，其实没有必要去检查同一行，因为八皇后，每个皇后都在不同行</span></span><br><span class="line">        <span class="comment">//这一点再for 循环下的多路递归种，利用step进行不同行的区分</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//检查左斜线 \</span></span><br><span class="line">        <span class="keyword">int</span> temp1 = col;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row; i &lt; height; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=height||temp1&gt;=length||i&lt;<span class="number">0</span>||temp1&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][temp1] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp1++;</span><br><span class="line">        &#125;</span><br><span class="line">        temp1 = col;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=height||temp1&gt;=length||i&lt;<span class="number">0</span>||temp1&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][temp1] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp1--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查右斜线 /</span></span><br><span class="line">        <span class="keyword">int</span> temp2 = col;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row; i &lt; height; i++,temp2--) &#123; <span class="comment">//★ 注意这个for</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=height||temp2&gt;=length||i&lt;<span class="number">0</span>||temp2&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][temp2] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//temp2--;</span></span><br><span class="line">        &#125;</span><br><span class="line">        temp2 = col;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=height||temp2&gt;=length||i&lt;<span class="number">0</span>||temp2&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][temp2] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get_height</span><span class="params">(<span class="keyword">int</span>[][]map)</span></span>&#123; <span class="comment">//返回二维数组有多少行</span></span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : map) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : row) &#123;</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get_length</span><span class="params">(<span class="keyword">int</span>[][]map)</span></span>&#123; <span class="comment">//返回二维数组每一行有多少元素</span></span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : map) &#123;</span><br><span class="line">            temp++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第二个版本代码"><a href="#第二个版本代码" class="headerlink" title="第二个版本代码"></a>第二个版本代码</h2><p>这里主要修改了check_around()函数，修改的地方主要有：</p><ul><li>用array[8]数组记录每个皇后的左边，下标i对应行数，值array[i]对应皇后所在的列数。（如果不用一个一维数组去记录皇后的位置的话，后面在利用斜率判断是否同一斜线时，还要去遍历整个map，去寻找已放置的皇后，这个复杂度就上去了，不推荐）</li><li>利用斜率判断皇后们是不是同处一条斜线</li><li>直接利用array[i]判断是不是同处一列</li><li>核心思想还是DFS</li><li>★★★用斜率判断是否同一斜线中的*1.0非常重要，不加的话会变成整型数字进行除，一定要转换为浮点数的除法★★★</li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解决八皇后排列问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Eight_queen</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Eight_queen eight_queen = <span class="keyword">new</span> Eight_queen();</span><br><span class="line">        eight_queen.DFS(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;八皇后走法一共有：&quot;</span>+eight_queen.count+<span class="string">&quot;种&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> step)</span></span>&#123; <span class="comment">//这里的step还是挺关键的</span></span><br><span class="line">        <span class="keyword">if</span>(step == <span class="number">8</span>)&#123; <span class="comment">//说明已经全部走完</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">//step从0~7</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span> ; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.check_around2(step,i))&#123; <span class="comment">//代表周围ok，可以放一个皇后</span></span><br><span class="line">                <span class="keyword">if</span>(array[<span class="number">0</span>] == <span class="number">0</span> &amp;&amp;  array[<span class="number">1</span>] == <span class="number">4</span>)&#123;</span><br><span class="line">                    System.out.println();</span><br><span class="line">                &#125;</span><br><span class="line">                array[step] = i;</span><br><span class="line">              </span><br><span class="line">                <span class="keyword">this</span>.DFS(step+<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//当走到这一步的时候说明死路了</span></span><br><span class="line">                <span class="comment">//收回</span></span><br><span class="line">                array[step] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//返回上一级DFS</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check_around2</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="keyword">this</span>.get_length(arr);</span><br><span class="line">        <span class="keyword">int</span> height = <span class="keyword">this</span>.get_height(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//利用斜率检查同一斜线</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="comment">//★★★这里的的*1.0非常重要，不加的话会变成整型数字进行除★★★</span></span><br><span class="line">            <span class="comment">// 比如会出现 5/3 = 1的情况，所以这里要转换为浮点数的触发~</span></span><br><span class="line">            <span class="keyword">if</span>(Math.abs((array[i]-col)*<span class="number">1.0</span>/(i-row)) == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查同一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(col == array[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查同一行</span></span><br><span class="line">        <span class="comment">//多路递归中，每次都根据step的值从下一行开始的，所以在在这里并不需要考虑同一行是否有多个皇后</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可见第二个版本的代码简化了很多，也巧妙很多，回头看看自己的一手代码，真的不忍直视，泪目~~</p><p>自己还要多加油努力啊，成为一个代码风格优美的程序员！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 迷宫求解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS--迷宫求解</title>
      <link href="/2021/10/17/DFS-%E8%BF%B7%E5%AE%AB%E6%B1%82%E8%A7%A3/"/>
      <url>/2021/10/17/DFS-%E8%BF%B7%E5%AE%AB%E6%B1%82%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="DFS–迷宫求解"><a href="#DFS–迷宫求解" class="headerlink" title="DFS–迷宫求解"></a>DFS–迷宫求解</h1><p>迷宫求解问题分为，1：求出一条路径即可。2：求出所有路径并求出最短路径。下面我对这两种情况都做出记录说明~</p><h2 id="只求一条路径"><a href="#只求一条路径" class="headerlink" title="只求一条路径"></a>只求一条路径</h2><p><strong>思路</strong>：这个函数里是采用的事递归回溯的思想。每走一步都可以选择四个方向。直到找到终点，所有压栈的递归方法逐个进行return。这里需要关注的地方是，map [ i ] [ j ]置为三的时刻，为死路，将当前的标志2置为3，而不是直接由0置为3的。</p><p>这段程序中有一个setway(),和一个setway2()。区别就是setway()可以将死路置为标志位3，因为这里面用的是if判断。setway2()的话则不可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"><span class="comment">//        1 1 1 1 1 1 1</span></span><br><span class="line"><span class="comment">// map    1 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">//        1 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">//        1 1 1 0 0 0 1</span></span><br><span class="line"><span class="comment">//        1 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">//        1 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">//        1 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">//        1 1 1 1 1 1 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mazeSolving</span> </span>&#123;</span><br><span class="line">    <span class="comment">//核心算法在这里</span></span><br><span class="line">    <span class="comment">//使用递归回溯来给小球找路</span></span><br><span class="line">    <span class="comment">//说明</span></span><br><span class="line">    <span class="comment">//1. map 表示地图</span></span><br><span class="line">    <span class="comment">//2. i,j 表示从地图的哪个位置开始出发 (1,1)</span></span><br><span class="line">    <span class="comment">//3. 如果小球能到 map[6][5] 位置， 则说明通路找到.</span></span><br><span class="line">    <span class="comment">//4. 约定： 当 map[i][j] 为 0 表示该点没有走过 当为 1 表示墙 ； 2 表示通路可以走 ； 3 表示该点已经走过， 但是走不通</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setWay</span><span class="params">(<span class="keyword">int</span>[][]map,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="keyword">this</span>.get_length(map)-<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> height = <span class="keyword">this</span>.get_height(map)-<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(map[height][length]==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//★如果map[i][j]!=0 就直接return,表明该点是墙1、已走路径2、死路3★</span></span><br><span class="line">            <span class="keyword">if</span>(map[i][j]==<span class="number">0</span>)&#123;  <span class="comment">//表明该点还么有走过，可以进行寻路递归</span></span><br><span class="line">                <span class="comment">//首先将该点标记为2（已走标记）</span></span><br><span class="line">                map[i][j]=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(setWay(map,i+<span class="number">1</span>,j))&#123;  <span class="comment">//★最核心的就是这四句话★</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(setWay(map,i,j-<span class="number">1</span>))&#123; <span class="comment">//★最核心的就是这四句话★</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(setWay(map,i-<span class="number">1</span>,j))&#123;  <span class="comment">//★最核心的就是这四句话★</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(setWay(map,i,j+<span class="number">1</span>))&#123; <span class="comment">//★最核心的就是这四句话★</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    map[i][j] = <span class="number">3</span>;  <span class="comment">////★这里表示该点的四个方向都没通过判断，为死路，则置为3★</span></span><br><span class="line">                    <span class="comment">//这里的置3只是为了好看，其实这里不写置3也会的一个答案</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//表明这个点不能再走，可能是1（墙），2（已走过），3（死路）</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setWay2</span><span class="params">(<span class="keyword">int</span>[][]map,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = <span class="keyword">this</span>.get_length(map)-<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> height = <span class="keyword">this</span>.get_height(map)-<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(map[height][length]==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(map[i][j]==<span class="number">0</span>)&#123;  <span class="comment">//表明该点还么有走过，可以进行寻路递归</span></span><br><span class="line">                map[i][j]=<span class="number">2</span>;</span><br><span class="line">                setWay(map,i,j+<span class="number">1</span>);</span><br><span class="line">                setWay(map,i+<span class="number">1</span>,j);</span><br><span class="line">                setWay(map,i,j-<span class="number">1</span>);</span><br><span class="line">                setWay(map,i-<span class="number">1</span>,j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//表明这个点不能再走，可能是1（墙），2（已走过），3（死路）</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get_length</span><span class="params">(<span class="keyword">int</span>[][]map)</span></span>&#123; <span class="comment">//返回二维数组的长度</span></span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : map) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : row) &#123;</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get_height</span><span class="params">(<span class="keyword">int</span>[][]map)</span></span>&#123; <span class="comment">//返回二维数组的高度</span></span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : map) &#123;</span><br><span class="line">                temp++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="遍历出迷宫中所有路径，并求出最短路径"><a href="#遍历出迷宫中所有路径，并求出最短路径" class="headerlink" title="遍历出迷宫中所有路径，并求出最短路径"></a>遍历出迷宫中所有路径，并求出最短路径</h2><p><strong>思路</strong>：一般需要遍历出所有的可能情况，就需要用到DFS了，也就是利用for循环才生多路递归。这里一定要深刻理解这里面的多路到底指的是哪方面的多路。如迷宫求解的4路递归，指的就是4个方向的选择；如八皇后的8路递归，指的就是每一行八个方格的选择。</p><p>其实我个人觉得DFS就相当于是一个求全排列的过程，它一定会把每一个点的所有情况都考虑到。</p><p>这里给出求迷宫所有路径的方法，求最短路径的思路也很简单。只需要比较step的大小即可~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        1 1 1 1 1 1 1</span></span><br><span class="line"><span class="comment">// map    1 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">//        1 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">//        1 1 1 0 0 0 1</span></span><br><span class="line"><span class="comment">//        1 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">//        1 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">//        1 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">//        1 1 1 1 1 1 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mazeSolving</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span>  min = <span class="number">999</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][]dir= &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;; <span class="comment">//每个位置都可以走四个方向</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] short_path = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> step,<span class="keyword">int</span>[][]map,<span class="keyword">int</span>[][]mark)</span></span>&#123; <span class="comment">//x,y为当前位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tx,ty;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">6</span>&amp;&amp;y==<span class="number">5</span>)&#123;  <span class="comment">//表明已找到出口</span></span><br><span class="line">            <span class="keyword">if</span>(step&lt;min)&#123;</span><br><span class="line">                min = step;</span><br><span class="line">                short_path = mark;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//返回</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//主要想法就是遍历出所有的可能性</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;=<span class="number">3</span> ; i++) &#123; <span class="comment">//利用for循环产生多路递归！</span></span><br><span class="line">            tx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">            ty = y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(map[tx][ty]==<span class="number">1</span>)&#123; <span class="comment">//表明该点是墙</span></span><br><span class="line">                <span class="keyword">continue</span>;  <span class="comment">//刚开始这里写成了 return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(map[tx][ty] == <span class="number">0</span> &amp;&amp; mark[tx][ty] == <span class="number">0</span>)&#123;</span><br><span class="line">                mark[tx][ty] = <span class="number">2</span>; <span class="comment">//标记该点已经走过</span></span><br><span class="line">                <span class="keyword">this</span>.DFS(tx,ty,step+<span class="number">1</span>,map,mark); <span class="comment">//注意这里用到了mark数组，且传入step+1;</span></span><br><span class="line">                mark[tx][ty] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">//执行到这里，这层dfs()函数已经结束，则要回到上一层dfs()函数</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几天由于集中刷题，自我感觉对DFS的理解还是很深刻的，可以灵活运用解出一些题目。希望自己后面能多多复习，巩固这个概念！</p><p>继续加油~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 迷宫求解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS求数组元素的全排列</title>
      <link href="/2021/10/15/DFS%E6%B1%82%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97/"/>
      <url>/2021/10/15/DFS%E6%B1%82%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="基于交换元素（选择首元素）的全排列"><a href="#基于交换元素（选择首元素）的全排列" class="headerlink" title="基于交换元素（选择首元素）的全排列"></a>基于交换元素（选择首元素）的全排列</h1><p>这里例如求数集{0，1，2，3}的全排列。使用DFS+回溯的方式解决。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>针对这种全排列的问题，一般都是用多路递归的方式，不同于之前接触的单路分支，多路分支一般都使用一个for循环创建多路，在这里，就是先将0，1，2，3每个数字都遍历到，每个取出来轮流当第一个元素，每一个分支都负责把剩下的三个元素进行再次的全排列。</p><p>比如第一个取出的数字一定是0，那么剩下的数字就是1，2，3。这里就创建了第二个分支，在这个分支里面，我们第一个取出的一定是1，当我们取出1之后，我们还剩下两个数字，2，3，这里我们又创建了第三个分支，在第三个分支里面，我们第一个取出的就是2，2之后我们就只剩下一个元素3了，当我们到了第四个分支，也就是只有一个节点的分支的时候，我们创建的分支数目和全排列出的结果的长度一致，都是4。那么我们就进行第一次输出。</p><p>接下来，我们要做的就是回到上一个分支，看看3这个节点有没有兄弟节点，若没有，跳回上一层节点，看看2这个节点有没有兄弟节点。</p><p>当然，这里想要实现各种排列输出，我们就需要一个基本动作就是交换元素之间的顺序，比如0132，对于数组0123我们就需要把[2]和[3]这两个下标的元素进行一个交换。<strong>交换的意思就是</strong>，<strong>在这个分支里面，我想要让下标为[3]的元素当一次首元素，然后对这个元素进行分支</strong>。最后进行输出。输出完事儿之后跳回上一个分支，如果这个分支有兄弟节点，就进入，否则，再跳回上一个分支。下面就是第一个分支进入0开头的排列的情况</p><p> <img src="/articleImg/25_article/image1.png" alt="image1"></p><h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><p>这里的全排列是基于交换的，选取首元素，进行回溯递归的思想。可以对任意的数组进行递归。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Permutation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> []arr = &#123;<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>&#125;;</span><br><span class="line">        Permutation permutation = <span class="keyword">new</span> Permutation();</span><br><span class="line">        permutation.permutation(arr,<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;计数种类：&quot;</span>+permutation.count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="keyword">char</span>[] chs, <span class="keyword">int</span> step )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(step==chs.length-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">                System.out.print(chs[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">//Arrays.toString(chs);</span></span><br><span class="line">            <span class="comment">//如果已经到了数组的最后一个元素，前面的元素已经排好，输出。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=step;i&lt;=chs.length-<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//把第一个元素分别与后面的元素进行交换，递归的调用其子数组进行排序</span></span><br><span class="line">            Swap(chs,i,step);</span><br><span class="line">            permutation(chs,step+<span class="number">1</span>);</span><br><span class="line">            Swap(chs,i,step);</span><br><span class="line">            <span class="comment">//子数组排序返回后要将第一个元素交换回来。</span></span><br><span class="line">            <span class="comment">//如果不交换回来会出错，比如说第一次1、2交换，第一个位置为2，子数组排序返回后如果不将1、2</span></span><br><span class="line">            <span class="comment">//交换回来第二次交换的时候就会将2、3交换，因此必须将1、2交换使1还是在第一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">char</span> chs[],<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp;</span><br><span class="line">        temp = chs[i];</span><br><span class="line">        chs[i] = chs[j];</span><br><span class="line">        chs[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对程序中 step = 0,i = 3时，进行手写记录。思路就是回溯递归！</p><p> <img src="/articleImg/25_article/image2.png" alt="image2"></p><h2 id="基于标记数组辅助的全排列"><a href="#基于标记数组辅助的全排列" class="headerlink" title="基于标记数组辅助的全排列"></a>基于标记数组辅助的全排列</h2><p>这里给出代码，这个代码时DFS的基础模板，建议深刻理解。</p><p>具体理解看标记出的注释即可，自我感觉，下面这份代码属于基础代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fullPermutation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] mark = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] box = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        fullPermutation fullPermutation = <span class="keyword">new</span> fullPermutation();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            fullPermutation.mark[i] = <span class="number">0</span>;</span><br><span class="line">            fullPermutation.box[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fullPermutation.dfs(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;总数&quot;</span>+fullPermutation.count);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//核心代码在这里</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(step == num+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//注意这个return在if判断里面</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123; <span class="comment">//遍历看哪个号码还没有使用</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.mark[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.mark[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">this</span>.box[step] = i; <span class="comment">//这里的i可以换成数组元素，数组的维度一定要与mark[]数组的维度一致！</span></span><br><span class="line">                <span class="keyword">this</span>.dfs(step+<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//重新尝试，退回到上一个点的位置</span></span><br><span class="line">                <span class="keyword">this</span>.mark[i] = <span class="number">0</span>;  <span class="comment">//注意这里是什么时候重新赋值为0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <img src="/articleImg/25_article/image3.png" alt="image3"></p><h1 id="注"><a href="#注" class="headerlink" title="注"></a>注</h1><p>这里的全排列并没有考虑重复的情况。这里简单的考虑为：先将全排列后的结果放在一个集合中，若后续全排列出来的结果，在集合中已经存在，则不加入这次排列结果。</p><p>若后续有复杂度更低的想法，会在这里进行更新补充。</p><p>继续加油~</p><p>——————————————————2021.10.16 22.40分  更新——————————————————</p><p>今天做了一题剪邮票，12位数的全排列好像有6亿多种，晕(((φ(◎ロ◎;)φ)))，用Hashset去重时，可把电脑累的够呛。这里我在网上检索到了一种去重方式，感觉设计的很巧妙。我自己也理解了好一会，才搞懂。而且网上很多的人对这句代码并没有太多的解释。。。难道是大家都默认这是句代码没难度吗，呜呜呜。。。</p><p>这里我给出去重代码，并附上自己的理解思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSwap</span><span class="params">(T[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; j; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[j] == array[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这个函数的主要作用是判断：从start（step）元素开始，到将要被交换元素的前一个位置，这个区间中有没有与值与即将被交换元素的值相等的元素</strong></p><p>也就是说：全排列中去掉重复的规则——去重的全排列就是从第一个数字起每个数分别与它后面非重复出现的数字交换。</p><p>那么如何去理解这句话呢，我是这么分析的，如果step~(n-1)位置上如果有值与n位置上值相等的元素。那么step与n位置处的交换值，就是毫无意义的，因为，此时这个排列<strong>属于</strong>当step和特殊位置（指与n对应的值相等）的交换后的全排列的子集。即会产生重复！！！</p><p><img src="/articleImg/25_article/image4.png" alt="image4"></p><p>重新给出去重后的全排列代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">permutation</span><span class="params">(T[] chs, <span class="keyword">int</span> step )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(step==chs.length-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Integer[] chs_copy = <span class="keyword">new</span> Integer[<span class="number">12</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">                chs_copy[i] = (Integer) chs[i];</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=step;i&lt;=chs.length-<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//把第一个元素分别与后面的元素进行交换，递归的调用其子数组进行排序</span></span><br><span class="line">            <span class="keyword">if</span>(isSwap(chs,step,i))&#123;</span><br><span class="line">                Swap(chs,i,step);</span><br><span class="line">                permutation(chs,step+<span class="number">1</span>);</span><br><span class="line">                Swap(chs,i,step);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//子数组排序返回后要将第一个元素交换回来。</span></span><br><span class="line">            <span class="comment">//如果不交换回来会出错，比如说第一次1、2交换，第一个位置为2，子数组排序返回后如果不将1、2</span></span><br><span class="line">            <span class="comment">//交换回来第二次交换的时候就会将2、3交换，因此必须将1、2交换使1还是在第一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>再给出一个举例分析:</p><p>去掉重复的全排列由于全排列就是从第一个数字起每个数分别与它后面的数字交换。我们先尝试加个这样的判断——如果一个数与后面的数字相同那么这二个数就不交换了。如122，第一个数与后面交换得212、221。然后122中第二数就不用与第三个数交换了，但对212，它第二个数与第三个数是不相同的，交换之后得到221。与由122中第一个数与第三个数交换所得的221重复了。所以这个方法不行。</p><p>换种思维，对122，第一个数1与第二个数2交换得到212，然后考虑第一个数1与第三个数2交换，此时由于第三个数等于第二个数，所以第一个数不再与第三个数交换。再考虑212，它的第二个数与第三个数交换可以得到解决221。此时全排列生成完毕。<br>这样我们也得到了在全排列中去掉重复的规则——去重的全排列就是从第一个数字起每个数分别与它后面非重复出现的数字交换。</p><p>继续加油~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS-数组全排列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>由八皇后问题引出----判断矩阵元素是否在同一斜线上</title>
      <link href="/2021/10/14/%E7%94%B1%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E5%BC%95%E5%87%BA-%E5%88%A4%E6%96%AD%E7%9F%A9%E9%98%B5%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E5%90%8C%E4%B8%80%E6%96%9C%E7%BA%BF%E4%B8%8A/"/>
      <url>/2021/10/14/%E7%94%B1%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E5%BC%95%E5%87%BA-%E5%88%A4%E6%96%AD%E7%9F%A9%E9%98%B5%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E5%90%8C%E4%B8%80%E6%96%9C%E7%BA%BF%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="由八皇后问题引出—-判断矩阵元素是否在同一斜线上"><a href="#由八皇后问题引出—-判断矩阵元素是否在同一斜线上" class="headerlink" title="由八皇后问题引出—-判断矩阵元素是否在同一斜线上"></a>由八皇后问题引出—-判断矩阵元素是否在同一斜线上</h1><h2 id="图1"><a href="#图1" class="headerlink" title="图1"></a>图1</h2><p> <img src="/articleImg/24_article/graph.png" alt="graph"></p><h2 id="图2"><a href="#图2" class="headerlink" title="图2"></a>图2</h2><p> <img src="/articleImg/24_article/graph2.png" alt="graph2"></p><p>如果该判断方法在八皇后中应用时，最好定义一个array[8]数组，存放以放置的皇后，在array数组中下标代表行数，数组值代表皇后所在列数。这样遍历起来会更方便。否则还要去遍历mark[][] [8] [8]二维数组。直接用array数组中对应的信息，去做判断效率很高！</p><p>用于其他算法，就直接使用即可~</p><p>继续加油！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 判断矩阵元素是否在同一斜线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Jetson上融合yolov5目标检测与双目摄像头测距</title>
      <link href="/2021/10/13/%E5%9C%A8Jetson%E4%B8%8A%E8%9E%8D%E5%90%88yolov5%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%8F%8C%E7%9B%AE%E6%91%84%E5%83%8F%E5%A4%B4%E6%B5%8B%E8%B7%9D/"/>
      <url>/2021/10/13/%E5%9C%A8Jetson%E4%B8%8A%E8%9E%8D%E5%90%88yolov5%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%8F%8C%E7%9B%AE%E6%91%84%E5%83%8F%E5%A4%B4%E6%B5%8B%E8%B7%9D/</url>
      
        <content type="html"><![CDATA[<h1 id="在Jetson上融合yolov5目标检测与双目摄像头测距"><a href="#在Jetson上融合yolov5目标检测与双目摄像头测距" class="headerlink" title="在Jetson上融合yolov5目标检测与双目摄像头测距"></a>在Jetson上融合yolov5目标检测与双目摄像头测距</h1><p>这几天都在做摄像头双目测距与yolov5识别的内容。主要想实现的功能是，将yolov5识别的物体，标注出距离左右摄像头的距离。到今天下午，已经可以实时处理USB双目摄像头采集的图像。在这里将相关的过程记录下来，以免遗忘。</p><h2 id="双目测距过程"><a href="#双目测距过程" class="headerlink" title="双目测距过程"></a>双目测距过程</h2><h3 id="使用Matlab进行双目标定"><a href="#使用Matlab进行双目标定" class="headerlink" title="使用Matlab进行双目标定"></a>使用Matlab进行双目标定</h3><h4 id="双目摄像头"><a href="#双目摄像头" class="headerlink" title="双目摄像头"></a>双目摄像头</h4><p>用的摄像头的uvc免驱的摄像头，这是非常爽的，插在nano的USB口上就可以使用，驱动yoloV5之后，效果如图</p><p><img src="/articleImg/18_article/yolo.png" alt="yolo"></p><ul><li><p>插入摄像头之后查看信息所需要的相关命令：<br/></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># shell 窗口下输入</span></span><br><span class="line">lsusb    <span class="comment"># 查看已存在的USB设备资源</span></span><br><span class="line">cat /dev/video*  <span class="comment"># 查看有几个摄像头设备 /dev/video0 代表0号摄像头   /dev/video1 代表1号摄像头 </span></span><br><span class="line"><span class="comment"># 主要也就是这两条命令来确认你的uvc免驱摄像头能不能使用</span></span><br></pre></td></tr></table></figure></li><li><p>确认可以使用后，肯定要驱动显示图像才好啊，下面给出我用的摄像头驱动显示代码<br/></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">AUTO = <span class="literal">False</span>  <span class="comment"># 自动拍照，或手动按s键拍照</span></span><br><span class="line">INTERVAL = <span class="number">2</span> <span class="comment"># 自动拍照间隔</span></span><br><span class="line"> </span><br><span class="line">cv2.namedWindow(<span class="string">&quot;left&quot;</span>)</span><br><span class="line">cv2.namedWindow(<span class="string">&quot;right&quot;</span>)</span><br><span class="line">camera = cv2.VideoCapture(<span class="number">0</span>)  <span class="comment"># 用几号摄像头就设置为几</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 设置分辨率 左右摄像机同一频率，同一设备ID；左右摄像机总分辨率1280x480；分割为两个640x480、640x480</span></span><br><span class="line">camera.<span class="built_in">set</span>(cv2.CAP_PROP_FRAME_WIDTH,<span class="number">1280</span>)</span><br><span class="line">camera.<span class="built_in">set</span>(cv2.CAP_PROP_FRAME_HEIGHT,<span class="number">480</span>)</span><br><span class="line"> </span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line">utc = time.time()</span><br><span class="line">folder = <span class="string">&quot;./SaveImage/&quot;</span> <span class="comment"># 拍照文件目录</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shot</span>(<span class="params">pos, frame</span>):</span></span><br><span class="line">    <span class="keyword">global</span> counter</span><br><span class="line">    path = folder + pos + <span class="string">&quot;_&quot;</span> + <span class="built_in">str</span>(counter) + <span class="string">&quot;.jpg&quot;</span></span><br><span class="line"> </span><br><span class="line">    cv2.imwrite(path, frame)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;snapshot saved into: &quot;</span> + path)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, frame = camera.read()</span><br><span class="line">    <span class="comment"># 裁剪坐标为[y0:y1, x0:x1] HEIGHT*WIDTH</span></span><br><span class="line">    left_frame = frame[<span class="number">0</span>:<span class="number">480</span>, <span class="number">0</span>:<span class="number">640</span>]</span><br><span class="line">    right_frame = frame[<span class="number">0</span>:<span class="number">480</span>, <span class="number">640</span>:<span class="number">1280</span>]</span><br><span class="line"> </span><br><span class="line">    cv2.imshow(<span class="string">&quot;left&quot;</span>, left_frame)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;right&quot;</span>, right_frame)</span><br><span class="line"> </span><br><span class="line">    now = time.time()</span><br><span class="line">    <span class="keyword">if</span> AUTO <span class="keyword">and</span> now - utc &gt;= INTERVAL:</span><br><span class="line">        shot(<span class="string">&quot;left&quot;</span>, left_frame)</span><br><span class="line">        shot(<span class="string">&quot;right&quot;</span>, right_frame)</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">        utc = now</span><br><span class="line"> </span><br><span class="line">    key = cv2.waitKey(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> key == <span class="built_in">ord</span>(<span class="string">&quot;q&quot;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">elif</span> key == <span class="built_in">ord</span>(<span class="string">&quot;s&quot;</span>):</span><br><span class="line">        shot(<span class="string">&quot;left&quot;</span>, left_frame)</span><br><span class="line">        shot(<span class="string">&quot;right&quot;</span>, right_frame)</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">camera.release()</span><br><span class="line">cv2.destroyWindow(<span class="string">&quot;left&quot;</span>)</span><br><span class="line">cv2.destroyWindow(<span class="string">&quot;right&quot;</span>)</span><br></pre></td></tr></table></figure><p>对双目摄像头的测试就到此为止了。</p></li></ul><h4 id="双目测距基本流程"><a href="#双目测距基本流程" class="headerlink" title="双目测距基本流程"></a><strong>双目测距基本流程</strong></h4><p>主要参考自 CSDN博主 ： <a href="https://blog.csdn.net/dulingwen">dulingwen</a></p><p>结起来，双目测距的大致流程如下：</p><p><img src="/articleImg/18_article/biaoding.png" alt="biaoding"></p><p>  在这里贴出代码，由于PCL库比较难装，这里将博主代码中的点云部分全部注释<br/></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> stereo.dianyuntu_yolo <span class="keyword">import</span> preprocess, undistortion, getRectifyTransform, draw_line, rectifyImage,\</span><br><span class="line">     stereoMatchSGBM, hw3ToN3</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> stereo <span class="keyword">import</span> stereoconfig_040_2</span><br><span class="line"></span><br><span class="line">image_width = <span class="number">1280</span> / <span class="number">2</span></span><br><span class="line">image_height = <span class="number">480</span></span><br><span class="line">skip_flag = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">detect():</span><br><span class="line">    <span class="comment"># .......将该段代码放在yolo代码中的 # Add bbox to image下</span></span><br><span class="line">     <span class="comment"># -----------------------------------------------------zl 9.15</span></span><br><span class="line">                        <span class="comment"># 识别框上中点坐标</span></span><br><span class="line">                        x = (xyxy[<span class="number">0</span>] + xyxy[<span class="number">2</span>]) / <span class="number">2</span></span><br><span class="line">                        y = (xyxy[<span class="number">1</span>] + xyxy[<span class="number">3</span>]) / <span class="number">2</span></span><br><span class="line">                        <span class="comment">#print(&quot; %s is  x: %d y: %d &quot; %(label,x,y) )</span></span><br><span class="line">                        skip_flag = <span class="literal">False</span></span><br><span class="line">                        <span class="keyword">if</span> (x &lt;= <span class="number">1280</span>):</span><br><span class="line">                            t3 = time_synchronized()</span><br><span class="line">    </span><br><span class="line">                            <span class="comment">################################</span></span><br><span class="line">                            <span class="comment">#stereo code</span></span><br><span class="line">                            p = <span class="string">&quot;test&quot;</span></span><br><span class="line">                            string = <span class="string">&#x27;&#x27;</span></span><br><span class="line">                            <span class="comment">#print(&quot;P is %d&quot; %p )</span></span><br><span class="line">                            <span class="comment"># 读取数据集的图片</span></span><br><span class="line">                            <span class="comment">#iml = cv2.imread(&#x27;./stereo/yolo/zuo/%szuo%d.bmp&#x27; %(string,p) )  # 左图</span></span><br><span class="line">                            <span class="comment">#imr = cv2.imread(&#x27;./stereo/yolo/you/%syou%d.bmp&#x27; %(string,p) )  # 右图</span></span><br><span class="line"></span><br><span class="line">                            <span class="comment">#iml = cv2.imread(&#x27;./stereo/yolo/zuo/%szuo%d.bmp&#x27; %(string,p) )  # 左图</span></span><br><span class="line">                            <span class="comment">#imr = cv2.imread(&#x27;./stereo/yolo/you/%syou%d.bmp&#x27; %(string,p) )  # 右图</span></span><br><span class="line">                            </span><br><span class="line">                            height_0, width_0 = im0.shape[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">                            <span class="comment">#print(&quot;width_0 =  %d &quot;  % width_0)</span></span><br><span class="line">                            <span class="comment">#print(&quot;height_0 = %d &quot;  % height_0)</span></span><br><span class="line"></span><br><span class="line">                            width_1 = width_0/<span class="number">2</span></span><br><span class="line">                            iml = im0[<span class="number">0</span>:<span class="built_in">int</span>(height_0), <span class="number">0</span>:<span class="built_in">int</span>(width_0/<span class="number">2</span>)]</span><br><span class="line">                            imr = im0[<span class="number">0</span>:<span class="built_in">int</span>(height_0), <span class="built_in">int</span>(width_0/<span class="number">2</span>):<span class="built_in">int</span>(width_0) ]</span><br><span class="line"></span><br><span class="line">                            height, width = iml.shape[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">                            <span class="comment">#cv2.imshow(&quot;iml&quot;,iml)</span></span><br><span class="line">                            <span class="comment">#cv2.imshow(&quot;imr&quot;,im0)</span></span><br><span class="line">                            <span class="comment">#cv2.waitKey(0)</span></span><br><span class="line"></span><br><span class="line">                            <span class="comment">#print(&quot;width =  %d &quot;  % width)</span></span><br><span class="line">                            <span class="comment">#print(&quot;height = %d &quot;  % height)</span></span><br><span class="line"></span><br><span class="line">                            <span class="comment"># 读取相机内参和外参</span></span><br><span class="line">                            config = stereoconfig_040_2.stereoCamera()</span><br><span class="line"></span><br><span class="line">                            <span class="comment"># 立体校正</span></span><br><span class="line">                            map1x, map1y, map2x, map2y, Q = getRectifyTransform(height, width, config)  <span class="comment"># 获取用于畸变校正和立体校正的映射矩阵以及用于计算像素空间坐标的重投影矩阵</span></span><br><span class="line">                            <span class="comment">#print(&quot;Print Q!&quot;)</span></span><br><span class="line">                            <span class="comment">#print(&quot;Q[2,3]:%.3f&quot;%Q[2,3])</span></span><br><span class="line">                            iml_rectified, imr_rectified = rectifyImage(iml, imr, map1x, map1y, map2x, map2y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                </span><br><span class="line">                            <span class="comment"># 绘制等间距平行线，检查立体校正的效果</span></span><br><span class="line">                            line = draw_line(iml_rectified, imr_rectified)</span><br><span class="line">                            <span class="comment">#cv2.imwrite(&#x27;./yolo/%s检验%d.png&#x27; %(string,p), line)</span></span><br><span class="line"></span><br><span class="line">                            <span class="comment"># 消除畸变</span></span><br><span class="line">                            iml = undistortion(iml, config.cam_matrix_left, config.distortion_l)</span><br><span class="line">                            imr = undistortion(imr, config.cam_matrix_right, config.distortion_r)</span><br><span class="line">                        </span><br><span class="line">                            <span class="comment"># 立体匹配</span></span><br><span class="line">                            iml_, imr_ = preprocess(iml, imr)  <span class="comment"># 预处理，一般可以削弱光照不均的影响，不做也可以</span></span><br><span class="line"></span><br><span class="line">                            iml_rectified_l, imr_rectified_r = rectifyImage(iml_, imr_, map1x, map1y, map2x, map2y)</span><br><span class="line">                            </span><br><span class="line">                            disp, _ = stereoMatchSGBM(iml_rectified_l, imr_rectified_r, <span class="literal">True</span>) </span><br><span class="line">                            <span class="comment">#cv2.imwrite(&#x27;./yolo/%s视差%d.png&#x27; %(string,p), disp)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            <span class="comment"># 计算像素点的3D坐标（左相机坐标系下）</span></span><br><span class="line">                            points_3d = cv2.reprojectImageTo3D(disp, Q)  <span class="comment"># 可以使用上文的stereo_config.py给出的参数</span></span><br><span class="line"></span><br><span class="line">                            <span class="comment">#points_3d = points_3d</span></span><br><span class="line"></span><br><span class="line">                            <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">                            #print(&quot;x is :%.3f&quot; %points_3d[int(y), int(x), 0] )</span></span><br><span class="line"><span class="string">                                print(&#x27;点 (%d, %d) 的三维坐标 (x:%.3fcm, y:%.3fcm, z:%.3fcm)&#x27; % (int(x), int(y), </span></span><br><span class="line"><span class="string">                                points_3d[int(y), int(x), 0]/10, </span></span><br><span class="line"><span class="string">                                points_3d[int(y), int(x), 1]/10, </span></span><br><span class="line"><span class="string">                                points_3d[int(y), int(x), 2]/10) )</span></span><br><span class="line"><span class="string">                            &#x27;&#x27;&#x27;</span></span><br><span class="line">                            count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            <span class="comment">#try:  暂时关闭</span></span><br><span class="line">                            <span class="comment"># points_3d = points_3d.numpy()</span></span><br><span class="line">                            <span class="built_in">print</span>(points_3d.shape)</span><br><span class="line">                            <span class="comment"># print(&quot;x的值为：&quot;,x , &quot;  y的值为：&quot;, y)</span></span><br><span class="line">                            <span class="keyword">if</span>(x &lt; image_width <span class="keyword">and</span> x &gt;= <span class="number">0</span> <span class="keyword">and</span> y&lt; image_height <span class="keyword">and</span> y&gt;=<span class="number">0</span>):</span><br><span class="line">                                <span class="keyword">while</span>( (points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">2</span>] &lt; <span class="number">0</span>) | (points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">2</span>] &gt; <span class="number">2500</span>) ):</span><br><span class="line"></span><br><span class="line">                                    <span class="comment"># print(&quot;x的值为：&quot;,x , &quot;  y的值为：&quot;, y)</span></span><br><span class="line"></span><br><span class="line">                                    count += <span class="number">1</span></span><br><span class="line">                                    x += count</span><br><span class="line"></span><br><span class="line">                                    <span class="comment"># 个人添加判断程序，x y的值一旦发生更新就需要进行判断</span></span><br><span class="line">                                    <span class="keyword">if</span>(x &gt;= image_width <span class="keyword">or</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> y&gt;= image_height <span class="keyword">or</span> y&lt;<span class="number">0</span>):</span><br><span class="line">                                        skip_flag = <span class="literal">True</span></span><br><span class="line">                                        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">if</span>( <span class="number">0</span> &lt; points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">2</span>] &lt; <span class="number">2300</span> ):</span><br><span class="line">                                        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                                    y += count</span><br><span class="line"></span><br><span class="line">                                    <span class="comment"># 个人添加判断程序，x y的值一旦发生更新就需要进行判断</span></span><br><span class="line">                                    <span class="keyword">if</span>(x &gt;= image_width <span class="keyword">or</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> y&gt;= image_height <span class="keyword">or</span> y&lt;<span class="number">0</span>):</span><br><span class="line">                                        skip_flag = <span class="literal">True</span></span><br><span class="line">                                        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">if</span>( <span class="number">0</span> &lt; points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">2</span>] &lt; <span class="number">2300</span> ):</span><br><span class="line">                                        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                                    count += <span class="number">1</span></span><br><span class="line">                                    x -= count</span><br><span class="line"></span><br><span class="line">                                    <span class="comment"># 个人添加判断程序，x y的值一旦发生更新就需要进行判断</span></span><br><span class="line">                                    <span class="keyword">if</span>(x &gt;= image_width <span class="keyword">or</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> y&gt;= image_height <span class="keyword">or</span> y&lt;<span class="number">0</span>):</span><br><span class="line">                                        skip_flag = <span class="literal">True</span></span><br><span class="line">                                        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">if</span>( <span class="number">0</span> &lt; points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">2</span>] &lt; <span class="number">2300</span> ):</span><br><span class="line">                                        <span class="keyword">break</span></span><br><span class="line">                                    y -= count</span><br><span class="line"></span><br><span class="line">                                    <span class="comment"># 个人添加判断程序，x y的值一旦发生更新就需要进行判断</span></span><br><span class="line">                                    <span class="keyword">if</span>(x &gt;= image_width <span class="keyword">or</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> y&gt;= image_height <span class="keyword">or</span> y&lt;<span class="number">0</span>):</span><br><span class="line">                                        skip_flag = <span class="literal">True</span></span><br><span class="line">                                        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">if</span>( <span class="number">0</span> &lt; points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">2</span>] &lt; <span class="number">2300</span> ):</span><br><span class="line">                                        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                                    <span class="comment">#if(count%2==1):</span></span><br><span class="line">                                     <span class="comment">#   x += 1</span></span><br><span class="line">                                    <span class="comment">#else:</span></span><br><span class="line">                                    <span class="comment">#    y += 1</span></span><br><span class="line"></span><br><span class="line">                                </span><br><span class="line">        </span><br><span class="line">                                <span class="keyword">if</span>(~skip_flag):</span><br><span class="line">                                    text_cxy = <span class="string">&quot;*&quot;</span></span><br><span class="line">                                    cv2.putText(im0, text_cxy, (<span class="built_in">int</span>(x), <span class="built_in">int</span>(y)) ,  cv2.FONT_ITALIC, <span class="number">1.2</span>, (<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">#tl = round(0.02 * (img.shape[0] + img.shape[1]) / 2) + 1  # line/font thickness</span></span><br><span class="line">                                    <span class="comment">#tf = max(tl - 1, 1)  # font thickness</span></span><br><span class="line">                                    <span class="comment">#cv2.putText(im0, text_cxy,  (int(x), int(y)), 0, tl / 3, [0, 0, 255], thickness=tf, lineType=cv2.LINE_AA)</span></span><br><span class="line">                                    </span><br><span class="line">                                    <span class="comment">#print(&quot;count is %d&quot; %count)</span></span><br><span class="line">                                    <span class="built_in">print</span>(<span class="string">&#x27;点 (%d, %d) 的三维坐标 (x:%.1fcm, y:%.1fcm, z:%.1fcm)&#x27;</span> % (<span class="built_in">int</span>(x), <span class="built_in">int</span>(y), </span><br><span class="line">                                        points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">0</span>]/<span class="number">10</span>, </span><br><span class="line">                                        points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">1</span>]/<span class="number">10</span>, </span><br><span class="line">                                        points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">2</span>]/<span class="number">10</span>) )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                    dis = ( (points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">0</span>] ** <span class="number">2</span> + points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">1</span>] ** <span class="number">2</span> + points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">2</span>] **<span class="number">2</span>) ** <span class="number">0.5</span> ) / <span class="number">10</span></span><br><span class="line">                                    <span class="built_in">print</span>(<span class="string">&#x27;点 (%d, %d) 的 %s 距离左摄像头的相对距离为 %0.1f cm&#x27;</span> %(x, y,label, dis) )</span><br><span class="line">                                </span><br><span class="line">                                    <span class="comment">#label = f&#x27;&#123;names[int(cls)]&#125; &#123;conf:.2f&#125; &#x27;</span></span><br><span class="line">                                    <span class="comment">#plot_one_box(xyxy, im0, label=label+ &#x27;x:%.2f y:%.2f z:%.2f&#x27; </span></span><br><span class="line">                                    <span class="comment">#                           %(points_3d[int(y), int(x), 0]/10, </span></span><br><span class="line">                                    <span class="comment">#                             points_3d[int(y), int(x), 1]/10 ,  </span></span><br><span class="line">                                    <span class="comment">#                             points_3d[int(y), int(x), 2]/10) , </span></span><br><span class="line">                                    <span class="comment">#                             color=colors[int(cls)], line_thickness=3)</span></span><br><span class="line"></span><br><span class="line">                                    text_x = <span class="string">&quot;x:%.1fcm&quot;</span> %(points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">0</span>]/<span class="number">10</span>)</span><br><span class="line">                                    text_y = <span class="string">&quot;y:%.1fcm&quot;</span> %(points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">1</span>]/<span class="number">10</span>)</span><br><span class="line">                                    text_z = <span class="string">&quot;z:%.1fcm&quot;</span> %(points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">2</span>]/<span class="number">10</span>)</span><br><span class="line">                                    text_dis = <span class="string">&quot;dis:%.1fcm&quot;</span> %dis</span><br><span class="line"></span><br><span class="line">                                    cv2.rectangle(im0,(<span class="built_in">int</span>(xyxy[<span class="number">0</span>]+(xyxy[<span class="number">2</span>]-xyxy[<span class="number">0</span>])),<span class="built_in">int</span>(xyxy[<span class="number">1</span>])),(<span class="built_in">int</span>(xyxy[<span class="number">0</span>]+(xyxy[<span class="number">2</span>]-xyxy[<span class="number">0</span>])+<span class="number">5</span>+<span class="number">220</span>),<span class="built_in">int</span>(xyxy[<span class="number">1</span>]+<span class="number">150</span>)),colors[<span class="built_in">int</span>(cls)],-<span class="number">1</span>);</span><br><span class="line">                                    cv2.putText(im0, text_x, (<span class="built_in">int</span>(xyxy[<span class="number">0</span>]+(xyxy[<span class="number">2</span>]-xyxy[<span class="number">0</span>])+<span class="number">5</span>), <span class="built_in">int</span>(xyxy[<span class="number">1</span>]+<span class="number">30</span>)),  cv2.FONT_ITALIC, <span class="number">1.2</span>, (<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>), <span class="number">3</span>)</span><br><span class="line">                                    cv2.putText(im0, text_y, (<span class="built_in">int</span>(xyxy[<span class="number">0</span>]+(xyxy[<span class="number">2</span>]-xyxy[<span class="number">0</span>])+<span class="number">5</span>), <span class="built_in">int</span>(xyxy[<span class="number">1</span>]+<span class="number">65</span>)),  cv2.FONT_ITALIC, <span class="number">1.2</span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">3</span>)</span><br><span class="line">                                    cv2.putText(im0, text_z, (<span class="built_in">int</span>(xyxy[<span class="number">0</span>]+(xyxy[<span class="number">2</span>]-xyxy[<span class="number">0</span>])+<span class="number">5</span>), <span class="built_in">int</span>(xyxy[<span class="number">1</span>]+<span class="number">100</span>)), cv2.FONT_ITALIC, <span class="number">1.2</span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">3</span>)</span><br><span class="line">                                    cv2.putText(im0, text_dis, (<span class="built_in">int</span>(xyxy[<span class="number">0</span>]+(xyxy[<span class="number">2</span>]-xyxy[<span class="number">0</span>])+<span class="number">5</span>), <span class="built_in">int</span>(xyxy[<span class="number">1</span>]+<span class="number">145</span>)), cv2.FONT_ITALIC, <span class="number">1.2</span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">#cv2.putText(im0, text_x, (xyxy[0]+(xyxy[2]-xyxy[0])+5, xyxy[1]+30),  cv2.FONT_ITALIC, 1, (102, 80, 250), 3)</span></span><br><span class="line">                                    <span class="comment">#cv2.putText(im0, text_y, (xyxy[0]+(xyxy[2]-xyxy[0])+5, xyxy[1]+65),  cv2.FONT_ITALIC, 1, (102, 80, 250), 3)</span></span><br><span class="line">                                    <span class="comment">#cv2.putText(im0, text_z, (xyxy[0]+(xyxy[2]-xyxy[0])+5, xyxy[1]+100), cv2.FONT_ITALIC, 1, (102, 80, 250), 3)</span></span><br><span class="line">                                    <span class="comment">#cv2.putText(im0, text_dis, (xyxy[0]+(xyxy[2]-xyxy[0])+5, xyxy[1]+145), cv2.FONT_ITALIC, 1, (102, 80, 250), 3)</span></span><br><span class="line"></span><br><span class="line">                                    <span class="comment"># cv2.imshow(&quot;img&amp;coor&quot;, im0)</span></span><br><span class="line">                                    <span class="comment"># 鼠标点击事件</span></span><br><span class="line">                                    <span class="comment">#def onMouse(event, x, y, flags, param):</span></span><br><span class="line">                                    <span class="comment">#    if event == cv2.EVENT_LBUTTONDOWN:</span></span><br><span class="line">                                    <span class="comment">#        print(&#x27;点 (%d, %d) 的三维坐标 (x:%.3fm, y:%.3fm, z:%.3fm)&#x27; % (x, y, points_3d[y, x, 0]/1000, points_3d[y, x, 1]/1000, points_3d[y, x, 2]/1000))</span></span><br><span class="line">                                    <span class="comment">#        dis = ( (points_3d[y, x, 0] ** 2 + points_3d[y, x, 1] ** 2 + points_3d[y, x, 2] **2) ** 0.5) / 1000</span></span><br><span class="line">                                    <span class="comment">#        print(&#x27;点 (%d, %d) 距离左摄像头的相对距离为 %0.3f m&#x27; %(x, y, dis) )</span></span><br><span class="line"></span><br><span class="line">                                    <span class="comment"># 显示图片</span></span><br><span class="line">                                    <span class="comment">#cv2.namedWindow(&quot;disparity&quot;,0)</span></span><br><span class="line">                                    <span class="comment">#cv2.imshow(&quot;disparity&quot;, disp)</span></span><br><span class="line">                                    <span class="comment">#cv2.setMouseCallback(&quot;disparity&quot;, onMouse, 0)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                    <span class="comment"># 构建点云--Point_XYZRGBA格式</span></span><br><span class="line">                                    <span class="comment">#pointcloud = DepthColor2Cloud(points_3d, iml)</span></span><br><span class="line"></span><br><span class="line">                                    <span class="comment"># 显示点云</span></span><br><span class="line">                                    <span class="comment">#view_cloud(pointcloud)</span></span><br><span class="line"></span><br><span class="line">                                    <span class="comment">#cv2.waitKey(0)</span></span><br><span class="line">                                    <span class="comment">#cv2.destroyAllWindows()</span></span><br><span class="line">                                <span class="comment">#except:</span></span><br><span class="line">                                    </span><br><span class="line">                                <span class="comment">#   print(&quot;next!&quot;)</span></span><br><span class="line">                                    t4 = time_synchronized()</span><br><span class="line">                                    <span class="built_in">print</span>(<span class="string">f&#x27;Done. (<span class="subst">&#123;t4 - t3:<span class="number">.3</span>f&#125;</span>s)&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码就会计算出双目测距的距离。注意该段代码需要导入matlab标定的相关参数。以及根据相关参数对图像进行修正的函数</p><p>这里给出整体代码的百度云链接。</p><p>链接：<a href="https://pan.baidu.com/s/1FUHlaKRHsZCxj6lS8il3Jw">https://pan.baidu.com/s/1FUHlaKRHsZCxj6lS8il3Jw</a><br>提取码：i2q5 </p><p>最后便可得出测试效果，如下图。</p><p><img src="/articleImg/18_article/distance.png" alt="distance"></p><h2 id="测试总结"><a href="#测试总结" class="headerlink" title="测试总结"></a>测试总结</h2><ul><li>单独在Jetson Nano上运行yolov5进行实时的目标检测还是挺快的</li><li>进行实时检测时需要指定摄像头数据 –source 0</li><li>在程序中可以设置摄像头的相关数据（双目摄像头需要设置分辨率，不设置的话只会有一个摄像头工作）</li><li>进行视频离线处理视频测距 OK</li><li>进行实时双目测距过程时，由于YOLOV5网络在处理实时数据，会resize图像，导致图像大小发生变化，因此经常会发生数组越界问题</li><li>总体来说，个人觉得测距精度不是很高，后续在进行相关的优化吧~</li></ul>]]></content>
      
      
      <categories>
          
          <category> JetsonNano </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双目测距 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常规表达式转逆波兰表达式</title>
      <link href="/2021/10/09/%E5%B8%B8%E8%A7%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2021/10/09/%E5%B8%B8%E8%A7%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="常规表达式转逆波兰表达式"><a href="#常规表达式转逆波兰表达式" class="headerlink" title="常规表达式转逆波兰表达式"></a>常规表达式转逆波兰表达式</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看到这个题目的时候，我在想，应该不难。这逆波兰表达式的计算顺序，和普通表达式计算的顺序是差不多的，那我在普通计算器实现程序的compute</p><p>函数中做一些改变，看能不能实现这个题目的想法。最后做完发现不太行，程序不够general，遇到一些特殊情况就gg了。主要原因是：普通计算器计算完中中间结果，会将中间结果压栈。在我修改过程中发现，我难以分辨出，本次出栈的结果中是否含有中间结果。因为如果是两个原生数（表达式中的数），就需要全部输出。</p><p>下面给出参考网上的实现思路，并给出自己的实现代码。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p> <img src="/articleImg/23_article/graph.png" alt="graph"></p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"><span class="comment">//将中缀表达式转化为后缀表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferExpression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TransferExpression transferExpression = <span class="keyword">new</span> TransferExpression();</span><br><span class="line">        List&lt;String&gt; strings = transferExpression.fun1(<span class="string">&quot;1+((2+3)×4)-5&quot;</span>);</span><br><span class="line">        List&lt;String&gt; strings1 = transferExpression.fun2(strings);</span><br><span class="line">        System.out.println(<span class="string">&quot;测试完毕&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;String&gt;fun2(List&lt;String&gt; S)&#123;</span><br><span class="line">        <span class="comment">//将分解好的因式，传入，开始进行中缀转后缀的转换</span></span><br><span class="line">        Stack&lt;String&gt; sign_stack = <span class="keyword">new</span> Stack&lt;&gt;(); <span class="comment">//作为运算符的符号栈</span></span><br><span class="line">        ArrayList&lt;String&gt; post_expression = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">//作为数字栈，这里用ArrayList模拟栈的存储，因为这里并不需要出栈</span></span><br><span class="line">        <span class="keyword">for</span> (String item : S) &#123;</span><br><span class="line">            <span class="keyword">if</span>(item.matches(<span class="string">&quot;\\d+&quot;</span>))&#123; <span class="comment">//正则表达式匹配，如果是数</span></span><br><span class="line">                post_expression.add(item);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">//元素为符号</span></span><br><span class="line">                <span class="keyword">char</span> temp = item.charAt(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(sign_stack.isEmpty())&#123;</span><br><span class="line">                    sign_stack.push(item);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(temp == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(!sign_stack.peek().equals(<span class="string">&quot;&quot;</span>+<span class="string">&#x27;(&#x27;</span>))&#123; <span class="comment">//直至扫描找到 （  ，扫描过程中一直出符号栈</span></span><br><span class="line">                        String pop_item = sign_stack.pop();</span><br><span class="line">                        post_expression.add(pop_item);</span><br><span class="line">                    &#125;</span><br><span class="line">                    sign_stack.pop(); <span class="comment">//把符号栈顶&#x27;(&#x27;出栈</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sign_stack.peek().equals(<span class="string">&quot;&quot;</span>+<span class="string">&#x27;(&#x27;</span>))&#123;</span><br><span class="line">                    sign_stack.push(item);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.Sign_priority(temp)&gt;<span class="keyword">this</span>.Sign_priority(sign_stack.peek().charAt(<span class="number">0</span>)))&#123;</span><br><span class="line">                    sign_stack.push(item);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123; <span class="comment">//说明temp符号的优先级小于栈顶符号的优先级,将栈顶元素出栈，再将temp符号压栈</span></span><br><span class="line">                    <span class="comment">//此时的符号肯定是正常的加减乘除</span></span><br><span class="line">                    String pop_item = sign_stack.pop();</span><br><span class="line">                    post_expression.add(pop_item);</span><br><span class="line">                    sign_stack.push(item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!sign_stack.isEmpty())&#123;</span><br><span class="line">            String pop_item = sign_stack.pop();</span><br><span class="line">            post_expression.add(pop_item);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(post_expression);</span><br><span class="line">        <span class="keyword">return</span> post_expression;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fun1</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        String str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c-<span class="string">&#x27;0&#x27;</span>&gt;=<span class="number">0</span>&amp;&amp;c-<span class="string">&#x27;0&#x27;</span>&lt;=<span class="number">9</span>)&#123; <span class="comment">//这里考虑多位数</span></span><br><span class="line">                str = str+c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!str.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">                    strings.add(str);</span><br><span class="line">                    strings.add(<span class="string">&quot;&quot;</span>+s.charAt(i));</span><br><span class="line">                    str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    strings.add(<span class="string">&quot;&quot;</span>+s.charAt(i));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!str.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">            strings.add(str);</span><br><span class="line">            str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(strings);</span><br><span class="line">        <span class="keyword">return</span> strings;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">Sign_priority</span><span class="params">(<span class="keyword">char</span> Sign)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> priority = -<span class="number">1</span>; <span class="comment">//数字大代表优先级大</span></span><br><span class="line">        <span class="keyword">if</span>(Sign == <span class="string">&#x27;+&#x27;</span>||Sign==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            priority = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Sign == <span class="string">&#x27;*&#x27;</span>||Sign==<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">            priority = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Sign == <span class="string">&#x27;&#123;&#x27;</span>||Sign==<span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">            priority = <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Sign == <span class="string">&#x27;[&#x27;</span>||Sign==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">            priority = <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Sign == <span class="string">&#x27;(&#x27;</span>||Sign==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            priority = <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> priority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>继续加油吧~</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中缀转后缀表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python处理excel之修改数据</title>
      <link href="/2021/10/09/python%E5%A4%84%E7%90%86excel%E4%B9%8B%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE/"/>
      <url>/2021/10/09/python%E5%A4%84%E7%90%86excel%E4%B9%8B%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="python处理excel之修改数据"><a href="#python处理excel之修改数据" class="headerlink" title="python处理excel之修改数据"></a>python处理excel之修改数据</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前两天在调试雷达传感器进行数据采集时，得到了一个复数矩阵，但是每个复数都是带着小括号的，这样的数据是没有办法导入到matlab中进行处理的。因为小括号在matlab中表示取某矩阵的元素。于是自己花了40分钟写了一个遍历excel数据，并修改数据的程序，这里记录一下，说不定以后还要用，省的自己再去找读取excel的函数。</p><h2 id="对应代码"><a href="#对应代码" class="headerlink" title="对应代码"></a>对应代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> scipy.io</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">filename=<span class="string">r&quot;C:\Users\zhanglei\Desktop\data\2.csv&quot;</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line">new_data_list = []</span><br><span class="line">row = <span class="number">0</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f:</span><br><span class="line">    reader=csv.reader(f) <span class="comment"># 获取reader对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        row = row+<span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;本次row为&quot;</span>,row)</span><br><span class="line">        header_row=<span class="built_in">next</span>(reader)  <span class="comment"># 获取可迭代对象</span></span><br><span class="line">        <span class="comment"># print(header_row[0])</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(header_row)):   <span class="comment"># 进行遍历</span></span><br><span class="line">            <span class="comment">#print(i)</span></span><br><span class="line">            <span class="keyword">if</span> row == <span class="number">287</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;这里报错&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(header_row[<span class="number">81</span>],header_row[<span class="number">82</span>],header_row[<span class="number">83</span>],header_row[<span class="number">84</span>])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># if header_row[i][0]</span></span><br><span class="line">            <span class="comment">#print(&quot;是否查找到(&quot;,header_row[i].rfind(&#x27;(&#x27;))</span></span><br><span class="line">            <span class="keyword">if</span> header_row[i].find(<span class="string">&#x27;(&#x27;</span>)!=-<span class="number">1</span>:</span><br><span class="line">                header_row[i] = header_row[i].split(<span class="string">&#x27;(&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># print(&quot;是否查找到)&quot;,header_row[i].rfind(&#x27;)&#x27;))</span></span><br><span class="line">            <span class="keyword">if</span> header_row[i].rfind(<span class="string">&#x27;)&#x27;</span>) != -<span class="number">1</span>:</span><br><span class="line">                header_row[i] = header_row[i].split(<span class="string">&#x27;)&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># print(header_row)</span></span><br><span class="line">        new_data_list.append(header_row)</span><br><span class="line"></span><br><span class="line">        count+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count==<span class="number">1080</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment">#print(len(header_row))</span></span><br><span class="line">        <span class="comment">#print(header_row)</span></span><br><span class="line">    <span class="built_in">print</span>(count)</span><br><span class="line">    <span class="comment">#print(new_data_list.shape)</span></span><br><span class="line"></span><br><span class="line">    list_shape = np.array(new_data_list).shape</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;转换后的维度&quot;</span>,list_shape)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;C:\Users\zhanglei\Desktop\data\Transfer2.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">        writer = csv.writer(csvfile)</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> new_data_list:</span><br><span class="line">            writer.writerow(row)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    scipy.io.savemat(<span class="string">&#x27;filename.mat&#x27;</span>,&#123;<span class="string">&#x27;my_data&#x27;</span>: new_data_list&#125;) <span class="comment"># 这里Sava为mat文件出现乱码，当时直接又转存为CSV，所以也没深究，后续再看</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>去除括号之前</p><p> <img src="/articleImg/19_article/data1.png" alt="data1"></p><p>去除之后</p><p> <img src="/articleImg/19_article/data2.png" alt="data2"></p><p>继续加油~</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 遍历修改excel数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆波兰表达式</title>
      <link href="/2021/10/08/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2021/10/08/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="逆波兰表达式"><a href="#逆波兰表达式" class="headerlink" title="逆波兰表达式"></a>逆波兰表达式</h2><h2 id="逆波兰表达式的解释"><a href="#逆波兰表达式的解释" class="headerlink" title="逆波兰表达式的解释"></a>逆波兰表达式的解释</h2><p>逆波兰记法中，操作符置于操作数的后面。例如表达“三加四”时，写作“3 4 + ”，而不是“3 + 4”。如果有多个操作符，操作符置于第二个操作数的后面，所以常规中缀记法的“3 - 4 + 5”在逆波兰记法中写作“3 4 - 5 + ”：先3减去4，再加上5。使用逆波兰记法的一个好处是不需要使用括号。例如中缀记法中“3 - 4 * 5”与“（3 - 4）*5”不相同，但后缀记法中前者写做“3 4 5 * - ”，无歧义地表示“3 (4 5 *) -”；后者写做“3 4 - 5 * ”。</p><p>逆波兰表达式的<a href="https://zh.wikipedia.org/wiki/%E8%A7%A3%E9%87%8A%E5%99%A8">解释器</a>一般是基于<a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88">堆栈</a>的。解释过程一般是：操作数入栈；遇到操作符时，操作数出栈，求值，将结果入栈；当一遍后，栈顶就是表达式的值。因此逆波兰表达式的求值使用堆栈结构很容易实现，并且能很快求值。</p><p>注意：逆波兰记法并不是简单的<a href="https://zh.wikipedia.org/wiki/%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">波兰表达式</a>的反转。因为对于不满足<a href="https://zh.wikipedia.org/wiki/%E4%BA%A4%E6%8D%A2%E5%BE%8B">交换律</a>的操作符，它的操作数写法仍然是常规顺序，如，波兰记法“/ 6 3”的逆波兰记法是“6 3 /”而不是“3 6 /”；数字的数位写法也是常规顺序。</p><h2 id="逆波兰计算器栈的实现思路"><a href="#逆波兰计算器栈的实现思路" class="headerlink" title="逆波兰计算器栈的实现思路"></a>逆波兰计算器栈的实现思路</h2><p> <img src="/articleImg/22_article/graph.png" alt="graph"></p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolandNotation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先定义给逆波兰表达式</span></span><br><span class="line">        <span class="comment">//(30+4)× 5-6 =&gt; 30 4 + 5 × 6 - =&gt; 164</span></span><br><span class="line">        String suffixExpression = <span class="string">&quot;4 5 * 8 - 60 + 8 2 / +&quot;</span>; <span class="comment">// 76</span></span><br><span class="line">        List&lt;String&gt; list = getListString(suffixExpression);</span><br><span class="line">        System.out.println(<span class="string">&quot;rpnList=&quot;</span> + list);</span><br><span class="line">        <span class="keyword">int</span> res = calculate(list);</span><br><span class="line">        System.out.println(<span class="string">&quot;计算的结果是=&quot;</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getListString</span><span class="params">(String suffixExpression)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将 suffixExpression 分割</span></span><br><span class="line">        String[] split = suffixExpression.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String ele : split) &#123;</span><br><span class="line">            list.add(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(List&lt;String&gt; ls)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建给栈, 只需要一个栈即可</span></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line">    <span class="comment">// 遍历 ls</span></span><br><span class="line">        <span class="keyword">for</span> (String item : ls) &#123;</span><br><span class="line">    <span class="comment">// 这里使用正则表达式来取出数</span></span><br><span class="line">            <span class="keyword">if</span> (item.matches(<span class="string">&quot;\\d+&quot;</span>)) &#123; <span class="comment">// 匹配的是多位数</span></span><br><span class="line">            <span class="comment">// 入栈</span></span><br><span class="line">                stack.push(item);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// pop 出两个数， 并运算， 再入栈</span></span><br><span class="line">                <span class="keyword">int</span> num2 = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> num1 = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (item.equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 + num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 - num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 * num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 / num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;运算符有误&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//把 res 入栈</span></span><br><span class="line">                stack.push(<span class="string">&quot;&quot;</span> + res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后留在 stack 中的数据是运算结果</span></span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>继续加油！！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆波兰表达式计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈实现综合计算器</title>
      <link href="/2021/10/08/%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
      <url>/2021/10/08/%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="栈实现综合计算器"><a href="#栈实现综合计算器" class="headerlink" title="栈实现综合计算器"></a>栈实现综合计算器</h1><p>这个其实在本科的时候，自己做过一遍，用的时C，当时理解还挺深刻的，没想到过了几年，自己又忘得差不多了哈哈哈，想到这里，我记得当时去解老师讲的迷宫求解，真的死了很多脑细胞，看来自己还是不属于天才型选手，那就多多努力吧。</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>这次给出java的实现代码，并简单记录实现的关键思路。以防后续遗忘。&lt;切记：这是一个边扫描，边入栈，边出栈，边计算，边入栈的过程&gt;</p><p> <img src="/articleImg/21_article/graph.png" alt="graph"></p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>在这里给出实现的代码，实测可正常运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中缀表达式求值，其实就是平时常见的多项式求值</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">calculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CharStack signStack; <span class="comment">//存放计算符号的栈</span></span><br><span class="line">    <span class="keyword">private</span> ArrayStack numStack; <span class="comment">//存放数字的栈</span></span><br><span class="line">    <span class="keyword">private</span>  CharStack checkBracketStack; <span class="comment">//检查表达式中括号是否合法的栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">calculator</span><span class="params">()</span></span>&#123;</span><br><span class="line">         signStack = <span class="keyword">new</span> CharStack(<span class="number">100</span>,<span class="string">&quot;signStack&quot;</span>);</span><br><span class="line">         numStack = <span class="keyword">new</span> ArrayStack(<span class="number">100</span>,<span class="string">&quot;numStack&quot;</span>);</span><br><span class="line">         checkBracketStack = <span class="keyword">new</span> CharStack(<span class="number">100</span>,<span class="string">&quot;checkBracketStack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修改支持多位数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculator_fun</span><span class="params">(String expression)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> value;</span><br><span class="line">        <span class="keyword">boolean</span> isdigit;</span><br><span class="line">        <span class="keyword">char</span> sign;</span><br><span class="line">        <span class="keyword">int</span> num1;</span><br><span class="line">        <span class="keyword">int</span> num2;</span><br><span class="line">        <span class="keyword">int</span> result;</span><br><span class="line">        <span class="keyword">boolean</span> numbers_flag = <span class="keyword">false</span>;</span><br><span class="line">        System.out.println(expression);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.check_expression(expression))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;表达式合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;表达式不合法，请确认后再次输入！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(expression);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; expression.length(); index++) &#123;</span><br><span class="line">            value = expression.charAt(index);</span><br><span class="line">            isdigit = Character.isDigit(value); <span class="comment">//判断一个字符是不是数字</span></span><br><span class="line">            <span class="keyword">if</span>(isdigit)&#123;</span><br><span class="line">                <span class="keyword">if</span>(numbers_flag)&#123;</span><br><span class="line">                    <span class="keyword">int</span> pop = <span class="keyword">this</span>.numStack.pop();</span><br><span class="line">                    <span class="keyword">this</span>.numStack.push(pop*<span class="number">10</span> + value-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">this</span>.numStack.push(value-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                numbers_flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                numbers_flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.signStack.isEmpty())&#123;</span><br><span class="line">                    <span class="comment">//符号栈为空时，直接压栈</span></span><br><span class="line">                    <span class="keyword">this</span>.signStack.push(value);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123; <span class="comment">//符号栈中已有元素</span></span><br><span class="line">                    <span class="keyword">if</span>(Sign_priority(value)&lt;=Sign_priority(<span class="keyword">this</span>.signStack.get_top())&amp;&amp;<span class="keyword">this</span>.signStack.get_top()!=<span class="string">&#x27;(&#x27;</span>&amp;&amp;<span class="keyword">this</span>.signStack.get_top()!=<span class="string">&#x27;[&#x27;</span>&amp;&amp;<span class="keyword">this</span>.signStack.get_top()!=<span class="string">&#x27;&#123;&#x27;</span>)&#123;  <span class="comment">//遍历到的符号与栈中符号比较优先级</span></span><br><span class="line">                        <span class="comment">//先出栈符号栈一个元素，再出栈符号栈两个元素，进行运算</span></span><br><span class="line">                         sign = <span class="keyword">this</span>.signStack.pop();</span><br><span class="line">                         num1 = <span class="keyword">this</span>.numStack.pop();</span><br><span class="line">                         num2 = <span class="keyword">this</span>.numStack.pop();</span><br><span class="line">                         result = <span class="keyword">this</span>.compute(num2,num1,sign);</span><br><span class="line">                        <span class="comment">//将所得结果压入数字栈</span></span><br><span class="line">                        <span class="keyword">this</span>.numStack.push(result);</span><br><span class="line">                        <span class="comment">//将当前遍历到的符号压入符号栈</span></span><br><span class="line">                        <span class="keyword">this</span>.signStack.push(value);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123; <span class="comment">//若优先级较大，则将该符号插入符号队列 “在这里可以处理添加括号优先级”</span></span><br><span class="line">                        <span class="keyword">if</span>(value == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                            <span class="keyword">this</span>.bracket_express_compute(value);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(value == <span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                            <span class="keyword">this</span>.bracket_express_compute(value);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(value == <span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">                            <span class="keyword">this</span>.bracket_express_compute(value);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="comment">//遍历到的符号优先级大于栈中符号，则入栈</span></span><br><span class="line">                            <span class="keyword">this</span>.signStack.push(value);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当经历for循环之后，符号栈可能不止一个元素  如表达式：2+6/2</span></span><br><span class="line">        <span class="comment">//尤其注意这里还有一个★循环★</span></span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="keyword">this</span>.signStack.isEmpty())&#123;</span><br><span class="line">            sign = <span class="keyword">this</span>.signStack.pop();</span><br><span class="line">            num1 = <span class="keyword">this</span>.numStack.pop();</span><br><span class="line">            num2 = <span class="keyword">this</span>.numStack.pop();</span><br><span class="line">            result = <span class="keyword">this</span>.compute(num2,num1,sign);</span><br><span class="line">            <span class="keyword">this</span>.numStack.push(result);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;最终的结果是:&quot;</span>+ <span class="keyword">this</span>.numStack.pop());</span><br><span class="line">        <span class="comment">//System.out.println(&quot;数字栈是否为空：&quot;+this.numStack.isEmpty());</span></span><br><span class="line">        <span class="comment">//System.out.println(&quot;符号栈是否为空：&quot;+this.signStack.isEmpty());</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">Sign_priority</span><span class="params">(<span class="keyword">char</span> Sign)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> priority = -<span class="number">1</span>; <span class="comment">//数字大代表优先级大</span></span><br><span class="line">        <span class="keyword">if</span>(Sign == <span class="string">&#x27;+&#x27;</span>||Sign==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            priority = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Sign == <span class="string">&#x27;*&#x27;</span>||Sign==<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">            priority = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Sign == <span class="string">&#x27;&#123;&#x27;</span>||Sign==<span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">            priority = <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Sign == <span class="string">&#x27;[&#x27;</span>||Sign==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">            priority = <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Sign == <span class="string">&#x27;(&#x27;</span>||Sign==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            priority = <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> priority;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2, <span class="keyword">char</span> sign)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=-<span class="number">999</span>;</span><br><span class="line">        <span class="keyword">switch</span>(sign)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                result = num1+num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                result = num1-num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                result = num1*num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                result = num1/num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bracket_express_compute</span><span class="params">(<span class="keyword">char</span> sign)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> anti_sign = <span class="keyword">this</span>.get_anti_bracket(sign);</span><br><span class="line">        <span class="keyword">while</span>(anti_sign != <span class="keyword">this</span>.signStack.get_top())&#123;</span><br><span class="line">            <span class="keyword">char</span> compute_sign = <span class="keyword">this</span>.signStack.pop();</span><br><span class="line">            <span class="keyword">int</span> num1 = <span class="keyword">this</span>.numStack.pop();</span><br><span class="line">            <span class="keyword">int</span> num2 = <span class="keyword">this</span>.numStack.pop();</span><br><span class="line">            <span class="keyword">int</span> result = <span class="keyword">this</span>.compute(num2,num1,compute_sign);</span><br><span class="line">            <span class="keyword">this</span>.numStack.push(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.signStack.pop(); <span class="comment">//将符号栈顶部的值为anti_sign的符号出栈</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">char</span> <span class="title">get_anti_bracket</span><span class="params">(<span class="keyword">char</span> sign)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> anti_sign;</span><br><span class="line">        <span class="keyword">switch</span>(sign)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">                anti_sign = <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                anti_sign = <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                anti_sign = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unexpected value: &quot;</span> + sign);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> anti_sign;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check_expression</span><span class="params">(String expression)</span></span>&#123;  <span class="comment">//检查表达式的合法性，这里面可能会有很多中可能性，本次只检查括号是否对应</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; expression.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> value = expression.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(value==<span class="string">&#x27;&#123;&#x27;</span>||value==<span class="string">&#x27;[&#x27;</span>||value==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.checkBracketStack.push(value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(value==<span class="string">&#x27;&#125;&#x27;</span>||value==<span class="string">&#x27;]&#x27;</span>||value==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">char</span> anti_value = <span class="keyword">this</span>.get_anti_bracket(value);</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.checkBracketStack.get_top()==anti_value)&#123;</span><br><span class="line">                    <span class="keyword">this</span>.checkBracketStack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.checkBracketStack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>继续加油吧！！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 综合计算器的实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈—后进先出</title>
      <link href="/2021/10/05/%E6%A0%88%E2%80%94%E5%90%8E%E8%BF%9B%E5%85%88%E5%87%BA/"/>
      <url>/2021/10/05/%E6%A0%88%E2%80%94%E5%90%8E%E8%BF%9B%E5%85%88%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="栈—后进先出"><a href="#栈—后进先出" class="headerlink" title="栈—后进先出"></a>栈—后进先出</h1><p>个人觉得栈、队列、链表、数组这些线性结构不算难，也容易理解，难点还是在树和图那里，之前学过一遍，感觉现在忘得很快，慢慢来，总有一天会全部熟练的。</p><p>这里简单的给出栈的示意图，及java的实现代码（自己实现）。</p><p>示意图如下：</p><p> <img src="/articleImg/20_article/zhan.png" alt="zhan"></p><p>java实现代码(其他类型代码实现也都大同小异)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize; <span class="comment">// 栈的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] stack; <span class="comment">// 数组， 数组模拟栈， 数据就放在该数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top = -<span class="number">1</span>;<span class="comment">// top 表示栈顶， 初始化为-1</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> maxSize,String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈-push</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先判断栈是否满</span></span><br><span class="line">        <span class="keyword">if</span>(isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈满&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">///出栈-pop, 将栈顶的数据返回</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先判断栈是否空</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">    <span class="comment">//抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="keyword">this</span>.name+<span class="string">&quot;栈空， 没有数据~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示栈的情况[遍历栈]， 遍历时， 需要从栈顶开始显示数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈空， 没有数据~~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="comment">//</span></span><br><span class="line">        <span class="comment">//需要从栈顶开始显示数据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = top; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;stack[%d]=%d\n&quot;</span>, i, stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其实在java的JDK中已经给出了栈的相关API引入的过程为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;  <span class="comment">//引入stack包</span></span><br><span class="line"></span><br><span class="line">Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">stack.push(item); <span class="comment">//压栈</span></span><br><span class="line">stack.pop();<span class="comment">//出栈，栈顶指针发生变化</span></span><br><span class="line">stack.peak(); <span class="comment">//获取栈顶指针，但是，栈顶指针指向不发生变化</span></span><br></pre></td></tr></table></figure><p>这一篇就简单给出栈的实现，对应的算法题，在后面几篇给出</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表及相关题目</title>
      <link href="/2021/09/28/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
      <url>/2021/09/28/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="单链表及相关题目"><a href="#单链表及相关题目" class="headerlink" title="单链表及相关题目"></a>单链表及相关题目</h1><p>今天复习的是数据结构中的单链表，整体感觉在自己能力范围之内，感觉自己的薄弱点还是在二叉树和回溯递归那一部分。慢慢来吧，感觉自己最近的学习状态还是不错的，鼓励一下自己！下面废话不多说，对今天学习的知识进行总结：</p><h2 id="单链表结构初始化"><a href="#单链表结构初始化" class="headerlink" title="单链表结构初始化"></a>单链表结构初始化</h2><p>java中的数据结构都是写在类中，这与C语言中的结构体是对应着的知识点，下面给出单链表的结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;  <span class="comment">//这个类就相当于链表中节点的结构，也就相当于C语言中的struct   //根据这个HeroNode，就直接可以慢慢创建出链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next; <span class="comment">//指向下一个节点</span></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对该结构简单分析：其实前三个变量都是无所谓的，你可以随便定义任何信息，最重要的是<strong>HeroNode next;</strong> 这个是链表中的核心，就是因为next节点的存在，才搭建出整个单链表。</p><h2 id="单链表算法流程"><a href="#单链表算法流程" class="headerlink" title="单链表算法流程"></a>单链表算法流程</h2><p> <img src="/articleImg/17_article/linked_list.png" alt="linked_list"></p><h2 id="单链表中必备的函数"><a href="#单链表中必备的函数" class="headerlink" title="单链表中必备的函数"></a>单链表中必备的函数</h2><p>在链表操作的过程中必备的函数有：<strong>数据的有序插入</strong>、<strong>返回头部元素</strong>、<strong>显示链表</strong>、<strong>更新链表中节点的信息</strong>、<strong>删除链表中的元素</strong>、<strong>尾插</strong>、<strong>头插</strong>等，下面给出类的实现：这些所有的方法都写在SingleLinkedList这个类中，如下</p><h3 id="SingleLinkedList类"><a href="#SingleLinkedList类" class="headerlink" title="SingleLinkedList类"></a>SingleLinkedList类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HeroNode head; <span class="comment">//属性</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SingleLinkedList</span><span class="params">()</span> </span>&#123; <span class="comment">//构造方法</span></span><br><span class="line">        head = <span class="keyword">new</span> HeroNode(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回头部元素"><a href="#返回头部元素" class="headerlink" title="返回头部元素"></a>返回头部元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据的有序插入"><a href="#数据的有序插入" class="headerlink" title="数据的有序插入"></a>数据的有序插入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(HeroNode hero1)</span> </span>&#123; <span class="comment">//根据节点信息中的编号，进行数据的插入</span></span><br><span class="line">    <span class="comment">//根据节点信息中的编号，升序插入</span></span><br><span class="line">    HeroNode temp = head;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//temp = temp.next;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(temp == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.head_add(hero1);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(temp.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.next.no&gt;=hero1.no)&#123;</span><br><span class="line">            <span class="comment">//找到该元素</span></span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        hero1.next = temp.next; <span class="comment">//进行插入</span></span><br><span class="line">        temp.next = hero1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tail_add(hero1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="显示链表"><a href="#显示链表" class="headerlink" title="显示链表"></a>显示链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123; <span class="comment">//显示链表</span></span><br><span class="line">    HeroNode temp = head;</span><br><span class="line">    temp = temp.next;</span><br><span class="line">    <span class="keyword">while</span>(temp != <span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.println(temp);</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更新链表中节点的信息"><a href="#更新链表中节点的信息" class="headerlink" title="更新链表中节点的信息"></a>更新链表中节点的信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode newHeroNode)</span> </span>&#123; <span class="comment">//更新链表中节点的信息</span></span><br><span class="line">    <span class="comment">//在本次更新节点过程中，节点的编号是不能更新的，因此可以根据节点的编号去索引节点位置</span></span><br><span class="line">    HeroNode temp = head.next;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(temp.no == newHeroNode.no)&#123;</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flag)&#123; <span class="comment">//表明找到,则更新信息</span></span><br><span class="line">        temp.name = newHeroNode.name;</span><br><span class="line">        temp.nickname = newHeroNode.nickname;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="comment">//没有找到该表好下的元素，进行头插</span></span><br><span class="line">        <span class="keyword">this</span>.addByOrder(newHeroNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="头插"><a href="#头插" class="headerlink" title="头插"></a>头插</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">head_add</span><span class="params">(HeroNode hero1)</span></span>&#123; <span class="comment">//头插</span></span><br><span class="line">    HeroNode temp = head;</span><br><span class="line">    hero1.next = temp.next;</span><br><span class="line">    temp.next = hero1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关题目的实现"><a href="#相关题目的实现" class="headerlink" title="相关题目的实现"></a>相关题目的实现</h2><p>本次的几个算法题目函数都写在LinkedListExercise一个类中</p><h3 id="求单链表中的节点个数"><a href="#求单链表中的节点个数" class="headerlink" title="求单链表中的节点个数"></a>求单链表中的节点个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fun1</span><span class="params">(SingleLinkedList singleLinkedList)</span></span>&#123; <span class="comment">//求单链表中的节点个数</span></span><br><span class="line">    HeroNode head = singleLinkedList.getHead(); <span class="comment">//获取该链表的头节点</span></span><br><span class="line">    HeroNode temp = head.next;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;<span class="comment">//记录链表中的节点个数</span></span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        num++;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找链表中的倒数第K个节点"><a href="#查找链表中的倒数第K个节点" class="headerlink" title="查找链表中的倒数第K个节点"></a>查找链表中的倒数第K个节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fun1</span><span class="params">(SingleLinkedList singleLinkedList)</span></span>&#123; <span class="comment">//求单链表中的节点个数</span></span><br><span class="line">    HeroNode head = singleLinkedList.getHead(); <span class="comment">//获取该链表的头节点</span></span><br><span class="line">    HeroNode temp = head.next;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;<span class="comment">//记录链表中的节点个数</span></span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        num++;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反转一个链表，并返回"><a href="#反转一个链表，并返回" class="headerlink" title="反转一个链表，并返回"></a>反转一个链表，并返回</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//网上写的代码写的挺不错的，多学习一下别人的优秀代码，有空自己吧这个函数修改一下</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SingleLinkedList <span class="title">fun3</span><span class="params">(SingleLinkedList LinkedList)</span></span>&#123;  <span class="comment">//反转一个链表，并返回</span></span><br><span class="line">    SingleLinkedList ReversedLinkedList = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line">    HeroNode head = LinkedList.getHead();</span><br><span class="line">    HeroNode temp = head.next;</span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        ReversedLinkedList.head_add(<span class="keyword">new</span> HeroNode(temp.no,temp.name,temp.nickname));  <span class="comment">//在debug的时候，这里如果不创建新节点保存数据，就会污染原始链表，导致无法遍历</span></span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ReversedLinkedList; <span class="comment">//返回反转后的新链表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="倒序打印单链表"><a href="#倒序打印单链表" class="headerlink" title="倒序打印单链表"></a>倒序打印单链表</h3><p>方式1：利用类中的反转函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun4</span><span class="params">(SingleLinkedList Linkedlist)</span></span>&#123; <span class="comment">//倒序打印单链表, 方式一：利用类中的反转函数</span></span><br><span class="line">    SingleLinkedList ReversedSingleLinkedList = <span class="keyword">this</span>.fun3(Linkedlist);</span><br><span class="line">    <span class="comment">//逆序打印</span></span><br><span class="line">    System.out.println(<span class="string">&quot;逆序打印&quot;</span>);</span><br><span class="line">    ReversedSingleLinkedList.list();</span><br><span class="line">    <span class="comment">//打印原链表</span></span><br><span class="line">    System.out.println(<span class="string">&quot;打印原链表&quot;</span>);</span><br><span class="line">    Linkedlist.list();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式2：反向遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun5</span><span class="params">(SingleLinkedList Linkedlist)</span></span>&#123; <span class="comment">//倒序打印单链表, 方式二：反向遍历</span></span><br><span class="line"></span><br><span class="line">    HeroNode temp = Linkedlist.getHead();</span><br><span class="line">    <span class="keyword">int</span> num = <span class="keyword">this</span>.fun1(Linkedlist);</span><br><span class="line">    <span class="keyword">int</span> k = num;</span><br><span class="line">    System.out.println(<span class="string">&quot;反向遍历打印链表&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(temp);</span><br><span class="line">        k = num-i-<span class="number">1</span>; <span class="comment">//计数k重新赋值</span></span><br><span class="line">        temp = Linkedlist.getHead(); <span class="comment">//temp重新拿到链表的头指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当然倒序打印还有方式三：利用栈保存元素，因为栈是后进先出，既满足倒序打印的需求</span></span><br><span class="line">    <span class="comment">//但是我还没复习到栈，这个需求留到后面再做吧</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式三：利用栈(由于java提供了stack包，这里我也给出相应的实现)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun7</span><span class="params">(SingleLinkedList Linkedlist)</span></span>&#123; <span class="comment">//利用栈逆序打印一个链表</span></span><br><span class="line"></span><br><span class="line">    Stack&lt;HeroNode&gt; stack = <span class="keyword">new</span> Stack&lt;HeroNode&gt;();<span class="comment">//创建一个栈</span></span><br><span class="line">    HeroNode head = Linkedlist.getHead();</span><br><span class="line">    HeroNode temp = head.next;</span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(temp);</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;开始出栈并逆序打印&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(!stack.empty())&#123;</span><br><span class="line">        HeroNode pop = stack.pop();</span><br><span class="line">        System.out.println(pop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两个有序链表进行有序合并"><a href="#两个有序链表进行有序合并" class="headerlink" title="两个有序链表进行有序合并"></a>两个有序链表进行有序合并</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SingleLinkedList <span class="title">fun6</span><span class="params">(SingleLinkedList Linkedlist1,SingleLinkedList Linkedlist2)</span></span>&#123;</span><br><span class="line">    <span class="comment">//这里合并两个有序链表，我个人觉得比较简单，直接调用addByOrder函即可</span></span><br><span class="line">    SingleLinkedList CombineSortedLinkedlist = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line">    HeroNode temp1 = Linkedlist1.getHead();</span><br><span class="line">    HeroNode temp2 = Linkedlist2.getHead();</span><br><span class="line">    <span class="keyword">while</span>(temp1.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//这里仍然需要创建新的HeroNode节点，去保存temp1.next节点中的信息，并被插入到CombineSortedLinkedlist中去</span></span><br><span class="line">        CombineSortedLinkedlist.addByOrder(<span class="keyword">new</span> HeroNode(temp1.next.no,temp1.next.name,temp1.next.nickname));</span><br><span class="line">        temp1 = temp1.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(temp2.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//这里仍然需要创建新的HeroNode节点，去保存temp1.next节点中的信息，并被插入到CombineSortedLinkedlist中去</span></span><br><span class="line">        CombineSortedLinkedlist.addByOrder(<span class="keyword">new</span> HeroNode(temp2.next.no,temp2.next.name,temp2.next.nickname));</span><br><span class="line">        temp2 = temp2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//合并后的新链表</span></span><br><span class="line">    System.out.println(<span class="string">&quot;合并后的新链表&quot;</span>);</span><br><span class="line">    CombineSortedLinkedlist.list();</span><br><span class="line">    <span class="keyword">return</span>  CombineSortedLinkedlist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结束语：继续加油~ fighting，希望自己能够坚持住！</p><ul><li>补充：单链表如果想删除元素的话，必须通过遍历的到被删除元素的前一个元素，在遍历的过程中用本片博客图片1中左边的遍历方式。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多个对象引用</title>
      <link href="/2021/09/26/%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8/"/>
      <url>/2021/09/26/%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="java中多个对象引用"><a href="#java中多个对象引用" class="headerlink" title="java中多个对象引用"></a>java中多个对象引用</h1><p>在堆中new出一个对象之后，对应栈中可以有多个地址指向该对象，也就是多个对象引用。</p><p>这些对象引用在调用对象方法时，实际上始终都是在调用堆中那个对象的方法。</p><p><strong>换个简单点的说法也就是，你这个对象可以有很多名字，但是最终不管通过哪一个名字来操作，影响的始终都是那一个对象！</strong></p><p>插个图吧：</p><p> <img src="/articleImg/16_article/object_reference.png" alt="object_reference"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多个对象引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>循环队列</title>
      <link href="/2021/09/25/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/"/>
      <url>/2021/09/25/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h1><h2 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h2><p>由于循环队列是普通队列的升级版本，使用效率更高，如果可以实现循环队列的话，那你实现普通队列应该也就没什么问题。</p><p>本次实现是用数组模拟队列，当然使用链队也是可以的。</p><p>下面简单的对循环队列做出简要说明，以备后期复习使用：</p><ul><li>因为队列的输出、 输入是分别从前后端来处理， 因此需要两个变量 front 及 rear 分别记录队列前后端的下标，front 会随着数据输出而改变， 而 rear 则是随着数据输入而改变， 如图所示  </li></ul><p> <img src="/articleImg/15_article/queue.png" alt="queue"></p><ul><li>循环队列中的元素个数，可以直接公式给出，当然 可以通过头尾节点的位置，通过遍历整个队列，也可得到队列中元素的个数。下面给出推导过程</li></ul><p><img src="/articleImg/15_article/count_num.png" alt="count_num"></p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p> <img src="/articleImg/15_article/process.png" alt="process"></p><h2 id="附上本次java代码"><a href="#附上本次java代码" class="headerlink" title="附上本次java代码"></a>附上本次java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircularArrayQueue</span></span>&#123;  <span class="comment">//这里实现循环队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize; <span class="comment">// 表示数组的最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front; <span class="comment">// 队列头</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear; <span class="comment">// 队列尾(********切记*************该循环队列中rear指示的是队列尾部的&quot;下一个空位置&quot;)</span></span><br><span class="line">    <span class="comment">//(也就是说rear对应的位置上没有元素的储存)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr; <span class="comment">// 该数据用于存放数据, 模拟队列</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircularArrayQueue</span><span class="params">(<span class="keyword">int</span> maxSize)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 队列头</span></span><br><span class="line">        front = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 队列尾</span></span><br><span class="line">        rear = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 该数据用于存放数据, 模拟队列</span></span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isfull</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = (rear+maxSize-front)%maxSize; <span class="comment">//在数组中队列中的元素可以通过该公式直接算出</span></span><br><span class="line">        <span class="comment">//博客中会解释该公式的由来</span></span><br><span class="line">        <span class="comment">//当然 可以通过头尾节点的位置，通过遍历整个队列，也可得到队列中元素的个数</span></span><br><span class="line">        <span class="keyword">return</span> num == maxSize-<span class="number">1</span>;  <span class="comment">//切记这里返回的是maxSize-1，因为rear位置上并没有储存数据</span></span><br><span class="line">        <span class="comment">//所以该队列的使用率为 maxSize-1</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isempty</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rear==front; <span class="comment">//当头尾标号相等时，队列为空，返回真</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isfull())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;该队列元素已满&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[rear] = value;</span><br><span class="line">        rear = (rear+<span class="number">1</span>)%maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span> </span>&#123; <span class="comment">//获取队头元素，队列是属于先进先出，取队头</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isempty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;该队列已空，无法取出数据&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[front];</span><br><span class="line">        front = (front+<span class="number">1</span>)%maxSize;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span> </span>&#123; <span class="comment">//查看队头元素，不用出队</span></span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> copy_front = front;  <span class="comment">//这里不可以直接使用front，否则毁坏队列</span></span><br><span class="line">        <span class="keyword">if</span>(isempty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列中无元素&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;开始打印该队列：队头-&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(copy_front != rear) &#123;</span><br><span class="line">            System.out.print(arr[copy_front]);</span><br><span class="line">            System.out.print(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            copy_front = (copy_front+<span class="number">1</span>)%maxSize;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;队尾&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用链队在思想上也是一样的，继续加油~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 循环队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>稀疏矩阵</title>
      <link href="/2021/09/24/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5/"/>
      <url>/2021/09/24/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h1><p>从今天开始简单记录一下自己用java写一些数据结构的过程吧，之前用C语言学习数据结构的时候，没有用心去记录，导致自己遗忘的很快，很是后悔。这次好好学，好好记~</p><p>由于稀疏矩阵较为简单，这里插入算法流图，并附上代码，以备后期复习用。</p><p> <img src="/articleImg/14_article/img1.png" alt="img1"></p><p>代码如下，代码中也有相关的注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"><span class="keyword">import</span> jdk.nashorn.api.scripting.ScriptObjectMirror;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//压缩后的矩阵第一行三个数的含义分别是  ： 原始数组的长度、原始数组的宽度、原始数组中非零数字的个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseMatrix</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] chessarray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        SparseMatrix sparseMatrix = <span class="keyword">new</span> SparseMatrix();</span><br><span class="line">        <span class="keyword">int</span>[][] compression = sparseMatrix.Compression();</span><br><span class="line">        sparseMatrix.recover();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] Compression()&#123;  <span class="comment">//压缩矩阵</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//记录有多少非0值</span></span><br><span class="line">        <span class="keyword">int</span> row_length=<span class="number">0</span>;<span class="comment">//chessarray长度</span></span><br><span class="line">        <span class="keyword">int</span> column_width=<span class="number">0</span>;<span class="comment">//chessarray宽度</span></span><br><span class="line">        <span class="comment">//初始化随便赋值几个非零值</span></span><br><span class="line">        chessarray[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        chessarray[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//打印该原始矩阵</span></span><br><span class="line">        System.out.println(<span class="string">&quot;原矩阵打印&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] rows : chessarray) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> temp : rows) &#123;</span><br><span class="line">                <span class="keyword">if</span>(rows==chessarray[<span class="number">0</span>])</span><br><span class="line">                    row_length++;</span><br><span class="line">                <span class="keyword">if</span>(temp!=<span class="number">0</span>)</span><br><span class="line">                    count++;</span><br><span class="line">                System.out.print(temp+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            column_width++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(row_length);</span></span><br><span class="line">        <span class="comment">//System.out.println(column_width);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始进行压缩矩阵的数据存储  （稀疏矩阵的核心就在这里吧）</span></span><br><span class="line">        <span class="keyword">int</span> [][]Compression_matrix = <span class="keyword">new</span> <span class="keyword">int</span>[count+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        Compression_matrix[<span class="number">0</span>][<span class="number">0</span>] = row_length;</span><br><span class="line">        Compression_matrix[<span class="number">0</span>][<span class="number">1</span>] = column_width;</span><br><span class="line">        Compression_matrix[<span class="number">0</span>][<span class="number">2</span>] = count;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(chessarray[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    Compression_matrix[index][<span class="number">0</span>] = i;</span><br><span class="line">                    Compression_matrix[index][<span class="number">1</span>] = j;</span><br><span class="line">                    Compression_matrix[index][<span class="number">2</span>] = chessarray[i][j];</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;压缩矩阵打印&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] compression_matrix : Compression_matrix) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> compressionMatrix : compression_matrix) &#123;</span><br><span class="line">                System.out.print(compressionMatrix+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将压缩后的矩阵存储到data文件中</span></span><br><span class="line">        BufferedWriter out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            out = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;F:\\Algorithm\\java\\稀疏矩阵\\matrix.data&quot;</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : Compression_matrix) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                    out.write(anInt+<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                out.newLine();</span><br><span class="line">            &#125;</span><br><span class="line">            out.flush();</span><br><span class="line">            out.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Compression_matrix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recover</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;  <span class="comment">//还原矩阵</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//从data文件中取出相关数据</span></span><br><span class="line">        BufferedReader in;</span><br><span class="line">        in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;F:\\Algorithm\\java\\稀疏矩阵\\matrix.data&quot;</span>));</span><br><span class="line">        String line = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> rows = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cols = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//读取第一行的值,获得原始数组几行几列，几个有效值</span></span><br><span class="line">        line = in.readLine();</span><br><span class="line">        String[] strings = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        rows = Integer.parseInt(strings[<span class="number">0</span>]);</span><br><span class="line">        cols = Integer.parseInt(strings[<span class="number">1</span>]);</span><br><span class="line">        sum = Integer.parseInt(strings[<span class="number">2</span>]);</span><br><span class="line">        <span class="comment">//初始化原始数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] ori = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((line = in.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            start++;</span><br><span class="line">            <span class="keyword">if</span>(start&lt;=sum)&#123; <span class="comment">//判断非零数字是否读取完毕</span></span><br><span class="line">                String[] split = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                ori[Integer.parseInt(split[<span class="number">0</span>])][Integer.parseInt(split[<span class="number">1</span>])] = Integer.parseInt(split[<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印还原后的矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : ori) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.print(anInt+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>后续加油！！！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 稀疏矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器中的三个域对象</title>
      <link href="/2021/09/23/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E7%9A%84%E4%B8%89%E4%B8%AA%E5%9F%9F%E5%AF%B9%E8%B1%A1/"/>
      <url>/2021/09/23/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E7%9A%84%E4%B8%89%E4%B8%AA%E5%9F%9F%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="tomcat中的三个域对象"><a href="#tomcat中的三个域对象" class="headerlink" title="tomcat中的三个域对象"></a>tomcat中的三个域对象</h1><table><thead><tr><th>域对象</th><th align="left">创建</th><th>销毁</th><th>作用范围</th><th>应用场景</th></tr></thead><tbody><tr><td>ServletContext</td><td align="left">服务器启动（每个服务器只有一个）</td><td>服务器正常关闭/项目从服务器移除</td><td>整个项目</td><td>记录网站访问次数,聊天室</td></tr><tr><td>HttpSession</td><td align="left">没有JSESSIONID这个cookie的时候，调 用request.getSession()方法（每个浏览器一个）</td><td>session过期（默认闲置30分钟），或者调用session对象的invalidate(）方法，或者服务器<strong>异常</strong>关闭</td><td>会话(多次请求)</td><td>验证码校验, <strong>保存用户登录状态</strong>等</td></tr><tr><td>HttpServletRequest</td><td align="left">来了请求（每次请求一个）</td><td>响应这个请求(或者请求已经接收了)</td><td>一次请求</td><td>servletA和jsp（servletB）之间数据传递(转发的时候存数据)</td></tr></tbody></table><h2 id="三个域对象如何选择"><a href="#三个域对象如何选择" class="headerlink" title="三个域对象如何选择"></a>三个域对象如何选择</h2><p>​    一般情况下, 最小的可以解决就用最小的.</p><p>​    但是需要根据情况(eg: 重定向, 多次请求, 会话范围, 用session;  如果是转发,一般选择request)</p><h2 id="ServletContext相关API"><a href="#ServletContext相关API" class="headerlink" title="ServletContext相关API"></a>ServletContext相关API</h2><ul><li>获取ServletContext对象                              ServletContext servletContext = getServletContext();</li><li>往容器ServletContext中存值                      servletContext.setAttribute(“name”,name);</li><li>从容器ServletContext中获取数据               String name = (String) servletContext.getAttribute(“name”);</li><li>获得文件mime-type                                     String mimeType01 = getServletContext().getMimeType(file01);</li><li>获得全局初始化参数                                     String getInitParameter(String name) ; //根据配置文件中的key得到value; </li><li>获取Web资源路径                                        String  getRealPath(String path);根据资源名称得到资源的绝对路径.</li><li>获取Web资源路径                                        getResourceAsStream(String path) ;返回制定路径文件的流</li></ul><h2 id="HttpSession相关API"><a href="#HttpSession相关API" class="headerlink" title="HttpSession相关API"></a>HttpSession相关API</h2><p>session是服务器端的技术, 数据保存在服务器端的</p><ul><li>获取session      requet.getSession()  只有在服务器端调用了该API，才有session产生</li><li>session基于cookie的<ul><li>创建session的同时 生成sessionId, 服务器自动通过Cookie的方式写给浏览器, 浏览器自己保存</li><li>下次的话 浏览器携带cookie(SessionId)找到对应的session使用了</li></ul></li><li>Object getAttribute(String name) ;获取值</li><li>void setAttribute(String name, Object value) ;存储值</li><li>void removeAttribute(String name)  ;移除</li></ul><h2 id="HttpServletRequest-相关知识"><a href="#HttpServletRequest-相关知识" class="headerlink" title="HttpServletRequest 相关知识"></a>HttpServletRequest 相关知识</h2><h3 id="request作用"><a href="#request作用" class="headerlink" title="request作用"></a>request作用</h3><ul><li><strong>操作请求三部分(行,头,体)</strong><ul><li>获取请求行的信息<ul><li>获取请求方式:getMethod() </li><li>获取请求的客户端的ip地址:getRemoteAddr()</li><li>获取项目部署的路径:getContextPath() </li><li>获取uri:统一资源标识符</li></ul></li><li>获取请求头的信息:getHeader(name)</li><li>获取请求参数（全部要掌握，最重要）<ul><li>getParameter(name)</li><li>getParameterValues(name)</li><li>getParameterMap()</li></ul></li><li>使用BeanUtils将map中的数据存储到JavaBean对象中（需要引入相关jar包）<ul><li>map的key要和JavaBean的属性名保持一致，如果不一致那么该字段的值就无法存储</li><li>BeanUtils中默认内置一些基本类型的转换器（如果map中的数据是string类型，JavaBean的属性还是int类型那么会自动转换）</li></ul></li></ul></li></ul><ul><li><strong>请求转发</strong>：request.getRequestDispatcher(“转发的路径”).forward(request,response); <ul><li>跳转操作是由服务器执行的，所以客户端地址栏不会发生变化</li><li>跳转操作不会发起新的请求</li><li>可以跳转到WEB-INF中的资源，但是不能跳转到其它项目的资源</li></ul></li></ul><ul><li><strong>作为”域对象“存数据</strong>  （一般会与请求转发一起使用）<ul><li>Object getAttribute(String name) ;  取</li><li>void setAttribute(String name,Object object)  ; 存</li><li>void removeAttribute(String name)  ; 移除</li></ul></li></ul><h3 id="response相关作用"><a href="#response相关作用" class="headerlink" title="response相关作用"></a>response相关作用</h3><ul><li>设置响应状态码:setStatus()</li><li>设置响应头:setHeader(name,value)<ul><li>refresh响应头，用于隔几秒钟之后跳转到某个页面</li><li>location响应头，用于重定向到某个页面</li></ul></li><li><strong>重定向</strong>的写法: sendRedirect(地址)</li><li>设置响应体的内容<ul><li>使用字符输出流输出文本内容<ul><li>response.getWriter()获取字符输出流</li><li>writer.write()/print()输出字符串</li><li>解决响应数据的中文乱码:response.setContentType(“text/html;charset=UTF-8”)</li></ul></li><li>使用字节输出流输出文件<ul><li>response.getOutputStream()获取字节输出流</li></ul></li></ul></li><li>使用IO流的框架进行边读边写</li></ul><h3 id="request中的请求转发与response中的重定向的区别"><a href="#request中的请求转发与response中的重定向的区别" class="headerlink" title="request中的请求转发与response中的重定向的区别"></a>request中的请求转发与response中的重定向的区别</h3><ul><li><strong>重定向特点</strong><ol><li>重定向的跳转是由浏览器发起的，在这个过程中浏览器会发起两次请求</li><li>定向跳转可以跳转到任意服务</li><li>无法跳转到WEB-INF中的资源，浏览器访问不到的，重定向也访问不到</li><li>重定向跳转不能和request域对象一起使用</li><li>重定向跳转浏览器的地址栏中的地址会变成跳转到的路径</li></ol></li><li><strong>请求转发特点</strong><ol><li>请求转发的跳转是由服务器发起的，在这个过程中浏览器只会发起一次请求</li><li>请求转发只能跳转到本项目的资源，但是可以跳转到WEB-INF中的资源</li><li>请求转发可以和request域对象一起使用</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器域对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java栈、堆、方法区</title>
      <link href="/2021/09/17/java%E6%A0%88%E3%80%81%E5%A0%86%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA/"/>
      <url>/2021/09/17/java%E6%A0%88%E3%80%81%E5%A0%86%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="java-堆、栈、方法区"><a href="#java-堆、栈、方法区" class="headerlink" title="java 堆、栈、方法区"></a>java 堆、栈、方法区</h1><h2 id="三个区的不同之处"><a href="#三个区的不同之处" class="headerlink" title="三个区的不同之处"></a>三个区的不同之处</h2><ul><li><h3 id="堆区"><a href="#堆区" class="headerlink" title="堆区:"></a>堆区:</h3><p>1.<strong>存储的全部是对象</strong>，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令)<br>2.jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，<strong>只存放对象本身</strong> 。</p></li><li><h3 id="栈区"><a href="#栈区" class="headerlink" title="栈区:"></a>栈区:</h3><p>1.每个线程包含一个栈区，栈中只保存<strong>基础数据类型的值</strong>和<strong>对象引用以及基础数据的引用</strong><br>2.每个栈中的数据(基础数据类型和对象引用)都是私有的，其他栈不能访问。<br>3.栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。 </p></li><li><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区:"></a>方法区:</h3><p>1.又叫静态区，跟堆一样，被所有的线程共享。<strong>方法区包含所有的class和static变量</strong>。<br>2.方法区中<strong>包含的都是在整个程序中永远唯一的元素</strong>，如class，static变量。 </p></li></ul><p> <img src="/articleImg/11_article/img1.png" alt="img1"></p><h3 id="什么是栈区的对象引用"><a href="#什么是栈区的对象引用" class="headerlink" title="什么是栈区的对象引用"></a>什么是栈区的对象引用</h3><p><strong>对象</strong>，就是类的一个实例化，把一个抽象不好理解的类举出一个实体来，例如人类是一个类，会吃喝拉撒，实例化出一个小明这个具体的人。 对象引用，就是得给这个人取个名字来指代他，跟c++的指针一样，指向这个人，可以给他一个名字王小明，王小明就是<strong>对象引用</strong>。我们想到这个人的时候就会用王小明去代替他，例如 王小明今天吃了什么，王小明多高，多重，是这个人的属性，用编程语言就是 print（王小明.身高）<br>那么在内存上有什么区别呢，当我 用人这个类实例化出王小明时，电脑是这样识别的 （人 王小明），王小明=new 人（185，60），先给出一个对象引用，此时王小明这个代号可以指向任何人，你也可以叫王小明，他也可以，然后我实例化出一个人，我把王小明这个代号指向了这个人，这个人的内存是在堆内存里的，而王小明这个对象引用是在栈内存里的</p><p>说白了对象引用就是实例对象的名字！</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆栈方法区 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java之对象之间的强制类型转换</title>
      <link href="/2021/09/17/java%E4%B9%8B%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/2021/09/17/java%E4%B9%8B%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="java之对象之间的强制类型转换"><a href="#java之对象之间的强制类型转换" class="headerlink" title="java之对象之间的强制类型转换"></a>java之对象之间的强制类型转换</h1><p>先定义一个父类，一个子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">father</span></span>&#123;  <span class="comment">//父类</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">son</span> <span class="keyword">extends</span> <span class="title">father</span></span>&#123;   <span class="comment">//子类</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>子类对象可以声明为父类类型，父类对象不可以声明为子类类型<br/></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test a=<span class="keyword">new</span> TestExtend();   <span class="comment">//正确</span></span><br><span class="line">TestExtend b=<span class="keyword">new</span> Test();   <span class="comment">//错误</span></span><br></pre></td></tr></table></figure></li><li><p>在子类对象声明为父类类型后，可以通过强制转型，转型回来<br/></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test a=<span class="keyword">new</span> TestExtend();</span><br><span class="line">TestExtend a=(TestExtend) b;         <span class="comment">//正确</span></span><br></pre></td></tr></table></figure></li><li><p>而父类对象声明为父类类型之后，并不能执行强制类型转化<br/></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test a=<span class="keyword">new</span> Test();</span><br><span class="line">TestExtend a=(TestExtend) a;                  <span class="comment">//错误</span></span><br></pre></td></tr></table></figure></li></ul><p>总结：因为在子类对象声明为父类类型后，其实对象的真实意义还是子类对象</p><p>转自 CSDN博主：LookUpMan</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强制类型转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中初始化块和静态初始化块的区别</title>
      <link href="/2021/09/15/Java%E4%B8%AD%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97%E5%92%8C%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2021/09/15/Java%E4%B8%AD%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97%E5%92%8C%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="Java中初始化块和静态初始化块的区别"><a href="#Java中初始化块和静态初始化块的区别" class="headerlink" title="Java中初始化块和静态初始化块的区别"></a>Java中初始化块和静态初始化块的区别</h1><h2 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h2><p>在Java中,有两种初始化块:<strong>静态初始化块</strong>和<strong>非静态初始化块</strong>.</p><ul><li><p><strong>静态初始化块</strong>:使用static定义,当类装载到系统时执行一次.若在静态初始化块中想初始化变量,那仅能初始化类变量,即static修饰的数据成员.</p></li><li><p><strong>非静态初始化块</strong>:在每个对象生成时都会被执行一次,可以初始化类的实例变量.</p><p>非静态初始化块会在构造函数执行时,且在构造函数主体代码执行之前被运行.</p><p>括号里的是初始化块(非静态初始化块)，这里面的代码在创建java对象时执行，而且在构造器之前执行！</p><p>其实初始化块就是构造器的补充，<strong>初始化块是不能接收任何参数的</strong>，定义的一些<strong>所有对象共有的属性、方法等内容时就可以用初始化块了初始化</strong>！！</p></li></ul><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>下面给出卷一中的示例代码<br/></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates object construction,</span></span><br><span class="line"><span class="comment"> * Aversion 1.01 2004-02-19</span></span><br><span class="line"><span class="comment"> * ©author Cay Horstmann</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorTest</span></span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">        <span class="comment">// fill the staff array with three Employee objects</span></span><br><span class="line">        Employee[] staff = <span class="keyword">new</span> Employee[<span class="number">3</span>]:</span><br><span class="line">        staff[<span class="number">0</span>] = <span class="keyword">new</span> Employee(<span class="string">&quot;Harry&quot;</span>, <span class="number">40000</span>);</span><br><span class="line">        staff[<span class="number">1</span>] = <span class="keyword">new</span> Employee(<span class="number">60000</span>);</span><br><span class="line">        staff[<span class="number">2</span>] = <span class="keyword">new</span> Employee();</span><br><span class="line">        <span class="comment">// print out information about all Employee objects</span></span><br><span class="line">        <span class="keyword">for</span> (Employee e : staff)</span><br><span class="line">        System,out.println(<span class="string">&quot;name=&quot;</span> + e.getNameO + <span class="string">&quot;,id=&quot;</span> + e.getldO + <span class="string">&quot;,salary:&quot;</span></span><br><span class="line">        + e.getSalary());</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextld;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">     <span class="keyword">private</span> String name = <span class="comment">// instance field initialization</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// static initialization block  </span></span><br><span class="line">     <span class="comment">//该类一被加载，就会执行该静态代码块，且只在加载类时执行一次</span></span><br><span class="line">      <span class="keyword">static</span></span><br><span class="line">      &#123;</span><br><span class="line">       Random generator = <span class="keyword">new</span> Random();</span><br><span class="line">       <span class="comment">// set nextld to a random number between 0 and 9999</span></span><br><span class="line">       nextld = generator.nextlnt(<span class="number">10000</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// object initialization block</span></span><br><span class="line">    <span class="comment">//初始代码块，在每次创造对象时，就会优于构造函数一步，执行</span></span><br><span class="line">        &#123;</span><br><span class="line">        id = nextld;</span><br><span class="line">        nextld++;</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="comment">// three overloaded constructors</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String n, <span class="keyword">double</span> s)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">     name = n;</span><br><span class="line">     salary = s;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">double</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// calls the Employee(String, double) constructor</span></span><br><span class="line">      ★★★  <span class="keyword">this</span>(<span class="string">&quot;Employee #&quot;</span> + nextld, s);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">        <span class="comment">// name initialized to &quot;&quot; see above</span></span><br><span class="line">        <span class="comment">// salary not explicitly set initialized to 0</span></span><br><span class="line">        <span class="comment">// id initialized in initialization block    </span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSalary</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getld</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对this顺便记录下"><a href="#对this顺便记录下" class="headerlink" title="对this顺便记录下"></a>对this顺便记录下</h2><p>在上述的代码中★★★处有个this，我对this的第二个功能理解的不太好，就是在构造函数中调用其他构造函数，这里简要也记录一下this<br/></p><ul><li><p>this作为隐式参数，也就是被构造的对象，我们以this.实例域的方式来访问实例域。<br/></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name,<span class="keyword">double</span> salary)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name=name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.salary=salary;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>this的另一个作用是调用自己同一个类的其他构造器，形式为this(…)<br/></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">double</span> s)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//调用Employee(String,double)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>(<span class="string">&quot;Employe#&quot;</span>+nextId,s);</span><br><span class="line"></span><br><span class="line">nextId++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当我们调用new Employee(6000）的时候，Employee（double）构造器将调用Employee(String,double)构造器。</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 初始化块和静态初始化块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法参数:Java中如何交换两个对象</title>
      <link href="/2021/09/09/%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0-Java%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1/"/>
      <url>/2021/09/09/%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0-Java%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="方法参数：Java中如何交换两个对象"><a href="#方法参数：Java中如何交换两个对象" class="headerlink" title="方法参数：Java中如何交换两个对象"></a>方法参数：Java中如何交换两个对象</h1><h2 id="方法参数传递的几种形式"><a href="#方法参数传递的几种形式" class="headerlink" title="方法参数传递的几种形式"></a>方法参数传递的几种形式</h2><p>java中只有值传递，基本类型传递的是值的副本，引用类型传递的是引用的副本。</p><p>在核心卷一中一共有三种情况，</p><ol><li><p>基本数据类型作为方法参数<br/></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> percent = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tripieValue</span><span class="params">(<span class="keyword">double</span> x)</span> <span class="comment">// doesn&#x27;t work</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x = <span class="number">3</span> * x;</span><br><span class="line">&#125;</span><br><span class="line">然后调用这个方法：</span><br><span class="line"><span class="keyword">double</span> percent = <span class="number">10</span>;</span><br><span class="line">tripieValue(percent);</span><br><span class="line"></span><br><span class="line">在方法调用之后， percent 的值还是 <span class="number">10</span>。</span><br></pre></td></tr></table></figure><p>对于基本数据类型总结来说就是：一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）  </p></li><li><p>对象作为方法参数<br/></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> tri pi eSal <span class="title">ary</span><span class="params">(Employee x)</span> <span class="comment">// works</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x.raiseSa1ary(<span class="number">200</span>) ;</span><br><span class="line">&#125;</span><br><span class="line">当调用</span><br><span class="line">harry = <span class="keyword">new</span> Employee(. . .) ;</span><br><span class="line">tripieValue(harry) ; <span class="comment">// 注意这里是传入的对象，对该对象进行了浅拷贝</span></span><br><span class="line"><span class="comment">// 最后 方法结束后，参数变量 x 不再使用。当然，对象变量 harry 继续引用那个薪金增至3倍的雇员对象</span></span><br></pre></td></tr></table></figure><p>对于这一点也就是说：一个方法可以改变一个对象参数的状态  </p></li><li><p>如果要交换两个对象，在Java方法中是行不通的，虽然做了浅拷贝，但改变副本的地址，对原本的实参没有影响。<br/>若想解决该问题，达到对象互换的效果，就应该借助第2点的思想“一个方法可以改变一个对象参数的状态”<br/>利用封装类的思想，把对象当作另一个类的成员变量。<br/></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Java program to demonstrate that we can use wrapper</span></span><br><span class="line"><span class="comment">// classes to swap to objects</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A car with model and no.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> model, no;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructor</span></span><br><span class="line">    Car(<span class="keyword">int</span> model, <span class="keyword">int</span> no)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.model = model;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Utility method to print object details</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;no = &quot;</span> + no + </span><br><span class="line">                           <span class="string">&quot;, model = &quot;</span> + model);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A Wrapper over class that is used for swapping</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarWrapper</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   Car c;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Constructor</span></span><br><span class="line">   CarWrapper(Car c)   &#123;<span class="keyword">this</span>.c = c;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A Class that use Car and swaps objects of Car</span></span><br><span class="line"><span class="comment">// using CarWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// This method swaps car objects in wrappers</span></span><br><span class="line">    <span class="comment">// cw1 and cw2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(CarWrapper cw1, </span></span></span><br><span class="line"><span class="params"><span class="function">                            CarWrapper cw2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Car temp = cw1.c;</span><br><span class="line">        cw1.c = cw2.c;</span><br><span class="line">        cw2.c = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Driver method</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Car c1 = <span class="keyword">new</span> Car(<span class="number">101</span>, <span class="number">1</span>);</span><br><span class="line">        Car c2 = <span class="keyword">new</span> Car(<span class="number">202</span>, <span class="number">2</span>);</span><br><span class="line">        CarWrapper cw1 = <span class="keyword">new</span> CarWrapper(c1);</span><br><span class="line">        CarWrapper cw2 = <span class="keyword">new</span> CarWrapper(c2);</span><br><span class="line">        swap(cw1, cw2);</span><br><span class="line">        cw1.c.print();</span><br><span class="line">        cw2.c.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">no = <span class="number">2</span>, model = <span class="number">202</span></span><br><span class="line">no = <span class="number">1</span>, model = <span class="number">101</span></span><br></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>Java中只有值传递，基本类型传递的是值的副本，引用类型传递的是引用的副本。</p><p>所以如果用户类不能访问到被交换的类的成员的时候，封装类可以解决这个问题。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法参数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通配符和正则表达式</title>
      <link href="/2021/09/09/%E9%80%9A%E9%85%8D%E7%AC%A6%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2021/09/09/%E9%80%9A%E9%85%8D%E7%AC%A6%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="通配符和正则表达式"><a href="#通配符和正则表达式" class="headerlink" title="通配符和正则表达式"></a>通配符和正则表达式</h1><p>今晚学了一会linux，记录一下吧，我觉得这个知识点是不是的就会出现，比如爬虫解析网页时也会需要到~</p><h2 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h2><ol><li>通配符代表的是bash的一个功能。一般只用于文件名匹配，它是由shell解析的，比如find，ls，cp，mv等。</li><li>正则表达式是一种字符串处理的方式。针对文件内容的文本过滤工具里，大都用到正则表达式，如vi，grep，awk，sed等</li><li>可以简单的理解为通配符只有*,?,[],{}这4种，而正则表达式复杂多了</li><li>在通配符中*可以匹配任意的0个或多个字符，而在正则表达式中他是重复之前的一个或者多个字符，不能独立使用的</li></ol><p>下面对这两个东西进行简要的记录。</p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="常用标识"><a href="#常用标识" class="headerlink" title="常用标识"></a>常用标识</h3><table><thead><tr><th>符号”.”</th><th>符号”*”</th><th>符号”[]”，总之就是取其中的一个</th></tr></thead><tbody><tr><td>匹配任意一个字符，除了换行符。类似shell通配符中的”?”，匹配一个任意字符。</td><td>“ * “表示前边字符有0个或多个。”.*”表示任意一个字符有0个或多个，也就是能匹配任意的字符。类似shell通配符中的”  * “，可以匹配任意字符。</td><td>“[ ]”中括号中可以包含表示字符集的表达式。使用方法大概有如下几种。<br/>[a-z]：表示a-z字符中的一个，也就是小写字母。<br/>[0-9]：表示0-9字符中的一个，也就是表示数字。<br/>[A-Z]：表示大写字母。<br/>[a-zA-Z]：表示字符集为小写字母或者大写字母。<br/>[a-zA-Z0-9]：表示普通字符，包括大小写字母和数字。<br/>[abc]：表示字符a或者字符b或者字符c。<br/>[ ^ 0-9 ]：表示非数字类型的字符，^表示取反意思，只能放在中括号的开始处才有意义。</td></tr></tbody></table><h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><table><thead><tr><th>字符</th><th align="center">含义</th></tr></thead><tbody><tr><td>^</td><td align="center">指向一行的开头<br/>这里要注意^符号需要放到 ^[]外面，才会代表行首的意思，否者放在里面，就表示取反了</td></tr><tr><td>$</td><td align="center">指向一行的结尾</td></tr><tr><td>.</td><td align="center">任意单个字符</td></tr><tr><td>\</td><td align="center">表示是转义字符</td></tr><tr><td>{}</td><td align="center">表示前边字符的数量范围，但是必须注意要加上转义字符” \ “<br/>eg:{2,9}：表示前边字符的重复次数大于2但小于9</td></tr></tbody></table><h3 id="拓展正则表达式"><a href="#拓展正则表达式" class="headerlink" title="拓展正则表达式"></a>拓展正则表达式</h3><p>扩展正则表达式是在基本正则表达式中扩展出来的，频率上可能没有基本正则表达式那么高</p><table><thead><tr><th>字符</th><th align="center">含义</th></tr></thead><tbody><tr><td>？</td><td align="center">表示前置字符有0个或1个</td></tr><tr><td>+</td><td align="center">表示前置字符有1个或多个</td></tr><tr><td>|</td><td align="center">表示指明两项之间的一个选择。<br/>abc|ABC：表示可以匹配abc或者ABC<br/>（需要注意在bash中他还表示管道，即上一条命令的输出作为下一条命令的参数）</td></tr><tr><td>()</td><td align="center">表示分组<br/> (a|b)b：表示可以匹配ab或者bb字串<br/>([0-9]) | ( [ 0 ] [0 - 9]):表示匹配0-9或者00-09</td></tr></tbody></table><p>特殊匹配模式</p><table><thead><tr><th>匹配模式</th><th>含义</th></tr></thead><tbody><tr><td>[:alnum:]</td><td>字母与数字字符,如grep[[:alnum:]] words.txt</td></tr><tr><td>[:alpha:]</td><td>字母</td></tr><tr><td>[:ascii:]</td><td>ASCII字符</td></tr><tr><td>[:blank:]</td><td>空格或制表符</td></tr><tr><td>[:cntrl:]</td><td>ASCII控制字符</td></tr><tr><td>[:digit:]</td><td>数字</td></tr><tr><td>[:graph:]</td><td>非控制、非空格字符</td></tr><tr><td>[:lower:]</td><td>小写字母</td></tr><tr><td>[:print:]</td><td>可打印字符</td></tr><tr><td>[:punct:]</td><td>标点符号字符</td></tr><tr><td>[:space:]</td><td>空白字符，包括垂直制表符</td></tr><tr><td>[:upper:]</td><td>大写字母</td></tr><tr><td>[:xdigit:]</td><td>十六进制数字</td></tr></tbody></table><p>下面简单记录以下通配符</p><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><h3 id="常见通配符"><a href="#常见通配符" class="headerlink" title="常见通配符"></a>常见通配符</h3><table><thead><tr><th><strong>通配符</strong></th><th><strong>含义</strong></th><th><strong>实例</strong></th></tr></thead><tbody><tr><td>*</td><td>匹配 0 或多个字符</td><td>a*b a与b之间可以有任意长度的任意字符, 也可以一个也没有, 如aabcb, axyzb, a012b, ab。</td></tr><tr><td>?</td><td>匹配任意一个字符</td><td>a?b a与b之间必须也只能有一个字符, 可以是任意字符, 如aab, abb, acb, a0b。</td></tr><tr><td>[list]</td><td>匹配 list 中的任意单一字符</td><td>a[xyz]b  a与b之间必须也只能有一个字符, 但只能是 x 或 y 或 z, 如: axb, ayb, azb。</td></tr><tr><td>[!list]或[ ^ list]</td><td>匹配 除list 中的任意单一字符</td><td>a[!0-9]b a与b之间必须也只能有一个字符, 但不能是阿拉伯数字, 如axb, aab, a-b。</td></tr><tr><td>[c1-c2]</td><td>匹配 c1-c2 中的任意单一字符 如：[0-9] [a-z]</td><td>a[0-9]b 0与9之间必须也只能有一个字符 如a0b, a1b… a9b。</td></tr><tr><td>[!c1-c2]或[ ^ c1-c2]</td><td>匹配不在c1-c2的任意字符</td><td>a[!0-9]b 如acb adb</td></tr><tr><td>{string1,string2,…}</td><td>匹配 sring1 或 string2 (或更多)其一字符串</td><td>a{abc,xyz,123}b 列出aabcb,axyzb,a123b</td></tr></tbody></table><h3 id="shell-元字符"><a href="#shell-元字符" class="headerlink" title="shell 元字符"></a>shell 元字符</h3><table><thead><tr><th>字符</th><th>说明</th></tr></thead><tbody><tr><td>IFS</td><td>由 <space> 或 <tab> 或 <enter> 三者之一组成(我们常用 space )</td></tr><tr><td>CR</td><td>由 <enter> 产生</td></tr><tr><td>=</td><td>设定变量</td></tr><tr><td>$</td><td>取变量值或取运算值</td></tr><tr><td>&gt;</td><td>重定向 stdout</td></tr><tr><td>&lt;</td><td>重定向 stdin</td></tr><tr><td>|</td><td>管道符号                 《注意这里与正则表达式的区别》</td></tr><tr><td>&amp;</td><td>重导向 file descriptor ，或将命令置于背景执行</td></tr><tr><td>( )</td><td>将其内的命令置于 nested subshell 执行，或用于运算或命令替换</td></tr><tr><td>{ }</td><td>将其内的命令置于 non-named function 中执行，或用在变量替换的界定范围</td></tr><tr><td>;</td><td>在前一个命令结束时，而忽略其返回值，继续执行下一个命令</td></tr><tr><td>&amp;&amp;</td><td>在前一个命令结束时，若返回值为 true，继续执行下一个命令</td></tr><tr><td>||</td><td>在前一个命令结束时，若返回值为 false，继续执行下一个命令</td></tr><tr><td>!</td><td>运算意义上的非（not）的意思</td></tr><tr><td>#</td><td>注释，常用在脚本中</td></tr><tr><td>\</td><td>转移字符，去除其后紧跟的元字符或通配符的特殊意义</td></tr></tbody></table><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>这里注意shell中单引号与双引号转义时的区别</p><table><thead><tr><th>字符</th><th>说明</th></tr></thead><tbody><tr><td>‘’(单引号)</td><td>硬转义，其内部所有的shell 元字符、通配符都会被关掉。</td></tr><tr><td>“”(双引号)</td><td>软转义，其内部只允许出现特定的shell 元字符：$用于参数替换 `(反单引号，esc键下面)用于命令替换</td></tr><tr><td>(反斜杠)</td><td>又叫转义，去除其后紧跟的元字符或通配符的特殊意义</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>就这样吧，先总结到这里，后续如果有什么需要补充的地方，再来修改吧~  该进行其他知识的学习了~</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通配符和正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在JestonNano上跑yoloV5</title>
      <link href="/2021/09/06/%E5%9C%A8JestonNano%E4%B8%8A%E8%B7%91yoloV5/"/>
      <url>/2021/09/06/%E5%9C%A8JestonNano%E4%B8%8A%E8%B7%91yoloV5/</url>
      
        <content type="html"><![CDATA[<h1 id="在Jeston-Nano上跑yoloV5"><a href="#在Jeston-Nano上跑yoloV5" class="headerlink" title="在Jeston Nano上跑yoloV5"></a>在Jeston Nano上跑yoloV5</h1><p>网上有很多教程都是讲如何在原生NANO上yoloV5，自己手上的Nano小车装有ros操作系统，我想把yolov5跑在ros中，这样就可以订阅摄像头话题了。</p><p>下面记录这两天解决这个问题的过程吧。</p><h2 id="CUDA确认"><a href="#CUDA确认" class="headerlink" title="CUDA确认"></a>CUDA确认</h2><p>jetson-nano的系统镜像中已经自带了cuda、cudnn、TensorRT等组件</p><ul><li><p>检查CUDA 开始时输入如下的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvcc -V  </span><br></pre></td></tr></table></figure></li><li><p>若没有发现cuda， 需要进行如下的配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit  ~/.bashrc</span><br><span class="line"></span><br><span class="line"># 在这个配置文件的最后写入如下的内容。</span><br><span class="line">export CUDA_HOME=/usr/local/cuda-10.2</span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/cuda-10.2/lib64:$LD_LIBRARY_PATH</span><br><span class="line">export PATH=/usr/local/cuda-10.2/bin:$PATH</span><br></pre></td></tr></table></figure></li><li><p>再次验证 nvcc -V  成功</p></li></ul><h2 id="Archiconda-构建python环境"><a href="#Archiconda-构建python环境" class="headerlink" title="Archiconda 构建python环境"></a>Archiconda 构建python环境</h2><p>首先Nano上安装Archiconda，注意这里不是Anaconda，Nano的cpu架构和window的不一样，属于aarch64的架构，所以在构建各个环境的时候需要格外注意这一点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">附上安装包 ：  https://github.com/Archiconda/build-tools/releases</span><br></pre></td></tr></table></figure><p>下载之后就和普通的anaconda一模一样。直接执行安装，会装一个基本的环境。但真正用的时候还是会conda create -n py36 python=3.6 这样创建环境，然后source activate py36 激活并使用。</p><p>安装完conda，可以用conda -V查看是否安装成功，若没成功，可自行百度各种答案。</p><p>下面进行介绍搭建环境顺序步骤</p><ul><li><p>创建python3.6 ，这里切记后续安装的环境都在这里env里进行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n py36 python=3.6</span><br></pre></td></tr></table></figure></li><li><p>安装torch</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 去英伟达官网下载相应的安装包（匹配jetson-nano）</span><br><span class="line"># 这里附上链接地址</span><br><span class="line">https://forums.developer.nvidia.com/t/pytorch-for-jetson-version-1-9-0-now-available/72048</span><br><span class="line"></span><br><span class="line"># 下载后，通过FileZilla传送到Nano中，安装命令如下</span><br><span class="line">pip install torch-1.6.0-cp36-cp36m-linux_aarch64.whl -i http://pypi.mirrors.ustc.edu.cn/simple/</span><br></pre></td></tr></table></figure></li><li><p>安装torchvision</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 不得不说这个玩意卡了我大半天，不然这个工作早就完成了~ 在英伟达官网上找不到与torch1.6匹配的torchvision0.7.0</span><br><span class="line"># 如果换用其它版本的torchvision，就会报以下错误</span><br><span class="line">RuntimeError: No such operator torchvision::nms </span><br><span class="line"></span><br><span class="line">#于是在网上科普答案，最终得解</span><br><span class="line">sudo apt-get install libjpeg-dev zlib1g-dev</span><br><span class="line">git clone --branch v0.7.0 https://gitee.com/zero-one-game/vision torchvision   </span><br><span class="line"># 鉴于国内网络环境，博主提供gitee码云加速下载，直接使用github会因出现网络问题而无法进行</span><br><span class="line">#这行命令是将源代码下载到了用户目录下的torchvision，如果torchvision已经存在，需要删除，如果提示permission denied</span><br><span class="line">#命令行使用sudo su 进入管理员模式，  执行 rm -r torchvision ,或者也可以自行查找更安全的删除方法</span><br><span class="line"></span><br><span class="line">cd torchvision   </span><br><span class="line"></span><br><span class="line">#进入用户目录下的torchvision，执行源代码编译工作，需要一定的时间，大概十多分钟</span><br><span class="line">sudo python3 setup.py install</span><br><span class="line"></span><br><span class="line">cd ../  # attempting to load torchvision from build dir will result in import error</span><br><span class="line">pip3 install &#x27;pillow&lt;7&#x27; # always needed for Python 2.7, not needed torchvision v0.5.0+ with Python 3.6</span><br><span class="line"></span><br><span class="line">-- 这里摘自CSDN博主「零壹博弈」</span><br></pre></td></tr></table></figure></li></ul><p>到这里yoloV5所需要的运行环境就算是做好了</p><h2 id="拉取yoloV5-ROS代码"><a href="#拉取yoloV5-ROS代码" class="headerlink" title="拉取yoloV5 ROS代码"></a>拉取yoloV5 ROS代码</h2><p>拉取地址如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/qianmin/yolov5_ROS</span><br></pre></td></tr></table></figure><p>在运行之前，需要做以下的工作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1:复制这个包(ros_yolo)到你的catkin_ws/src  </span><br><span class="line">2: catkin_make  </span><br><span class="line">3：在final_yolo.py中，你需要改变image_topic到你自己的相机输入主题  </span><br></pre></td></tr></table></figure><p>之后就可以开心的运行yoloV5啦</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1:roscore2:roslaunch robot_vision robot_camera.launch   # 在移动机器人端使用启动摄像头3:conda activate py36                               #进入相应python环境4:rosrun ros_yolo final_yolo.py             # 起飞~</span><br></pre></td></tr></table></figure><h2 id="运行结果示意图"><a href="#运行结果示意图" class="headerlink" title="运行结果示意图"></a>运行结果示意图</h2><p>摄像头运行</p><p><img src="/articleImg/6_article/image1.png">  </p><p>采集并识别处理后的结果</p><p><img src="/articleImg/6_article/image2.png"> </p><h2 id="未完成任务"><a href="#未完成任务" class="headerlink" title="未完成任务"></a>未完成任务</h2><p>1：感觉FPS还是有点低，虽然已经用了nano的自带gpu，我看网上有的说TensorRT还可以加速，后续可以再看一下。</p><p>2：之后打算问一下老师需不需要做一个自己的数据集，去训练参数并识别。</p><p>3：开始理解雷达成像算法</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python安装相关工具包时极慢</title>
      <link href="/2021/09/06/python%E5%AE%89%E8%A3%85%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E5%8C%85%E6%97%B6%E6%9E%81%E6%85%A2/"/>
      <url>/2021/09/06/python%E5%AE%89%E8%A3%85%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E5%8C%85%E6%97%B6%E6%9E%81%E6%85%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="python安装相关工具包时极慢"><a href="#python安装相关工具包时极慢" class="headerlink" title="python安装相关工具包时极慢"></a>python安装相关工具包时极慢</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARNING: Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None))</span><br></pre></td></tr></table></figure><p>当出现这个警告时代表着你安装时使用的源不太行，我当时的电脑已经配置了清华源（修改配置文件可自行百度），在已经配置清华源的情况下，我的下载还是感觉有点慢，感觉耽误很多时间啊，有没有！</p><p>解决方案也很简单，重新指定下载源。如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install 包名  -i http://pypi.mirrors.ustc.edu.cn/simple/</span><br></pre></td></tr></table></figure><p>如果出现报错，在后面再加上信任后缀</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--trusted-host pypi.mirrors.ustc.edu.cn</span><br></pre></td></tr></table></figure><p>这里也一并附上国内其他的下载源（u1s1我感觉中科大的最好用）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">阿里云 http://mirrors.aliyun.com/pypi/simple/</span><br><span class="line"></span><br><span class="line">中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/</span><br><span class="line"></span><br><span class="line">豆瓣(douban) http://pypi.douban.com/simple/</span><br><span class="line"></span><br><span class="line">清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>由于开代理导致python环境搭建失败</title>
      <link href="/2021/09/04/%E7%94%B1%E4%BA%8E%E5%BC%80%E4%BB%A3%E7%90%86%E5%AF%BC%E8%87%B4python%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%A4%B1%E8%B4%A5/"/>
      <url>/2021/09/04/%E7%94%B1%E4%BA%8E%E5%BC%80%E4%BB%A3%E7%90%86%E5%AF%BC%E8%87%B4python%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%A4%B1%E8%B4%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="由于开代理导致python环境搭建失败"><a href="#由于开代理导致python环境搭建失败" class="headerlink" title="由于开代理导致python环境搭建失败"></a>由于开代理导致python环境搭建失败</h1><p>以前用ssr翻墙也没遇到这种情况，现在改用clash（价格便宜10块钱80g）翻墙之后，在搭建环境的时候遇到以下两种情况。</p><ol><li><p>安装或运行时时报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">raise</span> ValueError(<span class="string">&quot;check_hostname requires server_hostname&quot;</span>)</span><br><span class="line">ValueError: check_hostname requires server_hostname</span><br></pre></td></tr></table></figure></li><li><p>安装包时报以下错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collecting package metadata (current_repodata.json): failed</span><br><span class="line"></span><br><span class="line">An unexpected error has occurred. Conda has prepared the above report.</span><br><span class="line"></span><br><span class="line">If submitted, this report will be used by core maintainers to improve</span><br><span class="line">future releases of conda.</span><br><span class="line">Would you like conda to send this report to the core maintainers?</span><br></pre></td></tr></table></figure></li></ol><p>遇到这样的情况，一般是由两种原因造成，并附上解决方案</p><ul><li><p>每次使用 pip install 命令下载插件的时候，下载的都是最新的版本，导致版本较高，可通过一下方式降级</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install 插件名称  -i http://mirrors.aliyun.com/pypi/simple</span><br></pre></td></tr></table></figure></li><li><p>极可能是开了代理，关闭代理之后，就可以运行或则是安装相应的python环境</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我们慢慢开始长大了</title>
      <link href="/2021/08/15/%E6%88%91%E4%BB%AC%E6%85%A2%E6%85%A2%E5%BC%80%E5%A7%8B%E9%95%BF%E5%A4%A7%E4%BA%86/"/>
      <url>/2021/08/15/%E6%88%91%E4%BB%AC%E6%85%A2%E6%85%A2%E5%BC%80%E5%A7%8B%E9%95%BF%E5%A4%A7%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<h1 id="长大"><a href="#长大" class="headerlink" title="长大"></a><strong>长大</strong></h1><p>​        我是1997年出生的一个小毛孩，不，现在不能说是小毛孩了。现在都已经24岁了，今天还穿着本命年该穿的红裤衩。最近一直有一个隐形的声音在我耳旁一直呼唤到“张磊，你已经长大了，父母开始变老了，该你来撑起这个家了”。我思绪万千，不得不承认自己长大了。如果还不想承认的话，那就看看自己身份证上的年龄吧，它是最诚实的。</p><h1 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a><strong>感悟</strong></h1><p>​        我无法避免长大，妹妹今年也都高三了。我想在这个关键的时间段，对自己做出一些改变。我想让自己在一年后找到一份好工作，在两年后顺利毕业。这是我人生中重要的一步。</p><h1 id="怎样做"><a href="#怎样做" class="headerlink" title="怎样做"></a><strong>怎样做</strong></h1>]]></content>
      
      
      <categories>
          
          <category> 个人感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 成长 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客搭建流程</title>
      <link href="/2021/08/14/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/"/>
      <url>/2021/08/14/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo博客搭建流程"><a href="#hexo博客搭建流程" class="headerlink" title="hexo博客搭建流程"></a><strong>hexo博客搭建流程</strong></h1><p>历经三天，我的博客终于达到了能接受的程度，还是挺开心的，因为一直都想写写博客的，一来呢：是为了记录一下自己学习的内容，做好分类。过去的几年自己确实学了不少东西，单片机啊，高数啊，JAVA基础啊，MySQL基础啊，python，数据结构…… 但都因为没有好好的整理与复习，导致自己容易遗忘，实属可惜。趁着暑假这个机会，我铁了心的想搭个博客。二来呢：为了找工作做准备，听说写博客是一个不错的个人名片。</p><p>废话少说，我把这次搭建博客的流程附上（本次安装在window10下操作，linux也差不多）：</p><h1 id="第一大块"><a href="#第一大块" class="headerlink" title="第一大块"></a><strong>第一大块</strong></h1><h2 id="安装hexo模板"><a href="#安装hexo模板" class="headerlink" title="安装hexo模板"></a><a href="https://www.bilibili.com/video/BV1Yb411a7ty">安装hexo模板</a></h2><ol><li><p>安装git工具   <a href="https://git-scm.com/">附上链接</a></p></li><li><p>安装<a href="https://nodejs.org/en/">Nodejs</a></p></li><li><p>创建一个文件夹（blog），在该文件夹下右键，选择git bash.</p><p><img src="/articleImg/second_article/image1.png"></p></li></ol><p>​            4.在git bash中进行如下安装操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">node -v#查看node版本</span><br><span class="line">npm -v#查看npm版本</span><br><span class="line">npm install -g cnpm --registry=http://registry.npm.taobao.org#安装淘宝的cnpm 管理器</span><br><span class="line">cnpm -v#查看cnpm版本</span><br><span class="line">cnpm install -g hexo-cli    #安装hexo框架</span><br><span class="line">hexo -v#查看hexo版本</span><br><span class="line">mkdir blog#创建blog目录</span><br><span class="line">cd blog #进入blog目录</span><br><span class="line">sudo hexo init #生成博客 初始化博客</span><br><span class="line">hexo s#启动本地博客服务</span><br><span class="line">http://localhost:4000/#本地访问地址</span><br><span class="line">hexo n 我的第一篇文章 #创建新的文章 </span><br><span class="line">#返回blog目录</span><br><span class="line">hexo clean #清理</span><br><span class="line">hexo g #生成</span><br><span class="line">#Github创建一个新的仓库 YourGithubName.github.io</span><br><span class="line">cnpm install --save hexo-deployer-git #在blog目录下安装git部署插件</span><br></pre></td></tr></table></figure><h2 id="配置本地hexo"><a href="#配置本地hexo" class="headerlink" title="配置本地hexo"></a>配置本地hexo</h2><p>这里其实改动的地方也不是很多。</p><p>​        1，配置_config.yml </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line"> repo: https://github.com/YourGithubName/YourGithubName.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>​        2，git bash中下载一个自己喜欢的主题，这里我下载的是butterfly</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 下载主题</span><br><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br><span class="line"># 解决报错 。如果沒有 pug 以及 stylus 的渲染器，还需要下载，否则在项目运行时会报错：</span><br><span class="line">cnpm install hexo-renderer-pug hexo-renderer-stylus --save</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        3，若想让自己的主题生效，还得配置博客根目录下的config.yml文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">修改source\categories文件夹下index.md文件为下面的代码</span><br><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2020-03-04 17:18:32</span><br><span class="line">type: categories</span><br><span class="line">layout: categories   #注意此行不添加则点击不会显示分类结果</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h1 id="第二大块"><a href="#第二大块" class="headerlink" title="第二大块"></a><strong>第二大块</strong></h1><h2 id="butterfly的美化"><a href="#butterfly的美化" class="headerlink" title="butterfly的美化"></a>butterfly的美化</h2><p>下面就是butterfly的美化了（主要修改主题文件夹下的config.yml文件），看着别人做的博客，确实很眼馋，自己改了又改，总觉得不满意，有那么一两个钟，我总是和一个样式美化不显示过不去，最后自己用尽对比、排除的方法，都没得到很好的解决。最终发现原来是浏览器没有清理缓存。这里提一句hexo clean 与 hexo c效果不一样,我在这个命令上吃了大亏，不要图省事就输入简写。</p><p>下面推荐几个我使用过的主题美化网站，这里面的博主写的都挺详细的，我在这里也就不重复了。嘻嘻</p><ol><li>首当其冲的肯定是GitHub上该主题的博主，在500多个closed issue中肯定能找到你想要的解决样式问题的答案。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/jerryc127/hexo-theme-butterfly/issues</span><br></pre></td></tr></table></figure><p>​            2.  下面几个网址都是关于美化博客，其他博主写的文章，写的都蛮详细的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 该网址在最下方贴出了很多了美化博客的传递门，可以上车</span><br><span class="line">https://butterfly.js.org/posts/7670b080/</span><br><span class="line"></span><br><span class="line"># 美化主题</span><br><span class="line">https://www.cnblogs.com/MoYu-zc/p/14395965.html</span><br><span class="line"></span><br><span class="line"># 美化主题</span><br><span class="line">https://blog.imzjw.cn/posts/b74f504f/</span><br></pre></td></tr></table></figure><p>​             3.给博客添加一些小功能            </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 添加评论系统</span><br><span class="line">https://blog.csdn.net/qq_35117024/article/details/107248047</span><br><span class="line"></span><br><span class="line">#添加分类雷达、日历图等数据统计</span><br><span class="line">https://guole.fun/posts/18158/</span><br></pre></td></tr></table></figure><p>​             4.这里记录几个比较好看的博客地址，以后有时间，自己在仿照魔改一下，哈哈</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">博主 : 花猪のBlog </span><br><span class="line">https://cnhuazhu.gitee.io/</span><br></pre></td></tr></table></figure><h2 id="第三大块"><a href="#第三大块" class="headerlink" title="第三大块"></a>第三大块</h2><p>这个大块简单记录一些些小问题，以后可能会用到。</p><p>Number one : 首先记录几个命令，每次调试的时候都很实用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 这两个把clean,生成，运行放在一起，省的自己每次要在git bash中输入三次命令。</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s -p 3999</span><br><span class="line"></span><br><span class="line">#这两是创建新的分区时使用</span><br><span class="line">hexo new page tags</span><br><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><p>这里创建之后有两个问题需要注意，不然你的目录，和分类不会显示！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1：修改source\categories文件夹下index.md文件为下面的代码</span><br><span class="line">        ---</span><br><span class="line">        title: 分类</span><br><span class="line">        date: 2020-03-04 17:18:32</span><br><span class="line">        type: categories</span><br><span class="line">        layout: categories   #注意此行不添加则点击不会显示分类结果</span><br><span class="line">        ---</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2：修改编辑scaffolds/post.md</span><br><span class="line">        ---</span><br><span class="line">        title: &#123;&#123; title &#125;&#125;</span><br><span class="line">        date: &#123;&#123; date &#125;&#125;</span><br><span class="line">        tags: &#123;&#123; tags &#125;&#125;</span><br><span class="line">        ---</span><br><span class="line">scaffolds/draft.md    scaffolds/pages.md 同理</span><br></pre></td></tr></table></figure><p>Number two: 当你不想用https进行 git传送时，可以通过下面的链接更改为SSH传送，我个人感觉SSH传送更稳定。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/qq_43768946/article/details/90411154?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control</span><br><span class="line"># 脑大 ，这个url怎么这么长....</span><br></pre></td></tr></table></figure><p>Number two: 当你hexo d传送不成功，可能是你的局域网问题吧，在windows -&gt; 控制面板 -&gt; 网络和Internet -&gt; Internet选项 -&gt; 连接 -&gt; 局域网设置  : 在这里取消代理服务器，更改位自动检测。</p><p>​    我就在自动检测和代理服务器这里切换切换，就上传了，大概就是应为传送时被墙的原因。</p><p>暂时先更新到这里吧~ 后面如果有相关优化，我会持续更新</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是Linux挂载？</title>
      <link href="/2021/08/13/%E4%BB%80%E4%B9%88%E6%98%AFLinux%E6%8C%82%E8%BD%BD%EF%BC%9F/"/>
      <url>/2021/08/13/%E4%BB%80%E4%B9%88%E6%98%AFLinux%E6%8C%82%E8%BD%BD%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是挂载？mount的用处在哪？"><a href="#什么是挂载？mount的用处在哪？" class="headerlink" title="什么是挂载？mount的用处在哪？"></a>什么是挂载？mount的用处在哪？</h1><p>1.提一句Windows下，mount挂载，就是给磁盘分区提供一个盘符（C,D,E,…）。比如插入U盘后系统自动分配给了它I:盘符其实就是挂载，退优盘的时候进行安全弹出，其实就是卸载unmount。</p><p>2.Linux下，不像Windows可以有C,D,E,多个目录，Linux只有一个根目录/。在装系统时，我们分配给linux的所有区都在/下的某个位置，比如/home等等。</p><p>3.提问者插入了新硬盘，分了新磁盘区sdb1。它现在还不属于/。</p><p>4.我们虽然可以在一些图形桌面系统里找到他的位置，浏览管理里面的文件，但在命令行却不知怎么访问它的目录，比如无法使用cd或者ls。也无法在编程时指定一个目录对它操作。</p><p>5.这时提问者使用了 mount /dev/sdb1 <del>/Share/ ，把新硬盘的区sdb1挂载到工作目录的</del>/Share/文件夹下，之后访问这个~/Share/文件夹就相当于访问这个硬盘2的sdb1分区了。对/Share/的任何操作，都相当于对sdb1里文件的操作。</p><p>6.所以Linux下，<span style='color:fuchsia'>mount挂载的作用，就是将一个设备（通常是存储设备）挂接到一个已存在的目录上。访问这个目录就是访问该存储设备。</span></p><p>7.linux将整个计算机的资源都整合成一个大的文件目录。我们要访问存储设备中的文件，必须将文件所在的分区挂载到一个已存在的目录上，然后通过访问这个目录来访问存储设备。<span style='color:fuchsia'>挂载就是把设备放在一个目录下，让系统知道怎么管理这个设备里的文件，了解这个存储设备的可读写特性之类的过程。</span></p><p>8.我们不是有/dev/sdb1 吗，直接对它操作不就行了？这不是它的目录吗？</p><p>9.这不是它的目录。虽然/dev是个目录，但/dev/sdb1不是目录。可以发现ls/dev/sdb1无法执行。/dev/sdb1，是一个类似指针的东西，指向这个分区的原始数据块。mount前，系统并不知道这个数据块哪部分数据代表文件，如何对它们操作。</p><p>10.插入CD，系统其实自动执行了 mount /dev/cdrom /media/cdrom。所以可以直接在/media/cdrom中对CD中的内容进行管理。</p><p>总结来说：挂载就是把设备（如U盘）加入到linux现有目录下，进而可以进行相应的管理。</p><p style='color:fuchsia'>不挂载的话久会造成无法使用cd或者ls等一系列命令。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mount </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
