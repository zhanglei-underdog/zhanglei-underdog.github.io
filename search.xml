<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Jquery与Ajax比较有用的API</title>
      <link href="/2021/12/15/Jquery%E4%B8%8EAjax%E6%AF%94%E8%BE%83%E6%9C%89%E7%94%A8%E7%9A%84API/"/>
      <url>/2021/12/15/Jquery%E4%B8%8EAjax%E6%AF%94%E8%BE%83%E6%9C%89%E7%94%A8%E7%9A%84API/</url>
      
        <content type="html"><![CDATA[<h1 id="Jquery与Ajax比较有用的API"><a href="#Jquery与Ajax比较有用的API" class="headerlink" title="Jquery与Ajax比较有用的API"></a>Jquery与Ajax比较有用的API</h1><h2 id="jQuery的概述"><a href="#jQuery的概述" class="headerlink" title="jQuery的概述"></a>jQuery的概述</h2><p>​    说白了: JQ就是js库, 封装了JS常见的操作,我们使用JS起来更加的简单  (特别是dom这块)</p><h2 id="jQuery的作用"><a href="#jQuery的作用" class="headerlink" title="jQuery的作用"></a>jQuery的作用</h2><p>​    jQuery最主要的作用是简化js的Dom树的操作 </p><h2 id="需要记忆的语法"><a href="#需要记忆的语法" class="headerlink" title="需要记忆的语法"></a>需要记忆的语法</h2><ul><li>JS对象转成jQ对象  ： $(js对象)</li><li>JQ对象转成JS对象  ： JQ对象[下标] 或者 JQ对象.get(下标) 下标一般写0</li><li>基本选择器</li></ul><table><thead><tr><th>选择器名称</th><th>语法</th><th>解释</th></tr></thead><tbody><tr><td>标签选择器（元素选择器）</td><td>$(“html标签名”)</td><td>获得所有匹配标签名称的于元素</td></tr><tr><td>id选择器</td><td>$(“#id的属性值”)</td><td>获得与指定id属性值匹配的元素</td></tr><tr><td>类选择器</td><td>$(“.class的属性值”)</td><td>获得与指定的class属性值匹配的元素</td></tr></tbody></table><ul><li>JQ操作样式</li></ul><table><thead><tr><th>API方法</th><th align="left">解释</th></tr></thead><tbody><tr><td>css(name) 使用很少</td><td align="left">获取CSS样式</td></tr><tr><td>css(name,value)</td><td align="left">设置CSS样式</td></tr><tr><td>addClass(类名)</td><td align="left">给标签添加类名</td></tr><tr><td>removeClass(类名)</td><td align="left">删除标签的类名</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">//目标: 鼠标移入输入框的时候，设置输入框的背景色为红色，移出输入框的时候设置输入框的背景色为蓝色</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 获取标签的css样式的方法: css(样式名) 用的很少</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 设置标签的css样式的方法: css(样式名,样式值),该方法其实就是改变了标签的行内样式</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//$(&quot;#ipt&quot;).css(&quot;background-color&quot;,&quot;red&quot;)</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="comment">//给输入框标签添加类名为&quot;redStyle&quot;</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// addClass(类名)添加类名</span></span></span><br><span class="line"><span class="javascript">            $(<span class="string">&quot;#ipt&quot;</span>).addClass(<span class="string">&quot;redStyle&quot;</span>)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 移除blueStyle类名</span></span></span><br><span class="line"><span class="javascript">            $(<span class="string">&quot;#ipt&quot;</span>).removeClass(<span class="string">&quot;blueStyle&quot;</span>)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//$(&quot;#ipt&quot;).css(&quot;background-color&quot;,&quot;blue&quot;)</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="comment">//给输入框标签添加类名为&quot;blueStyle&quot;</span></span></span><br><span class="line"><span class="javascript">            $(<span class="string">&quot;#ipt&quot;</span>).addClass(<span class="string">&quot;blueStyle&quot;</span>)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="comment">//移除redStyle类名</span></span></span><br><span class="line"><span class="javascript">            $(<span class="string">&quot;#ipt&quot;</span>).removeClass(<span class="string">&quot;redStyle&quot;</span>)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>使用JQ操作DOM</p><table><thead><tr><th>API方法</th><th>解释</th></tr></thead><tbody><tr><td>val([value])</td><td>获得/设置标签里面value属性相应的值</td></tr><tr><td>text([value])</td><td>获得/设置元素的文本内容</td></tr><tr><td>html([value])</td><td>获得/设置元素的标签体内容</td></tr></tbody></table></li><li><p>JQ中事件的使用</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jq对象.事件方法名(function()&#123;&#125;);</span><br><span class="line"></span><br><span class="line">eg:点击事件</span><br><span class="line">btn.click(function()&#123;&#125;);</span><br></pre></td></tr></table></figure><ul><li>JQ遍历</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jquery对象.each(function(index,element)&#123;&#125;);</span><br><span class="line"></span><br><span class="line">其中:(参数名字随便取的)</span><br><span class="line">index:就是元素在集合中的索引</span><br><span class="line">element：就是集合中的每一个元素对象</span><br></pre></td></tr></table></figure><ul><li>jquery的全局方法遍历</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$.each(jquery对象,function(index,element)&#123;&#125;);</span><br><span class="line"></span><br><span class="line">其中，</span><br><span class="line">index:就是元素在集合中的索引</span><br><span class="line">element：就是集合中的每一个元素对象</span><br></pre></td></tr></table></figure><p>详细见：<a href="http://www.jquery.com/">http://www.jquery.com</a></p><h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><p>解释 ：   AJax是可以做异步的请求,实现局部刷新一种客户端技术 。 注意关键词 异步~</p><h2 id="JQ的AJAX介绍"><a href="#JQ的AJAX介绍" class="headerlink" title="JQ的AJAX介绍"></a>JQ的AJAX介绍</h2><h4 id="JQuery的Ajax的API"><a href="#JQuery的Ajax的API" class="headerlink" title="JQuery的Ajax的API"></a>JQuery的Ajax的API</h4><table><thead><tr><th>请求方式</th><th>语法</th></tr></thead><tbody><tr><td><strong>GET请求</strong></td><td>$.get(url, <em>[data]</em>, <em>[callback]</em>, <em>[type]</em>)</td></tr><tr><td><strong>POST请求</strong></td><td>$.post(url, <em>[data]</em>, <em>[callback]</em>, <em>[type]</em>)</td></tr><tr><td><strong>AJAX请求</strong></td><td>$.ajax([settings])</td></tr></tbody></table><h4 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h4><ul><li><p>get方式,  语法    <code>$.get(url, [data], [callback], [type]);</code></p><table><thead><tr><th>参数名称</th><th>解释</th></tr></thead><tbody><tr><td>url</td><td>请求的服务器端url地址</td></tr><tr><td>data</td><td>发送给服务器端的请求参数，格式是key=value；get请求的参数可以直接写在url后面</td></tr><tr><td>callback</td><td>当请求成功后的回掉函数，可以在函数体中编写我们的逻辑代码</td></tr><tr><td>type</td><td>预期的返回数据的类型(默认为text)，取值可以是 xml, html, script, json, text, _defaul等   (最常用json)</td></tr></tbody></table></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个方法使用jQuery的ajax发送异步的get请求</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $.get(<span class="string">&quot;/demo01?username=tom&quot;</span>,<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//在这个回调函数中处理响应数据result</span></span><br><span class="line">        <span class="comment">//将响应数据展示在id为msg的div中</span></span><br><span class="line">        $(<span class="string">&quot;#msg&quot;</span>).html(result)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="post"><a href="#post" class="headerlink" title="post()"></a>post()</h4><ul><li>post方式, 语法 <code>$.post(url, [data], [callback], [type])</code></li></ul><table><thead><tr><th>参数名称</th><th>解释</th></tr></thead><tbody><tr><td>url</td><td>请求的服务器端url地址</td></tr><tr><td>data</td><td>发送给服务器端的请求参数，格式是key=value</td></tr><tr><td>callback</td><td>当请求成功后的回掉函数，可以在函数体中编写我们的逻辑代码</td></tr><tr><td>type</td><td>预期的返回数据的类型(默认为text)，取值可以是 xml, html, script, json, text, _defaul等  (最常用json)</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个方法使用jQuery的ajax方法发送异步请求</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn5</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        <span class="attr">url</span>:<span class="string">&quot;/demo01&quot;</span>, <span class="comment">//请求路径</span></span><br><span class="line">        <span class="attr">data</span>:<span class="string">&quot;username=lucy&quot;</span>, <span class="comment">//请求参数</span></span><br><span class="line">        <span class="attr">type</span>:<span class="string">&quot;POST&quot;</span>, <span class="comment">//请求方式</span></span><br><span class="line">        <span class="attr">success</span>:<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">            $(<span class="string">&quot;#msg&quot;</span>).html(result)</span><br><span class="line">        &#125;, <span class="comment">//请求成功时候的回调函数</span></span><br><span class="line">        <span class="attr">error</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            $(<span class="string">&quot;#msg&quot;</span>).html(<span class="string">&quot;服务器异常&quot;</span>)</span><br><span class="line">        &#125; <span class="comment">//请求失败时候的回调函数</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用Ajax之后，服务器端的代码一般的写法"><a href="#使用Ajax之后，服务器端的代码一般的写法" class="headerlink" title="使用Ajax之后，服务器端的代码一般的写法"></a>使用Ajax之后，服务器端的代码一般的写法</h2><p> <img src="/articleImg/45_article/mycode.png" alt="mycode"></p><p>自己学后端起步有点晚了，不过我相信，兴趣决定高度，努力决定程度，加油吧~摩托！</p>]]></content>
      
      
      <categories>
          
          <category> javaweb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsp提交form表单到servlet，但取值全为空？</title>
      <link href="/2021/12/15/jsp%E6%8F%90%E4%BA%A4form%E8%A1%A8%E5%8D%95%E5%88%B0servlet%EF%BC%8C%E4%BD%86%E5%8F%96%E5%80%BC%E5%85%A8%E4%B8%BA%E7%A9%BA%EF%BC%9F/"/>
      <url>/2021/12/15/jsp%E6%8F%90%E4%BA%A4form%E8%A1%A8%E5%8D%95%E5%88%B0servlet%EF%BC%8C%E4%BD%86%E5%8F%96%E5%80%BC%E5%85%A8%E4%B8%BA%E7%A9%BA%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="jsp提交form表单到servlet，但取值全为空？"><a href="#jsp提交form表单到servlet，但取值全为空？" class="headerlink" title="jsp提交form表单到servlet，但取值全为空？"></a>jsp提交form表单到servlet，但取值全为空？</h1><p>1.检查你的jsp页面</p><p>（1）当你提交表单到servlet时，当要获取表单的值是，request.getParameter(“（form表单中的name属性的值）”) 所以form表单提交的数据都用控件的name而不是id来控制的，浏览器会根据name来设定发送到服务器的request。因此如果用id，服务器是无 法得到数据的。 所以你需要检查你的form表单中是否忘记写name属性了？</p><p>3.检查jsp跳转到servlet的过程</p><p>jsp提交的方式是post，但是我却在doGet(HttpServletRequest request, HttpServletResponse response)里写代码 doPost方法里啥都没有 数据怎么可能会过去呢？所以粗心呀</p><p>有两种方法可以解决：</p><ul><li>把doGet方法里面的代码放在doPost里就可以了</li><li>也可以在doGet方法里写代码 但是需要在doPost方法里加一句代码：doGet(request, response);</li></ul><p> <img src="/articleImg/44_article/mecode.png" alt="mecode"></p>]]></content>
      
      
      <categories>
          
          <category> javaweb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JetsonNano配置IntelD455深度相机</title>
      <link href="/2021/11/21/JetsonNano%E9%85%8D%E7%BD%AEIntelD455%E6%B7%B1%E5%BA%A6%E7%9B%B8%E6%9C%BA/"/>
      <url>/2021/11/21/JetsonNano%E9%85%8D%E7%BD%AEIntelD455%E6%B7%B1%E5%BA%A6%E7%9B%B8%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Jetson-Nano配置Intel-D455深度相机"><a href="#Jetson-Nano配置Intel-D455深度相机" class="headerlink" title="Jetson Nano配置Intel D455深度相机"></a>Jetson Nano配置Intel D455深度相机</h1><p>首先我要说明为什么这么耽误时间，4天…</p><p>第一：git clone很慢 （后续已被解决）</p><p>第二：安装失败时，我就重装了NANO的镜像，担心旧文件会对下一次的重新编译产生影响</p><p>第三：编译的速度很慢，每次编译结束都需要两个钟左右！</p><p>第四：自己尝试很多其他方案，最终才works! </p><p>费了老鼻子劲了，才把这这东西配置好，嵌入式工程师不好当啊~</p><p>贴出Nvidia官网的安装指导，我安装官网的方式1，即按包去安装，试了几次，每次都不行，UI界面都出来了，但是就是连接不上D455相机。俺也不知道这是为啥，有可能是D455是一款较新的产品吧，相对于D435。（最后得解，源码编译大法解决问题）</p><h2 id="在源码编译的过程中，会遇到git-clone相关包，git不下来的现象（先进行这一步！）"><a href="#在源码编译的过程中，会遇到git-clone相关包，git不下来的现象（先进行这一步！）" class="headerlink" title="在源码编译的过程中，会遇到git clone相关包，git不下来的现象（先进行这一步！）"></a>在源码编译的过程中，会遇到git clone相关包，git不下来的现象（先进行这一步！）</h2><p>自己尝试ssr(shadowsocks)与proxychains为nano开代理去git clone，无奈失败，不知道问题出在哪里，后续有时间了可以再排查一下。时间紧任务重，不能死磕！</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>直接在windows上git cone，把这两个包都放到build文件夹下的third-party文件夹下<strong>（尤其注意文件根目录下也有一个thirty-party文件夹，不要放错了）</strong>。然后再把源码cmakelist中的git  clone都注释掉。</p><p>**pybind11 **：git clone <a href="https://github.com/pybind/pybind11.git">https://github.com/pybind/pybind11.git</a></p><p>注释掉 ~/librealsense/third-party文件夹下的pybind11中cmakelist中的git clone <a href="https://github.com/pybind/pybind11.git">https://github.com/pybind/pybind11.git</a></p><p><strong>libcurl</strong>:<a href="https://github.com/curl/curl"> https://github.com/curl/curl </a></p><p>注释掉 ~/librealsense/CMake 文件下的 external_libcurl.cmake 的 GIT_REPOSITORY “git://github.com/curl/curl.git” 。</p><p>并将提前下载后的 curl.zip 解压后 改名为 <strong>libcurl</strong> ，放入到 ~/librealsense/build/third-party。</p><h2 id="尝试源码编译"><a href="#尝试源码编译" class="headerlink" title="尝试源码编译"></a>尝试源码编译</h2><p>经历了按包安装的失败之后，自己便乖乖的去源码编译了。</p><p>源码地址：<a href="https://github.com/JetsonHacksNano/installLibrealsense">https://github.com/JetsonHacksNano/installLibrealsense</a>  直接下载zip即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>:运行udev脚本</span><br><span class="line">    cd librealsense</span><br><span class="line">    ./scripts/setup_udev_rules.sh</span><br><span class="line">    echo <span class="string">&#x27;hid_sensor_custom&#x27;</span> | sudo tee -a /etc/modules</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>：添加环境变量，也可直接添加到bashrc</span><br><span class="line">    export CUDA_HOME=/usr/local/cuda-<span class="number">10.2</span></span><br><span class="line">    export LD_LIBRARY_PATH=/usr/local/cuda-<span class="number">10.2</span>/lib64:$LD_LIBRARY_PATH</span><br><span class="line">    export PATH=/usr/local/cuda-<span class="number">10.2</span>/<span class="built_in">bin</span>:$PATH</span><br><span class="line">        </span><br><span class="line">    source一下</span><br><span class="line">    </span><br><span class="line"><span class="number">3</span>:编译</span><br><span class="line">    mkdir build</span><br><span class="line">    </span><br><span class="line">    cd build</span><br><span class="line">    </span><br><span class="line">    cmake ../ -DBUILD_PYTHON_BINDINGS:<span class="built_in">bool</span>=true -DPYTHON_EXECUTABLE=/home/bingda/archiconda3/envs/py36/<span class="built_in">bin</span>/python -DBUILD_WITH_CUDA=true  （注意我这里用的python环境是Archiconda中envs的py36）</span><br><span class="line">    </span><br><span class="line">    sudo make uninstall &amp;&amp; make clean</span><br><span class="line">    make -j4   <span class="comment">#多核make的时候会报错，可选择直接单核$make 这里尝试 j2</span></span><br><span class="line">    sudo make install</span><br><span class="line">    </span><br><span class="line"><span class="number">4</span>：添加环境变量 vim ~/.bashrc</span><br><span class="line">export PYTHONPATH=$PYTHONPATH:/usr/local/lib:/usr/local/lib/python3<span class="number">.6</span>/pyrealsense2</span><br></pre></td></tr></table></figure><p>验证是否编译成功：终端运行 realsense-viewer 即有相关的UI界面展示出来。</p><h2 id="源码编译之后，会发现在python环境下无法使用pyrealsense2包"><a href="#源码编译之后，会发现在python环境下无法使用pyrealsense2包" class="headerlink" title="源码编译之后，会发现在python环境下无法使用pyrealsense2包"></a>源码编译之后，会发现在python环境下无法使用pyrealsense2包</h2><p>这个问题也困扰了我一天，这里一共要进行两步解决：</p><p>第一： 在python文件下添加 该句代码，因为pyrealsense2包在该路径下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sys.path.append(&#x27;/usr/local/lib/python3.6/&#x27;)</span><br></pre></td></tr></table></figure><p>经过该步之后，发现可以import pyrealsense2 包了，但是其中的相关API功能均无法使用。</p><p>第二：将下述的三个.so文件，copy到python代码所在的路径（路径，文件名会随着你的环境可能不太一样）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib/python3.6/pyrealsense2/pyrealsense2.cpython-36m-aarch64-linux-gnu.so</span><br><span class="line">/usr/lib/python3.6/pyrealsense2/pyrealsense2.cpython-36m-aarch64-linux-gnu.so.2.49</span><br><span class="line">/usr/lib/python3.6/pyrealsense2/pyrealsense2.cpython-36m-aarch64-linux-gnu.so.2.49.0</span><br></pre></td></tr></table></figure><p>经过上述的两不，便可以正常使用pyrealsense2包的相关功能了~</p><p>终于大功告成！！！！！！！！很多问题也都是靠自己尝试得出的解决方案，在网络上没有百分百切合我问题的答案，所以还是蛮有成就感的~</p>]]></content>
      
      
      <categories>
          
          <category> JetsonNano </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Intel D455 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JetsonNano重装系统</title>
      <link href="/2021/11/21/JetsonNano%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/"/>
      <url>/2021/11/21/JetsonNano%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="Jetson-Nano-重装系统"><a href="#Jetson-Nano-重装系统" class="headerlink" title="Jetson Nano 重装系统"></a>Jetson Nano 重装系统</h1><p>最近在装intel的D455相机到jetson nano，是用的SD卡装系统的。当nano中的ubuntu系统环境被我装乱时，<br>我就想重新装系统，所以遇到需要重新格式化的问题。遇到的问题与下图：</p><p><img src="/articleImg/42_article/U%E7%9B%98.png" alt="U盘"></p><p>根本格式化不过来，只能通过终端操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cmd命令行，依次如下命令：</span><br><span class="line"></span><br><span class="line">diskpart</span><br><span class="line"></span><br><span class="line">list disk</span><br><span class="line"></span><br><span class="line">select disk 2*#一定要选对硬盘设备，要不然....* </span><br><span class="line"></span><br><span class="line">clean</span><br></pre></td></tr></table></figure><p>格式化SD卡之后可以通过，此电脑–管理—磁盘管理  进行对SD卡的从新分配磁盘空间。</p><p>ok~</p>]]></content>
      
      
      <categories>
          
          <category> JetsonNano </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 格式化SD卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以nano为载体的Ubuntu系统的各种下载源配置</title>
      <link href="/2021/11/21/%E4%BB%A5nano%E4%B8%BA%E8%BD%BD%E4%BD%93%E7%9A%84Ubuntu%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%84%E7%A7%8D%E4%B8%8B%E8%BD%BD%E6%BA%90%E9%85%8D%E7%BD%AE/"/>
      <url>/2021/11/21/%E4%BB%A5nano%E4%B8%BA%E8%BD%BD%E4%BD%93%E7%9A%84Ubuntu%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%84%E7%A7%8D%E4%B8%8B%E8%BD%BD%E6%BA%90%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="以nano为载体的Ubuntu系统的各种下载源配置"><a href="#以nano为载体的Ubuntu系统的各种下载源配置" class="headerlink" title="以nano为载体的Ubuntu系统的各种下载源配置"></a>以nano为载体的Ubuntu系统的各种下载源配置</h1><h2 id="安装Archiconda3"><a href="#安装Archiconda3" class="headerlink" title="安装Archiconda3"></a>安装Archiconda3</h2><p>下载地址：<a href="https://github.com/Archiconda/build-tools">https://github.com/Archiconda/build-tools</a></p><p>到release中找对应的版本就可以了</p><h2 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit ~/.bashrc </span><br><span class="line"></span><br><span class="line">export CUDA_HOME=/usr/local/cuda-10.2</span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/cuda-10.2/lib64:$LD_LIBRARY_PATH</span><br><span class="line">export PATH=/usr/local/cuda-10.2/bin:$PATH</span><br><span class="line"></span><br><span class="line">source一下</span><br></pre></td></tr></table></figure><h2 id="启动脚本"><a href="#启动脚本" class="headerlink" title="启动脚本"></a>启动脚本</h2><p>chmod a+x  -xxx.sh<br>./Archiconda-xxx.sh</p><h2 id="再次添加环境变量"><a href="#再次添加环境变量" class="headerlink" title="再次添加环境变量"></a>再次添加环境变量</h2><p>安装conda之后如果找不见，需要添加环境变量，方法如下：</p><p>（1）：sudo gedit~/.bashrc </p><p>（2）：export PATH=~/archiconda3/bin:$PATH</p><h2 id="更换conda源"><a href="#更换conda源" class="headerlink" title="更换conda源"></a>更换conda源</h2><p>conda 换源（清华源只能用http）</p><h3 id="方式1：通过终端添加"><a href="#方式1：通过终端添加" class="headerlink" title="方式1：通过终端添加"></a>方式1：通过终端添加</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/</span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/</span><br><span class="line"></span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure><p>如果需要删除某个通道的源，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config –remove channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br></pre></td></tr></table></figure><h3 id="方式二：通过文件写入添加"><a href="#方式二：通过文件写入添加" class="headerlink" title="方式二：通过文件写入添加"></a>方式二：通过文件写入添加</h3><p>sudo gedit ~/.condarc  （实测中该种方法表现并不佳，最终采用的是方式一去添加）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">channels:</span><br><span class="line">  - defaults</span><br><span class="line">show_channel_urls: true</span><br><span class="line">default_channels:</span><br><span class="line">  - http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</span><br><span class="line">  - http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r</span><br><span class="line">  - http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2</span><br><span class="line">custom_channels:</span><br><span class="line">  conda-forge: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  msys2: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  bioconda: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  menpo: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  pytorch: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  simpleitk: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br></pre></td></tr></table></figure><h2 id="更换apt源"><a href="#更换apt源" class="headerlink" title="更换apt源"></a><strong>更换apt源</strong></h2><p>配置文件进行备份</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure><p>如果需要<strong>恢复原来的配置文件</strong>，只需要用备份的配置文件覆盖原来的配置文件即可，命令如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list.bak /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>使用gedit打开source.list文件，命令如下（ubuntu18.04）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/apt/sources.list</span><br><span class="line">粘贴如下内容</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后更软件源，完成配置apt源。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><h2 id="更换pip源"><a href="#更换pip源" class="headerlink" title="更换pip源"></a><strong>更换pip源</strong></h2><p>方法一：在用户路径下创建.pip/pip.conf文件，因为执行pip命令时，会先运行~/.pip/pip.conf文件，命令如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/.pip</span><br><span class="line">sudo gedit ~/.pip/pip.conf</span><br></pre></td></tr></table></figure><p>将下面的命令添加到pip.conf文件中，点击保存，即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = http://pypi.douban.com/simple</span><br><span class="line">trusted-host = pypi.douban.com</span><br></pre></td></tr></table></figure><p>方法二 ：在pip时指定即可 （经常使用该方法）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install 包名  -i http://pypi.mirrors.ustc.edu.cn/simple/  --trusted-host pypi.mirrors.ustc.edu.cn</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JetsonNano </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/2021/10/25/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2021/10/25/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题（即所谓的并、查）。比如说，我们可以用并查集来判断一个森林中有几棵树、某个节点是否属于某棵树等。</p><h2 id="主要构成："><a href="#主要构成：" class="headerlink" title="主要构成："></a>主要构成：</h2><p>并查集主要由一个整型数组pre[ ]和两个函数getFather( )、merge( )构成。<br>数组 pre[ ] 记录了每个点的前驱节点是谁，函数 getFather(x)（路径压缩算法）用于查找指定节点 x 属于哪个集合（即找到当前节点最终的根节点），函数 merge(x,y) 用于合并两个节点 x 和 y 。</p><h2 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h2><p>并查集的主要作用是求连通分支数（如果一个图中所有点都存在可达关系（直接或间接相连），则此图的连通分支数为1；如果此图有两大子图各自全部可达，则此图的连通分支数为2……）</p><h2 id="求犯罪团伙题目"><a href="#求犯罪团伙题目" class="headerlink" title="求犯罪团伙题目"></a>求犯罪团伙题目</h2><h2 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h2><p>现在有10个强盗。<br>1号强盗与2号强盗是同伙。3号强盗与4号强盗是同伙。</p><p>5号强盗与2号强盗是同伙。4号强盗与6号强盗是同伙。</p><p>2号强盗与6号强盗是同伙。8号强盗与7号强盗是同伙。</p><p>9号强盗与7号强盗是同伙。1号强盗与6号强盗是同伙。</p><p>2号强盗与4号强盗是同伙。</p><p>请分析一共有多少个犯罪团伙。</p><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>初始化原则：pre[ ]数组的初始化节点是其本身编号，这很重要，一定要先初始化，在进行后续的操作。</p><p>靠左原则：所给线索中，左边强盗比较强势，让右边强盗归顺左边。</p><p>擒贼先擒王原则：每次需要合并节点时，比较要找到当前节点的根节点，将两个根节点进行合并。另外，在找根的过程中要本着<strong>路径压缩</strong>的思想，即：<strong>把找父过程中，所有的中间点，包括起始点的父都设为最终找到的根节点</strong>。</p><p>路径压缩可以用递归实现，也可以用栈实现。</p><p>java的实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckandSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[]pre = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">12</span>];<span class="comment">//用1~11去表示抓获的11个嫌疑人</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][]clue = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">2</span>&#125;,&#123;<span class="number">4</span>,<span class="number">6</span>&#125;,&#123;<span class="number">2</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">11</span>&#125;,&#123;<span class="number">8</span>,<span class="number">7</span>&#125;,&#123;<span class="number">9</span>,<span class="number">7</span>&#125;,&#123;<span class="number">9</span>,<span class="number">11</span>&#125;,&#123;<span class="number">1</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CheckandSet checkandSet = <span class="keyword">new</span> CheckandSet();</span><br><span class="line">        <span class="comment">//一定要对tree矩阵进行初始化，刚开始忘记了</span></span><br><span class="line">        checkandSet.init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; checkandSet.clue.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> leftF = checkandSet.getFather2(checkandSet.clue[i][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> rightF = checkandSet.getFather2(checkandSet.clue[i][<span class="number">1</span>]);</span><br><span class="line">            checkandSet.merge(leftF,rightF);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(checkandSet.pre));</span><br><span class="line">        System.out.printf(<span class="string">&quot;由上述的结果可得，一共有%d个犯罪团伙&quot;</span>,checkandSet.getAnswer2());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//啊哈算法上的求犯罪团伙的函数为</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getAnswer2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pre.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(pre[i] == i)</span><br><span class="line">                answer++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getAnswer</span><span class="params">()</span></span>&#123; <span class="comment">//从经过并查集算法的数组中，获取一共有多少个犯罪团伙</span></span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; rootStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pre.length; i++) &#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(rootStack.isEmpty())&#123;</span><br><span class="line">                rootStack.push(pre[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> size = rootStack.size();</span><br><span class="line">                <span class="keyword">for</span> (Integer integer : rootStack) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (integer == getFather(i)) &#123;</span><br><span class="line">                        flag = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            rootStack.push(getFather(i));</span><br><span class="line">            answer++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123; <span class="comment">//将两个节点合并，遵循靠左原则</span></span><br><span class="line">        <span class="comment">//i代表左边节点  j代表右边节点</span></span><br><span class="line">        pre[j] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//啊哈算法上的求根部的父节点，在更新中间值时，我用的是栈：先记录，在更新   啊哈算法上用的是递归</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getFather2</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123; <span class="comment">//擒贼先擒王</span></span><br><span class="line">        <span class="keyword">if</span>(pre[num] == num)</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        pre[num] = getFather2(pre[num]);</span><br><span class="line">        <span class="keyword">return</span> pre[num];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getFather</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123; <span class="comment">//擒贼先擒王</span></span><br><span class="line">        Stack&lt;Integer&gt; NumStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> temp = num;</span><br><span class="line">        <span class="keyword">while</span>(pre[temp] != temp)&#123;</span><br><span class="line">            NumStack.add(temp);</span><br><span class="line">            temp = pre[temp];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把找父过程中，所有的中间点，包括起始点的父都设为最终找到的根节点</span></span><br><span class="line">        <span class="keyword">while</span>(!NumStack.isEmpty())&#123;</span><br><span class="line">            Integer pop = NumStack.pop();</span><br><span class="line">            pre[pop] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp; <span class="comment">//返回这轮找到的根父</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pre.length; i++) &#123;</span><br><span class="line">            pre[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的运行结果如下</p><p><img src="/articleImg/40_article/image1.png" alt="image1"></p><p>继续加油~</p><p>最近要准备开题了，希望自己能顺利。锦鲤附体！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集找祖先 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树--堆排序</title>
      <link href="/2021/10/25/%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>/2021/10/25/%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树–堆排序"><a href="#二叉树–堆排序" class="headerlink" title="二叉树–堆排序"></a>二叉树–堆排序</h1><p>二叉树可以用链表表示，也可以用数组去模拟。本次博客实现的算法主要是依赖数组模拟的完全二叉树，去进行堆排序。</p><h2 id="数组模拟完全二叉树的一些特点"><a href="#数组模拟完全二叉树的一些特点" class="headerlink" title="数组模拟完全二叉树的一些特点"></a>数组模拟完全二叉树的一些特点</h2><p> <img src="/articleImg/39_article/image1.png" alt="image1"></p><ul><li><p>通过上图我们发现，如果完全二叉树的一个父结点编号为k，那么它左儿子的编号就是2<em>k，右儿子的编号就是2</em>k+1。如果已知儿子（左儿子或右儿子）的编号是x，那么它父结点的编号就是x/2，注意这里只取商的整数部分。在java、C中，如果除号“”两边都是整数的话，那么商也只有整数部分（即自动向下取整)，即4/2和5/2都是2。</p></li><li><p>另外如果一棵完全二叉树有N个结点，那么这个完全二叉树的高度为logzN，简写为 log N，即最多有 log N层结点。完全二叉树的最典型应用就是——堆。</p></li><li><p>就是所有父结点都比子结点要小 (注意:圆圈里面的数是值，圆圈上面的数是这个结点的编号)。符合这样特点的完全二叉树我们称为最小堆。反之，如果所有父结点都比子结点要大，这样的完全二叉树称为最大堆。那这一特性究竟有什么用呢?下面举例一个最小堆</p></li></ul><p> <img src="/articleImg/39_article/image2.png" alt="image2"></p><h2 id="堆排序思想"><a href="#堆排序思想" class="headerlink" title="堆排序思想"></a>堆排序思想</h2><p><strong>最小堆排序</strong>：每次将根节点的元素值输出，然后将最后一个叶子节点的元素值放到根节点，然后堆节点总数减1，最后向下调整元素。</p><p> <img src="/articleImg/39_article/graph1.png" alt="graph1"></p><p><strong>最大堆排序</strong>：每次将根节点的元素值与最后一个叶子节点的元素值进行互换，然后堆节点总数减1,最后向下调整元素。流程图和最小堆的异曲同工，这里就不画流程图了。</p><h2 id="堆排序代码"><a href="#堆排序代码" class="headerlink" title="堆排序代码"></a>堆排序代码</h2><p>在最小堆排序中需要的函数有：根据数组元素创建最小堆、将节点元素值较大的向下调整位置。</p><p>在最大堆排序中需要的函数有：根据数组元素创建最小堆、将节点元素值较小的向下调整位置。</p><p>另外在创建最小最大堆时，也可以从n/2节点处，向下调整元素，因为我们从最后一个结点开始，依次判断以这个结点为根的子树是否符合最小堆的特性。如果所有的子树都符合最小堆的特性，那么整棵树就是最小堆了。<strong>注意完全二叉树有一个性质:最后一个非叶结点是第n/2个结点。</strong></p><p>相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">heapsort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] binaryTree = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>; <span class="comment">//表示二叉树中的节点个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            heapsort Heapsort = <span class="keyword">new</span> heapsort();</span><br><span class="line">            Heapsort.binaryTree = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,<span class="number">23</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">17</span>,<span class="number">25</span>,<span class="number">19</span>,<span class="number">36</span>,<span class="number">99</span>,<span class="number">22</span>,<span class="number">28</span>,<span class="number">46</span>,<span class="number">92</span>&#125;; <span class="comment">//注意binaryTree是从下表1开始保存数据的，切记这里面有一个-1</span></span><br><span class="line">            Heapsort.num = <span class="number">14</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;排序之前：&quot;</span>+Arrays.toString(Heapsort.binaryTree));</span><br><span class="line">            Heapsort.heapsortFun(Heapsort.binaryTree,Heapsort.num);<span class="comment">//利用最小堆排序</span></span><br><span class="line">            <span class="comment">//Heapsort.heapsortFun2(Heapsort.binaryTree,Heapsort.num); //利用最大堆排序</span></span><br><span class="line">            System.out.println(<span class="string">&quot;排序之后：&quot;</span>+Arrays.toString(Heapsort.binaryTree));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapsortFun2</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> nodeNum)</span></span>&#123; <span class="comment">//堆排序函数，最大堆排序</span></span><br><span class="line">            <span class="keyword">this</span>.BuildMaximumHeap(arr,nodeNum);</span><br><span class="line">            System.out.println(<span class="string">&quot;最大堆：&quot;</span>+Arrays.toString(arr));</span><br><span class="line">            <span class="keyword">int</span> copyNodeNum = nodeNum;</span><br><span class="line">            <span class="keyword">while</span>(copyNodeNum&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.swap(<span class="number">1</span>,copyNodeNum,arr);</span><br><span class="line">                copyNodeNum--; <span class="comment">//先减，因为最后一个叶子节点上的数就是我们想要的排序数，不动它</span></span><br><span class="line">                <span class="keyword">this</span>.siftDownMax(<span class="number">1</span>,arr,copyNodeNum); <span class="comment">//再调整</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapsortFun</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> nodeNum)</span></span>&#123; <span class="comment">//堆排序函数，最小堆排序</span></span><br><span class="line">        <span class="comment">//主要思想：可以先建立最小堆，然后每次删除顶部元素并将顶部元素输出或者放入一个新的数组中，直到堆为空为止。</span></span><br><span class="line">        <span class="comment">// 最终输出的或者存放在新数组中的数就已经是排序好的了。</span></span><br><span class="line">        <span class="keyword">this</span>.BuildMinimumHeap2(); <span class="comment">//将此时的二叉树，转化为最小堆</span></span><br><span class="line">        <span class="keyword">int</span>[] CopyBinaryTree = <span class="keyword">new</span> <span class="keyword">int</span>[nodeNum+<span class="number">1</span>]; <span class="comment">//copy一下最小堆，不然最后转化，会破环原最小堆</span></span><br><span class="line">        System.arraycopy(arr, <span class="number">0</span>, CopyBinaryTree, <span class="number">0</span>, CopyBinaryTree.length);</span><br><span class="line">        System.out.println(<span class="string">&quot;最小堆：&quot;</span>+Arrays.toString(arr));</span><br><span class="line">        <span class="keyword">int</span> copyNum = nodeNum;</span><br><span class="line">        <span class="keyword">while</span>(copyNum&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//System.out.print(CopyBinaryTree[1]+&quot; &quot;);</span></span><br><span class="line">            CopyBinaryTree[<span class="number">1</span>] = CopyBinaryTree[copyNum];</span><br><span class="line">            copyNum--;</span><br><span class="line">            <span class="keyword">this</span>.siftDownMin(<span class="number">1</span>,CopyBinaryTree,copyNum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BuildMaximumHeap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> NodeNum)</span></span>&#123; <span class="comment">//建立最大堆</span></span><br><span class="line">        <span class="comment">//这里也是有两种建立方式，1：边插入元素，边调整元素 2：等元素全部插入完毕，调整节点即可。</span></span><br><span class="line">        <span class="comment">//这里选择第二种方式</span></span><br><span class="line">        <span class="keyword">int</span> copyNum = NodeNum;</span><br><span class="line">        <span class="keyword">while</span>(copyNum&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">            siftUpMax(copyNum,arr);</span><br><span class="line">            copyNum--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BuildMinimumHeap</span><span class="params">()</span></span>&#123; <span class="comment">//建立最小堆</span></span><br><span class="line">        <span class="comment">//每次将元素插入二叉树的末端，然后再把该元素向上调整即可</span></span><br><span class="line">        <span class="keyword">int</span> []standByArray = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">99</span>,<span class="number">5</span>,<span class="number">36</span>,<span class="number">7</span>,<span class="number">22</span>,<span class="number">17</span>,<span class="number">92</span>,<span class="number">12</span>,<span class="number">2</span>,<span class="number">19</span>,<span class="number">25</span>,<span class="number">28</span>,<span class="number">1</span>,<span class="number">46</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; standByArray.length; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.binaryTree[i+<span class="number">1</span>] = standByArray[i];</span><br><span class="line">            <span class="keyword">this</span>.siftUpMin(i+<span class="number">1</span>,<span class="keyword">this</span>.binaryTree);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BuildMinimumHeap2</span><span class="params">()</span></span>&#123; <span class="comment">//建立最小堆</span></span><br><span class="line">        <span class="comment">//我们从最后一个非叶子结点开始，依次判断以这个结点为根的子树是否符合最小堆的特性。</span></span><br><span class="line">        <span class="comment">// 如果所有的子树都符合最小堆的特性，那么整棵树就是最小堆了。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = num/<span class="number">2</span>; i &gt;=<span class="number">1</span> ; i--) &#123;</span><br><span class="line">            siftDownMin(i,binaryTree,<span class="keyword">this</span>.num); <span class="comment">//将binaryTree从num/2节点处开始调整</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最小堆,将上面较大的节点向下调整</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownMin</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span>[]arr,<span class="keyword">int</span> curNum)</span></span>&#123; <span class="comment">//传入一个需要向下调整的节点编号i，最小堆的节点个数，,以及对应的模拟二叉树</span></span><br><span class="line">        <span class="keyword">int</span> temp = i;</span><br><span class="line">        <span class="comment">//注意这里的num可能会变</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">2</span>*i&lt;=curNum)&#123; <span class="comment">//注意binaryTree是从下表1开始保存数据的，所以这里带等于</span></span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;arr[<span class="number">2</span>*i])&#123;</span><br><span class="line">                temp = <span class="number">2</span>*i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">2</span>*i+<span class="number">1</span>&lt;=curNum)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[temp]&gt;arr[<span class="number">2</span>*i+<span class="number">1</span>])</span><br><span class="line">                     temp = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp == i)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">this</span>.swap(i,temp,arr);</span><br><span class="line">            i = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大堆,将上面较小的节点向下调整</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownMax</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span>[]arr,<span class="keyword">int</span> curNum)</span></span>&#123; <span class="comment">//传入一个需要向下调整的节点编号i，最小堆的节点个数，,以及对应的模拟二叉树</span></span><br><span class="line">        <span class="keyword">int</span> temp = i;</span><br><span class="line">        <span class="comment">//注意这里的num可能会变</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">2</span>*i&lt;=curNum)&#123; <span class="comment">//注意binaryTree是从下表1开始保存数据的，所以这里带等于</span></span><br><span class="line">            <span class="keyword">if</span>(arr[i]&lt;arr[<span class="number">2</span>*i])&#123;</span><br><span class="line">                temp = <span class="number">2</span>*i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">2</span>*i+<span class="number">1</span>&lt;=curNum)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[temp]&lt;arr[<span class="number">2</span>*i+<span class="number">1</span>])</span><br><span class="line">                    temp = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp == i)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">this</span>.swap(i,temp,arr);</span><br><span class="line">            i = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最小堆,将下面较小的节点向上调整</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpMin</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span>[] arr)</span></span>&#123; <span class="comment">//传入一个需要向上调整的节点编号，,以及对应的模拟二叉树</span></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            temp = i;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt; arr[i/<span class="number">2</span>])&#123;</span><br><span class="line">                swap(i,i/<span class="number">2</span>,arr);</span><br><span class="line">                i = i/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp == i)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大堆,将下面较大的节点向上调整</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpMax</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span>[] arr)</span></span>&#123; <span class="comment">//传入一个需要向上调整的节点编号，,以及对应的模拟二叉树</span></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            temp = i;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[i/<span class="number">2</span>])&#123;</span><br><span class="line">                swap(i,i/<span class="number">2</span>,arr);</span><br><span class="line">                i = i/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp == i)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j,<span class="keyword">int</span> []arr)</span></span>&#123; <span class="comment">//交换binaryTree中 i 位置 和j 位置的元素,以及对应的模拟二叉树</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面程序的注释也写得蛮清楚的，最重要的还是要理解算法的思想。</p><p>继续加油吧~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图最短路径--贝尔曼福特算法Bellman-Ford</title>
      <link href="/2021/10/25/%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-%E8%B4%9D%E5%B0%94%E6%9B%BC%E7%A6%8F%E7%89%B9%E7%AE%97%E6%B3%95Bellman-Ford/"/>
      <url>/2021/10/25/%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-%E8%B4%9D%E5%B0%94%E6%9B%BC%E7%A6%8F%E7%89%B9%E7%AE%97%E6%B3%95Bellman-Ford/</url>
      
        <content type="html"><![CDATA[<h1 id="图最短路径–贝尔曼福特算法Bellman-Ford"><a href="#图最短路径–贝尔曼福特算法Bellman-Ford" class="headerlink" title="图最短路径–贝尔曼福特算法Bellman-Ford"></a>图最短路径–贝尔曼福特算法Bellman-Ford</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近几天学习算法的状态一般是晚上看算法思想，第二天上午或则下午自己动手实现算法，之后与算法书上的代码进行对比，学习别人优秀简洁的思路，然后整理到博客上。我感觉这样的学习效果还可以。因为这样的话，同一个算法我可以在不同的时间进行回顾。加深了印象~ 在对比代码的时候，确实发现了很多别人优秀的代码，让自己蠢蠢欲动，想要把那种思想吸收到自己身上！这也许就是代码之美吧哈哈哈，来自1024节的快乐~~</p><p>下面我对今天的博客内容进行记录备忘</p><p>对了，最近学习的是《啊哈算法》里面的内容，所以大部分实现的算法都是里面的。</p><h2 id="贝尔曼福特算法思想介绍"><a href="#贝尔曼福特算法思想介绍" class="headerlink" title="贝尔曼福特算法思想介绍"></a>贝尔曼福特算法思想介绍</h2><ul><li><p>Dijkstra算法虽然好，但是它不能解决带有负权边(边的权值为负数)的图。Bellman-Ford算法非常简单，核心代码只有4行，并且可以完美地解决带有负权边的图。</p></li><li><p>贝尔曼福特算法中图的表示用的是邻接表。</p></li></ul><p>核心代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (k=<span class="number">1</span>;k&lt;=n-<span class="number">1</span>;k++) <span class="comment">//只需要进行n-1轮就可以了。因为在一个含有n个顶点的图中，任意两点之间的最短路径最多包含n-1边。</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++) <span class="comment">//m代表边的个数，即枚举每一条边</span></span><br><span class="line"><span class="keyword">if</span>(dis[v[i]] &gt;dis[u[i]] + w[i])</span><br><span class="line">dis[v[i]] = dis [u[i]]+w[i];</span><br><span class="line"><span class="comment">//其中余u、v和w三个数组是用来记录边的信息。例如第i条边存储在u[i]、v[i]和 w[i]中，表示从顶点u[i]到顶点[i]这条边上u[i]到v[i]权值为w[i]。</span></span><br></pre></td></tr></table></figure><ul><li>上面条件判断的两行代码意思是:看看能否通过u[i]→v[ i ] (权值为w[i]）这条边，使得1号顶点到v[i]号顶点的距离变短。即1号顶点到u[i]号顶点的距离（dis[u[i]]）加上u[i]→v[i]这条边（权值为w[i])的值是否会比原先1号顶点到v[i]号顶点的距离(dis[v[i]]）要小。<strong>这一点其实与Dijkstra的“松弛”操作是一样的</strong>。现在我们要把所有的边都松弛一遍，上述的代码是进行了n-1轮松弛操作。</li></ul><h2 id="算法图解"><a href="#算法图解" class="headerlink" title="算法图解"></a>算法图解</h2><p> <img src="/articleImg/38_article/image1.jpg" alt="image1"></p><p>Bellman-Ford算法经常会在未达到n-1轮松弛前就已经计算出最短路，因为n-1其实是最大值。因此可以添加一个一维数组用来备份数组dis。如果在新一轮的松弛中数组dis没有发生变化，则可以提前跳出循环。</p><h2 id="未使用队列优化的代码"><a href="#未使用队列优化的代码" class="headerlink" title="未使用队列优化的代码"></a>未使用队列优化的代码</h2><p>用java实现的算法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//贝尔曼福特算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BellmanFord</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> []first = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>]; <span class="comment">//代表第i个节点的第一条出边</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> []next = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>]; <span class="comment">//代表第j条边的下一条出边, 切记这里的出边仍然是属于第i个节点的出边</span></span><br><span class="line">    <span class="comment">//初始化五个节点，五条边</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] u=&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] v=&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] w=&#123;<span class="number">2</span>,-<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span>[]cost = &#123;<span class="number">0</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>&#125;;<span class="comment">//初始化节点1，到其他节点的最短路径，999模拟无穷大</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BellmanFord bellmanFord = <span class="keyword">new</span> BellmanFord();</span><br><span class="line">        bellmanFord.first = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        bellmanFord.next = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        bellmanFord.bellmanford(<span class="number">5</span>,<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//bellmanFord.bellmanfordQueue(); //使用队列优化贝尔曼福特算法</span></span><br><span class="line">        System.out.println(Arrays.toString(bellmanFord.cost));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bellmanford</span><span class="params">(<span class="keyword">int</span> nodeCount,<span class="keyword">int</span> sideCount)</span></span>&#123; <span class="comment">//未使用队列优化算法</span></span><br><span class="line">        <span class="comment">//可以设立一个标志位，当最小代价数据数值不发生改变的时候，便可以结束整个松弛操作</span></span><br><span class="line">        <span class="keyword">boolean</span> check = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">//用来检测在n-1轮松弛之后，在进行一次松弛操作，来判断是否含有负权回路（判断依据：第n轮松弛是否发生路径代价更新）</span></span><br><span class="line">        <span class="comment">//对每个结点进行n-1轮的松弛，每一轮需要将每一条边都尝试一次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; nodeCount - <span class="number">1</span>; k++) &#123; <span class="comment">//核心算法在这里</span></span><br><span class="line">            check = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sideCount; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.cost[<span class="keyword">this</span>.v[i]-<span class="number">1</span>]&gt;<span class="keyword">this</span>.cost[<span class="keyword">this</span>.u[i]-<span class="number">1</span>]+<span class="keyword">this</span>.w[i] &amp;&amp; <span class="keyword">this</span>.cost[<span class="keyword">this</span>.u[i]-<span class="number">1</span>] != <span class="number">999</span>)&#123;  <span class="comment">//注意这里数组下表是从0开始的，而节点个数是从1开始的，所以需要减1</span></span><br><span class="line">                    <span class="keyword">this</span>.cost[<span class="keyword">this</span>.v[i]-<span class="number">1</span>] = <span class="keyword">this</span>.cost[<span class="keyword">this</span>.u[i]-<span class="number">1</span>]+<span class="keyword">this</span>.w[i];</span><br><span class="line">                    check = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!check)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sideCount; i++) &#123; <span class="comment">//进行第n轮松弛操作，若发生参数更新则说明有负权回路</span></span><br><span class="line">            <span class="keyword">if</span>(cost[<span class="keyword">this</span>.v[i]-<span class="number">1</span>]&gt;cost[<span class="keyword">this</span>.u[i]-<span class="number">1</span>]+w[i] &amp;&amp; cost[<span class="keyword">this</span>.u[i]-<span class="number">1</span>] != <span class="number">999</span>)&#123;  <span class="comment">//注意这里数组下表是从0开始的，而节点个数是从1开始的，所以需要减1</span></span><br><span class="line">                <span class="keyword">this</span>.cost[v[i]-<span class="number">1</span>] = cost[<span class="keyword">this</span>.u[i]-<span class="number">1</span>]+w[i]; <span class="comment">// 因为cost的维度是[5],节点个数是5，first,next数组的维度是[6],从下标1开始，到下标5为止，表示1~5个节点</span></span><br><span class="line">                <span class="comment">//所以这里有减1的操作，如果cost数组维度也是[6],并从1下标开始计数，则可以避免减1的操作</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            System.out.println(<span class="string">&quot;此图中含有负权回路~~~&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用队列优化算法"><a href="#使用队列优化算法" class="headerlink" title="使用队列优化算法"></a>使用队列优化算法</h2><p>Bellman-Ford算法的另一种优化:每次仅对最短路程发生变化了的点的相邻边执行松弛操作。但是如何知道当前哪些点的最短路程发生了变化呢?这里可以用一个队列来维护这些点，算法大致如下。</p><ul><li>每次选取队首顶点u，对顶点u的所有出边进行松弛操作。例如有一条u→v的边，如果通过u→v这条边使得源点到顶点v的最短路程变短(dis[u]+e[u] [v]&lt;dis[v])，且顶点v不在当前的队列中，就将顶点v放入队尾。需要注意的是，同一个顶点同时在队列中出现多次是毫无意义的，所以我们需要一个数组来判重（判断哪些点已经在队列中)。在对顶点u的所有出边松弛完毕后,就将顶点v出队。接下来不断从队列中取出新的队首顶点再进行如上操作，直至队列空为止。</li></ul><h2 id="优化图解"><a href="#优化图解" class="headerlink" title="优化图解"></a>优化图解</h2><p>我们用数组dis来存放1号顶点到其余各个顶点的最短路径。初始时dis[1]为0，其余为无穷大。接下来将1号顶点入队。然后对一号节点的所有出边进行松弛，松弛成功的节点，再加入队列。一直到队列为空结束！</p><p> <img src="/articleImg/38_article/image2.png" alt="image2"></p><h2 id="使用队列优化的代码函数"><a href="#使用队列优化的代码函数" class="headerlink" title="使用队列优化的代码函数"></a>使用队列优化的代码函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用队列优化贝尔曼福特算法的思想就是，每次仅对最短路估计值发生变化了的顶点的所有出边执行松弛操作。</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bellmanfordQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">       <span class="comment">//先用邻接表将所有的边信息进行保存</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">//将所有的边开始读入，并模仿单链表进行存储相关信息</span></span><br><span class="line">           <span class="comment">////这里相当于是一个链表操作，采用头插的方式</span></span><br><span class="line">           <span class="keyword">this</span>.next[i] = <span class="keyword">this</span>.first[<span class="keyword">this</span>.u[i]]; <span class="comment">//将当前节点u[i]中保存的出边，赋值到next[i]</span></span><br><span class="line">           <span class="keyword">this</span>.first[<span class="keyword">this</span>.u[i]] = i; <span class="comment">//将当前是第几条边赋值给first数组当前节点</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       queue.add(<span class="number">1</span>);<span class="comment">//这里模拟的是求1号节点到其他节点的最短路径，所以这里先将节点1入队</span></span><br><span class="line">       <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">           Integer topNode = queue.poll();</span><br><span class="line">           <span class="keyword">int</span> temp = <span class="keyword">this</span>.first[topNode];</span><br><span class="line">           <span class="keyword">while</span>(temp != -<span class="number">1</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span>(<span class="keyword">this</span>.cost[<span class="keyword">this</span>.v[temp]-<span class="number">1</span>]&gt;<span class="keyword">this</span>.cost[<span class="keyword">this</span>.u[temp]-<span class="number">1</span>]+<span class="keyword">this</span>.w[temp] &amp;&amp; <span class="keyword">this</span>.cost[<span class="keyword">this</span>.u[temp]-<span class="number">1</span>]!=<span class="number">999</span>)&#123;</span><br><span class="line">                   <span class="keyword">this</span>.cost[<span class="keyword">this</span>.v[temp]-<span class="number">1</span>] = <span class="keyword">this</span>.cost[<span class="keyword">this</span>.u[temp]-<span class="number">1</span>]+<span class="keyword">this</span>.w[temp];</span><br><span class="line">                   queue.add(<span class="keyword">this</span>.v[temp]);</span><br><span class="line">               &#125;</span><br><span class="line">               temp = <span class="keyword">this</span>.next[temp];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这个算法总结的差不多了，最重要的还是理解算法的思想。写代码就是顺其自然的事了。</p><p>继续加油吧~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bellman-Ford </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图--邻接表的两种实现</title>
      <link href="/2021/10/23/%E5%9B%BE-%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0/"/>
      <url>/2021/10/23/%E5%9B%BE-%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="图–邻接表的两种实现"><a href="#图–邻接表的两种实现" class="headerlink" title="图–邻接表的两种实现"></a>图–邻接表的两种实现</h1><p>图的结构有很多种中的表示方法，邻接矩阵、邻接表表示法、星形表示法、弧表示法、关联矩阵表示法等。这里对邻接表的表示做出记录。</p><p>要表示的图结构如下</p><p> <img src="/articleImg/37_article/image1.png" alt="image1"></p><h2 id="单链表实现邻接表"><a href="#单链表实现邻接表" class="headerlink" title="单链表实现邻接表"></a>单链表实现邻接表</h2><p> <img src="/articleImg/37_article/image2.jpg" alt="image2"></p><p>单链表存储起来还是挺简单的，这里我把每个单链表存在了Arraylist中，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里用链表实现图的邻接表</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">adjaceencyList2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;LinkedList&lt;Integer[]&gt;&gt; linkedLists = <span class="keyword">new</span> ArrayList&lt;LinkedList&lt;Integer[]&gt;&gt;();</span><br><span class="line">    <span class="comment">//这三个数组其实是代表一条边的信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> []u = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>]; <span class="comment">//代表开始节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> []v = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>]; <span class="comment">//代表结束节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> []w = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>]; <span class="comment">//代表这条边的代价</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        adjaceencyList2 adjacencyList = <span class="keyword">new</span> adjaceencyList2();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">5</span> ; i++) &#123; <span class="comment">//初始化链表list,list中的每一个元素是一个单链表</span></span><br><span class="line">            adjacencyList.linkedLists.add(<span class="keyword">new</span> LinkedList&lt;Integer[]&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        adjacencyList.u = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        adjacencyList.v = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        adjacencyList.w = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">5</span> ; i++) &#123; <span class="comment">//初始化链表数组中的相关信息</span></span><br><span class="line">            adjacencyList.linkedLists.get(adjacencyList.u[i]).add(<span class="keyword">new</span> Integer[]&#123;adjacencyList.v[i], adjacencyList.w[i]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//举例显示</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">5</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(adjacencyList.linkedLists.get(i).size() == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;第%d节点没有出边&quot;</span>,i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.printf(<span class="string">&quot;第%d节点：&quot;</span>,i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adjacencyList.linkedLists.get(i).size(); j++) &#123;</span><br><span class="line">                System.out.print(Arrays.toString(adjacencyList.linkedLists.get(i).get(j)));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组模拟实现邻接表"><a href="#数组模拟实现邻接表" class="headerlink" title="数组模拟实现邻接表"></a>数组模拟实现邻接表</h2><p>单链表实现我还挺好懂得，等到了要用数组模拟的时候我卡了一会，啊哈算法上用两个一维数组就把这几个单链表模拟出来了，如果是我来做第一手模拟操作的话，我可能会用一个二维数组去模拟，二维数组的每一行模拟一个单链表。</p><p>下面将模拟过程贴图，方便自己以后复习：</p><p> <img src="/articleImg/37_article/image3.png" alt="image3"></p><p> <img src="/articleImg/37_article/image4.png" alt="image4"></p><p><strong>即 first[u[i]]保存顶点u[i]的第一条边的编号，next[i]存储“编号为i的边”的“下一条边”的编号。</strong></p><p>那么啊哈算法程序中中又是怎么模拟这几个单链表所存储的信息的呢？请看我下面的程序注释。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package com.zhanglei;</span><br><span class="line"></span><br><span class="line">//图的临界表表示方法~ 其实就是用单链表去存储相关信息下</span><br><span class="line"></span><br><span class="line">//但是也可以用数组进行模拟，这里主要讨论的时数组进行模拟，昨天在思考这两句代码时被卡住了</span><br><span class="line">//在这里做出记录~</span><br><span class="line">public class adjacencyList &#123;</span><br><span class="line">    //本次要存储的是一个 4个节点 5条边的图</span><br><span class="line">    private int []first = new int[5]; //代表第i个节点的第一条出边</span><br><span class="line">    private int []next = new int[6]; //代表第j条边的下一条出边, 切记这里的出边仍然是属于第i个节点的出边</span><br><span class="line">    //next数组的作用就是想把第i个节点的所有出边都能索引到</span><br><span class="line"></span><br><span class="line">    //这三个数组其实是代表一条边的信息</span><br><span class="line">    private int []u = new int[6]; //代表开始节点</span><br><span class="line">    private int []v = new int[6]; //代表结束节点</span><br><span class="line">    private int []w = new int[6]; //代表这条边的代价</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        adjacencyList adjacencyList = new adjacencyList();</span><br><span class="line">        adjacencyList.first = new int[]&#123;-1, -1, -1, -1, -1&#125;;</span><br><span class="line">        adjacencyList.next = new int[]&#123;-1, -1, -1, -1, -1,-1&#125;;</span><br><span class="line">        adjacencyList.u = new int[]&#123;1, 4, 1, 2, 1&#125;;</span><br><span class="line">        adjacencyList.v = new int[]&#123;4, 3, 2, 4, 3&#125;;</span><br><span class="line">        adjacencyList.w = new int[]&#123;9, 8, 5, 6, 7&#125;;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123; //将所有的边开始读入，并模仿单链表进行存储相关信息</span><br><span class="line"></span><br><span class="line">            //采用头插的方式   ★关键在这里★</span><br><span class="line">            adjacencyList.next[i] = adjacencyList.first[adjacencyList.u[i]]; //将当前节点u[i]中保存的出边，赋值到next[i]</span><br><span class="line">            adjacencyList.first[adjacencyList.u[i]] = i; //将当前是第几条边赋值给first数组当前节点</span><br><span class="line">            //这里相当于是一个链表操作，</span><br><span class="line">        &#125;</span><br><span class="line">        //经过上述的操作之后，就可以通过节点的一条出边，而访问到该节点的所有出边号</span><br><span class="line">        //比如这里遍历出1号节点的所有出边号</span><br><span class="line">         int k = adjacencyList.first[1];</span><br><span class="line">        while(k!=-1)&#123;</span><br><span class="line">            System.out.printf(&quot;出边号 %d&quot;,k);</span><br><span class="line">            k = adjacencyList.next[k];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面的程序我们可以知道，啊哈算法中的first数组和next数组，都是存储的边号信息，就是存储的这是第几条边，而边对应的信息还需要到u[i]、v[i]、w[i]中去索引。但是上述的两句算法思想还是值得自己去吸收回味的。</p><p>最后的运行结果如下：</p><p> <img src="/articleImg/37_article/image5.png" alt="image5"></p><p>继续加油吧</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图的邻接表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图最短路径--迪杰斯特拉算法Dijkstra</title>
      <link href="/2021/10/23/%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95Dijkstra/"/>
      <url>/2021/10/23/%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95Dijkstra/</url>
      
        <content type="html"><![CDATA[<h1 id="图最短路径–迪杰斯特拉算法Dijkstra"><a href="#图最短路径–迪杰斯特拉算法Dijkstra" class="headerlink" title="图最短路径–迪杰斯特拉算法Dijkstra"></a>图最短路径–迪杰斯特拉算法Dijkstra</h1><h2 id="本次求解的图"><a href="#本次求解的图" class="headerlink" title="本次求解的图"></a>本次求解的图</h2><p> <img src="/articleImg/36_article/image1.png" alt="image1"></p><h2 id="算法思想梳理"><a href="#算法思想梳理" class="headerlink" title="算法思想梳理"></a>算法思想梳理</h2><p> <img src="/articleImg/36_article/image2.png" alt="image2"></p><p>就如上方的算法流程图，那么什么叫代价确定值呢？下面给出解释：</p><p>再图的邻接矩阵表示方法中，我们一般需要用一个一维数组dis来存储1号顶点到其余各个顶点的初始路程，如下：</p><p> <img src="/articleImg/36_article/image3.png" alt="image3"></p><p>既然是求1号顶点到其余各个顶点的最短路程，那就先找一个离1号顶点最近的顶点。通过数组dis可知当前离1号顶点最近的是2号顶点。当选择了2号顶点后，dis[2]的值就已经从“估计值”变为了“确定值”，即1号顶点到2号顶点的最短路程就是当前dis[2]值。为什么呢？ 如下:</p><p>你想啊，目前离1号顶点最近的是2号顶点，并且这个图所有的边都是正数，那么肯定不可能通过第三个顶点中转，使得1号顶点到2号顶点的路程进一步缩短了。</p><h2 id="什么是松弛呢"><a href="#什么是松弛呢" class="headerlink" title="什么是松弛呢"></a>什么是松弛呢</h2><p>这里还以求1号节点到其他节点的最短路径为例：当我们选择确定值对应的2号节点作为中转时，</p><p>我们发现dis[3]=12，dis[2]+e[2] [3]=1+9=10，dis[3]&gt;dis[2]+e[2] [3],因此dis[3]要更新为10。这个过程有个专业术语叫做“<strong>松弛</strong>”，1号顶点到3号顶点的路程即 dis[3]，通过2→3这条边松弛成功。这便是 Dijkstra算法的主要思想:通过“边”来松弛1号顶点到其余各个顶点的路程。</p><p>其中 dis[3]表示1号顶点到3号顶点的路程，e[2] [3]表示2→3这条边。</p><h2 id="给出算法代码及运行结果"><a href="#给出算法代码及运行结果" class="headerlink" title="给出算法代码及运行结果"></a>给出算法代码及运行结果</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图的迪杰斯特拉-单源最短路（一个点到其余各点的最短路径）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dijkstra</span> </span>&#123;</span><br><span class="line">    <span class="comment">//图的邻接矩阵,这里用999表示无穷大值</span></span><br><span class="line">    <span class="comment">//5*6</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [][] map= &#123;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">12</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>&#125;,&#123;<span class="number">999</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">999</span>,<span class="number">999</span>&#125;,&#123;<span class="number">999</span>,<span class="number">999</span>,<span class="number">0</span>,<span class="number">999</span>,<span class="number">5</span>,<span class="number">999</span>&#125;,&#123;<span class="number">999</span>,<span class="number">999</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">13</span>,<span class="number">15</span>&#125;,&#123;<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">0</span>,<span class="number">4</span>&#125;,&#123;<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [][] min_cost= &#123;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">12</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>&#125;,&#123;<span class="number">999</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">999</span>,<span class="number">999</span>&#125;,&#123;<span class="number">999</span>,<span class="number">999</span>,<span class="number">0</span>,<span class="number">999</span>,<span class="number">5</span>,<span class="number">999</span>&#125;,&#123;<span class="number">999</span>,<span class="number">999</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">13</span>,<span class="number">15</span>&#125;,&#123;<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">0</span>,<span class="number">4</span>&#125;,&#123;<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> []mark = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>]; <span class="comment">//来标记“确定值”，也就是该节点处目前已确定的最小值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dijkstra dijkstra = <span class="keyword">new</span> Dijkstra();</span><br><span class="line">        dijkstra.dijkstra();</span><br><span class="line">        System.out.println(<span class="string">&quot;经过迪杰斯特拉算法之后，得到的最小代价矩阵为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : dijkstra.min_cost) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%3d &quot;</span>,anInt);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//先求节点1的单源最短路径</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123; <span class="comment">//这个for是为了求出全部节点的最小代价路径</span></span><br><span class="line">            <span class="keyword">this</span>.zeroMark(<span class="keyword">this</span>.mark);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">this</span>.updateOver(<span class="keyword">this</span>.mark,i))&#123; <span class="comment">//求当前节点的到其他节点的最短路径</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> cur_min_val = <span class="number">999</span>;</span><br><span class="line">                <span class="keyword">int</span> cur_min_pos = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j  &lt; <span class="number">6</span> ; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="keyword">this</span>.min_cost[i][j]!=<span class="number">0</span>&amp;&amp;<span class="keyword">this</span>.min_cost[i][j]!=<span class="number">999</span>&amp;&amp;cur_min_val&gt;<span class="keyword">this</span>.min_cost[i][j]&amp;&amp;<span class="keyword">this</span>.mark[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                        cur_min_val = <span class="keyword">this</span>.min_cost[i][j];</span><br><span class="line">                        cur_min_pos = j; <span class="comment">//当前确定值的坐标</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(cur_min_pos == -<span class="number">1</span>) <span class="comment">//该节点已找出全部的确定最小值</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.mark[cur_min_pos] = <span class="number">1</span>; <span class="comment">//将当前确定值进行标记</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="keyword">this</span>.map[cur_min_pos][j]!=<span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.map[cur_min_pos][j] &lt; <span class="number">999</span>&amp;&amp;j!=<span class="number">0</span>)&#123; <span class="comment">//代表当前确定值，到其他节点有边，那么我们来看看，能不能因此更新代价矩阵</span></span><br><span class="line">                        <span class="keyword">int</span> temp = <span class="keyword">this</span>.min_cost[i][cur_min_pos] + <span class="keyword">this</span>.min_cost[cur_min_pos][j];</span><br><span class="line">                        <span class="keyword">if</span>(<span class="keyword">this</span>.min_cost[i][j] &gt; temp)&#123; <span class="comment">//表示可以更新</span></span><br><span class="line">                            <span class="keyword">this</span>.min_cost[i][j] = temp;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">zeroMark</span><span class="params">(<span class="keyword">int</span>[] mark)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span> ; i++) &#123;</span><br><span class="line">            mark[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">updateOver</span><span class="params">(<span class="keyword">int</span>[] mark,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=j&amp;&amp;mark[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p> <img src="/articleImg/36_article/image4.png" alt="image4"></p><p>附：如果在用迪杰斯特拉算法去求最短路径时，利用临界表去表示图，将会使算法的复杂度下降。</p><p>继续加油吧~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dijkstra最短路径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图最短路径--弗洛伊德算法Floyd</title>
      <link href="/2021/10/23/%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95Floyd/"/>
      <url>/2021/10/23/%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95Floyd/</url>
      
        <content type="html"><![CDATA[<h1 id="图最短路径–弗洛伊德算法Floyd"><a href="#图最短路径–弗洛伊德算法Floyd" class="headerlink" title="图最短路径–弗洛伊德算法Floyd"></a>图最短路径–弗洛伊德算法Floyd</h1><h2 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h2><p> <img src="/articleImg/35_article/image1.png" alt="image1"></p><p>如上图的的图和代价矩阵，我们希望知道任意两个节点间的最短路径。我们当然可以通过DFS遍历出两个节点，如1节点到5节点之间的所有路径，然后比较得出最短路径即可。</p><p>但是后续几篇博客中我将学习几种算法复杂度更低的最短路径算法。</p><h2 id="Floyd算法思想"><a href="#Floyd算法思想" class="headerlink" title="Floyd算法思想"></a>Floyd算法思想</h2><ul><li><p>我们来想一想，根据以往的经验，如果要让任意两点（例如从顶点a到顶点b）之间的路程变短，只能引入第三个点(顶点k)，并通过这个顶点k中转即a→k→b，才可能缩短原来从顶点a到顶点b的路程。那么这个中转的顶点k是1~n中的哪个点呢?甚至有时候不只通过一个点，而是经过两个点或者更多点中转会更短，即 a→k1→k2→b或者a&gt;k1→k2→…ki…→b。我们发现每个顶点都有可能使得另外两个顶点之间的路程变短。<br>当任意两点之间不允许经过第三个点时,这些城市之间的最短路程就是初始路程。</p></li><li><p>假如现在只允许经过1号顶点，求任意两点之间的最短路程，应该如何求呢?<br>只需判断e[i] [1]+e[1] [j]是否比 e[i] [j]要小即可。e[i] [j]表示的是从i号顶点到j号顶点之间的路程。e[i] [1]+e[1] [j]表示的是从i号顶点先到1号顶点，再从1号顶点到j号顶点的路程之和。其中i是1<del>n循环，j也是1</del>n循环，代码实现如下。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在只允许经过1号顶点的情况下,任意两点之间的最短路程更新为:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(j=l;j&lt;=n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i][j] &gt;e[i][<span class="number">1</span>]+e[<span class="number">1</span>][])</span><br><span class="line">e[i][j]=e[i][<span class="number">1</span>] +e[<span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对应代码"><a href="#对应代码" class="headerlink" title="对应代码"></a>对应代码</h2><p>根据上述的算法思想，我们很容易算法推广到允许所有顶点最为中转，去求最短路径，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package com.zhanglei;</span><br><span class="line"></span><br><span class="line">//弗洛伊德算法，求最短路径</span><br><span class="line">public class Floyd &#123;</span><br><span class="line">    private int[][] nodeCost =&#123;&#123;0,2,6,4&#125;,&#123;999,0,3,999&#125;,&#123;7,999,0,1&#125;,&#123;5,999,12,0&#125;&#125;;//原始的代价矩阵4*4</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Floyd floyd = new Floyd();</span><br><span class="line">        floyd.floyd();</span><br><span class="line">        for (int[] ints : floyd.nodeCost) &#123;</span><br><span class="line">            for (int anInt : ints) &#123;</span><br><span class="line">                System.out.printf(&quot;%3d&quot;,anInt);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void floyd()&#123; //弗洛伊德算法</span><br><span class="line">        for (int k = 0; k &lt;4 ; k++) &#123; //k代表以哪个节点为中转节点</span><br><span class="line">            for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">                for (int j = 0; j &lt;4; j++) &#123;</span><br><span class="line">                    if(i == k)</span><br><span class="line">                        break;</span><br><span class="line">                    int temp = this.nodeCost[i][k] + this.nodeCost[k][j];</span><br><span class="line">                    if(this.nodeCost[i][j]&gt;temp)</span><br><span class="line">                        this.nodeCost[i][j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终结果如下：</p><p> <img src="/articleImg/35_article/image2.png" alt="image2"></p><p>继续加油吧~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Floyd最短路径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重装系统后如何恢复hexo博客</title>
      <link href="/2021/10/20/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8Dhexo%E5%8D%9A%E5%AE%A2/"/>
      <url>/2021/10/20/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8Dhexo%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="重装系统后如何恢复hexo博客"><a href="#重装系统后如何恢复hexo博客" class="headerlink" title="重装系统后如何恢复hexo博客"></a>重装系统后如何恢复hexo博客</h1><p>随着博客越写越多，我很担心博客的迁移问题，以后可能会换很多台办公电脑，怎么能保证自己的积累不会前功尽弃呢！这里我特别记录一篇如何迁移恢复hexo博客的文章。</p><h2 id="大前提是自己的本地博客文件都还健在"><a href="#大前提是自己的本地博客文件都还健在" class="headerlink" title="大前提是自己的本地博客文件都还健在~"></a>大前提是自己的本地博客文件都还健在~</h2><p>1.安装Node.js，git，并查看当前软件环境，2021年10月安装的环境版本如下 </p><p> <img src="/articleImg/34_article/image1.png" alt="image1"></p><p>2.配置SSH key</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/. ssh    <span class="comment">//查看C:\Users\用户名.ssh下有无ssh文件夹，没有则创建</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;邮件地址&quot;</span> <span class="comment">//创建key</span></span><br></pre></td></tr></table></figure><p>3.将本地生成的 SSH key配置到github</p><p>4.ssh -T <a href="mailto:&#x67;&#x69;&#x74;&#x40;&#x67;&#x69;&#x74;&#x68;&#117;&#98;&#x2e;&#x63;&#x6f;&#x6d;">&#x67;&#x69;&#x74;&#x40;&#x67;&#x69;&#x74;&#x68;&#117;&#98;&#x2e;&#x63;&#x6f;&#x6d;</a>  测试是否成功</p><p>5.用户名 邮箱配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;zhanglei-underdog&quot;</span><span class="comment">// 你的github用户名，非昵称</span></span><br><span class="line">git config --global user.email  <span class="string">&quot;zhanglei.szu@gmail.com&quot;</span><span class="comment">// 填写你的github注册邮箱</span></span><br></pre></td></tr></table></figure><p>6.进入到博客(pgzxc)文件夹删除<strong>node_modules</strong>   <strong>public</strong>   <strong>.git</strong>   <strong>.deploy_git</strong>文件夹，删除后如下</p><p>  <img src="/articleImg/34_article/image2.png" alt="image2"></p><p>7.关联Github项目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin git<span class="meta">@github</span>.com:PGzxc/PGzxc.github.io.git</span><br></pre></td></tr></table></figure><p>8.运行如下指令”npm install –g hexo ”安装hexo，也可用cnpm,具体参考前面的博客。</p><p>9.<strong>运行如下指令安装项目依赖</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install  </span><br></pre></td></tr></table></figure><p>​    10.hexo -g 生成并本地预览,即可</p><h2 id="顺带记录如何将博客同时推送到GitHub与gitee"><a href="#顺带记录如何将博客同时推送到GitHub与gitee" class="headerlink" title="顺带记录如何将博客同时推送到GitHub与gitee"></a>顺带记录如何将博客同时推送到GitHub与gitee</h2><p>1.查看C:\Users\用户名.ssh下有无ssh文件夹，没有则创建</p><p>2.通过下面的命令，依次生成两个平台的key</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;xxxxxxx@qq.com&quot; -f &quot;github_id_rsa&quot;</span><br><span class="line">$ ssh-keygen -t rsa -C &quot;xxxxxxx@qq.com&quot; -f &quot;gitee_id_rsa&quot;</span><br></pre></td></tr></table></figure><p>3.完成后，.ssh文件夹生成以下文件</p><p> <img src="/articleImg/34_article/image3.png" alt="image3"></p><p>4.打开gitee_id_rsa.pub文件与github_id_rsa.pub文件，将其配置到各自平台的SSH中</p><p>5.在.ssh文件夹下，创建config文件解决ssh冲突（config文件没有后缀名），输入以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># gitee</span><br><span class="line">Host gitee.com</span><br><span class="line">HostName gitee.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/gitee_id_rsa</span><br><span class="line"> </span><br><span class="line"># github</span><br><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/github_id_rsa</span><br></pre></td></tr></table></figure><p>6，测试gitee命令：<strong>ssh -T <a href="mailto:&#x67;&#x69;&#x74;&#64;&#x67;&#x69;&#116;&#101;&#101;&#x2e;&#99;&#x6f;&#x6d;">&#x67;&#x69;&#x74;&#64;&#x67;&#x69;&#116;&#101;&#101;&#x2e;&#99;&#x6f;&#x6d;</a></strong>        测试GitHub命令：<strong>ssh -T <a href="mailto:&#x67;&#x69;&#116;&#64;&#103;&#x69;&#x74;&#x68;&#x75;&#98;&#46;&#99;&#x6f;&#109;">&#x67;&#x69;&#116;&#64;&#103;&#x69;&#x74;&#x68;&#x75;&#98;&#46;&#99;&#x6f;&#109;</a></strong></p><p>今天记录完这个，心里终于踏实了~</p><p>继续加油~</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo博客迁移恢复 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图-DFS求最小代价路径</title>
      <link href="/2021/10/20/%E5%9B%BE-DFS%E6%B1%82%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7%E8%B7%AF%E5%BE%84/"/>
      <url>/2021/10/20/%E5%9B%BE-DFS%E6%B1%82%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h1 id="DFS求图中最小代价路径"><a href="#DFS求图中最小代价路径" class="headerlink" title="DFS求图中最小代价路径"></a>DFS求图中最小代价路径</h1><p> <img src="/articleImg/33_article/image1.png" alt="image1"></p><h2 id="程序说明"><a href="#程序说明" class="headerlink" title="程序说明"></a>程序说明</h2><p>利用DFS，从节点1出发，找出到节点5的最小代价路径。&lt;这里注意时最小代价路径，不是最短路径&gt;</p><ul><li>当每条边的代价相同时，用BFS更优，因为BFS第一次到达目标点的时候，便是最小代价路径。</li><li>当每条边的代价不同时，用DFS更优，期间可以返回代价已经大于min的检索。等所有的可能性都遍历完之后，便会的到一条最小代价路径。</li><li>也就是说BFS只遍历到一条路径答案，而DFS则将所有的可行性路径都遍历了一遍，最终的到最小代价路径。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过DFS遍历，求出图中从起始点到终点的最小代价路径</span></span><br><span class="line"><span class="comment">//当每条边的代价相同时，用BFS更优，因为BFS第一次到达目标点的时候，便是最小代价路径</span></span><br><span class="line"><span class="comment">//当每条边的代价不同时，用DFS更优，期间可以返回代价已经大于min的检索。等所有的可能性都遍历完之后，便会的到一条最小代价路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinimumCost</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][]map=&#123;&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">10</span>&#125;,&#123;<span class="number">999</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">999</span>,<span class="number">7</span>&#125;,&#123;<span class="number">4</span>,<span class="number">999</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">999</span>&#125;,&#123;<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>,<span class="number">0</span>,<span class="number">5</span>&#125;,&#123;<span class="number">999</span>,<span class="number">999</span>,<span class="number">3</span>,<span class="number">999</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> min = <span class="number">9999</span>;<span class="comment">//最小代价变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cost;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] markNode = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]; <span class="comment">//用来标记节点是否被遍历过</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MinimumCost minimumCost = <span class="keyword">new</span> MinimumCost();</span><br><span class="line">        minimumCost.markNode[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        minimumCost.DFS(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;最小代价为：&quot;</span>+minimumCost.min);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> step,<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="number">4</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本次cost代价为：&quot;</span>+<span class="keyword">this</span>.cost);</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.cost&lt;<span class="keyword">this</span>.min)</span><br><span class="line">                <span class="keyword">this</span>.min = <span class="keyword">this</span>.cost;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.map[cur][i]!=<span class="number">0</span>&amp;&amp;<span class="keyword">this</span>.map[cur][i]!= <span class="number">999</span> )&#123; <span class="comment">//代表有边</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.markNode[i] == <span class="number">1</span>) <span class="comment">//这里判断的是指向边对应节点是否已被遍历过</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">this</span>.cost = <span class="keyword">this</span>.cost+<span class="keyword">this</span>.map[cur][i];</span><br><span class="line">                <span class="keyword">this</span>.markNode[i] = <span class="number">1</span>; <span class="comment">//这里一定要写成this.markNode[i] = 1，因为这里要去指向边了</span></span><br><span class="line">                DFS(step+<span class="number">1</span>,i);</span><br><span class="line">                <span class="comment">//尤其注意this.cost，this.markNode[i]在这里进行清零，如果不理解为什么，就去看看DFS求全排列</span></span><br><span class="line">                <span class="keyword">this</span>.cost = <span class="keyword">this</span>.cost - <span class="keyword">this</span>.map[cur][i];</span><br><span class="line">                <span class="keyword">this</span>.markNode[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>继续加油吧~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS求最小代价路径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFS-连通域检测</title>
      <link href="/2021/10/20/BFS-%E8%BF%9E%E9%80%9A%E5%9F%9F%E6%A3%80%E6%B5%8B/"/>
      <url>/2021/10/20/BFS-%E8%BF%9E%E9%80%9A%E5%9F%9F%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="BFS连通域检测"><a href="#BFS连通域检测" class="headerlink" title="BFS连通域检测"></a>BFS连通域检测</h1><p>0代表不通，大于0的值代表可走，检测从（6，8）处出发的连通域。矩阵形式如下</p><p> <img src="/articleImg/32_article/image1.png" alt="image1"></p><p>本次实现分别用BFS的思想和DFS的思想去解决该连通域检测问题，里面有一两个需要注意的小细节，已经在代码中的注释中写清楚了。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检索出矩阵中所有的连通域</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionDomain</span> </span>&#123;</span><br><span class="line">    <span class="comment">//该map的起始点在（6，8）处，map的大小是10*10的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [][]map = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">4</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [][]mark = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][<span class="number">10</span>];<span class="comment">//用来标记该点有没有走过</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][]dir= &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;; <span class="comment">//每个位置都可以走四个方向</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConnectionDomain connectionDomain = <span class="keyword">new</span> ConnectionDomain();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : connectionDomain.map) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%3d&quot;</span>,anInt);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------------------&quot;</span>);</span><br><span class="line">        connectionDomain.BFS(<span class="number">6</span>,<span class="number">8</span>);</span><br><span class="line">        <span class="comment">//connectionDomain.DFS(6,8,0);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : connectionDomain.map) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%3d&quot;</span>,anInt);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(connectionDomain.sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123; <span class="comment">//用BFS解连通域问题</span></span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;<span class="keyword">int</span>[]&gt;();<span class="comment">//用一个队列来辅助BFS的遍历</span></span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x,y&#125;);</span><br><span class="line">        sum++;</span><br><span class="line">        <span class="keyword">this</span>.mark[x][y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.map[x][y] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span>[] peek = queue.peek(); <span class="comment">//取队列中的队头元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> tempX = peek[<span class="number">0</span>] + <span class="keyword">this</span>.dir[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> tempY = peek[<span class="number">1</span>] + <span class="keyword">this</span>.dir[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(tempX&lt;<span class="number">0</span>||tempY&lt;<span class="number">0</span>||tempX&gt;<span class="number">9</span>||tempY&gt;<span class="number">9</span>||<span class="keyword">this</span>.mark[tempX][tempY] == <span class="number">1</span>||<span class="keyword">this</span>.map[tempX][tempY] == <span class="number">0</span>) <span class="comment">//越界，或则该点已走过，或则该点为海</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.mark[tempX][tempY] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">this</span>.map[tempX][tempY] = -<span class="number">1</span>;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;tempX,tempY&#125;);</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> step)</span></span>&#123; <span class="comment">//用DFS解决连通域问题</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">4</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tempX = x + <span class="keyword">this</span>.dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> tempY = y + <span class="keyword">this</span>.dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(tempX&lt;<span class="number">0</span>||tempY&lt;<span class="number">0</span>||tempX&gt;<span class="number">9</span>||tempY&gt;<span class="number">9</span>||<span class="keyword">this</span>.mark[tempX][tempY] == <span class="number">1</span>||<span class="keyword">this</span>.map[tempX][tempY] == <span class="number">0</span>) <span class="comment">//越界，或则该点已走过，或则该点为海</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">this</span>.mark[tempX][tempY] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">this</span>.map[tempX][tempY] = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">this</span>.sum++;</span><br><span class="line">            DFS(tempX,tempY,step+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>继续加油~~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFS--迷宫求解得一条最短路径</title>
      <link href="/2021/10/20/BFS-%E8%BF%B7%E5%AE%AB%E6%B1%82%E8%A7%A3%E5%BE%97%E4%B8%80%E6%9D%A1%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
      <url>/2021/10/20/BFS-%E8%BF%B7%E5%AE%AB%E6%B1%82%E8%A7%A3%E5%BE%97%E4%B8%80%E6%9D%A1%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h1 id="BFS–迷宫求解得一条最短路径"><a href="#BFS–迷宫求解得一条最短路径" class="headerlink" title="BFS–迷宫求解得一条最短路径"></a>BFS–迷宫求解得一条最短路径</h1><h2 id="BFS自我思考"><a href="#BFS自我思考" class="headerlink" title="BFS自我思考"></a>BFS自我思考</h2><ul><li>利用广度优先搜索解决迷宫问题</li><li>个人感觉广度优先搜索的核心在于，先把把每个点可以到达的位置都加入到队列中，随着队头移动，推进队尾元素的入队，最终实现遍历的效果（网上称为着色法）</li><li>广度优先算法在搜索到目标点的时候，就会开始结束程序，所以只会找到一条可行路径，但是这条路径却是最短的！</li></ul><p>下面我想截三张图，以便自己能够在以后复习的时候，更快回味BFS，截图来自–《啊哈算法》</p><p><img src="/articleImg/31_article/image1.png" alt="image1"></p><ul><li><strong>其实BFS，也没有用到递归，最重要的思想就是用到队列，记录下了每一次都能着色到的点。这很关键，是整个算法的核心。</strong></li></ul><p>有了这样的思路，我们解决迷宫问题就迎刃而解了，因为总有那么一步，我们能能到达终点。但只会找到一条可行路径，这条路径却是最短的。</p><ul><li><strong>切记如果想打印出最短路径，必须在队列节点数据类型中，加入一个前驱节点属性。并在从后往前遍历最短路径的时候，用栈去记录，这样就可以在打印路径的时候，从前往后打印了。</strong></li></ul><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用广度优先搜索解决迷宫问题</span></span><br><span class="line"><span class="comment">//个人感觉广度优先搜索的核心在于，先把把每个点可以到达的位置都加入到队列中，随着队头移动，推进队尾元素的入队，最终实现遍历的效果（网上称为着色法）</span></span><br><span class="line"><span class="comment">//广度优先算法在搜索到目标点的时候，就会开始结束程序，所以只会找到一条可行路径，但是这条路径却是最短的！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mazeSolving</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] mark = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][]dir= &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;; <span class="comment">//每个位置都可以走四个方向</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> queueElementCount;</span><br><span class="line">    <span class="comment">//迷宫地图</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [][]map=&#123;&#123;<span class="number">1</span>,<span class="number">1</span> ,<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> ,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>, <span class="number">0</span> ,<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> ,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">1</span>&#125;,&#123;<span class="number">1</span> ,<span class="number">0</span> ,<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,&#123;<span class="number">1</span> ,<span class="number">0</span>, <span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span> ,<span class="number">0</span>, <span class="number">1</span>&#125;,&#123;<span class="number">1</span>, <span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span> ,<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">        <span class="comment">//因为只有当遍历到终点的时候，才会知道最短路径，如果利用前驱节点，来记录最短路径的话，就需要从后往前走，这时候用栈来记录比较合适</span></span><br><span class="line">        Stack&lt;<span class="keyword">int</span>[]&gt; pathStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        mazeSolving mazeSolving = <span class="keyword">new</span> mazeSolving();</span><br><span class="line"></span><br><span class="line">        mazeSolving.BFS(<span class="number">1</span>,<span class="number">1</span>,queue);</span><br><span class="line"></span><br><span class="line">        Node pathNode = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            Node peek = queue.peek();</span><br><span class="line">            System.out.println(peek);</span><br><span class="line">            <span class="keyword">if</span>(peek.getX() == <span class="number">6</span> &amp;&amp; peek.getY() == <span class="number">5</span>)&#123;</span><br><span class="line">                pathNode = peek; <span class="comment">//将出口处的队列节点保留</span></span><br><span class="line">            &#125;</span><br><span class="line">            queue.remove();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!(pathNode.getX()==<span class="number">1</span>&amp;&amp;pathNode.getY()==<span class="number">1</span>))&#123;</span><br><span class="line">            pathStack.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;pathNode.getX(), pathNode.getY()&#125;);</span><br><span class="line">            pathNode = pathNode.getPreNode();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pathStack.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pathStack.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span>[] pop = pathStack.pop();</span><br><span class="line">            System.out.println(Arrays.toString(pop));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,Queue&lt;Node&gt; queue)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node();</span><br><span class="line">        node.setX(x);</span><br><span class="line">        node.setY(y);</span><br><span class="line">        node.setStep(step);</span><br><span class="line">        queue.add(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line"></span><br><span class="line">            Node peek = queue.peek();</span><br><span class="line">            step = peek.getStep() + <span class="number">1</span>;<span class="comment">//步数更新</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span> ; i++) &#123;</span><br><span class="line">                <span class="comment">//获取头部元素</span></span><br><span class="line">                Node tempNode  = <span class="keyword">new</span> Node();</span><br><span class="line">                <span class="keyword">int</span> tempX = peek.getX() +<span class="keyword">this</span>.dir[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> tempY = peek.getY()+<span class="keyword">this</span>.dir[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(tempX&lt;<span class="number">0</span>||tempY&lt;<span class="number">0</span>||tempX&gt;<span class="number">7</span>||tempY&gt;<span class="number">6</span>||<span class="keyword">this</span>.mark[tempX][tempY] == <span class="number">1</span>||<span class="keyword">this</span>.map[tempX][tempY] == <span class="number">1</span>) <span class="comment">//越界，或则该点已走过，或则该点为墙</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(mark[tempX][tempY] == <span class="number">0</span>)&#123;</span><br><span class="line">                    mark[tempX][tempY] = <span class="number">1</span>;</span><br><span class="line">                    tempNode.setPreNode(peek);</span><br><span class="line">                    tempNode.setX(tempX);</span><br><span class="line">                    tempNode.setY(tempY);</span><br><span class="line">                    tempNode.setStep(step);</span><br><span class="line">                    queue.add(tempNode);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tempX == <span class="number">6</span> &amp;&amp; tempY == <span class="number">5</span>) <span class="comment">//代表已经找到终点</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            queue.remove(); <span class="comment">//该头节点已尽心尽力，把它能到达的位置，都加到队列里了，所以这里删除该头节点</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123; <span class="comment">//（队列节点）迷宫节点需要记录的信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> step;</span><br><span class="line">    <span class="keyword">private</span> Node PreNode;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPreNode</span><span class="params">(Node preNode)</span> </span>&#123;</span><br><span class="line">        PreNode = preNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getPreNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PreNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStep</span><span class="params">(<span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.step = step;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;x=&quot;</span> + x +</span><br><span class="line">                <span class="string">&quot;, y=&quot;</span> + y +</span><br><span class="line">                <span class="string">&quot;, step=&quot;</span> + step +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 继续加油~~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS--水管工游戏</title>
      <link href="/2021/10/20/DFS-%E6%B0%B4%E7%AE%A1%E5%B7%A5%E6%B8%B8%E6%88%8F/"/>
      <url>/2021/10/20/DFS-%E6%B0%B4%E7%AE%A1%E5%B7%A5%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="DFS–水管工游戏"><a href="#DFS–水管工游戏" class="headerlink" title="DFS–水管工游戏"></a>DFS–水管工游戏</h1><h2 id="规则简介"><a href="#规则简介" class="headerlink" title="规则简介"></a>规则简介</h2><p>游戏的大致规则是这样的。一块矩形土地被分为N * M的单位正方形，现在这块土地上已经埋设有一些水管，水管将从坐标为(1,1)左上角左部边缘，延伸到(N,M)右下角右部边缘。水管只有2种，如下图所示</p><p> <img src="/articleImg/30_article/image1.png" alt="image1"></p><p>每种管道将占据一个单位正方形土地。你现在可以旋转这些管道，使得构成一个管道系统，即创造一条从(1,1)到(N,M)的连通管道。标有树木的方格表示这里没有管道。比如一个4*5的土地中(4,2)处有一个树木。我们可以旋转其中的一些管道，使之构成一个连通的管道系统，如下图。</p><p> <img src="/articleImg/30_article/image2.png" alt="image2"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>水管游戏就相当于是一个有条件的迷宫游戏，进水管的方向，连接点的水管类型就是这个迷宫的行走条件</li><li>从进水口到出水口，通过旋转中间水管零件的方向，来打通水管</li><li>我在写这道题的时候，是先判断入水口的方向，在判断连接点的水管类型</li><li>当然这题也可以，先判断连接点的水管类型，在判断入水口的方向。</li></ul><p>根据上述思路我们做出以下设定，并写出模拟矩阵：</p><p> <img src="/articleImg/30_article/image3.png" alt="image3"></p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="comment">//水管游戏就相当于是一个有条件的迷宫游戏，进水管的方向，连接点的水管类型就是这个迷宫的行走条件</span></span><br><span class="line"><span class="comment">//从进水口到出水口，通过旋转中间水管零件的方向，来打通水管</span></span><br><span class="line"><span class="comment">//我在写这道题的时候，是先判断入水口的方向，在判断连接点的水管类型</span></span><br><span class="line"><span class="comment">//当然这题也可以，先判断连接点的水管类型，在判断入水口的方向</span></span><br><span class="line"><span class="comment">//用矩阵模拟</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaterPipe</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [][]map = &#123;&#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">0</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>&#125;,&#123;<span class="number">6</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>&#125;,&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [][]mark = &#123;&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WaterPipe waterPipe = <span class="keyword">new</span> WaterPipe();</span><br><span class="line">        waterPipe.DFS(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y, <span class="keyword">int</span> flag, <span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">4</span> &amp;&amp; y == <span class="number">4</span>)&#123; <span class="comment">//表示已经找到最末端的出水口</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : <span class="keyword">this</span>.mark) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%3d&quot;</span>,anInt);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>||x&gt;<span class="number">4</span>||y&lt;<span class="number">0</span>||y&gt;<span class="number">3</span>||<span class="keyword">this</span>.mark[x][y] == <span class="number">1</span>)&#123; <span class="comment">//越界，或则该点水管已被使用过</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123; <span class="comment">//进水口在左边</span></span><br><span class="line">            <span class="keyword">if</span>((<span class="keyword">this</span>.map[x][y] == <span class="number">5</span> || <span class="keyword">this</span>.map[x][y] == <span class="number">6</span>)&amp;&amp;<span class="keyword">this</span>.mark[x][y] == <span class="number">0</span>)&#123; <span class="comment">//对接点是直管</span></span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">1</span>;</span><br><span class="line">                DFS(x,y+<span class="number">1</span>,<span class="number">1</span>,step+<span class="number">1</span>);</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.map[x][y] &gt;= <span class="number">1</span> &amp;&amp; <span class="keyword">this</span>.map[x][y] &lt;= <span class="number">4</span>&amp;&amp;<span class="keyword">this</span>.mark[x][y] == <span class="number">0</span>)&#123; <span class="comment">//对接点是弯管</span></span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">1</span>;</span><br><span class="line">                DFS(x+<span class="number">1</span>,y,<span class="number">4</span>,step+<span class="number">1</span>);</span><br><span class="line">                DFS(x-<span class="number">1</span>,y,<span class="number">2</span>,step+<span class="number">1</span>);</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">2</span>)&#123; <span class="comment">//进水口在下边</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.map[x][y] == <span class="number">5</span> || <span class="keyword">this</span>.map[x][y] == <span class="number">6</span>&amp;&amp;<span class="keyword">this</span>.mark[x][y] == <span class="number">0</span>)&#123; <span class="comment">//对接点是直管</span></span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">1</span>;</span><br><span class="line">                DFS(x-<span class="number">1</span>,y,<span class="number">2</span>,step+<span class="number">1</span>);</span><br><span class="line">                flag = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.map[x][y] &gt;= <span class="number">1</span> &amp;&amp; <span class="keyword">this</span>.map[x][y] &lt;= <span class="number">4</span>&amp;&amp;<span class="keyword">this</span>.mark[x][y] == <span class="number">0</span>)&#123; <span class="comment">//对接点是弯管</span></span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">1</span>;</span><br><span class="line">                DFS(x,y+<span class="number">1</span>,<span class="number">1</span>,step+<span class="number">1</span>);</span><br><span class="line">                DFS(x,y-<span class="number">1</span>,<span class="number">3</span>,step+<span class="number">1</span>);</span><br><span class="line">                flag = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">3</span>)&#123; <span class="comment">//进水口在右边</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.map[x][y] == <span class="number">5</span> || <span class="keyword">this</span>.map[x][y] == <span class="number">6</span>&amp;&amp;<span class="keyword">this</span>.mark[x][y] == <span class="number">0</span>)&#123; <span class="comment">//对接点是直管</span></span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">1</span>;</span><br><span class="line">                DFS(x,y-<span class="number">1</span>,<span class="number">3</span>,step+<span class="number">1</span>);</span><br><span class="line">                flag = <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.map[x][y] &gt;= <span class="number">1</span> &amp;&amp; <span class="keyword">this</span>.map[x][y] &lt;= <span class="number">4</span>&amp;&amp;<span class="keyword">this</span>.mark[x][y] == <span class="number">0</span>)&#123; <span class="comment">//对接点是弯管</span></span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">1</span>;</span><br><span class="line">                DFS(x+<span class="number">1</span>,y,<span class="number">4</span>,step+<span class="number">1</span>);</span><br><span class="line">                DFS(x-<span class="number">1</span>,y,<span class="number">2</span>,step+<span class="number">1</span>);</span><br><span class="line">                flag = <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">4</span>)&#123; <span class="comment">//进水口在上边</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.map[x][y] == <span class="number">5</span> || <span class="keyword">this</span>.map[x][y] == <span class="number">6</span>&amp;&amp;<span class="keyword">this</span>.mark[x][y] == <span class="number">0</span>)&#123; <span class="comment">//对接点是直管</span></span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">1</span>;</span><br><span class="line">                DFS(x+<span class="number">1</span>,y,<span class="number">4</span>,step+<span class="number">1</span>);</span><br><span class="line">                flag = <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.map[x][y] &gt;= <span class="number">1</span> &amp;&amp; <span class="keyword">this</span>.map[x][y] &lt;= <span class="number">4</span>&amp;&amp;<span class="keyword">this</span>.mark[x][y] == <span class="number">0</span>)&#123; <span class="comment">//对接点是弯管</span></span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">1</span>;</span><br><span class="line">                DFS(x,y+<span class="number">1</span>,<span class="number">1</span>,step+<span class="number">1</span>);</span><br><span class="line">                DFS(x,y-<span class="number">1</span>,<span class="number">3</span>,step+<span class="number">1</span>);</span><br><span class="line">                flag = <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">this</span>.mark[x][y] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的代码也可以先判断水管类型，再判断进水口方向。</p><p>DFS一定要注意当前这一步需要做什么，然后在考虑下一步怎么走。</p><p>继续加油~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 有条件的迷宫求解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS--方格填数</title>
      <link href="/2021/10/18/DFS-%E6%96%B9%E6%A0%BC%E5%A1%AB%E6%95%B0/"/>
      <url>/2021/10/18/DFS-%E6%96%B9%E6%A0%BC%E5%A1%AB%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="DFS–方格填数"><a href="#DFS–方格填数" class="headerlink" title="DFS–方格填数"></a>DFS–方格填数</h2><h2 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h2><p>如下的10个格子</p><p> <img src="/articleImg/29_article/image1.png" alt="image1"></p><p>填入0~9的数字。要求：连续的两个数字不能相邻。（左右、上下、对角都算相邻）</p><p>一共有多少种可能的填数方案？</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>用全排列,求出0~9十个数的全排列。全排列的思路和代码在前面几篇中已给出。这里就不在贴出。</li><li>将一维全排列填入到方格中，这里要注意边界条件（1，第一个格子与最后一个格子缺失。2，数组是否越界）</li><li>然后再利用for循环判断每个位置处周围的数是否满足条件。这里要注意边界条件。</li></ul><h2 id="第一个版本代码（暴力）"><a href="#第一个版本代码（暴力）" class="headerlink" title="第一个版本代码（暴力）"></a>第一个版本代码（暴力）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FillNumber</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> [][]dir = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;&#125;;    <span class="comment">//周围相邻的八个元素</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> [][]grid = &#123;&#123;-<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>&#125;,&#123;-<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>&#125;,&#123;-<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            Permutation&lt;Integer&gt; integerPermutation = <span class="keyword">new</span> Permutation&lt;&gt;();</span><br><span class="line">            FillNumber fillNumber = <span class="keyword">new</span> FillNumber();</span><br><span class="line"></span><br><span class="line">            Integer []numSet = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">            integerPermutation.permutation(numSet,<span class="number">0</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;全排列的种类：&quot;</span>+integerPermutation.count);</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (Integer[] integers : integerPermutation.arrayList) &#123; <span class="comment">//遍历该全排列</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; integers.length; i++) &#123; <span class="comment">//将全排列中的数值，写入到二维数组中</span></span><br><span class="line">                    fillNumber.grid[(i+<span class="number">1</span>)/<span class="number">4</span>][(i+<span class="number">1</span>)%<span class="number">4</span>] = integers[i];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(fillNumber.grid[i][j] == -<span class="number">1</span>)</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++) &#123; <span class="comment">//判断该点八个方向上有没有相邻元素</span></span><br><span class="line">                            <span class="keyword">int</span> temp;</span><br><span class="line">                            <span class="keyword">int</span> check_x,check_y;</span><br><span class="line">                            check_x = i+fillNumber.dir[k][<span class="number">0</span>];</span><br><span class="line">                            check_y = j+fillNumber.dir[k][<span class="number">1</span>]; <span class="comment">//这里刚开始携程了 i+fillNumber.dir[k][1],泪目了，这加出来的坐标怎么能对呢</span></span><br><span class="line">                            <span class="keyword">if</span>(check_x&lt;<span class="number">0</span>||check_x&gt;<span class="number">2</span>||check_y&lt;<span class="number">0</span>||check_y&gt;<span class="number">3</span>||(check_x == <span class="number">0</span>&amp;&amp; check_y ==<span class="number">0</span>)||(check_x == <span class="number">2</span>&amp;&amp; check_y ==<span class="number">3</span>)) <span class="comment">//存在越界</span></span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            <span class="keyword">if</span>(Math.abs(fillNumber.grid[check_x][check_y] - fillNumber.grid[i][j]) == <span class="number">1</span>)&#123; <span class="comment">//说明该排列中存在相邻元素</span></span><br><span class="line">                                flag = <span class="keyword">false</span>; <span class="comment">//结束该次判断</span></span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(!flag)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(!flag)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag)</span><br><span class="line">                    fillNumber.ans++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;符合要求的填数方式：&quot;</span>+fillNumber.ans);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>简单来看这就是一个放数问题，和求全排列，解八皇后问题，是差不多的。只不过这里在放数的时候，有一定的条件：即连续的两个数字不能相邻。</p><p>在把握好这个条件的前提下，利用DFS做解答。</p><ul><li>这这个DFS里面条件判断有两个，条件①该数是否已被放置过；条件② 连续的两个数字不能相邻</li></ul><h2 id="第二个版本代码（DFS）"><a href="#第二个版本代码（DFS）" class="headerlink" title="第二个版本代码（DFS）"></a>第二个版本代码（DFS）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FillNumber</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer []numSet = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> Integer []mark = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [][]grid = &#123;&#123;-<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>&#125;,&#123;-<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>&#125;,&#123;-<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>&#125;&#125;; <span class="comment">//注：这里的初值千万不能赋值为 -1，否则回溯的时候 -1-0= 1，会少很多计数值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [][]dir = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;&#125;;    <span class="comment">//周围相邻的八个元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ans  = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FillNumber fillNumber = <span class="keyword">new</span> FillNumber();</span><br><span class="line">        fillNumber.DFS(<span class="number">0</span>);</span><br><span class="line">        System.out.println(fillNumber.ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(step == <span class="number">10</span>)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.numSet.length; i++) &#123; <span class="comment">//这里产生多路递归</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>; <span class="comment">//用来标志该点放置的数是否符合条件              条件①</span></span><br><span class="line">            <span class="keyword">if</span>(mark[i]==<span class="number">0</span>)&#123; <span class="comment">//判断该数有没有被使用过（有没有被放置过）</span></span><br><span class="line">                <span class="keyword">this</span>.grid[(step+<span class="number">1</span>)/<span class="number">4</span>][(step+<span class="number">1</span>)%<span class="number">4</span>] = i;</span><br><span class="line">                mark[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++) &#123; <span class="comment">//判断该点八个方向上有没有相邻元素  条件②</span></span><br><span class="line">                <span class="keyword">int</span> temp;</span><br><span class="line">                <span class="keyword">int</span> check_x,check_y;</span><br><span class="line">                check_x = (step+<span class="number">1</span>)/<span class="number">4</span>+<span class="keyword">this</span>.dir[k][<span class="number">0</span>];</span><br><span class="line">                check_y = (step+<span class="number">1</span>)%<span class="number">4</span>+<span class="keyword">this</span>.dir[k][<span class="number">1</span>]; <span class="comment">//这里刚开始携程了 i+fillNumber.dir[k][1],泪目了，这加出来的坐标怎么能对呢</span></span><br><span class="line">                <span class="keyword">if</span>(check_x&lt;<span class="number">0</span>||check_x&gt;<span class="number">2</span>||check_y&lt;<span class="number">0</span>||check_y&gt;<span class="number">3</span>||(check_x == <span class="number">0</span>&amp;&amp; check_y ==<span class="number">0</span>)||(check_x == <span class="number">2</span>&amp;&amp; check_y ==<span class="number">3</span>)) <span class="comment">//存在越界</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(Math.abs(<span class="keyword">this</span>.grid[check_x][check_y] - <span class="keyword">this</span>.grid[(step+<span class="number">1</span>)/<span class="number">4</span>][(step+<span class="number">1</span>)%<span class="number">4</span>]) == <span class="number">1</span>)&#123; <span class="comment">//说明该排列中存在相邻元素</span></span><br><span class="line">                    flag = <span class="keyword">false</span>; <span class="comment">//结束该次判断</span></span><br><span class="line">                    <span class="keyword">this</span>.grid[(step+<span class="number">1</span>)/<span class="number">4</span>][(step+<span class="number">1</span>)%<span class="number">4</span>] = -<span class="number">2</span>;</span><br><span class="line">                    mark[i] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            DFS(step+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">this</span>.grid[(step+<span class="number">1</span>)/<span class="number">4</span>][(step+<span class="number">1</span>)%<span class="number">4</span>] = -<span class="number">2</span>;</span><br><span class="line">            mark[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接续加油~~~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 有条件的全排列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS--剪邮票</title>
      <link href="/2021/10/18/DFS-%E5%89%AA%E9%82%AE%E7%A5%A8/"/>
      <url>/2021/10/18/DFS-%E5%89%AA%E9%82%AE%E7%A5%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="DFS–剪邮票"><a href="#DFS–剪邮票" class="headerlink" title="DFS–剪邮票"></a>DFS–剪邮票</h1><h2 id="问题简介"><a href="#问题简介" class="headerlink" title="问题简介"></a>问题简介</h2><p> 有12张连在一起的12生肖的邮票。现在你要从中剪下5张来，要求必须是连着的。（仅仅连接一个角不算相连）比如，图中，粉红色所示部分就是合格的剪取。</p><p> <img src="/articleImg/28_article/image1.png" alt="image1"></p><p>请你计算，一共有多少种不同的剪取方法。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li><p>定义一个1*12的一维数组[]numberSet编上{1,1,1,1,1,1,1,0,0,0,0,0}，其中0代表该位置被剪了下来。对numberSet数组进行<strong>去重</strong>全排列，全排列很简单，关键是去重！！关于去重部分的思路我在前面的博客，已单独列出。</p></li><li><p>得到去重全排列之后，将一维数组转化成对应的3*4二维数组，进行连通性检测就可以了，如果联通则本次剪裁可以纳入answer。连通性检测用到的回溯的思想，注意这题的DFS没有用到for。其实也可以给改成用for。4个方向嘛。</p></li><li><p>第一个版本代码，是我用迷宫求解中的代码，改编的得到的测试连通性代码。因为可以把剪下来把减下来的邮票（0）当成可走路径，把未被减下来的邮票（1）当成墙。重点是我不设置出口重点，也就是说，通过递归之后，会将减下来的邮票（该连通域下所有可走路径）都置为3，且回到起点startx，starty。当回到起点时，我只需要判断map中是否还有没走的路径（0）即可~</p></li></ul><h2 id="第一个版本代码"><a href="#第一个版本代码" class="headerlink" title="第一个版本代码"></a>第一个版本代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">package com.zhanglei;</span><br><span class="line"></span><br><span class="line">//蓝桥杯真题 剪邮票</span><br><span class="line">public class Cut_the_stamps &#123;</span><br><span class="line">    private int [][] num_matrix = new int[3][4]; //存放1~12</span><br><span class="line">    private int [][] stamp_matrix = new int[3][4]; //存放这次减下来的邮票，1代表未剪下，0代表被剪下</span><br><span class="line">    private int[][]dir= &#123;&#123;0,1&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;,&#123;1,0&#125;&#125;; //每个位置都可以走四个方向</span><br><span class="line">    private int ans = 0;</span><br><span class="line"></span><br><span class="line">//核心算法在这里</span><br><span class="line">public boolean setWay(int x,int y,int startx, int starty)&#123;//x y 代表此次开始的坐标</span><br><span class="line"></span><br><span class="line">        if(x&lt;0||x&gt;2||y&lt;0||y&gt;3)&#123;  //发生越界</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(stamp_matrix[x][y]==0)&#123;  //表明该点还么有走过，可以进行寻路递归</span><br><span class="line"></span><br><span class="line">            //首先将该点标记为2（已走标记）</span><br><span class="line">            stamp_matrix[x][y]=2;</span><br><span class="line"></span><br><span class="line">            if(setWay(x+1,y,startx,starty))&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(setWay(x,y-1,startx,starty))&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(setWay(x-1,y,startx,starty))&#123;  //没找到路径，因为这里写成i+1</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(setWay(x,y+1,startx,starty))&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                if(x==startx&amp;&amp;y==starty)&#123; //说明递归回到了起点</span><br><span class="line">                    int count = 0;//记录矩阵中有多少个3</span><br><span class="line">                    for (int m = 0; m &lt; 3; m++) &#123;</span><br><span class="line">                        for (int n = 0; n &lt; 4; n++) &#123;</span><br><span class="line">                           if(stamp_matrix[m][n] == 3)</span><br><span class="line">                               count++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(count == 5)</span><br><span class="line">                        return true;</span><br><span class="line">                    else</span><br><span class="line">                        return false;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;//表明这个点不能再走，可能是1（墙），2（已走过），3（死路）</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Permutation &lt;Integer&gt;permutation = new &lt;Integer&gt;Permutation(); //创建一个可以进行全排列的类</span><br><span class="line">        Cut_the_stamps cut_the_stamps = new Cut_the_stamps();</span><br><span class="line">        Integer []numberSet = &#123;1,1,1,1,1,1,1,0,0,0,0,0&#125;;</span><br><span class="line">        //初始化 num_matrix</span><br><span class="line">        int k = 1;</span><br><span class="line">        for (int[] num_matrix : cut_the_stamps.num_matrix) &#123;</span><br><span class="line">            for (int i = 0; i &lt; num_matrix.length; i++) &#123;</span><br><span class="line">                num_matrix[i] = k;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; 4; j++) &#123;</span><br><span class="line">                cut_the_stamps.stamp_matrix[i][j] = numberSet[i*4+j];</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        permutation.permutation(numberSet,0);</span><br><span class="line">        //System.out.println(&quot;arrayList的大小为：&quot;+permutation.arrayList.size());</span><br><span class="line">        int startx = -1,starty = -1;</span><br><span class="line">        for (Integer[] integers : permutation.arrayList) &#123;</span><br><span class="line">            startx = -1;</span><br><span class="line">            starty = -1;</span><br><span class="line">            for (int i = 0; i &lt; numberSet.length; i++) &#123;</span><br><span class="line">                numberSet[i] = integers[i];</span><br><span class="line">                if(integers[i]==0&amp;&amp; startx==-1)&#123;</span><br><span class="line">                    startx = i/4;</span><br><span class="line">                    starty = i%4;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //为stamp_matrix 重新附上0 1 初值，相当于重新减一次邮票</span><br><span class="line">            for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">                for (int j = 0; j &lt; 4; j++) &#123;</span><br><span class="line">                    cut_the_stamps.stamp_matrix[i][j] = numberSet[i*4+j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;--------------------&quot;);</span><br><span class="line">            boolean check = cut_the_stamps.setWay(startx, starty, startx, starty); //第一个版本代码</span><br><span class="line"></span><br><span class="line">//            cut_the_stamps.dfs(startx,starty);  //第二个版本代码</span><br><span class="line">//            boolean check = cut_the_stamps.IsContain2(cut_the_stamps.stamp_matrix, 0); //第二个版本代码</span><br><span class="line"></span><br><span class="line">            if(check)</span><br><span class="line">                cut_the_stamps.ans++;</span><br><span class="line">            //System.out.println(&quot;是否连通：&quot;+ check);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;不重复剪邮票的方式共有：&quot;+permutation.count);</span><br><span class="line">        System.out.println(&quot;可以连通，符合题意的种类共有：&quot;+cut_the_stamps.ans);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //获取numberSet的非重复全排列</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean IsContain(int[]arr,int num)&#123;</span><br><span class="line">        for (int m : arr) &#123;</span><br><span class="line">            if(m == num)</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;//不包含</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第二个版本代码"><a href="#第二个版本代码" class="headerlink" title="第二个版本代码"></a>第二个版本代码</h2><ul><li>这个版本★处的代码，可以用for循环生成这四路递归。main函数和第一个版本的一样，这里就不再贴一次了</li><li>这个直接在边多路递归，边将走过的路径置为墙，算法效率更高。相比之下，第一个版本的代码就有点画蛇添足。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.zhanglei;</span><br><span class="line"></span><br><span class="line">//蓝桥杯真题 剪邮票</span><br><span class="line">public class Cut_the_stamps &#123;</span><br><span class="line">   </span><br><span class="line">   //整个函数返回代表，该连通域下已全部为墙，无路可走！</span><br><span class="line">    void dfs(int x,int y)&#123;  //DFS之后判断里面是不是纯1，代表联通</span><br><span class="line">        if(x&gt;2||x&lt;0||y&gt;3||y&lt;0) return ;</span><br><span class="line">        //运行到这里，说明已经越界了，则需要返回上一级的dfs()，然后换个方向继续寻找</span><br><span class="line">        if(stamp_matrix[x][y]==1) return ;</span><br><span class="line">        //这里，就是这个点不是需要剪的位置，则返回上一级的dfs()函数，</span><br><span class="line">        //继续执行未完成的dfs()函数，也就是换个方向继续找</span><br><span class="line">        stamp_matrix[x][y]=1;    //找到了，则将这个点标记</span><br><span class="line">        dfs(x+1,y); //★</span><br><span class="line">        dfs(x,y+1);//★</span><br><span class="line">        dfs(x-1,y);//★</span><br><span class="line">        dfs(x,y-1);//★</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean IsContain2(int[][]arr,int num)&#123;</span><br><span class="line">        for (int[] ints : arr) &#123;</span><br><span class="line">            for (int anInt : ints) &#123;</span><br><span class="line">                if(anInt == num)</span><br><span class="line">                    return false;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        return true;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>继续加油~~~！！！！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 连通性检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS--八皇后问题</title>
      <link href="/2021/10/18/DFS-%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"/>
      <url>/2021/10/18/DFS-%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="DFS–八皇后问题"><a href="#DFS–八皇后问题" class="headerlink" title="DFS–八皇后问题"></a>DFS–八皇后问题</h1><h2 id="问题简介"><a href="#问题简介" class="headerlink" title="问题简介"></a>问题简介</h2><p>八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出:在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即:任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法(92)。</p><p>这里列出一种结果，如下图：</p><p> <img src="/articleImg/27_article/image1.png" alt="image1"></p><h2 id="第一个版本思路及代码"><a href="#第一个版本思路及代码" class="headerlink" title="第一个版本思路及代码"></a>第一个版本思路及代码</h2><p><strong>思路</strong>：当我写八皇后题目的时候很自然的就想到了DFS，</p><ul><li>利用一个for，循环八次，产生八路递归，为什么是八次呢？因为是一个8*8的方格，所以每一行会有一个皇后，每一个皇后在每一行上可以有八种位置选择（这里选择的是列数）。</li><li>DFS函数传入step，代表递归深度，我在这里也就吧step，当成每次放皇后的行数。当step == 8的时候，递归基成立，返回结果！</li><li>这里的check_around函数写的比较暴力，第二个版本的较为巧妙</li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解决八皇后排列问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Eight_queen</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][]mark = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Eight_queen eight_queen = <span class="keyword">new</span> Eight_queen();</span><br><span class="line">        eight_queen.DFS(<span class="number">0</span>,eight_queen.mark);</span><br><span class="line">        System.out.println(<span class="string">&quot;八皇后走法一共有：&quot;</span>+eight_queen.count+<span class="string">&quot;种&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 核心算法在这里</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> step,<span class="keyword">int</span> [][]mark)</span></span>&#123; <span class="comment">//这里的step还是挺关键的</span></span><br><span class="line">        <span class="keyword">if</span>(step == <span class="number">8</span>)&#123; <span class="comment">//说明已经全部走完</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">//step从0~7</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.check_around(mark,step,i))&#123; <span class="comment">//代表周围ok，可以放一个皇后</span></span><br><span class="line">                mark[step][i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">this</span>.DFS(step+<span class="number">1</span>,mark);</span><br><span class="line">                <span class="comment">//当走到这一步的时候说明死路了</span></span><br><span class="line">                <span class="comment">//收回</span></span><br><span class="line">                mark[step][i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//返回上一级DFS</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check_around</span><span class="params">(<span class="keyword">int</span>[][]arr,<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span></span>&#123; <span class="comment">//row，col代表要检查元素的位置</span></span><br><span class="line">        <span class="keyword">int</span> length = <span class="keyword">this</span>.get_length(arr);</span><br><span class="line">        <span class="keyword">int</span> height = <span class="keyword">this</span>.get_height(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查同一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][col] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row; i &lt;height ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][col] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里进行说明，其实没有必要去检查同一行，因为八皇后，每个皇后都在不同行</span></span><br><span class="line">        <span class="comment">//这一点再for 循环下的多路递归种，利用step进行不同行的区分</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//检查左斜线 \</span></span><br><span class="line">        <span class="keyword">int</span> temp1 = col;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row; i &lt; height; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=height||temp1&gt;=length||i&lt;<span class="number">0</span>||temp1&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][temp1] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp1++;</span><br><span class="line">        &#125;</span><br><span class="line">        temp1 = col;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=height||temp1&gt;=length||i&lt;<span class="number">0</span>||temp1&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][temp1] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp1--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查右斜线 /</span></span><br><span class="line">        <span class="keyword">int</span> temp2 = col;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row; i &lt; height; i++,temp2--) &#123; <span class="comment">//★ 注意这个for</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=height||temp2&gt;=length||i&lt;<span class="number">0</span>||temp2&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][temp2] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//temp2--;</span></span><br><span class="line">        &#125;</span><br><span class="line">        temp2 = col;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=height||temp2&gt;=length||i&lt;<span class="number">0</span>||temp2&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][temp2] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get_height</span><span class="params">(<span class="keyword">int</span>[][]map)</span></span>&#123; <span class="comment">//返回二维数组有多少行</span></span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : map) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : row) &#123;</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get_length</span><span class="params">(<span class="keyword">int</span>[][]map)</span></span>&#123; <span class="comment">//返回二维数组每一行有多少元素</span></span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : map) &#123;</span><br><span class="line">            temp++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第二个版本代码"><a href="#第二个版本代码" class="headerlink" title="第二个版本代码"></a>第二个版本代码</h2><p>这里主要修改了check_around()函数，修改的地方主要有：</p><ul><li>用array[8]数组记录每个皇后的左边，下标i对应行数，值array[i]对应皇后所在的列数。（如果不用一个一维数组去记录皇后的位置的话，后面在利用斜率判断是否同一斜线时，还要去遍历整个map，去寻找已放置的皇后，这个复杂度就上去了，不推荐）</li><li>利用斜率判断皇后们是不是同处一条斜线</li><li>直接利用array[i]判断是不是同处一列</li><li>核心思想还是DFS</li><li>★★★用斜率判断是否同一斜线中的*1.0非常重要，不加的话会变成整型数字进行除，一定要转换为浮点数的除法★★★</li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解决八皇后排列问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Eight_queen</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Eight_queen eight_queen = <span class="keyword">new</span> Eight_queen();</span><br><span class="line">        eight_queen.DFS(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;八皇后走法一共有：&quot;</span>+eight_queen.count+<span class="string">&quot;种&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> step)</span></span>&#123; <span class="comment">//这里的step还是挺关键的</span></span><br><span class="line">        <span class="keyword">if</span>(step == <span class="number">8</span>)&#123; <span class="comment">//说明已经全部走完</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">//step从0~7</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span> ; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.check_around2(step,i))&#123; <span class="comment">//代表周围ok，可以放一个皇后</span></span><br><span class="line">                <span class="keyword">if</span>(array[<span class="number">0</span>] == <span class="number">0</span> &amp;&amp;  array[<span class="number">1</span>] == <span class="number">4</span>)&#123;</span><br><span class="line">                    System.out.println();</span><br><span class="line">                &#125;</span><br><span class="line">                array[step] = i;</span><br><span class="line">              </span><br><span class="line">                <span class="keyword">this</span>.DFS(step+<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//当走到这一步的时候说明死路了</span></span><br><span class="line">                <span class="comment">//收回</span></span><br><span class="line">                array[step] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//返回上一级DFS</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check_around2</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="keyword">this</span>.get_length(arr);</span><br><span class="line">        <span class="keyword">int</span> height = <span class="keyword">this</span>.get_height(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//利用斜率检查同一斜线</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="comment">//★★★这里的的*1.0非常重要，不加的话会变成整型数字进行除★★★</span></span><br><span class="line">            <span class="comment">// 比如会出现 5/3 = 1的情况，所以这里要转换为浮点数的触发~</span></span><br><span class="line">            <span class="keyword">if</span>(Math.abs((array[i]-col)*<span class="number">1.0</span>/(i-row)) == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查同一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(col == array[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查同一行</span></span><br><span class="line">        <span class="comment">//多路递归中，每次都根据step的值从下一行开始的，所以在在这里并不需要考虑同一行是否有多个皇后</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可见第二个版本的代码简化了很多，也巧妙很多，回头看看自己的一手代码，真的不忍直视，泪目~~</p><p>自己还要多加油努力啊，成为一个代码风格优美的程序员！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 迷宫求解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS--迷宫求解</title>
      <link href="/2021/10/17/DFS-%E8%BF%B7%E5%AE%AB%E6%B1%82%E8%A7%A3/"/>
      <url>/2021/10/17/DFS-%E8%BF%B7%E5%AE%AB%E6%B1%82%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="DFS–迷宫求解"><a href="#DFS–迷宫求解" class="headerlink" title="DFS–迷宫求解"></a>DFS–迷宫求解</h1><p>迷宫求解问题分为，1：求出一条路径即可。2：求出所有路径并求出最短路径。下面我对这两种情况都做出记录说明~</p><h2 id="只求一条路径"><a href="#只求一条路径" class="headerlink" title="只求一条路径"></a>只求一条路径</h2><p><strong>思路</strong>：这个函数里是采用的事递归回溯的思想。每走一步都可以选择四个方向。直到找到终点，所有压栈的递归方法逐个进行return。这里需要关注的地方是，map [ i ] [ j ]置为三的时刻，为死路，将当前的标志2置为3，而不是直接由0置为3的。</p><p>这段程序中有一个setway(),和一个setway2()。区别就是setway()可以将死路置为标志位3，因为这里面用的是if判断。setway2()的话则不可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"><span class="comment">//        1 1 1 1 1 1 1</span></span><br><span class="line"><span class="comment">// map    1 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">//        1 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">//        1 1 1 0 0 0 1</span></span><br><span class="line"><span class="comment">//        1 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">//        1 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">//        1 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">//        1 1 1 1 1 1 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mazeSolving</span> </span>&#123;</span><br><span class="line">    <span class="comment">//核心算法在这里</span></span><br><span class="line">    <span class="comment">//使用递归回溯来给小球找路</span></span><br><span class="line">    <span class="comment">//说明</span></span><br><span class="line">    <span class="comment">//1. map 表示地图</span></span><br><span class="line">    <span class="comment">//2. i,j 表示从地图的哪个位置开始出发 (1,1)</span></span><br><span class="line">    <span class="comment">//3. 如果小球能到 map[6][5] 位置， 则说明通路找到.</span></span><br><span class="line">    <span class="comment">//4. 约定： 当 map[i][j] 为 0 表示该点没有走过 当为 1 表示墙 ； 2 表示通路可以走 ； 3 表示该点已经走过， 但是走不通</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setWay</span><span class="params">(<span class="keyword">int</span>[][]map,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="keyword">this</span>.get_length(map)-<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> height = <span class="keyword">this</span>.get_height(map)-<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(map[height][length]==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//★如果map[i][j]!=0 就直接return,表明该点是墙1、已走路径2、死路3★</span></span><br><span class="line">            <span class="keyword">if</span>(map[i][j]==<span class="number">0</span>)&#123;  <span class="comment">//表明该点还么有走过，可以进行寻路递归</span></span><br><span class="line">                <span class="comment">//首先将该点标记为2（已走标记）</span></span><br><span class="line">                map[i][j]=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(setWay(map,i+<span class="number">1</span>,j))&#123;  <span class="comment">//★最核心的就是这四句话★</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(setWay(map,i,j-<span class="number">1</span>))&#123; <span class="comment">//★最核心的就是这四句话★</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(setWay(map,i-<span class="number">1</span>,j))&#123;  <span class="comment">//★最核心的就是这四句话★</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(setWay(map,i,j+<span class="number">1</span>))&#123; <span class="comment">//★最核心的就是这四句话★</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    map[i][j] = <span class="number">3</span>;  <span class="comment">////★这里表示该点的四个方向都没通过判断，为死路，则置为3★</span></span><br><span class="line">                    <span class="comment">//这里的置3只是为了好看，其实这里不写置3也会的一个答案</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//表明这个点不能再走，可能是1（墙），2（已走过），3（死路）</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setWay2</span><span class="params">(<span class="keyword">int</span>[][]map,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = <span class="keyword">this</span>.get_length(map)-<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> height = <span class="keyword">this</span>.get_height(map)-<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(map[height][length]==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(map[i][j]==<span class="number">0</span>)&#123;  <span class="comment">//表明该点还么有走过，可以进行寻路递归</span></span><br><span class="line">                map[i][j]=<span class="number">2</span>;</span><br><span class="line">                setWay(map,i,j+<span class="number">1</span>);</span><br><span class="line">                setWay(map,i+<span class="number">1</span>,j);</span><br><span class="line">                setWay(map,i,j-<span class="number">1</span>);</span><br><span class="line">                setWay(map,i-<span class="number">1</span>,j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//表明这个点不能再走，可能是1（墙），2（已走过），3（死路）</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get_length</span><span class="params">(<span class="keyword">int</span>[][]map)</span></span>&#123; <span class="comment">//返回二维数组的长度</span></span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : map) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : row) &#123;</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get_height</span><span class="params">(<span class="keyword">int</span>[][]map)</span></span>&#123; <span class="comment">//返回二维数组的高度</span></span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : map) &#123;</span><br><span class="line">                temp++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="遍历出迷宫中所有路径，并求出最短路径"><a href="#遍历出迷宫中所有路径，并求出最短路径" class="headerlink" title="遍历出迷宫中所有路径，并求出最短路径"></a>遍历出迷宫中所有路径，并求出最短路径</h2><p><strong>思路</strong>：一般需要遍历出所有的可能情况，就需要用到DFS了，也就是利用for循环才生多路递归。这里一定要深刻理解这里面的多路到底指的是哪方面的多路。如迷宫求解的4路递归，指的就是4个方向的选择；如八皇后的8路递归，指的就是每一行八个方格的选择。</p><p>其实我个人觉得DFS就相当于是一个求全排列的过程，它一定会把每一个点的所有情况都考虑到。</p><p>这里给出求迷宫所有路径的方法，求最短路径的思路也很简单。只需要比较step的大小即可~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        1 1 1 1 1 1 1</span></span><br><span class="line"><span class="comment">// map    1 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">//        1 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">//        1 1 1 0 0 0 1</span></span><br><span class="line"><span class="comment">//        1 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">//        1 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">//        1 0 0 0 0 0 1</span></span><br><span class="line"><span class="comment">//        1 1 1 1 1 1 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mazeSolving</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span>  min = <span class="number">999</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][]dir= &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;; <span class="comment">//每个位置都可以走四个方向</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] short_path = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> step,<span class="keyword">int</span>[][]map,<span class="keyword">int</span>[][]mark)</span></span>&#123; <span class="comment">//x,y为当前位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tx,ty;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">6</span>&amp;&amp;y==<span class="number">5</span>)&#123;  <span class="comment">//表明已找到出口</span></span><br><span class="line">            <span class="keyword">if</span>(step&lt;min)&#123;</span><br><span class="line">                min = step;</span><br><span class="line">                short_path = mark;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//返回</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//主要想法就是遍历出所有的可能性</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;=<span class="number">3</span> ; i++) &#123; <span class="comment">//利用for循环产生多路递归！</span></span><br><span class="line">            tx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">            ty = y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(map[tx][ty]==<span class="number">1</span>)&#123; <span class="comment">//表明该点是墙</span></span><br><span class="line">                <span class="keyword">continue</span>;  <span class="comment">//刚开始这里写成了 return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(map[tx][ty] == <span class="number">0</span> &amp;&amp; mark[tx][ty] == <span class="number">0</span>)&#123;</span><br><span class="line">                mark[tx][ty] = <span class="number">2</span>; <span class="comment">//标记该点已经走过</span></span><br><span class="line">                <span class="keyword">this</span>.DFS(tx,ty,step+<span class="number">1</span>,map,mark); <span class="comment">//注意这里用到了mark数组，且传入step+1;</span></span><br><span class="line">                mark[tx][ty] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">//执行到这里，这层dfs()函数已经结束，则要回到上一层dfs()函数</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几天由于集中刷题，自我感觉对DFS的理解还是很深刻的，可以灵活运用解出一些题目。希望自己后面能多多复习，巩固这个概念！</p><p>继续加油~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 迷宫求解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS求数组元素的全排列</title>
      <link href="/2021/10/15/DFS%E6%B1%82%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97/"/>
      <url>/2021/10/15/DFS%E6%B1%82%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="基于交换元素（选择首元素）的全排列"><a href="#基于交换元素（选择首元素）的全排列" class="headerlink" title="基于交换元素（选择首元素）的全排列"></a>基于交换元素（选择首元素）的全排列</h1><p>这里例如求数集{0，1，2，3}的全排列。使用DFS+回溯的方式解决。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>针对这种全排列的问题，一般都是用多路递归的方式，不同于之前接触的单路分支，多路分支一般都使用一个for循环创建多路，在这里，就是先将0，1，2，3每个数字都遍历到，每个取出来轮流当第一个元素，每一个分支都负责把剩下的三个元素进行再次的全排列。</p><p>比如第一个取出的数字一定是0，那么剩下的数字就是1，2，3。这里就创建了第二个分支，在这个分支里面，我们第一个取出的一定是1，当我们取出1之后，我们还剩下两个数字，2，3，这里我们又创建了第三个分支，在第三个分支里面，我们第一个取出的就是2，2之后我们就只剩下一个元素3了，当我们到了第四个分支，也就是只有一个节点的分支的时候，我们创建的分支数目和全排列出的结果的长度一致，都是4。那么我们就进行第一次输出。</p><p>接下来，我们要做的就是回到上一个分支，看看3这个节点有没有兄弟节点，若没有，跳回上一层节点，看看2这个节点有没有兄弟节点。</p><p>当然，这里想要实现各种排列输出，我们就需要一个基本动作就是交换元素之间的顺序，比如0132，对于数组0123我们就需要把[2]和[3]这两个下标的元素进行一个交换。<strong>交换的意思就是</strong>，<strong>在这个分支里面，我想要让下标为[3]的元素当一次首元素，然后对这个元素进行分支</strong>。最后进行输出。输出完事儿之后跳回上一个分支，如果这个分支有兄弟节点，就进入，否则，再跳回上一个分支。下面就是第一个分支进入0开头的排列的情况</p><p> <img src="/articleImg/25_article/image1.png" alt="image1"></p><h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><p>这里的全排列是基于交换的，选取首元素，进行回溯递归的思想。可以对任意的数组进行递归。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Permutation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> []arr = &#123;<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>&#125;;</span><br><span class="line">        Permutation permutation = <span class="keyword">new</span> Permutation();</span><br><span class="line">        permutation.permutation(arr,<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;计数种类：&quot;</span>+permutation.count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="keyword">char</span>[] chs, <span class="keyword">int</span> step )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(step==chs.length-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">                System.out.print(chs[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">//Arrays.toString(chs);</span></span><br><span class="line">            <span class="comment">//如果已经到了数组的最后一个元素，前面的元素已经排好，输出。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=step;i&lt;=chs.length-<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//把第一个元素分别与后面的元素进行交换，递归的调用其子数组进行排序</span></span><br><span class="line">            Swap(chs,i,step);</span><br><span class="line">            permutation(chs,step+<span class="number">1</span>);</span><br><span class="line">            Swap(chs,i,step);</span><br><span class="line">            <span class="comment">//子数组排序返回后要将第一个元素交换回来。</span></span><br><span class="line">            <span class="comment">//如果不交换回来会出错，比如说第一次1、2交换，第一个位置为2，子数组排序返回后如果不将1、2</span></span><br><span class="line">            <span class="comment">//交换回来第二次交换的时候就会将2、3交换，因此必须将1、2交换使1还是在第一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">char</span> chs[],<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp;</span><br><span class="line">        temp = chs[i];</span><br><span class="line">        chs[i] = chs[j];</span><br><span class="line">        chs[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对程序中 step = 0,i = 3时，进行手写记录。思路就是回溯递归！</p><p> <img src="/articleImg/25_article/image2.png" alt="image2"></p><h2 id="基于标记数组辅助的全排列"><a href="#基于标记数组辅助的全排列" class="headerlink" title="基于标记数组辅助的全排列"></a>基于标记数组辅助的全排列</h2><p>这里给出代码，这个代码时DFS的基础模板，建议深刻理解。</p><p>具体理解看标记出的注释即可，自我感觉，下面这份代码属于基础代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fullPermutation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] mark = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] box = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        fullPermutation fullPermutation = <span class="keyword">new</span> fullPermutation();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            fullPermutation.mark[i] = <span class="number">0</span>;</span><br><span class="line">            fullPermutation.box[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fullPermutation.dfs(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;总数&quot;</span>+fullPermutation.count);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//核心代码在这里</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(step == num+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//注意这个return在if判断里面</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123; <span class="comment">//遍历看哪个号码还没有使用</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.mark[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.mark[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">this</span>.box[step] = i; <span class="comment">//这里的i可以换成数组元素，数组的维度一定要与mark[]数组的维度一致！</span></span><br><span class="line">                <span class="keyword">this</span>.dfs(step+<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//重新尝试，退回到上一个点的位置</span></span><br><span class="line">                <span class="keyword">this</span>.mark[i] = <span class="number">0</span>;  <span class="comment">//注意这里是什么时候重新赋值为0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <img src="/articleImg/25_article/image3.png" alt="image3"></p><h1 id="注"><a href="#注" class="headerlink" title="注"></a>注</h1><p>这里的全排列并没有考虑重复的情况。这里简单的考虑为：先将全排列后的结果放在一个集合中，若后续全排列出来的结果，在集合中已经存在，则不加入这次排列结果。</p><p>若后续有复杂度更低的想法，会在这里进行更新补充。</p><p>继续加油~</p><p>——————————————————2021.10.16 22.40分  更新——————————————————</p><p>今天做了一题剪邮票，12位数的全排列好像有6亿多种，晕(((φ(◎ロ◎;)φ)))，用Hashset去重时，可把电脑累的够呛。这里我在网上检索到了一种去重方式，感觉设计的很巧妙。我自己也理解了好一会，才搞懂。而且网上很多的人对这句代码并没有太多的解释。。。难道是大家都默认这是句代码没难度吗，呜呜呜。。。</p><p>这里我给出去重代码，并附上自己的理解思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSwap</span><span class="params">(T[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; j; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[j] == array[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这个函数的主要作用是判断：从start（step）元素开始，到将要被交换元素的前一个位置，这个区间中有没有与值与即将被交换元素的值相等的元素</strong></p><p>也就是说：全排列中去掉重复的规则——去重的全排列就是从第一个数字起每个数分别与它后面非重复出现的数字交换。</p><p>那么如何去理解这句话呢，我是这么分析的，如果step~(n-1)位置上如果有值与n位置上值相等的元素。那么step与n位置处的交换值，就是毫无意义的，因为，此时这个排列<strong>属于</strong>当step和特殊位置（指与n对应的值相等）的交换后的全排列的子集。即会产生重复！！！</p><p><img src="/articleImg/25_article/image4.png" alt="image4"></p><p>重新给出去重后的全排列代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">permutation</span><span class="params">(T[] chs, <span class="keyword">int</span> step )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(step==chs.length-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Integer[] chs_copy = <span class="keyword">new</span> Integer[<span class="number">12</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">                chs_copy[i] = (Integer) chs[i];</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=step;i&lt;=chs.length-<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//把第一个元素分别与后面的元素进行交换，递归的调用其子数组进行排序</span></span><br><span class="line">            <span class="keyword">if</span>(isSwap(chs,step,i))&#123;</span><br><span class="line">                Swap(chs,i,step);</span><br><span class="line">                permutation(chs,step+<span class="number">1</span>);</span><br><span class="line">                Swap(chs,i,step);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//子数组排序返回后要将第一个元素交换回来。</span></span><br><span class="line">            <span class="comment">//如果不交换回来会出错，比如说第一次1、2交换，第一个位置为2，子数组排序返回后如果不将1、2</span></span><br><span class="line">            <span class="comment">//交换回来第二次交换的时候就会将2、3交换，因此必须将1、2交换使1还是在第一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>再给出一个举例分析:</p><p>去掉重复的全排列由于全排列就是从第一个数字起每个数分别与它后面的数字交换。我们先尝试加个这样的判断——如果一个数与后面的数字相同那么这二个数就不交换了。如122，第一个数与后面交换得212、221。然后122中第二数就不用与第三个数交换了，但对212，它第二个数与第三个数是不相同的，交换之后得到221。与由122中第一个数与第三个数交换所得的221重复了。所以这个方法不行。</p><p>换种思维，对122，第一个数1与第二个数2交换得到212，然后考虑第一个数1与第三个数2交换，此时由于第三个数等于第二个数，所以第一个数不再与第三个数交换。再考虑212，它的第二个数与第三个数交换可以得到解决221。此时全排列生成完毕。<br>这样我们也得到了在全排列中去掉重复的规则——去重的全排列就是从第一个数字起每个数分别与它后面非重复出现的数字交换。</p><p>继续加油~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS-数组全排列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>由八皇后问题引出----判断矩阵元素是否在同一斜线上</title>
      <link href="/2021/10/14/%E7%94%B1%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E5%BC%95%E5%87%BA-%E5%88%A4%E6%96%AD%E7%9F%A9%E9%98%B5%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E5%90%8C%E4%B8%80%E6%96%9C%E7%BA%BF%E4%B8%8A/"/>
      <url>/2021/10/14/%E7%94%B1%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E5%BC%95%E5%87%BA-%E5%88%A4%E6%96%AD%E7%9F%A9%E9%98%B5%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E5%90%8C%E4%B8%80%E6%96%9C%E7%BA%BF%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="由八皇后问题引出—-判断矩阵元素是否在同一斜线上"><a href="#由八皇后问题引出—-判断矩阵元素是否在同一斜线上" class="headerlink" title="由八皇后问题引出—-判断矩阵元素是否在同一斜线上"></a>由八皇后问题引出—-判断矩阵元素是否在同一斜线上</h1><h2 id="图1"><a href="#图1" class="headerlink" title="图1"></a>图1</h2><p> <img src="/articleImg/24_article/graph.png" alt="graph"></p><h2 id="图2"><a href="#图2" class="headerlink" title="图2"></a>图2</h2><p> <img src="/articleImg/24_article/graph2.png" alt="graph2"></p><p>如果该判断方法在八皇后中应用时，最好定义一个array[8]数组，存放以放置的皇后，在array数组中下标代表行数，数组值代表皇后所在列数。这样遍历起来会更方便。否则还要去遍历mark[][] [8] [8]二维数组。直接用array数组中对应的信息，去做判断效率很高！</p><p>用于其他算法，就直接使用即可~</p><p>继续加油！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 判断矩阵元素是否在同一斜线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Jetson上融合yolov5目标检测与双目摄像头测距</title>
      <link href="/2021/10/13/%E5%9C%A8Jetson%E4%B8%8A%E8%9E%8D%E5%90%88yolov5%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%8F%8C%E7%9B%AE%E6%91%84%E5%83%8F%E5%A4%B4%E6%B5%8B%E8%B7%9D/"/>
      <url>/2021/10/13/%E5%9C%A8Jetson%E4%B8%8A%E8%9E%8D%E5%90%88yolov5%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%8F%8C%E7%9B%AE%E6%91%84%E5%83%8F%E5%A4%B4%E6%B5%8B%E8%B7%9D/</url>
      
        <content type="html"><![CDATA[<h1 id="在Jetson上融合yolov5目标检测与双目摄像头测距"><a href="#在Jetson上融合yolov5目标检测与双目摄像头测距" class="headerlink" title="在Jetson上融合yolov5目标检测与双目摄像头测距"></a>在Jetson上融合yolov5目标检测与双目摄像头测距</h1><p>这几天都在做摄像头双目测距与yolov5识别的内容。主要想实现的功能是，将yolov5识别的物体，标注出距离左右摄像头的距离。到今天下午，已经可以实时处理USB双目摄像头采集的图像。在这里将相关的过程记录下来，以免遗忘。</p><h2 id="双目测距过程"><a href="#双目测距过程" class="headerlink" title="双目测距过程"></a>双目测距过程</h2><h3 id="使用Matlab进行双目标定"><a href="#使用Matlab进行双目标定" class="headerlink" title="使用Matlab进行双目标定"></a>使用Matlab进行双目标定</h3><h4 id="双目摄像头"><a href="#双目摄像头" class="headerlink" title="双目摄像头"></a>双目摄像头</h4><p>用的摄像头的uvc免驱的摄像头，这是非常爽的，插在nano的USB口上就可以使用，驱动yoloV5之后，效果如图</p><p><img src="/articleImg/18_article/yolo.png" alt="yolo"></p><ul><li><p>插入摄像头之后查看信息所需要的相关命令：<br/></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># shell 窗口下输入</span></span><br><span class="line">lsusb    <span class="comment"># 查看已存在的USB设备资源</span></span><br><span class="line">cat /dev/video*  <span class="comment"># 查看有几个摄像头设备 /dev/video0 代表0号摄像头   /dev/video1 代表1号摄像头 </span></span><br><span class="line"><span class="comment"># 主要也就是这两条命令来确认你的uvc免驱摄像头能不能使用</span></span><br></pre></td></tr></table></figure></li><li><p>确认可以使用后，肯定要驱动显示图像才好啊，下面给出我用的摄像头驱动显示代码<br/></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">AUTO = <span class="literal">False</span>  <span class="comment"># 自动拍照，或手动按s键拍照</span></span><br><span class="line">INTERVAL = <span class="number">2</span> <span class="comment"># 自动拍照间隔</span></span><br><span class="line"> </span><br><span class="line">cv2.namedWindow(<span class="string">&quot;left&quot;</span>)</span><br><span class="line">cv2.namedWindow(<span class="string">&quot;right&quot;</span>)</span><br><span class="line">camera = cv2.VideoCapture(<span class="number">0</span>)  <span class="comment"># 用几号摄像头就设置为几</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 设置分辨率 左右摄像机同一频率，同一设备ID；左右摄像机总分辨率1280x480；分割为两个640x480、640x480</span></span><br><span class="line">camera.<span class="built_in">set</span>(cv2.CAP_PROP_FRAME_WIDTH,<span class="number">1280</span>)</span><br><span class="line">camera.<span class="built_in">set</span>(cv2.CAP_PROP_FRAME_HEIGHT,<span class="number">480</span>)</span><br><span class="line"> </span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line">utc = time.time()</span><br><span class="line">folder = <span class="string">&quot;./SaveImage/&quot;</span> <span class="comment"># 拍照文件目录</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shot</span>(<span class="params">pos, frame</span>):</span></span><br><span class="line">    <span class="keyword">global</span> counter</span><br><span class="line">    path = folder + pos + <span class="string">&quot;_&quot;</span> + <span class="built_in">str</span>(counter) + <span class="string">&quot;.jpg&quot;</span></span><br><span class="line"> </span><br><span class="line">    cv2.imwrite(path, frame)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;snapshot saved into: &quot;</span> + path)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, frame = camera.read()</span><br><span class="line">    <span class="comment"># 裁剪坐标为[y0:y1, x0:x1] HEIGHT*WIDTH</span></span><br><span class="line">    left_frame = frame[<span class="number">0</span>:<span class="number">480</span>, <span class="number">0</span>:<span class="number">640</span>]</span><br><span class="line">    right_frame = frame[<span class="number">0</span>:<span class="number">480</span>, <span class="number">640</span>:<span class="number">1280</span>]</span><br><span class="line"> </span><br><span class="line">    cv2.imshow(<span class="string">&quot;left&quot;</span>, left_frame)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;right&quot;</span>, right_frame)</span><br><span class="line"> </span><br><span class="line">    now = time.time()</span><br><span class="line">    <span class="keyword">if</span> AUTO <span class="keyword">and</span> now - utc &gt;= INTERVAL:</span><br><span class="line">        shot(<span class="string">&quot;left&quot;</span>, left_frame)</span><br><span class="line">        shot(<span class="string">&quot;right&quot;</span>, right_frame)</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">        utc = now</span><br><span class="line"> </span><br><span class="line">    key = cv2.waitKey(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> key == <span class="built_in">ord</span>(<span class="string">&quot;q&quot;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">elif</span> key == <span class="built_in">ord</span>(<span class="string">&quot;s&quot;</span>):</span><br><span class="line">        shot(<span class="string">&quot;left&quot;</span>, left_frame)</span><br><span class="line">        shot(<span class="string">&quot;right&quot;</span>, right_frame)</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">camera.release()</span><br><span class="line">cv2.destroyWindow(<span class="string">&quot;left&quot;</span>)</span><br><span class="line">cv2.destroyWindow(<span class="string">&quot;right&quot;</span>)</span><br></pre></td></tr></table></figure><p>对双目摄像头的测试就到此为止了。</p></li></ul><h4 id="双目测距基本流程"><a href="#双目测距基本流程" class="headerlink" title="双目测距基本流程"></a><strong>双目测距基本流程</strong></h4><p>主要参考自 CSDN博主 ： <a href="https://blog.csdn.net/dulingwen">dulingwen</a></p><p>结起来，双目测距的大致流程如下：</p><p><img src="/articleImg/18_article/biaoding.png" alt="biaoding"></p><p>  在这里贴出代码，由于PCL库比较难装，这里将博主代码中的点云部分全部注释<br/></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> stereo.dianyuntu_yolo <span class="keyword">import</span> preprocess, undistortion, getRectifyTransform, draw_line, rectifyImage,\</span><br><span class="line">     stereoMatchSGBM, hw3ToN3</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> stereo <span class="keyword">import</span> stereoconfig_040_2</span><br><span class="line"></span><br><span class="line">image_width = <span class="number">1280</span> / <span class="number">2</span></span><br><span class="line">image_height = <span class="number">480</span></span><br><span class="line">skip_flag = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">detect():</span><br><span class="line">    <span class="comment"># .......将该段代码放在yolo代码中的 # Add bbox to image下</span></span><br><span class="line">     <span class="comment"># -----------------------------------------------------zl 9.15</span></span><br><span class="line">                        <span class="comment"># 识别框上中点坐标</span></span><br><span class="line">                        x = (xyxy[<span class="number">0</span>] + xyxy[<span class="number">2</span>]) / <span class="number">2</span></span><br><span class="line">                        y = (xyxy[<span class="number">1</span>] + xyxy[<span class="number">3</span>]) / <span class="number">2</span></span><br><span class="line">                        <span class="comment">#print(&quot; %s is  x: %d y: %d &quot; %(label,x,y) )</span></span><br><span class="line">                        skip_flag = <span class="literal">False</span></span><br><span class="line">                        <span class="keyword">if</span> (x &lt;= <span class="number">1280</span>):</span><br><span class="line">                            t3 = time_synchronized()</span><br><span class="line">    </span><br><span class="line">                            <span class="comment">################################</span></span><br><span class="line">                            <span class="comment">#stereo code</span></span><br><span class="line">                            p = <span class="string">&quot;test&quot;</span></span><br><span class="line">                            string = <span class="string">&#x27;&#x27;</span></span><br><span class="line">                            <span class="comment">#print(&quot;P is %d&quot; %p )</span></span><br><span class="line">                            <span class="comment"># 读取数据集的图片</span></span><br><span class="line">                            <span class="comment">#iml = cv2.imread(&#x27;./stereo/yolo/zuo/%szuo%d.bmp&#x27; %(string,p) )  # 左图</span></span><br><span class="line">                            <span class="comment">#imr = cv2.imread(&#x27;./stereo/yolo/you/%syou%d.bmp&#x27; %(string,p) )  # 右图</span></span><br><span class="line"></span><br><span class="line">                            <span class="comment">#iml = cv2.imread(&#x27;./stereo/yolo/zuo/%szuo%d.bmp&#x27; %(string,p) )  # 左图</span></span><br><span class="line">                            <span class="comment">#imr = cv2.imread(&#x27;./stereo/yolo/you/%syou%d.bmp&#x27; %(string,p) )  # 右图</span></span><br><span class="line">                            </span><br><span class="line">                            height_0, width_0 = im0.shape[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">                            <span class="comment">#print(&quot;width_0 =  %d &quot;  % width_0)</span></span><br><span class="line">                            <span class="comment">#print(&quot;height_0 = %d &quot;  % height_0)</span></span><br><span class="line"></span><br><span class="line">                            width_1 = width_0/<span class="number">2</span></span><br><span class="line">                            iml = im0[<span class="number">0</span>:<span class="built_in">int</span>(height_0), <span class="number">0</span>:<span class="built_in">int</span>(width_0/<span class="number">2</span>)]</span><br><span class="line">                            imr = im0[<span class="number">0</span>:<span class="built_in">int</span>(height_0), <span class="built_in">int</span>(width_0/<span class="number">2</span>):<span class="built_in">int</span>(width_0) ]</span><br><span class="line"></span><br><span class="line">                            height, width = iml.shape[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">                            <span class="comment">#cv2.imshow(&quot;iml&quot;,iml)</span></span><br><span class="line">                            <span class="comment">#cv2.imshow(&quot;imr&quot;,im0)</span></span><br><span class="line">                            <span class="comment">#cv2.waitKey(0)</span></span><br><span class="line"></span><br><span class="line">                            <span class="comment">#print(&quot;width =  %d &quot;  % width)</span></span><br><span class="line">                            <span class="comment">#print(&quot;height = %d &quot;  % height)</span></span><br><span class="line"></span><br><span class="line">                            <span class="comment"># 读取相机内参和外参</span></span><br><span class="line">                            config = stereoconfig_040_2.stereoCamera()</span><br><span class="line"></span><br><span class="line">                            <span class="comment"># 立体校正</span></span><br><span class="line">                            map1x, map1y, map2x, map2y, Q = getRectifyTransform(height, width, config)  <span class="comment"># 获取用于畸变校正和立体校正的映射矩阵以及用于计算像素空间坐标的重投影矩阵</span></span><br><span class="line">                            <span class="comment">#print(&quot;Print Q!&quot;)</span></span><br><span class="line">                            <span class="comment">#print(&quot;Q[2,3]:%.3f&quot;%Q[2,3])</span></span><br><span class="line">                            iml_rectified, imr_rectified = rectifyImage(iml, imr, map1x, map1y, map2x, map2y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                </span><br><span class="line">                            <span class="comment"># 绘制等间距平行线，检查立体校正的效果</span></span><br><span class="line">                            line = draw_line(iml_rectified, imr_rectified)</span><br><span class="line">                            <span class="comment">#cv2.imwrite(&#x27;./yolo/%s检验%d.png&#x27; %(string,p), line)</span></span><br><span class="line"></span><br><span class="line">                            <span class="comment"># 消除畸变</span></span><br><span class="line">                            iml = undistortion(iml, config.cam_matrix_left, config.distortion_l)</span><br><span class="line">                            imr = undistortion(imr, config.cam_matrix_right, config.distortion_r)</span><br><span class="line">                        </span><br><span class="line">                            <span class="comment"># 立体匹配</span></span><br><span class="line">                            iml_, imr_ = preprocess(iml, imr)  <span class="comment"># 预处理，一般可以削弱光照不均的影响，不做也可以</span></span><br><span class="line"></span><br><span class="line">                            iml_rectified_l, imr_rectified_r = rectifyImage(iml_, imr_, map1x, map1y, map2x, map2y)</span><br><span class="line">                            </span><br><span class="line">                            disp, _ = stereoMatchSGBM(iml_rectified_l, imr_rectified_r, <span class="literal">True</span>) </span><br><span class="line">                            <span class="comment">#cv2.imwrite(&#x27;./yolo/%s视差%d.png&#x27; %(string,p), disp)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            <span class="comment"># 计算像素点的3D坐标（左相机坐标系下）</span></span><br><span class="line">                            points_3d = cv2.reprojectImageTo3D(disp, Q)  <span class="comment"># 可以使用上文的stereo_config.py给出的参数</span></span><br><span class="line"></span><br><span class="line">                            <span class="comment">#points_3d = points_3d</span></span><br><span class="line"></span><br><span class="line">                            <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">                            #print(&quot;x is :%.3f&quot; %points_3d[int(y), int(x), 0] )</span></span><br><span class="line"><span class="string">                                print(&#x27;点 (%d, %d) 的三维坐标 (x:%.3fcm, y:%.3fcm, z:%.3fcm)&#x27; % (int(x), int(y), </span></span><br><span class="line"><span class="string">                                points_3d[int(y), int(x), 0]/10, </span></span><br><span class="line"><span class="string">                                points_3d[int(y), int(x), 1]/10, </span></span><br><span class="line"><span class="string">                                points_3d[int(y), int(x), 2]/10) )</span></span><br><span class="line"><span class="string">                            &#x27;&#x27;&#x27;</span></span><br><span class="line">                            count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            <span class="comment">#try:  暂时关闭</span></span><br><span class="line">                            <span class="comment"># points_3d = points_3d.numpy()</span></span><br><span class="line">                            <span class="built_in">print</span>(points_3d.shape)</span><br><span class="line">                            <span class="comment"># print(&quot;x的值为：&quot;,x , &quot;  y的值为：&quot;, y)</span></span><br><span class="line">                            <span class="keyword">if</span>(x &lt; image_width <span class="keyword">and</span> x &gt;= <span class="number">0</span> <span class="keyword">and</span> y&lt; image_height <span class="keyword">and</span> y&gt;=<span class="number">0</span>):</span><br><span class="line">                                <span class="keyword">while</span>( (points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">2</span>] &lt; <span class="number">0</span>) | (points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">2</span>] &gt; <span class="number">2500</span>) ):</span><br><span class="line"></span><br><span class="line">                                    <span class="comment"># print(&quot;x的值为：&quot;,x , &quot;  y的值为：&quot;, y)</span></span><br><span class="line"></span><br><span class="line">                                    count += <span class="number">1</span></span><br><span class="line">                                    x += count</span><br><span class="line"></span><br><span class="line">                                    <span class="comment"># 个人添加判断程序，x y的值一旦发生更新就需要进行判断</span></span><br><span class="line">                                    <span class="keyword">if</span>(x &gt;= image_width <span class="keyword">or</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> y&gt;= image_height <span class="keyword">or</span> y&lt;<span class="number">0</span>):</span><br><span class="line">                                        skip_flag = <span class="literal">True</span></span><br><span class="line">                                        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">if</span>( <span class="number">0</span> &lt; points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">2</span>] &lt; <span class="number">2300</span> ):</span><br><span class="line">                                        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                                    y += count</span><br><span class="line"></span><br><span class="line">                                    <span class="comment"># 个人添加判断程序，x y的值一旦发生更新就需要进行判断</span></span><br><span class="line">                                    <span class="keyword">if</span>(x &gt;= image_width <span class="keyword">or</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> y&gt;= image_height <span class="keyword">or</span> y&lt;<span class="number">0</span>):</span><br><span class="line">                                        skip_flag = <span class="literal">True</span></span><br><span class="line">                                        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">if</span>( <span class="number">0</span> &lt; points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">2</span>] &lt; <span class="number">2300</span> ):</span><br><span class="line">                                        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                                    count += <span class="number">1</span></span><br><span class="line">                                    x -= count</span><br><span class="line"></span><br><span class="line">                                    <span class="comment"># 个人添加判断程序，x y的值一旦发生更新就需要进行判断</span></span><br><span class="line">                                    <span class="keyword">if</span>(x &gt;= image_width <span class="keyword">or</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> y&gt;= image_height <span class="keyword">or</span> y&lt;<span class="number">0</span>):</span><br><span class="line">                                        skip_flag = <span class="literal">True</span></span><br><span class="line">                                        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">if</span>( <span class="number">0</span> &lt; points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">2</span>] &lt; <span class="number">2300</span> ):</span><br><span class="line">                                        <span class="keyword">break</span></span><br><span class="line">                                    y -= count</span><br><span class="line"></span><br><span class="line">                                    <span class="comment"># 个人添加判断程序，x y的值一旦发生更新就需要进行判断</span></span><br><span class="line">                                    <span class="keyword">if</span>(x &gt;= image_width <span class="keyword">or</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> y&gt;= image_height <span class="keyword">or</span> y&lt;<span class="number">0</span>):</span><br><span class="line">                                        skip_flag = <span class="literal">True</span></span><br><span class="line">                                        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">if</span>( <span class="number">0</span> &lt; points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">2</span>] &lt; <span class="number">2300</span> ):</span><br><span class="line">                                        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                                    <span class="comment">#if(count%2==1):</span></span><br><span class="line">                                     <span class="comment">#   x += 1</span></span><br><span class="line">                                    <span class="comment">#else:</span></span><br><span class="line">                                    <span class="comment">#    y += 1</span></span><br><span class="line"></span><br><span class="line">                                </span><br><span class="line">        </span><br><span class="line">                                <span class="keyword">if</span>(~skip_flag):</span><br><span class="line">                                    text_cxy = <span class="string">&quot;*&quot;</span></span><br><span class="line">                                    cv2.putText(im0, text_cxy, (<span class="built_in">int</span>(x), <span class="built_in">int</span>(y)) ,  cv2.FONT_ITALIC, <span class="number">1.2</span>, (<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">#tl = round(0.02 * (img.shape[0] + img.shape[1]) / 2) + 1  # line/font thickness</span></span><br><span class="line">                                    <span class="comment">#tf = max(tl - 1, 1)  # font thickness</span></span><br><span class="line">                                    <span class="comment">#cv2.putText(im0, text_cxy,  (int(x), int(y)), 0, tl / 3, [0, 0, 255], thickness=tf, lineType=cv2.LINE_AA)</span></span><br><span class="line">                                    </span><br><span class="line">                                    <span class="comment">#print(&quot;count is %d&quot; %count)</span></span><br><span class="line">                                    <span class="built_in">print</span>(<span class="string">&#x27;点 (%d, %d) 的三维坐标 (x:%.1fcm, y:%.1fcm, z:%.1fcm)&#x27;</span> % (<span class="built_in">int</span>(x), <span class="built_in">int</span>(y), </span><br><span class="line">                                        points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">0</span>]/<span class="number">10</span>, </span><br><span class="line">                                        points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">1</span>]/<span class="number">10</span>, </span><br><span class="line">                                        points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">2</span>]/<span class="number">10</span>) )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                    dis = ( (points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">0</span>] ** <span class="number">2</span> + points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">1</span>] ** <span class="number">2</span> + points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">2</span>] **<span class="number">2</span>) ** <span class="number">0.5</span> ) / <span class="number">10</span></span><br><span class="line">                                    <span class="built_in">print</span>(<span class="string">&#x27;点 (%d, %d) 的 %s 距离左摄像头的相对距离为 %0.1f cm&#x27;</span> %(x, y,label, dis) )</span><br><span class="line">                                </span><br><span class="line">                                    <span class="comment">#label = f&#x27;&#123;names[int(cls)]&#125; &#123;conf:.2f&#125; &#x27;</span></span><br><span class="line">                                    <span class="comment">#plot_one_box(xyxy, im0, label=label+ &#x27;x:%.2f y:%.2f z:%.2f&#x27; </span></span><br><span class="line">                                    <span class="comment">#                           %(points_3d[int(y), int(x), 0]/10, </span></span><br><span class="line">                                    <span class="comment">#                             points_3d[int(y), int(x), 1]/10 ,  </span></span><br><span class="line">                                    <span class="comment">#                             points_3d[int(y), int(x), 2]/10) , </span></span><br><span class="line">                                    <span class="comment">#                             color=colors[int(cls)], line_thickness=3)</span></span><br><span class="line"></span><br><span class="line">                                    text_x = <span class="string">&quot;x:%.1fcm&quot;</span> %(points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">0</span>]/<span class="number">10</span>)</span><br><span class="line">                                    text_y = <span class="string">&quot;y:%.1fcm&quot;</span> %(points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">1</span>]/<span class="number">10</span>)</span><br><span class="line">                                    text_z = <span class="string">&quot;z:%.1fcm&quot;</span> %(points_3d[<span class="built_in">int</span>(y), <span class="built_in">int</span>(x), <span class="number">2</span>]/<span class="number">10</span>)</span><br><span class="line">                                    text_dis = <span class="string">&quot;dis:%.1fcm&quot;</span> %dis</span><br><span class="line"></span><br><span class="line">                                    cv2.rectangle(im0,(<span class="built_in">int</span>(xyxy[<span class="number">0</span>]+(xyxy[<span class="number">2</span>]-xyxy[<span class="number">0</span>])),<span class="built_in">int</span>(xyxy[<span class="number">1</span>])),(<span class="built_in">int</span>(xyxy[<span class="number">0</span>]+(xyxy[<span class="number">2</span>]-xyxy[<span class="number">0</span>])+<span class="number">5</span>+<span class="number">220</span>),<span class="built_in">int</span>(xyxy[<span class="number">1</span>]+<span class="number">150</span>)),colors[<span class="built_in">int</span>(cls)],-<span class="number">1</span>);</span><br><span class="line">                                    cv2.putText(im0, text_x, (<span class="built_in">int</span>(xyxy[<span class="number">0</span>]+(xyxy[<span class="number">2</span>]-xyxy[<span class="number">0</span>])+<span class="number">5</span>), <span class="built_in">int</span>(xyxy[<span class="number">1</span>]+<span class="number">30</span>)),  cv2.FONT_ITALIC, <span class="number">1.2</span>, (<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>), <span class="number">3</span>)</span><br><span class="line">                                    cv2.putText(im0, text_y, (<span class="built_in">int</span>(xyxy[<span class="number">0</span>]+(xyxy[<span class="number">2</span>]-xyxy[<span class="number">0</span>])+<span class="number">5</span>), <span class="built_in">int</span>(xyxy[<span class="number">1</span>]+<span class="number">65</span>)),  cv2.FONT_ITALIC, <span class="number">1.2</span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">3</span>)</span><br><span class="line">                                    cv2.putText(im0, text_z, (<span class="built_in">int</span>(xyxy[<span class="number">0</span>]+(xyxy[<span class="number">2</span>]-xyxy[<span class="number">0</span>])+<span class="number">5</span>), <span class="built_in">int</span>(xyxy[<span class="number">1</span>]+<span class="number">100</span>)), cv2.FONT_ITALIC, <span class="number">1.2</span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">3</span>)</span><br><span class="line">                                    cv2.putText(im0, text_dis, (<span class="built_in">int</span>(xyxy[<span class="number">0</span>]+(xyxy[<span class="number">2</span>]-xyxy[<span class="number">0</span>])+<span class="number">5</span>), <span class="built_in">int</span>(xyxy[<span class="number">1</span>]+<span class="number">145</span>)), cv2.FONT_ITALIC, <span class="number">1.2</span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">#cv2.putText(im0, text_x, (xyxy[0]+(xyxy[2]-xyxy[0])+5, xyxy[1]+30),  cv2.FONT_ITALIC, 1, (102, 80, 250), 3)</span></span><br><span class="line">                                    <span class="comment">#cv2.putText(im0, text_y, (xyxy[0]+(xyxy[2]-xyxy[0])+5, xyxy[1]+65),  cv2.FONT_ITALIC, 1, (102, 80, 250), 3)</span></span><br><span class="line">                                    <span class="comment">#cv2.putText(im0, text_z, (xyxy[0]+(xyxy[2]-xyxy[0])+5, xyxy[1]+100), cv2.FONT_ITALIC, 1, (102, 80, 250), 3)</span></span><br><span class="line">                                    <span class="comment">#cv2.putText(im0, text_dis, (xyxy[0]+(xyxy[2]-xyxy[0])+5, xyxy[1]+145), cv2.FONT_ITALIC, 1, (102, 80, 250), 3)</span></span><br><span class="line"></span><br><span class="line">                                    <span class="comment"># cv2.imshow(&quot;img&amp;coor&quot;, im0)</span></span><br><span class="line">                                    <span class="comment"># 鼠标点击事件</span></span><br><span class="line">                                    <span class="comment">#def onMouse(event, x, y, flags, param):</span></span><br><span class="line">                                    <span class="comment">#    if event == cv2.EVENT_LBUTTONDOWN:</span></span><br><span class="line">                                    <span class="comment">#        print(&#x27;点 (%d, %d) 的三维坐标 (x:%.3fm, y:%.3fm, z:%.3fm)&#x27; % (x, y, points_3d[y, x, 0]/1000, points_3d[y, x, 1]/1000, points_3d[y, x, 2]/1000))</span></span><br><span class="line">                                    <span class="comment">#        dis = ( (points_3d[y, x, 0] ** 2 + points_3d[y, x, 1] ** 2 + points_3d[y, x, 2] **2) ** 0.5) / 1000</span></span><br><span class="line">                                    <span class="comment">#        print(&#x27;点 (%d, %d) 距离左摄像头的相对距离为 %0.3f m&#x27; %(x, y, dis) )</span></span><br><span class="line"></span><br><span class="line">                                    <span class="comment"># 显示图片</span></span><br><span class="line">                                    <span class="comment">#cv2.namedWindow(&quot;disparity&quot;,0)</span></span><br><span class="line">                                    <span class="comment">#cv2.imshow(&quot;disparity&quot;, disp)</span></span><br><span class="line">                                    <span class="comment">#cv2.setMouseCallback(&quot;disparity&quot;, onMouse, 0)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                    <span class="comment"># 构建点云--Point_XYZRGBA格式</span></span><br><span class="line">                                    <span class="comment">#pointcloud = DepthColor2Cloud(points_3d, iml)</span></span><br><span class="line"></span><br><span class="line">                                    <span class="comment"># 显示点云</span></span><br><span class="line">                                    <span class="comment">#view_cloud(pointcloud)</span></span><br><span class="line"></span><br><span class="line">                                    <span class="comment">#cv2.waitKey(0)</span></span><br><span class="line">                                    <span class="comment">#cv2.destroyAllWindows()</span></span><br><span class="line">                                <span class="comment">#except:</span></span><br><span class="line">                                    </span><br><span class="line">                                <span class="comment">#   print(&quot;next!&quot;)</span></span><br><span class="line">                                    t4 = time_synchronized()</span><br><span class="line">                                    <span class="built_in">print</span>(<span class="string">f&#x27;Done. (<span class="subst">&#123;t4 - t3:<span class="number">.3</span>f&#125;</span>s)&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码就会计算出双目测距的距离。注意该段代码需要导入matlab标定的相关参数。以及根据相关参数对图像进行修正的函数</p><p>这里给出整体代码的百度云链接。</p><p>链接：<a href="https://pan.baidu.com/s/1FUHlaKRHsZCxj6lS8il3Jw">https://pan.baidu.com/s/1FUHlaKRHsZCxj6lS8il3Jw</a><br>提取码：i2q5 </p><p>最后便可得出测试效果，如下图。</p><p><img src="/articleImg/18_article/distance.png" alt="distance"></p><h2 id="测试总结"><a href="#测试总结" class="headerlink" title="测试总结"></a>测试总结</h2><ul><li>单独在Jetson Nano上运行yolov5进行实时的目标检测还是挺快的</li><li>进行实时检测时需要指定摄像头数据 –source 0</li><li>在程序中可以设置摄像头的相关数据（双目摄像头需要设置分辨率，不设置的话只会有一个摄像头工作）</li><li>进行视频离线处理视频测距 OK</li><li>进行实时双目测距过程时，由于YOLOV5网络在处理实时数据，会resize图像，导致图像大小发生变化，因此经常会发生数组越界问题</li><li>总体来说，个人觉得测距精度不是很高，后续在进行相关的优化吧~</li></ul>]]></content>
      
      
      <categories>
          
          <category> Nano车载平台 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双目测距 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常规表达式转逆波兰表达式</title>
      <link href="/2021/10/09/%E5%B8%B8%E8%A7%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2021/10/09/%E5%B8%B8%E8%A7%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="常规表达式转逆波兰表达式"><a href="#常规表达式转逆波兰表达式" class="headerlink" title="常规表达式转逆波兰表达式"></a>常规表达式转逆波兰表达式</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看到这个题目的时候，我在想，应该不难。这逆波兰表达式的计算顺序，和普通表达式计算的顺序是差不多的，那我在普通计算器实现程序的compute</p><p>函数中做一些改变，看能不能实现这个题目的想法。最后做完发现不太行，程序不够general，遇到一些特殊情况就gg了。主要原因是：普通计算器计算完中中间结果，会将中间结果压栈。在我修改过程中发现，我难以分辨出，本次出栈的结果中是否含有中间结果。因为如果是两个原生数（表达式中的数），就需要全部输出。</p><p>下面给出参考网上的实现思路，并给出自己的实现代码。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p> <img src="/articleImg/23_article/graph.png" alt="graph"></p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"><span class="comment">//将中缀表达式转化为后缀表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferExpression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TransferExpression transferExpression = <span class="keyword">new</span> TransferExpression();</span><br><span class="line">        List&lt;String&gt; strings = transferExpression.fun1(<span class="string">&quot;1+((2+3)×4)-5&quot;</span>);</span><br><span class="line">        List&lt;String&gt; strings1 = transferExpression.fun2(strings);</span><br><span class="line">        System.out.println(<span class="string">&quot;测试完毕&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;String&gt;fun2(List&lt;String&gt; S)&#123;</span><br><span class="line">        <span class="comment">//将分解好的因式，传入，开始进行中缀转后缀的转换</span></span><br><span class="line">        Stack&lt;String&gt; sign_stack = <span class="keyword">new</span> Stack&lt;&gt;(); <span class="comment">//作为运算符的符号栈</span></span><br><span class="line">        ArrayList&lt;String&gt; post_expression = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">//作为数字栈，这里用ArrayList模拟栈的存储，因为这里并不需要出栈</span></span><br><span class="line">        <span class="keyword">for</span> (String item : S) &#123;</span><br><span class="line">            <span class="keyword">if</span>(item.matches(<span class="string">&quot;\\d+&quot;</span>))&#123; <span class="comment">//正则表达式匹配，如果是数</span></span><br><span class="line">                post_expression.add(item);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">//元素为符号</span></span><br><span class="line">                <span class="keyword">char</span> temp = item.charAt(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(sign_stack.isEmpty())&#123;</span><br><span class="line">                    sign_stack.push(item);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(temp == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(!sign_stack.peek().equals(<span class="string">&quot;&quot;</span>+<span class="string">&#x27;(&#x27;</span>))&#123; <span class="comment">//直至扫描找到 （  ，扫描过程中一直出符号栈</span></span><br><span class="line">                        String pop_item = sign_stack.pop();</span><br><span class="line">                        post_expression.add(pop_item);</span><br><span class="line">                    &#125;</span><br><span class="line">                    sign_stack.pop(); <span class="comment">//把符号栈顶&#x27;(&#x27;出栈</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sign_stack.peek().equals(<span class="string">&quot;&quot;</span>+<span class="string">&#x27;(&#x27;</span>))&#123;</span><br><span class="line">                    sign_stack.push(item);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.Sign_priority(temp)&gt;<span class="keyword">this</span>.Sign_priority(sign_stack.peek().charAt(<span class="number">0</span>)))&#123;</span><br><span class="line">                    sign_stack.push(item);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123; <span class="comment">//说明temp符号的优先级小于栈顶符号的优先级,将栈顶元素出栈，再将temp符号压栈</span></span><br><span class="line">                    <span class="comment">//此时的符号肯定是正常的加减乘除</span></span><br><span class="line">                    String pop_item = sign_stack.pop();</span><br><span class="line">                    post_expression.add(pop_item);</span><br><span class="line">                    sign_stack.push(item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!sign_stack.isEmpty())&#123;</span><br><span class="line">            String pop_item = sign_stack.pop();</span><br><span class="line">            post_expression.add(pop_item);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(post_expression);</span><br><span class="line">        <span class="keyword">return</span> post_expression;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fun1</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        String str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c-<span class="string">&#x27;0&#x27;</span>&gt;=<span class="number">0</span>&amp;&amp;c-<span class="string">&#x27;0&#x27;</span>&lt;=<span class="number">9</span>)&#123; <span class="comment">//这里考虑多位数</span></span><br><span class="line">                str = str+c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!str.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">                    strings.add(str);</span><br><span class="line">                    strings.add(<span class="string">&quot;&quot;</span>+s.charAt(i));</span><br><span class="line">                    str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    strings.add(<span class="string">&quot;&quot;</span>+s.charAt(i));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!str.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">            strings.add(str);</span><br><span class="line">            str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(strings);</span><br><span class="line">        <span class="keyword">return</span> strings;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">Sign_priority</span><span class="params">(<span class="keyword">char</span> Sign)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> priority = -<span class="number">1</span>; <span class="comment">//数字大代表优先级大</span></span><br><span class="line">        <span class="keyword">if</span>(Sign == <span class="string">&#x27;+&#x27;</span>||Sign==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            priority = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Sign == <span class="string">&#x27;*&#x27;</span>||Sign==<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">            priority = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Sign == <span class="string">&#x27;&#123;&#x27;</span>||Sign==<span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">            priority = <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Sign == <span class="string">&#x27;[&#x27;</span>||Sign==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">            priority = <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Sign == <span class="string">&#x27;(&#x27;</span>||Sign==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            priority = <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> priority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>继续加油吧~</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中缀转后缀表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python处理excel之修改数据</title>
      <link href="/2021/10/09/python%E5%A4%84%E7%90%86excel%E4%B9%8B%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE/"/>
      <url>/2021/10/09/python%E5%A4%84%E7%90%86excel%E4%B9%8B%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="python处理excel之修改数据"><a href="#python处理excel之修改数据" class="headerlink" title="python处理excel之修改数据"></a>python处理excel之修改数据</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前两天在调试雷达传感器进行数据采集时，得到了一个复数矩阵，但是每个复数都是带着小括号的，这样的数据是没有办法导入到matlab中进行处理的。因为小括号在matlab中表示取某矩阵的元素。于是自己花了40分钟写了一个遍历excel数据，并修改数据的程序，这里记录一下，说不定以后还要用，省的自己再去找读取excel的函数。</p><h2 id="对应代码"><a href="#对应代码" class="headerlink" title="对应代码"></a>对应代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> scipy.io</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">filename=<span class="string">r&quot;C:\Users\zhanglei\Desktop\data\2.csv&quot;</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line">new_data_list = []</span><br><span class="line">row = <span class="number">0</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f:</span><br><span class="line">    reader=csv.reader(f) <span class="comment"># 获取reader对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        row = row+<span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;本次row为&quot;</span>,row)</span><br><span class="line">        header_row=<span class="built_in">next</span>(reader)  <span class="comment"># 获取可迭代对象</span></span><br><span class="line">        <span class="comment"># print(header_row[0])</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(header_row)):   <span class="comment"># 进行遍历</span></span><br><span class="line">            <span class="comment">#print(i)</span></span><br><span class="line">            <span class="keyword">if</span> row == <span class="number">287</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;这里报错&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(header_row[<span class="number">81</span>],header_row[<span class="number">82</span>],header_row[<span class="number">83</span>],header_row[<span class="number">84</span>])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># if header_row[i][0]</span></span><br><span class="line">            <span class="comment">#print(&quot;是否查找到(&quot;,header_row[i].rfind(&#x27;(&#x27;))</span></span><br><span class="line">            <span class="keyword">if</span> header_row[i].find(<span class="string">&#x27;(&#x27;</span>)!=-<span class="number">1</span>:</span><br><span class="line">                header_row[i] = header_row[i].split(<span class="string">&#x27;(&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># print(&quot;是否查找到)&quot;,header_row[i].rfind(&#x27;)&#x27;))</span></span><br><span class="line">            <span class="keyword">if</span> header_row[i].rfind(<span class="string">&#x27;)&#x27;</span>) != -<span class="number">1</span>:</span><br><span class="line">                header_row[i] = header_row[i].split(<span class="string">&#x27;)&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># print(header_row)</span></span><br><span class="line">        new_data_list.append(header_row)</span><br><span class="line"></span><br><span class="line">        count+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count==<span class="number">1080</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment">#print(len(header_row))</span></span><br><span class="line">        <span class="comment">#print(header_row)</span></span><br><span class="line">    <span class="built_in">print</span>(count)</span><br><span class="line">    <span class="comment">#print(new_data_list.shape)</span></span><br><span class="line"></span><br><span class="line">    list_shape = np.array(new_data_list).shape</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;转换后的维度&quot;</span>,list_shape)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;C:\Users\zhanglei\Desktop\data\Transfer2.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">        writer = csv.writer(csvfile)</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> new_data_list:</span><br><span class="line">            writer.writerow(row)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    scipy.io.savemat(<span class="string">&#x27;filename.mat&#x27;</span>,&#123;<span class="string">&#x27;my_data&#x27;</span>: new_data_list&#125;) <span class="comment"># 这里Sava为mat文件出现乱码，当时直接又转存为CSV，所以也没深究，后续再看</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>去除括号之前</p><p> <img src="/articleImg/19_article/data1.png" alt="data1"></p><p>去除之后</p><p> <img src="/articleImg/19_article/data2.png" alt="data2"></p><p>继续加油~</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 遍历修改excel数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆波兰表达式</title>
      <link href="/2021/10/08/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2021/10/08/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="逆波兰表达式"><a href="#逆波兰表达式" class="headerlink" title="逆波兰表达式"></a>逆波兰表达式</h2><h2 id="逆波兰表达式的解释"><a href="#逆波兰表达式的解释" class="headerlink" title="逆波兰表达式的解释"></a>逆波兰表达式的解释</h2><p>逆波兰记法中，操作符置于操作数的后面。例如表达“三加四”时，写作“3 4 + ”，而不是“3 + 4”。如果有多个操作符，操作符置于第二个操作数的后面，所以常规中缀记法的“3 - 4 + 5”在逆波兰记法中写作“3 4 - 5 + ”：先3减去4，再加上5。使用逆波兰记法的一个好处是不需要使用括号。例如中缀记法中“3 - 4 * 5”与“（3 - 4）*5”不相同，但后缀记法中前者写做“3 4 5 * - ”，无歧义地表示“3 (4 5 *) -”；后者写做“3 4 - 5 * ”。</p><p>逆波兰表达式的<a href="https://zh.wikipedia.org/wiki/%E8%A7%A3%E9%87%8A%E5%99%A8">解释器</a>一般是基于<a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88">堆栈</a>的。解释过程一般是：操作数入栈；遇到操作符时，操作数出栈，求值，将结果入栈；当一遍后，栈顶就是表达式的值。因此逆波兰表达式的求值使用堆栈结构很容易实现，并且能很快求值。</p><p>注意：逆波兰记法并不是简单的<a href="https://zh.wikipedia.org/wiki/%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">波兰表达式</a>的反转。因为对于不满足<a href="https://zh.wikipedia.org/wiki/%E4%BA%A4%E6%8D%A2%E5%BE%8B">交换律</a>的操作符，它的操作数写法仍然是常规顺序，如，波兰记法“/ 6 3”的逆波兰记法是“6 3 /”而不是“3 6 /”；数字的数位写法也是常规顺序。</p><h2 id="逆波兰计算器栈的实现思路"><a href="#逆波兰计算器栈的实现思路" class="headerlink" title="逆波兰计算器栈的实现思路"></a>逆波兰计算器栈的实现思路</h2><p> <img src="/articleImg/22_article/graph.png" alt="graph"></p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolandNotation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先定义给逆波兰表达式</span></span><br><span class="line">        <span class="comment">//(30+4)× 5-6 =&gt; 30 4 + 5 × 6 - =&gt; 164</span></span><br><span class="line">        String suffixExpression = <span class="string">&quot;4 5 * 8 - 60 + 8 2 / +&quot;</span>; <span class="comment">// 76</span></span><br><span class="line">        List&lt;String&gt; list = getListString(suffixExpression);</span><br><span class="line">        System.out.println(<span class="string">&quot;rpnList=&quot;</span> + list);</span><br><span class="line">        <span class="keyword">int</span> res = calculate(list);</span><br><span class="line">        System.out.println(<span class="string">&quot;计算的结果是=&quot;</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getListString</span><span class="params">(String suffixExpression)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将 suffixExpression 分割</span></span><br><span class="line">        String[] split = suffixExpression.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String ele : split) &#123;</span><br><span class="line">            list.add(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(List&lt;String&gt; ls)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建给栈, 只需要一个栈即可</span></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line">    <span class="comment">// 遍历 ls</span></span><br><span class="line">        <span class="keyword">for</span> (String item : ls) &#123;</span><br><span class="line">    <span class="comment">// 这里使用正则表达式来取出数</span></span><br><span class="line">            <span class="keyword">if</span> (item.matches(<span class="string">&quot;\\d+&quot;</span>)) &#123; <span class="comment">// 匹配的是多位数</span></span><br><span class="line">            <span class="comment">// 入栈</span></span><br><span class="line">                stack.push(item);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// pop 出两个数， 并运算， 再入栈</span></span><br><span class="line">                <span class="keyword">int</span> num2 = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> num1 = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (item.equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 + num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 - num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 * num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 / num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;运算符有误&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//把 res 入栈</span></span><br><span class="line">                stack.push(<span class="string">&quot;&quot;</span> + res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后留在 stack 中的数据是运算结果</span></span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>继续加油！！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆波兰表达式计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈实现综合计算器</title>
      <link href="/2021/10/08/%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
      <url>/2021/10/08/%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="栈实现综合计算器"><a href="#栈实现综合计算器" class="headerlink" title="栈实现综合计算器"></a>栈实现综合计算器</h1><p>这个其实在本科的时候，自己做过一遍，用的时C，当时理解还挺深刻的，没想到过了几年，自己又忘得差不多了哈哈哈，想到这里，我记得当时去解老师讲的迷宫求解，真的死了很多脑细胞，看来自己还是不属于天才型选手，那就多多努力吧。</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>这次给出java的实现代码，并简单记录实现的关键思路。以防后续遗忘。&lt;切记：这是一个边扫描，边入栈，边出栈，边计算，边入栈的过程&gt;</p><p> <img src="/articleImg/21_article/graph.png" alt="graph"></p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>在这里给出实现的代码，实测可正常运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中缀表达式求值，其实就是平时常见的多项式求值</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">calculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CharStack signStack; <span class="comment">//存放计算符号的栈</span></span><br><span class="line">    <span class="keyword">private</span> ArrayStack numStack; <span class="comment">//存放数字的栈</span></span><br><span class="line">    <span class="keyword">private</span>  CharStack checkBracketStack; <span class="comment">//检查表达式中括号是否合法的栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">calculator</span><span class="params">()</span></span>&#123;</span><br><span class="line">         signStack = <span class="keyword">new</span> CharStack(<span class="number">100</span>,<span class="string">&quot;signStack&quot;</span>);</span><br><span class="line">         numStack = <span class="keyword">new</span> ArrayStack(<span class="number">100</span>,<span class="string">&quot;numStack&quot;</span>);</span><br><span class="line">         checkBracketStack = <span class="keyword">new</span> CharStack(<span class="number">100</span>,<span class="string">&quot;checkBracketStack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修改支持多位数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculator_fun</span><span class="params">(String expression)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> value;</span><br><span class="line">        <span class="keyword">boolean</span> isdigit;</span><br><span class="line">        <span class="keyword">char</span> sign;</span><br><span class="line">        <span class="keyword">int</span> num1;</span><br><span class="line">        <span class="keyword">int</span> num2;</span><br><span class="line">        <span class="keyword">int</span> result;</span><br><span class="line">        <span class="keyword">boolean</span> numbers_flag = <span class="keyword">false</span>;</span><br><span class="line">        System.out.println(expression);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.check_expression(expression))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;表达式合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;表达式不合法，请确认后再次输入！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(expression);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; expression.length(); index++) &#123;</span><br><span class="line">            value = expression.charAt(index);</span><br><span class="line">            isdigit = Character.isDigit(value); <span class="comment">//判断一个字符是不是数字</span></span><br><span class="line">            <span class="keyword">if</span>(isdigit)&#123;</span><br><span class="line">                <span class="keyword">if</span>(numbers_flag)&#123;</span><br><span class="line">                    <span class="keyword">int</span> pop = <span class="keyword">this</span>.numStack.pop();</span><br><span class="line">                    <span class="keyword">this</span>.numStack.push(pop*<span class="number">10</span> + value-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">this</span>.numStack.push(value-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                numbers_flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                numbers_flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.signStack.isEmpty())&#123;</span><br><span class="line">                    <span class="comment">//符号栈为空时，直接压栈</span></span><br><span class="line">                    <span class="keyword">this</span>.signStack.push(value);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123; <span class="comment">//符号栈中已有元素</span></span><br><span class="line">                    <span class="keyword">if</span>(Sign_priority(value)&lt;=Sign_priority(<span class="keyword">this</span>.signStack.get_top())&amp;&amp;<span class="keyword">this</span>.signStack.get_top()!=<span class="string">&#x27;(&#x27;</span>&amp;&amp;<span class="keyword">this</span>.signStack.get_top()!=<span class="string">&#x27;[&#x27;</span>&amp;&amp;<span class="keyword">this</span>.signStack.get_top()!=<span class="string">&#x27;&#123;&#x27;</span>)&#123;  <span class="comment">//遍历到的符号与栈中符号比较优先级</span></span><br><span class="line">                        <span class="comment">//先出栈符号栈一个元素，再出栈符号栈两个元素，进行运算</span></span><br><span class="line">                         sign = <span class="keyword">this</span>.signStack.pop();</span><br><span class="line">                         num1 = <span class="keyword">this</span>.numStack.pop();</span><br><span class="line">                         num2 = <span class="keyword">this</span>.numStack.pop();</span><br><span class="line">                         result = <span class="keyword">this</span>.compute(num2,num1,sign);</span><br><span class="line">                        <span class="comment">//将所得结果压入数字栈</span></span><br><span class="line">                        <span class="keyword">this</span>.numStack.push(result);</span><br><span class="line">                        <span class="comment">//将当前遍历到的符号压入符号栈</span></span><br><span class="line">                        <span class="keyword">this</span>.signStack.push(value);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123; <span class="comment">//若优先级较大，则将该符号插入符号队列 “在这里可以处理添加括号优先级”</span></span><br><span class="line">                        <span class="keyword">if</span>(value == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                            <span class="keyword">this</span>.bracket_express_compute(value);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(value == <span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                            <span class="keyword">this</span>.bracket_express_compute(value);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(value == <span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">                            <span class="keyword">this</span>.bracket_express_compute(value);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="comment">//遍历到的符号优先级大于栈中符号，则入栈</span></span><br><span class="line">                            <span class="keyword">this</span>.signStack.push(value);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当经历for循环之后，符号栈可能不止一个元素  如表达式：2+6/2</span></span><br><span class="line">        <span class="comment">//尤其注意这里还有一个★循环★</span></span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="keyword">this</span>.signStack.isEmpty())&#123;</span><br><span class="line">            sign = <span class="keyword">this</span>.signStack.pop();</span><br><span class="line">            num1 = <span class="keyword">this</span>.numStack.pop();</span><br><span class="line">            num2 = <span class="keyword">this</span>.numStack.pop();</span><br><span class="line">            result = <span class="keyword">this</span>.compute(num2,num1,sign);</span><br><span class="line">            <span class="keyword">this</span>.numStack.push(result);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;最终的结果是:&quot;</span>+ <span class="keyword">this</span>.numStack.pop());</span><br><span class="line">        <span class="comment">//System.out.println(&quot;数字栈是否为空：&quot;+this.numStack.isEmpty());</span></span><br><span class="line">        <span class="comment">//System.out.println(&quot;符号栈是否为空：&quot;+this.signStack.isEmpty());</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">Sign_priority</span><span class="params">(<span class="keyword">char</span> Sign)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> priority = -<span class="number">1</span>; <span class="comment">//数字大代表优先级大</span></span><br><span class="line">        <span class="keyword">if</span>(Sign == <span class="string">&#x27;+&#x27;</span>||Sign==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            priority = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Sign == <span class="string">&#x27;*&#x27;</span>||Sign==<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">            priority = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Sign == <span class="string">&#x27;&#123;&#x27;</span>||Sign==<span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">            priority = <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Sign == <span class="string">&#x27;[&#x27;</span>||Sign==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">            priority = <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Sign == <span class="string">&#x27;(&#x27;</span>||Sign==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            priority = <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> priority;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2, <span class="keyword">char</span> sign)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=-<span class="number">999</span>;</span><br><span class="line">        <span class="keyword">switch</span>(sign)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                result = num1+num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                result = num1-num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                result = num1*num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                result = num1/num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bracket_express_compute</span><span class="params">(<span class="keyword">char</span> sign)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> anti_sign = <span class="keyword">this</span>.get_anti_bracket(sign);</span><br><span class="line">        <span class="keyword">while</span>(anti_sign != <span class="keyword">this</span>.signStack.get_top())&#123;</span><br><span class="line">            <span class="keyword">char</span> compute_sign = <span class="keyword">this</span>.signStack.pop();</span><br><span class="line">            <span class="keyword">int</span> num1 = <span class="keyword">this</span>.numStack.pop();</span><br><span class="line">            <span class="keyword">int</span> num2 = <span class="keyword">this</span>.numStack.pop();</span><br><span class="line">            <span class="keyword">int</span> result = <span class="keyword">this</span>.compute(num2,num1,compute_sign);</span><br><span class="line">            <span class="keyword">this</span>.numStack.push(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.signStack.pop(); <span class="comment">//将符号栈顶部的值为anti_sign的符号出栈</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">char</span> <span class="title">get_anti_bracket</span><span class="params">(<span class="keyword">char</span> sign)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> anti_sign;</span><br><span class="line">        <span class="keyword">switch</span>(sign)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">                anti_sign = <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                anti_sign = <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                anti_sign = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unexpected value: &quot;</span> + sign);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> anti_sign;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check_expression</span><span class="params">(String expression)</span></span>&#123;  <span class="comment">//检查表达式的合法性，这里面可能会有很多中可能性，本次只检查括号是否对应</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; expression.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> value = expression.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(value==<span class="string">&#x27;&#123;&#x27;</span>||value==<span class="string">&#x27;[&#x27;</span>||value==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.checkBracketStack.push(value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(value==<span class="string">&#x27;&#125;&#x27;</span>||value==<span class="string">&#x27;]&#x27;</span>||value==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">char</span> anti_value = <span class="keyword">this</span>.get_anti_bracket(value);</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.checkBracketStack.get_top()==anti_value)&#123;</span><br><span class="line">                    <span class="keyword">this</span>.checkBracketStack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.checkBracketStack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>继续加油吧！！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 综合计算器的实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈—后进先出</title>
      <link href="/2021/10/05/%E6%A0%88%E2%80%94%E5%90%8E%E8%BF%9B%E5%85%88%E5%87%BA/"/>
      <url>/2021/10/05/%E6%A0%88%E2%80%94%E5%90%8E%E8%BF%9B%E5%85%88%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="栈—后进先出"><a href="#栈—后进先出" class="headerlink" title="栈—后进先出"></a>栈—后进先出</h1><p>个人觉得栈、队列、链表、数组这些线性结构不算难，也容易理解，难点还是在树和图那里，之前学过一遍，感觉现在忘得很快，慢慢来，总有一天会全部熟练的。</p><p>这里简单的给出栈的示意图，及java的实现代码（自己实现）。</p><p>示意图如下：</p><p> <img src="/articleImg/20_article/zhan.png" alt="zhan"></p><p>java实现代码(其他类型代码实现也都大同小异)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize; <span class="comment">// 栈的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] stack; <span class="comment">// 数组， 数组模拟栈， 数据就放在该数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top = -<span class="number">1</span>;<span class="comment">// top 表示栈顶， 初始化为-1</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> maxSize,String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈-push</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先判断栈是否满</span></span><br><span class="line">        <span class="keyword">if</span>(isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈满&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">///出栈-pop, 将栈顶的数据返回</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先判断栈是否空</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">    <span class="comment">//抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="keyword">this</span>.name+<span class="string">&quot;栈空， 没有数据~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示栈的情况[遍历栈]， 遍历时， 需要从栈顶开始显示数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈空， 没有数据~~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="comment">//</span></span><br><span class="line">        <span class="comment">//需要从栈顶开始显示数据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = top; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;stack[%d]=%d\n&quot;</span>, i, stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其实在java的JDK中已经给出了栈的相关API引入的过程为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;  <span class="comment">//引入stack包</span></span><br><span class="line"></span><br><span class="line">Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">stack.push(item); <span class="comment">//压栈</span></span><br><span class="line">stack.pop();<span class="comment">//出栈，栈顶指针发生变化</span></span><br><span class="line">stack.peak(); <span class="comment">//获取栈顶指针，但是，栈顶指针指向不发生变化</span></span><br></pre></td></tr></table></figure><p>这一篇就简单给出栈的实现，对应的算法题，在后面几篇给出</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表及相关题目</title>
      <link href="/2021/09/28/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
      <url>/2021/09/28/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="单链表及相关题目"><a href="#单链表及相关题目" class="headerlink" title="单链表及相关题目"></a>单链表及相关题目</h1><p>今天复习的是数据结构中的单链表，整体感觉在自己能力范围之内，感觉自己的薄弱点还是在二叉树和回溯递归那一部分。慢慢来吧，感觉自己最近的学习状态还是不错的，鼓励一下自己！下面废话不多说，对今天学习的知识进行总结：</p><h2 id="单链表结构初始化"><a href="#单链表结构初始化" class="headerlink" title="单链表结构初始化"></a>单链表结构初始化</h2><p>java中的数据结构都是写在类中，这与C语言中的结构体是对应着的知识点，下面给出单链表的结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;  <span class="comment">//这个类就相当于链表中节点的结构，也就相当于C语言中的struct   //根据这个HeroNode，就直接可以慢慢创建出链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next; <span class="comment">//指向下一个节点</span></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对该结构简单分析：其实前三个变量都是无所谓的，你可以随便定义任何信息，最重要的是<strong>HeroNode next;</strong> 这个是链表中的核心，就是因为next节点的存在，才搭建出整个单链表。</p><h2 id="单链表算法流程"><a href="#单链表算法流程" class="headerlink" title="单链表算法流程"></a>单链表算法流程</h2><p> <img src="/articleImg/17_article/linked_list.png" alt="linked_list"></p><h2 id="单链表中必备的函数"><a href="#单链表中必备的函数" class="headerlink" title="单链表中必备的函数"></a>单链表中必备的函数</h2><p>在链表操作的过程中必备的函数有：<strong>数据的有序插入</strong>、<strong>返回头部元素</strong>、<strong>显示链表</strong>、<strong>更新链表中节点的信息</strong>、<strong>删除链表中的元素</strong>、<strong>尾插</strong>、<strong>头插</strong>等，下面给出类的实现：这些所有的方法都写在SingleLinkedList这个类中，如下</p><h3 id="SingleLinkedList类"><a href="#SingleLinkedList类" class="headerlink" title="SingleLinkedList类"></a>SingleLinkedList类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HeroNode head; <span class="comment">//属性</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SingleLinkedList</span><span class="params">()</span> </span>&#123; <span class="comment">//构造方法</span></span><br><span class="line">        head = <span class="keyword">new</span> HeroNode(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回头部元素"><a href="#返回头部元素" class="headerlink" title="返回头部元素"></a>返回头部元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据的有序插入"><a href="#数据的有序插入" class="headerlink" title="数据的有序插入"></a>数据的有序插入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(HeroNode hero1)</span> </span>&#123; <span class="comment">//根据节点信息中的编号，进行数据的插入</span></span><br><span class="line">    <span class="comment">//根据节点信息中的编号，升序插入</span></span><br><span class="line">    HeroNode temp = head;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//temp = temp.next;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(temp == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.head_add(hero1);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(temp.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.next.no&gt;=hero1.no)&#123;</span><br><span class="line">            <span class="comment">//找到该元素</span></span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        hero1.next = temp.next; <span class="comment">//进行插入</span></span><br><span class="line">        temp.next = hero1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tail_add(hero1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="显示链表"><a href="#显示链表" class="headerlink" title="显示链表"></a>显示链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123; <span class="comment">//显示链表</span></span><br><span class="line">    HeroNode temp = head;</span><br><span class="line">    temp = temp.next;</span><br><span class="line">    <span class="keyword">while</span>(temp != <span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.println(temp);</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更新链表中节点的信息"><a href="#更新链表中节点的信息" class="headerlink" title="更新链表中节点的信息"></a>更新链表中节点的信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode newHeroNode)</span> </span>&#123; <span class="comment">//更新链表中节点的信息</span></span><br><span class="line">    <span class="comment">//在本次更新节点过程中，节点的编号是不能更新的，因此可以根据节点的编号去索引节点位置</span></span><br><span class="line">    HeroNode temp = head.next;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(temp.no == newHeroNode.no)&#123;</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flag)&#123; <span class="comment">//表明找到,则更新信息</span></span><br><span class="line">        temp.name = newHeroNode.name;</span><br><span class="line">        temp.nickname = newHeroNode.nickname;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="comment">//没有找到该表好下的元素，进行头插</span></span><br><span class="line">        <span class="keyword">this</span>.addByOrder(newHeroNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="头插"><a href="#头插" class="headerlink" title="头插"></a>头插</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">head_add</span><span class="params">(HeroNode hero1)</span></span>&#123; <span class="comment">//头插</span></span><br><span class="line">    HeroNode temp = head;</span><br><span class="line">    hero1.next = temp.next;</span><br><span class="line">    temp.next = hero1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关题目的实现"><a href="#相关题目的实现" class="headerlink" title="相关题目的实现"></a>相关题目的实现</h2><p>本次的几个算法题目函数都写在LinkedListExercise一个类中</p><h3 id="求单链表中的节点个数"><a href="#求单链表中的节点个数" class="headerlink" title="求单链表中的节点个数"></a>求单链表中的节点个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fun1</span><span class="params">(SingleLinkedList singleLinkedList)</span></span>&#123; <span class="comment">//求单链表中的节点个数</span></span><br><span class="line">    HeroNode head = singleLinkedList.getHead(); <span class="comment">//获取该链表的头节点</span></span><br><span class="line">    HeroNode temp = head.next;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;<span class="comment">//记录链表中的节点个数</span></span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        num++;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找链表中的倒数第K个节点"><a href="#查找链表中的倒数第K个节点" class="headerlink" title="查找链表中的倒数第K个节点"></a>查找链表中的倒数第K个节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fun1</span><span class="params">(SingleLinkedList singleLinkedList)</span></span>&#123; <span class="comment">//求单链表中的节点个数</span></span><br><span class="line">    HeroNode head = singleLinkedList.getHead(); <span class="comment">//获取该链表的头节点</span></span><br><span class="line">    HeroNode temp = head.next;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;<span class="comment">//记录链表中的节点个数</span></span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        num++;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反转一个链表，并返回"><a href="#反转一个链表，并返回" class="headerlink" title="反转一个链表，并返回"></a>反转一个链表，并返回</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//网上写的代码写的挺不错的，多学习一下别人的优秀代码，有空自己吧这个函数修改一下</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SingleLinkedList <span class="title">fun3</span><span class="params">(SingleLinkedList LinkedList)</span></span>&#123;  <span class="comment">//反转一个链表，并返回</span></span><br><span class="line">    SingleLinkedList ReversedLinkedList = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line">    HeroNode head = LinkedList.getHead();</span><br><span class="line">    HeroNode temp = head.next;</span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        ReversedLinkedList.head_add(<span class="keyword">new</span> HeroNode(temp.no,temp.name,temp.nickname));  <span class="comment">//在debug的时候，这里如果不创建新节点保存数据，就会污染原始链表，导致无法遍历</span></span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ReversedLinkedList; <span class="comment">//返回反转后的新链表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="倒序打印单链表"><a href="#倒序打印单链表" class="headerlink" title="倒序打印单链表"></a>倒序打印单链表</h3><p>方式1：利用类中的反转函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun4</span><span class="params">(SingleLinkedList Linkedlist)</span></span>&#123; <span class="comment">//倒序打印单链表, 方式一：利用类中的反转函数</span></span><br><span class="line">    SingleLinkedList ReversedSingleLinkedList = <span class="keyword">this</span>.fun3(Linkedlist);</span><br><span class="line">    <span class="comment">//逆序打印</span></span><br><span class="line">    System.out.println(<span class="string">&quot;逆序打印&quot;</span>);</span><br><span class="line">    ReversedSingleLinkedList.list();</span><br><span class="line">    <span class="comment">//打印原链表</span></span><br><span class="line">    System.out.println(<span class="string">&quot;打印原链表&quot;</span>);</span><br><span class="line">    Linkedlist.list();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式2：反向遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun5</span><span class="params">(SingleLinkedList Linkedlist)</span></span>&#123; <span class="comment">//倒序打印单链表, 方式二：反向遍历</span></span><br><span class="line"></span><br><span class="line">    HeroNode temp = Linkedlist.getHead();</span><br><span class="line">    <span class="keyword">int</span> num = <span class="keyword">this</span>.fun1(Linkedlist);</span><br><span class="line">    <span class="keyword">int</span> k = num;</span><br><span class="line">    System.out.println(<span class="string">&quot;反向遍历打印链表&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(temp);</span><br><span class="line">        k = num-i-<span class="number">1</span>; <span class="comment">//计数k重新赋值</span></span><br><span class="line">        temp = Linkedlist.getHead(); <span class="comment">//temp重新拿到链表的头指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当然倒序打印还有方式三：利用栈保存元素，因为栈是后进先出，既满足倒序打印的需求</span></span><br><span class="line">    <span class="comment">//但是我还没复习到栈，这个需求留到后面再做吧</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式三：利用栈(由于java提供了stack包，这里我也给出相应的实现)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun7</span><span class="params">(SingleLinkedList Linkedlist)</span></span>&#123; <span class="comment">//利用栈逆序打印一个链表</span></span><br><span class="line"></span><br><span class="line">    Stack&lt;HeroNode&gt; stack = <span class="keyword">new</span> Stack&lt;HeroNode&gt;();<span class="comment">//创建一个栈</span></span><br><span class="line">    HeroNode head = Linkedlist.getHead();</span><br><span class="line">    HeroNode temp = head.next;</span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(temp);</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;开始出栈并逆序打印&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(!stack.empty())&#123;</span><br><span class="line">        HeroNode pop = stack.pop();</span><br><span class="line">        System.out.println(pop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两个有序链表进行有序合并"><a href="#两个有序链表进行有序合并" class="headerlink" title="两个有序链表进行有序合并"></a>两个有序链表进行有序合并</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SingleLinkedList <span class="title">fun6</span><span class="params">(SingleLinkedList Linkedlist1,SingleLinkedList Linkedlist2)</span></span>&#123;</span><br><span class="line">    <span class="comment">//这里合并两个有序链表，我个人觉得比较简单，直接调用addByOrder函即可</span></span><br><span class="line">    SingleLinkedList CombineSortedLinkedlist = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line">    HeroNode temp1 = Linkedlist1.getHead();</span><br><span class="line">    HeroNode temp2 = Linkedlist2.getHead();</span><br><span class="line">    <span class="keyword">while</span>(temp1.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//这里仍然需要创建新的HeroNode节点，去保存temp1.next节点中的信息，并被插入到CombineSortedLinkedlist中去</span></span><br><span class="line">        CombineSortedLinkedlist.addByOrder(<span class="keyword">new</span> HeroNode(temp1.next.no,temp1.next.name,temp1.next.nickname));</span><br><span class="line">        temp1 = temp1.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(temp2.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//这里仍然需要创建新的HeroNode节点，去保存temp1.next节点中的信息，并被插入到CombineSortedLinkedlist中去</span></span><br><span class="line">        CombineSortedLinkedlist.addByOrder(<span class="keyword">new</span> HeroNode(temp2.next.no,temp2.next.name,temp2.next.nickname));</span><br><span class="line">        temp2 = temp2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//合并后的新链表</span></span><br><span class="line">    System.out.println(<span class="string">&quot;合并后的新链表&quot;</span>);</span><br><span class="line">    CombineSortedLinkedlist.list();</span><br><span class="line">    <span class="keyword">return</span>  CombineSortedLinkedlist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结束语：继续加油~ fighting，希望自己能够坚持住！</p><ul><li>补充：单链表如果想删除元素的话，必须通过遍历的到被删除元素的前一个元素，在遍历的过程中用本片博客图片1中左边的遍历方式。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多个对象引用</title>
      <link href="/2021/09/26/%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8/"/>
      <url>/2021/09/26/%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="java中多个对象引用"><a href="#java中多个对象引用" class="headerlink" title="java中多个对象引用"></a>java中多个对象引用</h1><p>在堆中new出一个对象之后，对应栈中可以有多个地址指向该对象，也就是多个对象引用。</p><p>这些对象引用在调用对象方法时，实际上始终都是在调用堆中那个对象的方法。</p><p><strong>换个简单点的说法也就是，你这个对象可以有很多名字，但是最终不管通过哪一个名字来操作，影响的始终都是那一个对象！</strong></p><p>插个图吧：</p><p> <img src="/articleImg/16_article/object_reference.png" alt="object_reference"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多个对象引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>循环队列</title>
      <link href="/2021/09/25/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/"/>
      <url>/2021/09/25/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h1><h2 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h2><p>由于循环队列是普通队列的升级版本，使用效率更高，如果可以实现循环队列的话，那你实现普通队列应该也就没什么问题。</p><p>本次实现是用数组模拟队列，当然使用链队也是可以的。</p><p>下面简单的对循环队列做出简要说明，以备后期复习使用：</p><ul><li>因为队列的输出、 输入是分别从前后端来处理， 因此需要两个变量 front 及 rear 分别记录队列前后端的下标，front 会随着数据输出而改变， 而 rear 则是随着数据输入而改变， 如图所示  </li></ul><p> <img src="/articleImg/15_article/queue.png" alt="queue"></p><ul><li>循环队列中的元素个数，可以直接公式给出，当然 可以通过头尾节点的位置，通过遍历整个队列，也可得到队列中元素的个数。下面给出推导过程</li></ul><p><img src="/articleImg/15_article/count_num.png" alt="count_num"></p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p> <img src="/articleImg/15_article/process.png" alt="process"></p><h2 id="附上本次java代码"><a href="#附上本次java代码" class="headerlink" title="附上本次java代码"></a>附上本次java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircularArrayQueue</span></span>&#123;  <span class="comment">//这里实现循环队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize; <span class="comment">// 表示数组的最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front; <span class="comment">// 队列头</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear; <span class="comment">// 队列尾(********切记*************该循环队列中rear指示的是队列尾部的&quot;下一个空位置&quot;)</span></span><br><span class="line">    <span class="comment">//(也就是说rear对应的位置上没有元素的储存)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr; <span class="comment">// 该数据用于存放数据, 模拟队列</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircularArrayQueue</span><span class="params">(<span class="keyword">int</span> maxSize)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 队列头</span></span><br><span class="line">        front = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 队列尾</span></span><br><span class="line">        rear = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 该数据用于存放数据, 模拟队列</span></span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isfull</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = (rear+maxSize-front)%maxSize; <span class="comment">//在数组中队列中的元素可以通过该公式直接算出</span></span><br><span class="line">        <span class="comment">//博客中会解释该公式的由来</span></span><br><span class="line">        <span class="comment">//当然 可以通过头尾节点的位置，通过遍历整个队列，也可得到队列中元素的个数</span></span><br><span class="line">        <span class="keyword">return</span> num == maxSize-<span class="number">1</span>;  <span class="comment">//切记这里返回的是maxSize-1，因为rear位置上并没有储存数据</span></span><br><span class="line">        <span class="comment">//所以该队列的使用率为 maxSize-1</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isempty</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rear==front; <span class="comment">//当头尾标号相等时，队列为空，返回真</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isfull())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;该队列元素已满&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[rear] = value;</span><br><span class="line">        rear = (rear+<span class="number">1</span>)%maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span> </span>&#123; <span class="comment">//获取队头元素，队列是属于先进先出，取队头</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isempty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;该队列已空，无法取出数据&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[front];</span><br><span class="line">        front = (front+<span class="number">1</span>)%maxSize;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span> </span>&#123; <span class="comment">//查看队头元素，不用出队</span></span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> copy_front = front;  <span class="comment">//这里不可以直接使用front，否则毁坏队列</span></span><br><span class="line">        <span class="keyword">if</span>(isempty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列中无元素&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;开始打印该队列：队头-&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(copy_front != rear) &#123;</span><br><span class="line">            System.out.print(arr[copy_front]);</span><br><span class="line">            System.out.print(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            copy_front = (copy_front+<span class="number">1</span>)%maxSize;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;队尾&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用链队在思想上也是一样的，继续加油~</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 循环队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>稀疏矩阵</title>
      <link href="/2021/09/24/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5/"/>
      <url>/2021/09/24/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h1><p>从今天开始简单记录一下自己用java写一些数据结构的过程吧，之前用C语言学习数据结构的时候，没有用心去记录，导致自己遗忘的很快，很是后悔。这次好好学，好好记~</p><p>由于稀疏矩阵较为简单，这里插入算法流图，并附上代码，以备后期复习用。</p><p> <img src="/articleImg/14_article/img1.png" alt="img1"></p><p>代码如下，代码中也有相关的注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhanglei;</span><br><span class="line"><span class="keyword">import</span> jdk.nashorn.api.scripting.ScriptObjectMirror;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//压缩后的矩阵第一行三个数的含义分别是  ： 原始数组的长度、原始数组的宽度、原始数组中非零数字的个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseMatrix</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] chessarray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        SparseMatrix sparseMatrix = <span class="keyword">new</span> SparseMatrix();</span><br><span class="line">        <span class="keyword">int</span>[][] compression = sparseMatrix.Compression();</span><br><span class="line">        sparseMatrix.recover();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] Compression()&#123;  <span class="comment">//压缩矩阵</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//记录有多少非0值</span></span><br><span class="line">        <span class="keyword">int</span> row_length=<span class="number">0</span>;<span class="comment">//chessarray长度</span></span><br><span class="line">        <span class="keyword">int</span> column_width=<span class="number">0</span>;<span class="comment">//chessarray宽度</span></span><br><span class="line">        <span class="comment">//初始化随便赋值几个非零值</span></span><br><span class="line">        chessarray[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        chessarray[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//打印该原始矩阵</span></span><br><span class="line">        System.out.println(<span class="string">&quot;原矩阵打印&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] rows : chessarray) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> temp : rows) &#123;</span><br><span class="line">                <span class="keyword">if</span>(rows==chessarray[<span class="number">0</span>])</span><br><span class="line">                    row_length++;</span><br><span class="line">                <span class="keyword">if</span>(temp!=<span class="number">0</span>)</span><br><span class="line">                    count++;</span><br><span class="line">                System.out.print(temp+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            column_width++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(row_length);</span></span><br><span class="line">        <span class="comment">//System.out.println(column_width);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始进行压缩矩阵的数据存储  （稀疏矩阵的核心就在这里吧）</span></span><br><span class="line">        <span class="keyword">int</span> [][]Compression_matrix = <span class="keyword">new</span> <span class="keyword">int</span>[count+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        Compression_matrix[<span class="number">0</span>][<span class="number">0</span>] = row_length;</span><br><span class="line">        Compression_matrix[<span class="number">0</span>][<span class="number">1</span>] = column_width;</span><br><span class="line">        Compression_matrix[<span class="number">0</span>][<span class="number">2</span>] = count;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(chessarray[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    Compression_matrix[index][<span class="number">0</span>] = i;</span><br><span class="line">                    Compression_matrix[index][<span class="number">1</span>] = j;</span><br><span class="line">                    Compression_matrix[index][<span class="number">2</span>] = chessarray[i][j];</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;压缩矩阵打印&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] compression_matrix : Compression_matrix) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> compressionMatrix : compression_matrix) &#123;</span><br><span class="line">                System.out.print(compressionMatrix+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将压缩后的矩阵存储到data文件中</span></span><br><span class="line">        BufferedWriter out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            out = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;F:\\Algorithm\\java\\稀疏矩阵\\matrix.data&quot;</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : Compression_matrix) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                    out.write(anInt+<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                out.newLine();</span><br><span class="line">            &#125;</span><br><span class="line">            out.flush();</span><br><span class="line">            out.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Compression_matrix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recover</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;  <span class="comment">//还原矩阵</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//从data文件中取出相关数据</span></span><br><span class="line">        BufferedReader in;</span><br><span class="line">        in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;F:\\Algorithm\\java\\稀疏矩阵\\matrix.data&quot;</span>));</span><br><span class="line">        String line = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> rows = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cols = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//读取第一行的值,获得原始数组几行几列，几个有效值</span></span><br><span class="line">        line = in.readLine();</span><br><span class="line">        String[] strings = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        rows = Integer.parseInt(strings[<span class="number">0</span>]);</span><br><span class="line">        cols = Integer.parseInt(strings[<span class="number">1</span>]);</span><br><span class="line">        sum = Integer.parseInt(strings[<span class="number">2</span>]);</span><br><span class="line">        <span class="comment">//初始化原始数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] ori = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((line = in.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            start++;</span><br><span class="line">            <span class="keyword">if</span>(start&lt;=sum)&#123; <span class="comment">//判断非零数字是否读取完毕</span></span><br><span class="line">                String[] split = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                ori[Integer.parseInt(split[<span class="number">0</span>])][Integer.parseInt(split[<span class="number">1</span>])] = Integer.parseInt(split[<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印还原后的矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : ori) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.print(anInt+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>后续加油！！！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 稀疏矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器中的三个域对象</title>
      <link href="/2021/09/23/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E7%9A%84%E4%B8%89%E4%B8%AA%E5%9F%9F%E5%AF%B9%E8%B1%A1/"/>
      <url>/2021/09/23/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E7%9A%84%E4%B8%89%E4%B8%AA%E5%9F%9F%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="tomcat中的三个域对象"><a href="#tomcat中的三个域对象" class="headerlink" title="tomcat中的三个域对象"></a>tomcat中的三个域对象</h1><table><thead><tr><th>域对象</th><th align="left">创建</th><th>销毁</th><th>作用范围</th><th>应用场景</th></tr></thead><tbody><tr><td>ServletContext</td><td align="left">服务器启动（每个服务器只有一个）</td><td>服务器正常关闭/项目从服务器移除</td><td>整个项目</td><td>记录网站访问次数,聊天室</td></tr><tr><td>HttpSession</td><td align="left">没有JSESSIONID这个cookie的时候，调 用request.getSession()方法（每个浏览器一个）</td><td>session过期（默认闲置30分钟），或者调用session对象的invalidate(）方法，或者服务器<strong>异常</strong>关闭</td><td>会话(多次请求)</td><td>验证码校验, <strong>保存用户登录状态</strong>等</td></tr><tr><td>HttpServletRequest</td><td align="left">来了请求（每次请求一个）</td><td>响应这个请求(或者请求已经接收了)</td><td>一次请求</td><td>servletA和jsp（servletB）之间数据传递(转发的时候存数据)</td></tr></tbody></table><h2 id="三个域对象如何选择"><a href="#三个域对象如何选择" class="headerlink" title="三个域对象如何选择"></a>三个域对象如何选择</h2><p>​    一般情况下, 最小的可以解决就用最小的.</p><p>​    但是需要根据情况(eg: 重定向, 多次请求, 会话范围, 用session;  如果是转发,一般选择request)</p><h2 id="ServletContext相关API"><a href="#ServletContext相关API" class="headerlink" title="ServletContext相关API"></a>ServletContext相关API</h2><ul><li>获取ServletContext对象                              ServletContext servletContext = getServletContext();</li><li>往容器ServletContext中存值                      servletContext.setAttribute(“name”,name);</li><li>从容器ServletContext中获取数据               String name = (String) servletContext.getAttribute(“name”);</li><li>获得文件mime-type                                     String mimeType01 = getServletContext().getMimeType(file01);</li><li>获得全局初始化参数                                     String getInitParameter(String name) ; //根据配置文件中的key得到value; </li><li>获取Web资源路径                                        String  getRealPath(String path);根据资源名称得到资源的绝对路径.</li><li>获取Web资源路径                                        getResourceAsStream(String path) ;返回制定路径文件的流</li></ul><h2 id="HttpSession相关API"><a href="#HttpSession相关API" class="headerlink" title="HttpSession相关API"></a>HttpSession相关API</h2><p>session是服务器端的技术, 数据保存在服务器端的</p><ul><li>获取session      requet.getSession()  只有在服务器端调用了该API，才有session产生</li><li>session基于cookie的<ul><li>创建session的同时 生成sessionId, 服务器自动通过Cookie的方式写给浏览器, 浏览器自己保存</li><li>下次的话 浏览器携带cookie(SessionId)找到对应的session使用了</li></ul></li><li>Object getAttribute(String name) ;获取值</li><li>void setAttribute(String name, Object value) ;存储值</li><li>void removeAttribute(String name)  ;移除</li></ul><h2 id="HttpServletRequest-相关知识"><a href="#HttpServletRequest-相关知识" class="headerlink" title="HttpServletRequest 相关知识"></a>HttpServletRequest 相关知识</h2><h3 id="request作用"><a href="#request作用" class="headerlink" title="request作用"></a>request作用</h3><ul><li><strong>操作请求三部分(行,头,体)</strong><ul><li>获取请求行的信息<ul><li>获取请求方式:getMethod() </li><li>获取请求的客户端的ip地址:getRemoteAddr()</li><li>获取项目部署的路径:getContextPath() </li><li>获取uri:统一资源标识符</li></ul></li><li>获取请求头的信息:getHeader(name)</li><li>获取请求参数（全部要掌握，最重要）<ul><li>getParameter(name)</li><li>getParameterValues(name)</li><li>getParameterMap()</li></ul></li><li>使用BeanUtils将map中的数据存储到JavaBean对象中（需要引入相关jar包）<ul><li>map的key要和JavaBean的属性名保持一致，如果不一致那么该字段的值就无法存储</li><li>BeanUtils中默认内置一些基本类型的转换器（如果map中的数据是string类型，JavaBean的属性还是int类型那么会自动转换）</li></ul></li></ul></li></ul><ul><li><strong>请求转发</strong>：request.getRequestDispatcher(“转发的路径”).forward(request,response); <ul><li>跳转操作是由服务器执行的，所以客户端地址栏不会发生变化</li><li>跳转操作不会发起新的请求</li><li>可以跳转到WEB-INF中的资源，但是不能跳转到其它项目的资源</li></ul></li></ul><ul><li><strong>作为”域对象“存数据</strong>  （一般会与请求转发一起使用）<ul><li>Object getAttribute(String name) ;  取</li><li>void setAttribute(String name,Object object)  ; 存</li><li>void removeAttribute(String name)  ; 移除</li></ul></li></ul><h3 id="response相关作用"><a href="#response相关作用" class="headerlink" title="response相关作用"></a>response相关作用</h3><ul><li>设置响应状态码:setStatus()</li><li>设置响应头:setHeader(name,value)<ul><li>refresh响应头，用于隔几秒钟之后跳转到某个页面</li><li>location响应头，用于重定向到某个页面</li></ul></li><li><strong>重定向</strong>的写法: sendRedirect(地址)</li><li>设置响应体的内容<ul><li>使用字符输出流输出文本内容<ul><li>response.getWriter()获取字符输出流</li><li>writer.write()/print()输出字符串</li><li>解决响应数据的中文乱码:response.setContentType(“text/html;charset=UTF-8”)</li></ul></li><li>使用字节输出流输出文件<ul><li>response.getOutputStream()获取字节输出流</li></ul></li></ul></li><li>使用IO流的框架进行边读边写</li></ul><h3 id="request中的请求转发与response中的重定向的区别"><a href="#request中的请求转发与response中的重定向的区别" class="headerlink" title="request中的请求转发与response中的重定向的区别"></a>request中的请求转发与response中的重定向的区别</h3><ul><li><strong>重定向特点</strong><ol><li>重定向的跳转是由浏览器发起的，在这个过程中浏览器会发起两次请求</li><li>定向跳转可以跳转到任意服务</li><li>无法跳转到WEB-INF中的资源，浏览器访问不到的，重定向也访问不到</li><li>重定向跳转不能和request域对象一起使用</li><li>重定向跳转浏览器的地址栏中的地址会变成跳转到的路径</li></ol></li><li><strong>请求转发特点</strong><ol><li>请求转发的跳转是由服务器发起的，在这个过程中浏览器只会发起一次请求</li><li>请求转发只能跳转到本项目的资源，但是可以跳转到WEB-INF中的资源</li><li>请求转发可以和request域对象一起使用</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器域对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java栈、堆、方法区</title>
      <link href="/2021/09/17/java%E6%A0%88%E3%80%81%E5%A0%86%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA/"/>
      <url>/2021/09/17/java%E6%A0%88%E3%80%81%E5%A0%86%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="java-堆、栈、方法区"><a href="#java-堆、栈、方法区" class="headerlink" title="java 堆、栈、方法区"></a>java 堆、栈、方法区</h1><h2 id="三个区的不同之处"><a href="#三个区的不同之处" class="headerlink" title="三个区的不同之处"></a>三个区的不同之处</h2><ul><li><h3 id="堆区"><a href="#堆区" class="headerlink" title="堆区:"></a>堆区:</h3><p>1.<strong>存储的全部是对象</strong>，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令)<br>2.jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，<strong>只存放对象本身</strong> 。</p></li><li><h3 id="栈区"><a href="#栈区" class="headerlink" title="栈区:"></a>栈区:</h3><p>1.每个线程包含一个栈区，栈中只保存<strong>基础数据类型的值</strong>和<strong>对象引用以及基础数据的引用</strong><br>2.每个栈中的数据(基础数据类型和对象引用)都是私有的，其他栈不能访问。<br>3.栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。 </p></li><li><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区:"></a>方法区:</h3><p>1.又叫静态区，跟堆一样，被所有的线程共享。<strong>方法区包含所有的class和static变量</strong>。<br>2.方法区中<strong>包含的都是在整个程序中永远唯一的元素</strong>，如class，static变量。 </p></li></ul><p> <img src="/articleImg/11_article/img1.png" alt="img1"></p><h3 id="什么是栈区的对象引用"><a href="#什么是栈区的对象引用" class="headerlink" title="什么是栈区的对象引用"></a>什么是栈区的对象引用</h3><p><strong>对象</strong>，就是类的一个实例化，把一个抽象不好理解的类举出一个实体来，例如人类是一个类，会吃喝拉撒，实例化出一个小明这个具体的人。 对象引用，就是得给这个人取个名字来指代他，跟c++的指针一样，指向这个人，可以给他一个名字王小明，王小明就是<strong>对象引用</strong>。我们想到这个人的时候就会用王小明去代替他，例如 王小明今天吃了什么，王小明多高，多重，是这个人的属性，用编程语言就是 print（王小明.身高）<br>那么在内存上有什么区别呢，当我 用人这个类实例化出王小明时，电脑是这样识别的 （人 王小明），王小明=new 人（185，60），先给出一个对象引用，此时王小明这个代号可以指向任何人，你也可以叫王小明，他也可以，然后我实例化出一个人，我把王小明这个代号指向了这个人，这个人的内存是在堆内存里的，而王小明这个对象引用是在栈内存里的</p><p>说白了对象引用就是实例对象的名字！</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆栈方法区 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java之对象之间的强制类型转换</title>
      <link href="/2021/09/17/java%E4%B9%8B%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/2021/09/17/java%E4%B9%8B%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="java之对象之间的强制类型转换"><a href="#java之对象之间的强制类型转换" class="headerlink" title="java之对象之间的强制类型转换"></a>java之对象之间的强制类型转换</h1><p>先定义一个父类，一个子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">father</span></span>&#123;  <span class="comment">//父类</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">son</span> <span class="keyword">extends</span> <span class="title">father</span></span>&#123;   <span class="comment">//子类</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>子类对象可以声明为父类类型，父类对象不可以声明为子类类型<br/></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test a=<span class="keyword">new</span> TestExtend();   <span class="comment">//正确</span></span><br><span class="line">TestExtend b=<span class="keyword">new</span> Test();   <span class="comment">//错误</span></span><br></pre></td></tr></table></figure></li><li><p>在子类对象声明为父类类型后，可以通过强制转型，转型回来<br/></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test a=<span class="keyword">new</span> TestExtend();</span><br><span class="line">TestExtend a=(TestExtend) b;         <span class="comment">//正确</span></span><br></pre></td></tr></table></figure></li><li><p>而父类对象声明为父类类型之后，并不能执行强制类型转化<br/></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test a=<span class="keyword">new</span> Test();</span><br><span class="line">TestExtend a=(TestExtend) a;                  <span class="comment">//错误</span></span><br></pre></td></tr></table></figure></li></ul><p>总结：因为在子类对象声明为父类类型后，其实对象的真实意义还是子类对象</p><p>转自 CSDN博主：LookUpMan</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强制类型转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中初始化块和静态初始化块的区别</title>
      <link href="/2021/09/15/Java%E4%B8%AD%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97%E5%92%8C%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2021/09/15/Java%E4%B8%AD%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97%E5%92%8C%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="Java中初始化块和静态初始化块的区别"><a href="#Java中初始化块和静态初始化块的区别" class="headerlink" title="Java中初始化块和静态初始化块的区别"></a>Java中初始化块和静态初始化块的区别</h1><h2 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h2><p>在Java中,有两种初始化块:<strong>静态初始化块</strong>和<strong>非静态初始化块</strong>.</p><ul><li><p><strong>静态初始化块</strong>:使用static定义,当类装载到系统时执行一次.若在静态初始化块中想初始化变量,那仅能初始化类变量,即static修饰的数据成员.</p></li><li><p><strong>非静态初始化块</strong>:在每个对象生成时都会被执行一次,可以初始化类的实例变量.</p><p>非静态初始化块会在构造函数执行时,且在构造函数主体代码执行之前被运行.</p><p>括号里的是初始化块(非静态初始化块)，这里面的代码在创建java对象时执行，而且在构造器之前执行！</p><p>其实初始化块就是构造器的补充，<strong>初始化块是不能接收任何参数的</strong>，定义的一些<strong>所有对象共有的属性、方法等内容时就可以用初始化块了初始化</strong>！！</p></li></ul><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>下面给出卷一中的示例代码<br/></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates object construction,</span></span><br><span class="line"><span class="comment"> * Aversion 1.01 2004-02-19</span></span><br><span class="line"><span class="comment"> * ©author Cay Horstmann</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorTest</span></span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">        <span class="comment">// fill the staff array with three Employee objects</span></span><br><span class="line">        Employee[] staff = <span class="keyword">new</span> Employee[<span class="number">3</span>]:</span><br><span class="line">        staff[<span class="number">0</span>] = <span class="keyword">new</span> Employee(<span class="string">&quot;Harry&quot;</span>, <span class="number">40000</span>);</span><br><span class="line">        staff[<span class="number">1</span>] = <span class="keyword">new</span> Employee(<span class="number">60000</span>);</span><br><span class="line">        staff[<span class="number">2</span>] = <span class="keyword">new</span> Employee();</span><br><span class="line">        <span class="comment">// print out information about all Employee objects</span></span><br><span class="line">        <span class="keyword">for</span> (Employee e : staff)</span><br><span class="line">        System,out.println(<span class="string">&quot;name=&quot;</span> + e.getNameO + <span class="string">&quot;,id=&quot;</span> + e.getldO + <span class="string">&quot;,salary:&quot;</span></span><br><span class="line">        + e.getSalary());</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextld;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">     <span class="keyword">private</span> String name = <span class="comment">// instance field initialization</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// static initialization block  </span></span><br><span class="line">     <span class="comment">//该类一被加载，就会执行该静态代码块，且只在加载类时执行一次</span></span><br><span class="line">      <span class="keyword">static</span></span><br><span class="line">      &#123;</span><br><span class="line">       Random generator = <span class="keyword">new</span> Random();</span><br><span class="line">       <span class="comment">// set nextld to a random number between 0 and 9999</span></span><br><span class="line">       nextld = generator.nextlnt(<span class="number">10000</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// object initialization block</span></span><br><span class="line">    <span class="comment">//初始代码块，在每次创造对象时，就会优于构造函数一步，执行</span></span><br><span class="line">        &#123;</span><br><span class="line">        id = nextld;</span><br><span class="line">        nextld++;</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="comment">// three overloaded constructors</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String n, <span class="keyword">double</span> s)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">     name = n;</span><br><span class="line">     salary = s;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">double</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// calls the Employee(String, double) constructor</span></span><br><span class="line">      ★★★  <span class="keyword">this</span>(<span class="string">&quot;Employee #&quot;</span> + nextld, s);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">        <span class="comment">// name initialized to &quot;&quot; see above</span></span><br><span class="line">        <span class="comment">// salary not explicitly set initialized to 0</span></span><br><span class="line">        <span class="comment">// id initialized in initialization block    </span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSalary</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getld</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对this顺便记录下"><a href="#对this顺便记录下" class="headerlink" title="对this顺便记录下"></a>对this顺便记录下</h2><p>在上述的代码中★★★处有个this，我对this的第二个功能理解的不太好，就是在构造函数中调用其他构造函数，这里简要也记录一下this<br/></p><ul><li><p>this作为隐式参数，也就是被构造的对象，我们以this.实例域的方式来访问实例域。<br/></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name,<span class="keyword">double</span> salary)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name=name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.salary=salary;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>this的另一个作用是调用自己同一个类的其他构造器，形式为this(…)<br/></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">double</span> s)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//调用Employee(String,double)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>(<span class="string">&quot;Employe#&quot;</span>+nextId,s);</span><br><span class="line"></span><br><span class="line">nextId++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当我们调用new Employee(6000）的时候，Employee（double）构造器将调用Employee(String,double)构造器。</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 初始化块和静态初始化块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法参数:Java中如何交换两个对象</title>
      <link href="/2021/09/09/%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0-Java%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1/"/>
      <url>/2021/09/09/%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0-Java%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="方法参数：Java中如何交换两个对象"><a href="#方法参数：Java中如何交换两个对象" class="headerlink" title="方法参数：Java中如何交换两个对象"></a>方法参数：Java中如何交换两个对象</h1><h2 id="方法参数传递的几种形式"><a href="#方法参数传递的几种形式" class="headerlink" title="方法参数传递的几种形式"></a>方法参数传递的几种形式</h2><p>java中只有值传递，基本类型传递的是值的副本，引用类型传递的是引用的副本。</p><p>在核心卷一中一共有三种情况，</p><ol><li><p>基本数据类型作为方法参数<br/></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> percent = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tripieValue</span><span class="params">(<span class="keyword">double</span> x)</span> <span class="comment">// doesn&#x27;t work</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x = <span class="number">3</span> * x;</span><br><span class="line">&#125;</span><br><span class="line">然后调用这个方法：</span><br><span class="line"><span class="keyword">double</span> percent = <span class="number">10</span>;</span><br><span class="line">tripieValue(percent);</span><br><span class="line"></span><br><span class="line">在方法调用之后， percent 的值还是 <span class="number">10</span>。</span><br></pre></td></tr></table></figure><p>对于基本数据类型总结来说就是：一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）  </p></li><li><p>对象作为方法参数<br/></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> tri pi eSal <span class="title">ary</span><span class="params">(Employee x)</span> <span class="comment">// works</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x.raiseSa1ary(<span class="number">200</span>) ;</span><br><span class="line">&#125;</span><br><span class="line">当调用</span><br><span class="line">harry = <span class="keyword">new</span> Employee(. . .) ;</span><br><span class="line">tripieValue(harry) ; <span class="comment">// 注意这里是传入的对象，对该对象进行了浅拷贝</span></span><br><span class="line"><span class="comment">// 最后 方法结束后，参数变量 x 不再使用。当然，对象变量 harry 继续引用那个薪金增至3倍的雇员对象</span></span><br></pre></td></tr></table></figure><p>对于这一点也就是说：一个方法可以改变一个对象参数的状态  </p></li><li><p>如果要交换两个对象，在Java方法中是行不通的，虽然做了浅拷贝，但改变副本的地址，对原本的实参没有影响。<br/>若想解决该问题，达到对象互换的效果，就应该借助第2点的思想“一个方法可以改变一个对象参数的状态”<br/>利用封装类的思想，把对象当作另一个类的成员变量。<br/></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Java program to demonstrate that we can use wrapper</span></span><br><span class="line"><span class="comment">// classes to swap to objects</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A car with model and no.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> model, no;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructor</span></span><br><span class="line">    Car(<span class="keyword">int</span> model, <span class="keyword">int</span> no)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.model = model;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Utility method to print object details</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;no = &quot;</span> + no + </span><br><span class="line">                           <span class="string">&quot;, model = &quot;</span> + model);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A Wrapper over class that is used for swapping</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarWrapper</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   Car c;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Constructor</span></span><br><span class="line">   CarWrapper(Car c)   &#123;<span class="keyword">this</span>.c = c;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A Class that use Car and swaps objects of Car</span></span><br><span class="line"><span class="comment">// using CarWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// This method swaps car objects in wrappers</span></span><br><span class="line">    <span class="comment">// cw1 and cw2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(CarWrapper cw1, </span></span></span><br><span class="line"><span class="params"><span class="function">                            CarWrapper cw2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Car temp = cw1.c;</span><br><span class="line">        cw1.c = cw2.c;</span><br><span class="line">        cw2.c = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Driver method</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Car c1 = <span class="keyword">new</span> Car(<span class="number">101</span>, <span class="number">1</span>);</span><br><span class="line">        Car c2 = <span class="keyword">new</span> Car(<span class="number">202</span>, <span class="number">2</span>);</span><br><span class="line">        CarWrapper cw1 = <span class="keyword">new</span> CarWrapper(c1);</span><br><span class="line">        CarWrapper cw2 = <span class="keyword">new</span> CarWrapper(c2);</span><br><span class="line">        swap(cw1, cw2);</span><br><span class="line">        cw1.c.print();</span><br><span class="line">        cw2.c.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">no = <span class="number">2</span>, model = <span class="number">202</span></span><br><span class="line">no = <span class="number">1</span>, model = <span class="number">101</span></span><br></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>Java中只有值传递，基本类型传递的是值的副本，引用类型传递的是引用的副本。</p><p>所以如果用户类不能访问到被交换的类的成员的时候，封装类可以解决这个问题。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法参数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通配符和正则表达式</title>
      <link href="/2021/09/09/%E9%80%9A%E9%85%8D%E7%AC%A6%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2021/09/09/%E9%80%9A%E9%85%8D%E7%AC%A6%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="通配符和正则表达式"><a href="#通配符和正则表达式" class="headerlink" title="通配符和正则表达式"></a>通配符和正则表达式</h1><p>今晚学了一会linux，记录一下吧，我觉得这个知识点是不是的就会出现，比如爬虫解析网页时也会需要到~</p><h2 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h2><ol><li>通配符代表的是bash的一个功能。一般只用于文件名匹配，它是由shell解析的，比如find，ls，cp，mv等。</li><li>正则表达式是一种字符串处理的方式。针对文件内容的文本过滤工具里，大都用到正则表达式，如vi，grep，awk，sed等</li><li>可以简单的理解为通配符只有*,?,[],{}这4种，而正则表达式复杂多了</li><li>在通配符中*可以匹配任意的0个或多个字符，而在正则表达式中他是重复之前的一个或者多个字符，不能独立使用的</li></ol><p>下面对这两个东西进行简要的记录。</p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="常用标识"><a href="#常用标识" class="headerlink" title="常用标识"></a>常用标识</h3><table><thead><tr><th>符号”.”</th><th>符号”*”</th><th>符号”[]”，总之就是取其中的一个</th></tr></thead><tbody><tr><td>匹配任意一个字符，除了换行符。类似shell通配符中的”?”，匹配一个任意字符。</td><td>“ * “表示前边字符有0个或多个。”.*”表示任意一个字符有0个或多个，也就是能匹配任意的字符。类似shell通配符中的”  * “，可以匹配任意字符。</td><td>“[ ]”中括号中可以包含表示字符集的表达式。使用方法大概有如下几种。<br/>[a-z]：表示a-z字符中的一个，也就是小写字母。<br/>[0-9]：表示0-9字符中的一个，也就是表示数字。<br/>[A-Z]：表示大写字母。<br/>[a-zA-Z]：表示字符集为小写字母或者大写字母。<br/>[a-zA-Z0-9]：表示普通字符，包括大小写字母和数字。<br/>[abc]：表示字符a或者字符b或者字符c。<br/>[ ^ 0-9 ]：表示非数字类型的字符，^表示取反意思，只能放在中括号的开始处才有意义。</td></tr></tbody></table><h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><table><thead><tr><th>字符</th><th align="center">含义</th></tr></thead><tbody><tr><td>^</td><td align="center">指向一行的开头<br/>这里要注意^符号需要放到 ^[]外面，才会代表行首的意思，否者放在里面，就表示取反了</td></tr><tr><td>$</td><td align="center">指向一行的结尾</td></tr><tr><td>.</td><td align="center">任意单个字符</td></tr><tr><td>\</td><td align="center">表示是转义字符</td></tr><tr><td>{}</td><td align="center">表示前边字符的数量范围，但是必须注意要加上转义字符” \ “<br/>eg:{2,9}：表示前边字符的重复次数大于2但小于9</td></tr></tbody></table><h3 id="拓展正则表达式"><a href="#拓展正则表达式" class="headerlink" title="拓展正则表达式"></a>拓展正则表达式</h3><p>扩展正则表达式是在基本正则表达式中扩展出来的，频率上可能没有基本正则表达式那么高</p><table><thead><tr><th>字符</th><th align="center">含义</th></tr></thead><tbody><tr><td>？</td><td align="center">表示前置字符有0个或1个</td></tr><tr><td>+</td><td align="center">表示前置字符有1个或多个</td></tr><tr><td>|</td><td align="center">表示指明两项之间的一个选择。<br/>abc|ABC：表示可以匹配abc或者ABC<br/>（需要注意在bash中他还表示管道，即上一条命令的输出作为下一条命令的参数）</td></tr><tr><td>()</td><td align="center">表示分组<br/> (a|b)b：表示可以匹配ab或者bb字串<br/>([0-9]) | ( [ 0 ] [0 - 9]):表示匹配0-9或者00-09</td></tr></tbody></table><p>特殊匹配模式</p><table><thead><tr><th>匹配模式</th><th>含义</th></tr></thead><tbody><tr><td>[:alnum:]</td><td>字母与数字字符,如grep[[:alnum:]] words.txt</td></tr><tr><td>[:alpha:]</td><td>字母</td></tr><tr><td>[:ascii:]</td><td>ASCII字符</td></tr><tr><td>[:blank:]</td><td>空格或制表符</td></tr><tr><td>[:cntrl:]</td><td>ASCII控制字符</td></tr><tr><td>[:digit:]</td><td>数字</td></tr><tr><td>[:graph:]</td><td>非控制、非空格字符</td></tr><tr><td>[:lower:]</td><td>小写字母</td></tr><tr><td>[:print:]</td><td>可打印字符</td></tr><tr><td>[:punct:]</td><td>标点符号字符</td></tr><tr><td>[:space:]</td><td>空白字符，包括垂直制表符</td></tr><tr><td>[:upper:]</td><td>大写字母</td></tr><tr><td>[:xdigit:]</td><td>十六进制数字</td></tr></tbody></table><p>下面简单记录以下通配符</p><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><h3 id="常见通配符"><a href="#常见通配符" class="headerlink" title="常见通配符"></a>常见通配符</h3><table><thead><tr><th><strong>通配符</strong></th><th><strong>含义</strong></th><th><strong>实例</strong></th></tr></thead><tbody><tr><td>*</td><td>匹配 0 或多个字符</td><td>a*b a与b之间可以有任意长度的任意字符, 也可以一个也没有, 如aabcb, axyzb, a012b, ab。</td></tr><tr><td>?</td><td>匹配任意一个字符</td><td>a?b a与b之间必须也只能有一个字符, 可以是任意字符, 如aab, abb, acb, a0b。</td></tr><tr><td>[list]</td><td>匹配 list 中的任意单一字符</td><td>a[xyz]b  a与b之间必须也只能有一个字符, 但只能是 x 或 y 或 z, 如: axb, ayb, azb。</td></tr><tr><td>[!list]或[ ^ list]</td><td>匹配 除list 中的任意单一字符</td><td>a[!0-9]b a与b之间必须也只能有一个字符, 但不能是阿拉伯数字, 如axb, aab, a-b。</td></tr><tr><td>[c1-c2]</td><td>匹配 c1-c2 中的任意单一字符 如：[0-9] [a-z]</td><td>a[0-9]b 0与9之间必须也只能有一个字符 如a0b, a1b… a9b。</td></tr><tr><td>[!c1-c2]或[ ^ c1-c2]</td><td>匹配不在c1-c2的任意字符</td><td>a[!0-9]b 如acb adb</td></tr><tr><td>{string1,string2,…}</td><td>匹配 sring1 或 string2 (或更多)其一字符串</td><td>a{abc,xyz,123}b 列出aabcb,axyzb,a123b</td></tr></tbody></table><h3 id="shell-元字符"><a href="#shell-元字符" class="headerlink" title="shell 元字符"></a>shell 元字符</h3><table><thead><tr><th>字符</th><th>说明</th></tr></thead><tbody><tr><td>IFS</td><td>由 <space> 或 <tab> 或 <enter> 三者之一组成(我们常用 space )</td></tr><tr><td>CR</td><td>由 <enter> 产生</td></tr><tr><td>=</td><td>设定变量</td></tr><tr><td>$</td><td>取变量值或取运算值</td></tr><tr><td>&gt;</td><td>重定向 stdout</td></tr><tr><td>&lt;</td><td>重定向 stdin</td></tr><tr><td>|</td><td>管道符号                 《注意这里与正则表达式的区别》</td></tr><tr><td>&amp;</td><td>重导向 file descriptor ，或将命令置于背景执行</td></tr><tr><td>( )</td><td>将其内的命令置于 nested subshell 执行，或用于运算或命令替换</td></tr><tr><td>{ }</td><td>将其内的命令置于 non-named function 中执行，或用在变量替换的界定范围</td></tr><tr><td>;</td><td>在前一个命令结束时，而忽略其返回值，继续执行下一个命令</td></tr><tr><td>&amp;&amp;</td><td>在前一个命令结束时，若返回值为 true，继续执行下一个命令</td></tr><tr><td>||</td><td>在前一个命令结束时，若返回值为 false，继续执行下一个命令</td></tr><tr><td>!</td><td>运算意义上的非（not）的意思</td></tr><tr><td>#</td><td>注释，常用在脚本中</td></tr><tr><td>\</td><td>转移字符，去除其后紧跟的元字符或通配符的特殊意义</td></tr></tbody></table><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>这里注意shell中单引号与双引号转义时的区别</p><table><thead><tr><th>字符</th><th>说明</th></tr></thead><tbody><tr><td>‘’(单引号)</td><td>硬转义，其内部所有的shell 元字符、通配符都会被关掉。</td></tr><tr><td>“”(双引号)</td><td>软转义，其内部只允许出现特定的shell 元字符：$用于参数替换 `(反单引号，esc键下面)用于命令替换</td></tr><tr><td>(反斜杠)</td><td>又叫转义，去除其后紧跟的元字符或通配符的特殊意义</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>就这样吧，先总结到这里，后续如果有什么需要补充的地方，再来修改吧~  该进行其他知识的学习了~</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通配符和正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在JestonNano上跑yoloV5</title>
      <link href="/2021/09/06/%E5%9C%A8JestonNano%E4%B8%8A%E8%B7%91yoloV5/"/>
      <url>/2021/09/06/%E5%9C%A8JestonNano%E4%B8%8A%E8%B7%91yoloV5/</url>
      
        <content type="html"><![CDATA[<h1 id="在Jeston-Nano上跑yoloV5"><a href="#在Jeston-Nano上跑yoloV5" class="headerlink" title="在Jeston Nano上跑yoloV5"></a>在Jeston Nano上跑yoloV5</h1><p>网上有很多教程都是讲如何在原生NANO上yoloV5，自己手上的Nano小车装有ros操作系统，我想把yolov5跑在ros中，这样就可以订阅摄像头话题了。</p><p>下面记录这两天解决这个问题的过程吧。</p><h2 id="CUDA确认"><a href="#CUDA确认" class="headerlink" title="CUDA确认"></a>CUDA确认</h2><p>jetson-nano的系统镜像中已经自带了cuda、cudnn、TensorRT等组件</p><ul><li><p>检查CUDA 开始时输入如下的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvcc -V  </span><br></pre></td></tr></table></figure></li><li><p>若没有发现cuda， 需要进行如下的配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit  ~/.bashrc</span><br><span class="line"></span><br><span class="line"># 在这个配置文件的最后写入如下的内容。</span><br><span class="line">export CUDA_HOME=/usr/local/cuda-10.2</span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/cuda-10.2/lib64:$LD_LIBRARY_PATH</span><br><span class="line">export PATH=/usr/local/cuda-10.2/bin:$PATH</span><br></pre></td></tr></table></figure></li><li><p>再次验证 nvcc -V  成功</p></li></ul><h2 id="Archiconda-构建python环境"><a href="#Archiconda-构建python环境" class="headerlink" title="Archiconda 构建python环境"></a>Archiconda 构建python环境</h2><p>首先Nano上安装Archiconda，注意这里不是Anaconda，Nano的cpu架构和window的不一样，属于aarch64的架构，所以在构建各个环境的时候需要格外注意这一点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">附上安装包 ：  https://github.com/Archiconda/build-tools/releases</span><br></pre></td></tr></table></figure><p>下载之后就和普通的anaconda一模一样。直接执行安装，会装一个基本的环境。但真正用的时候还是会conda create -n py36 python=3.6 这样创建环境，然后source activate py36 激活并使用。</p><p>安装完conda，可以用conda -V查看是否安装成功，若没成功，可自行百度各种答案。</p><p>下面进行介绍搭建环境顺序步骤</p><ul><li><p>创建python3.6 ，这里切记后续安装的环境都在这里env里进行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n py36 python=3.6</span><br></pre></td></tr></table></figure></li><li><p>安装torch</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 去英伟达官网下载相应的安装包（匹配jetson-nano）</span><br><span class="line"># 这里附上链接地址</span><br><span class="line">https://forums.developer.nvidia.com/t/pytorch-for-jetson-version-1-9-0-now-available/72048</span><br><span class="line"></span><br><span class="line"># 下载后，通过FileZilla传送到Nano中，安装命令如下</span><br><span class="line">pip install torch-1.6.0-cp36-cp36m-linux_aarch64.whl -i http://pypi.mirrors.ustc.edu.cn/simple/</span><br></pre></td></tr></table></figure></li><li><p>安装torchvision</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 不得不说这个玩意卡了我大半天，不然这个工作早就完成了~ 在英伟达官网上找不到与torch1.6匹配的torchvision0.7.0</span><br><span class="line"># 如果换用其它版本的torchvision，就会报以下错误</span><br><span class="line">RuntimeError: No such operator torchvision::nms </span><br><span class="line"></span><br><span class="line">#于是在网上科普答案，最终得解</span><br><span class="line">sudo apt-get install libjpeg-dev zlib1g-dev</span><br><span class="line">git clone --branch v0.7.0 https://gitee.com/zero-one-game/vision torchvision   </span><br><span class="line"># 鉴于国内网络环境，博主提供gitee码云加速下载，直接使用github会因出现网络问题而无法进行</span><br><span class="line">#这行命令是将源代码下载到了用户目录下的torchvision，如果torchvision已经存在，需要删除，如果提示permission denied</span><br><span class="line">#命令行使用sudo su 进入管理员模式，  执行 rm -r torchvision ,或者也可以自行查找更安全的删除方法</span><br><span class="line"></span><br><span class="line">cd torchvision   </span><br><span class="line"></span><br><span class="line">#进入用户目录下的torchvision，执行源代码编译工作，需要一定的时间，大概十多分钟</span><br><span class="line">sudo python3 setup.py install</span><br><span class="line"></span><br><span class="line">cd ../  # attempting to load torchvision from build dir will result in import error</span><br><span class="line">pip3 install &#x27;pillow&lt;7&#x27; # always needed for Python 2.7, not needed torchvision v0.5.0+ with Python 3.6</span><br><span class="line"></span><br><span class="line">-- 这里摘自CSDN博主「零壹博弈」</span><br></pre></td></tr></table></figure></li></ul><p>到这里yoloV5所需要的运行环境就算是做好了</p><h2 id="拉取yoloV5-ROS代码"><a href="#拉取yoloV5-ROS代码" class="headerlink" title="拉取yoloV5 ROS代码"></a>拉取yoloV5 ROS代码</h2><p>拉取地址如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/qianmin/yolov5_ROS</span><br></pre></td></tr></table></figure><p>在运行之前，需要做以下的工作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1:复制这个包(ros_yolo)到你的catkin_ws/src  </span><br><span class="line">2: catkin_make  </span><br><span class="line">3：在final_yolo.py中，你需要改变image_topic到你自己的相机输入主题  </span><br></pre></td></tr></table></figure><p>之后就可以开心的运行yoloV5啦</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1:roscore2:roslaunch robot_vision robot_camera.launch   # 在移动机器人端使用启动摄像头3:conda activate py36                               #进入相应python环境4:rosrun ros_yolo final_yolo.py             # 起飞~</span><br></pre></td></tr></table></figure><h2 id="运行结果示意图"><a href="#运行结果示意图" class="headerlink" title="运行结果示意图"></a>运行结果示意图</h2><p>摄像头运行</p><p><img src="/articleImg/6_article/image1.png">  </p><p>采集并识别处理后的结果</p><p><img src="/articleImg/6_article/image2.png"> </p><h2 id="未完成任务"><a href="#未完成任务" class="headerlink" title="未完成任务"></a>未完成任务</h2><p>1：感觉FPS还是有点低，虽然已经用了nano的自带gpu，我看网上有的说TensorRT还可以加速，后续可以再看一下。</p><p>2：之后打算问一下老师需不需要做一个自己的数据集，去训练参数并识别。</p><p>3：开始理解雷达成像算法</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python安装相关工具包时极慢</title>
      <link href="/2021/09/06/python%E5%AE%89%E8%A3%85%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E5%8C%85%E6%97%B6%E6%9E%81%E6%85%A2/"/>
      <url>/2021/09/06/python%E5%AE%89%E8%A3%85%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E5%8C%85%E6%97%B6%E6%9E%81%E6%85%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="python安装相关工具包时极慢"><a href="#python安装相关工具包时极慢" class="headerlink" title="python安装相关工具包时极慢"></a>python安装相关工具包时极慢</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARNING: Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None))</span><br></pre></td></tr></table></figure><p>当出现这个警告时代表着你安装时使用的源不太行，我当时的电脑已经配置了清华源（修改配置文件可自行百度），在已经配置清华源的情况下，我的下载还是感觉有点慢，感觉耽误很多时间啊，有没有！</p><p>解决方案也很简单，重新指定下载源。如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install 包名  -i http://pypi.mirrors.ustc.edu.cn/simple/</span><br></pre></td></tr></table></figure><p>如果出现报错，在后面再加上信任后缀</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--trusted-host pypi.mirrors.ustc.edu.cn</span><br></pre></td></tr></table></figure><p>这里也一并附上国内其他的下载源（u1s1我感觉中科大的最好用）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">阿里云 http://mirrors.aliyun.com/pypi/simple/</span><br><span class="line"></span><br><span class="line">中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/</span><br><span class="line"></span><br><span class="line">豆瓣(douban) http://pypi.douban.com/simple/</span><br><span class="line"></span><br><span class="line">清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>由于开代理导致python环境搭建失败</title>
      <link href="/2021/09/04/%E7%94%B1%E4%BA%8E%E5%BC%80%E4%BB%A3%E7%90%86%E5%AF%BC%E8%87%B4python%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%A4%B1%E8%B4%A5/"/>
      <url>/2021/09/04/%E7%94%B1%E4%BA%8E%E5%BC%80%E4%BB%A3%E7%90%86%E5%AF%BC%E8%87%B4python%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%A4%B1%E8%B4%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="由于开代理导致python环境搭建失败"><a href="#由于开代理导致python环境搭建失败" class="headerlink" title="由于开代理导致python环境搭建失败"></a>由于开代理导致python环境搭建失败</h1><p>以前用ssr翻墙也没遇到这种情况，现在改用clash（价格便宜10块钱80g）翻墙之后，在搭建环境的时候遇到以下两种情况。</p><ol><li><p>安装或运行时时报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">raise</span> ValueError(<span class="string">&quot;check_hostname requires server_hostname&quot;</span>)</span><br><span class="line">ValueError: check_hostname requires server_hostname</span><br></pre></td></tr></table></figure></li><li><p>安装包时报以下错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collecting package metadata (current_repodata.json): failed</span><br><span class="line"></span><br><span class="line">An unexpected error has occurred. Conda has prepared the above report.</span><br><span class="line"></span><br><span class="line">If submitted, this report will be used by core maintainers to improve</span><br><span class="line">future releases of conda.</span><br><span class="line">Would you like conda to send this report to the core maintainers?</span><br></pre></td></tr></table></figure></li></ol><p>遇到这样的情况，一般是由两种原因造成，并附上解决方案</p><ul><li><p>每次使用 pip install 命令下载插件的时候，下载的都是最新的版本，导致版本较高，可通过一下方式降级</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install 插件名称  -i http://mirrors.aliyun.com/pypi/simple</span><br></pre></td></tr></table></figure></li><li><p>极可能是开了代理，关闭代理之后，就可以运行或则是安装相应的python环境</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我们慢慢开始长大了</title>
      <link href="/2021/08/15/%E6%88%91%E4%BB%AC%E6%85%A2%E6%85%A2%E5%BC%80%E5%A7%8B%E9%95%BF%E5%A4%A7%E4%BA%86/"/>
      <url>/2021/08/15/%E6%88%91%E4%BB%AC%E6%85%A2%E6%85%A2%E5%BC%80%E5%A7%8B%E9%95%BF%E5%A4%A7%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<h1 id="长大"><a href="#长大" class="headerlink" title="长大"></a><strong>长大</strong></h1><p>​        我是1997年出生的一个小毛孩，不，现在不能说是小毛孩了。现在都已经24岁了，今天还穿着本命年该穿的红裤衩。最近一直有一个隐形的声音在我耳旁一直呼唤到“张磊，你已经长大了，父母开始变老了，该你来撑起这个家了”。我思绪万千，不得不承认自己长大了。如果还不想承认的话，那就看看自己身份证上的年龄吧，它是最诚实的。</p><h1 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a><strong>感悟</strong></h1><p>​        我无法避免长大，妹妹今年也都高三了。我想在这个关键的时间段，对自己做出一些改变。我想让自己在一年后找到一份好工作，在两年后顺利毕业。这是我人生中重要的一步。</p><h1 id="怎样做"><a href="#怎样做" class="headerlink" title="怎样做"></a><strong>怎样做</strong></h1>]]></content>
      
      
      <categories>
          
          <category> 个人感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 成长 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客搭建流程</title>
      <link href="/2021/08/14/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/"/>
      <url>/2021/08/14/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo博客搭建流程"><a href="#hexo博客搭建流程" class="headerlink" title="hexo博客搭建流程"></a><strong>hexo博客搭建流程</strong></h1><p>历经三天，我的博客终于达到了能接受的程度，还是挺开心的，因为一直都想写写博客的，一来呢：是为了记录一下自己学习的内容，做好分类。过去的几年自己确实学了不少东西，单片机啊，高数啊，JAVA基础啊，MySQL基础啊，python，数据结构…… 但都因为没有好好的整理与复习，导致自己容易遗忘，实属可惜。趁着暑假这个机会，我铁了心的想搭个博客。二来呢：为了找工作做准备，听说写博客是一个不错的个人名片。</p><p>废话少说，我把这次搭建博客的流程附上（本次安装在window10下操作，linux也差不多）：</p><h1 id="第一大块"><a href="#第一大块" class="headerlink" title="第一大块"></a><strong>第一大块</strong></h1><h2 id="安装hexo模板"><a href="#安装hexo模板" class="headerlink" title="安装hexo模板"></a><a href="https://www.bilibili.com/video/BV1Yb411a7ty">安装hexo模板</a></h2><ol><li><p>安装git工具   <a href="https://git-scm.com/">附上链接</a></p></li><li><p>安装<a href="https://nodejs.org/en/">Nodejs</a></p></li><li><p>创建一个文件夹（blog），在该文件夹下右键，选择git bash.</p><p><img src="/articleImg/second_article/image1.png"></p></li></ol><p>​            4.在git bash中进行如下安装操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">node -v#查看node版本</span><br><span class="line">npm -v#查看npm版本</span><br><span class="line">npm install -g cnpm --registry=http://registry.npm.taobao.org#安装淘宝的cnpm 管理器</span><br><span class="line">cnpm -v#查看cnpm版本</span><br><span class="line">cnpm install -g hexo-cli    #安装hexo框架</span><br><span class="line">hexo -v#查看hexo版本</span><br><span class="line">mkdir blog#创建blog目录</span><br><span class="line">cd blog #进入blog目录</span><br><span class="line">sudo hexo init #生成博客 初始化博客</span><br><span class="line">hexo s#启动本地博客服务</span><br><span class="line">http://localhost:4000/#本地访问地址</span><br><span class="line">hexo n 我的第一篇文章 #创建新的文章 </span><br><span class="line">#返回blog目录</span><br><span class="line">hexo clean #清理</span><br><span class="line">hexo g #生成</span><br><span class="line">#Github创建一个新的仓库 YourGithubName.github.io</span><br><span class="line">cnpm install --save hexo-deployer-git #在blog目录下安装git部署插件</span><br></pre></td></tr></table></figure><h2 id="配置本地hexo"><a href="#配置本地hexo" class="headerlink" title="配置本地hexo"></a>配置本地hexo</h2><p>这里其实改动的地方也不是很多。</p><p>​        1，配置_config.yml </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line"> repo: https://github.com/YourGithubName/YourGithubName.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>​        2，git bash中下载一个自己喜欢的主题，这里我下载的是butterfly</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 下载主题</span><br><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br><span class="line"># 解决报错 。如果沒有 pug 以及 stylus 的渲染器，还需要下载，否则在项目运行时会报错：</span><br><span class="line">cnpm install hexo-renderer-pug hexo-renderer-stylus --save</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        3，若想让自己的主题生效，还得配置博客根目录下的config.yml文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">修改source\categories文件夹下index.md文件为下面的代码</span><br><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2020-03-04 17:18:32</span><br><span class="line">type: categories</span><br><span class="line">layout: categories   #注意此行不添加则点击不会显示分类结果</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h1 id="第二大块"><a href="#第二大块" class="headerlink" title="第二大块"></a><strong>第二大块</strong></h1><h2 id="butterfly的美化"><a href="#butterfly的美化" class="headerlink" title="butterfly的美化"></a>butterfly的美化</h2><p>下面就是butterfly的美化了（主要修改主题文件夹下的config.yml文件），看着别人做的博客，确实很眼馋，自己改了又改，总觉得不满意，有那么一两个钟，我总是和一个样式美化不显示过不去，最后自己用尽对比、排除的方法，都没得到很好的解决。最终发现原来是浏览器没有清理缓存。这里提一句hexo clean 与 hexo c效果不一样,我在这个命令上吃了大亏，不要图省事就输入简写。</p><p>下面推荐几个我使用过的主题美化网站，这里面的博主写的都挺详细的，我在这里也就不重复了。嘻嘻</p><ol><li>首当其冲的肯定是GitHub上该主题的博主，在500多个closed issue中肯定能找到你想要的解决样式问题的答案。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/jerryc127/hexo-theme-butterfly/issues</span><br></pre></td></tr></table></figure><p>​            2.  下面几个网址都是关于美化博客，其他博主写的文章，写的都蛮详细的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 该网址在最下方贴出了很多了美化博客的传递门，可以上车</span><br><span class="line">https://butterfly.js.org/posts/7670b080/</span><br><span class="line"></span><br><span class="line"># 美化主题</span><br><span class="line">https://www.cnblogs.com/MoYu-zc/p/14395965.html</span><br><span class="line"></span><br><span class="line"># 美化主题</span><br><span class="line">https://blog.imzjw.cn/posts/b74f504f/</span><br></pre></td></tr></table></figure><p>​             3.给博客添加一些小功能            </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 添加评论系统</span><br><span class="line">https://blog.csdn.net/qq_35117024/article/details/107248047</span><br><span class="line"></span><br><span class="line">#添加分类雷达、日历图等数据统计</span><br><span class="line">https://guole.fun/posts/18158/</span><br></pre></td></tr></table></figure><p>​             4.这里记录几个比较好看的博客地址，以后有时间，自己在仿照魔改一下，哈哈</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">博主 : 花猪のBlog </span><br><span class="line">https://cnhuazhu.gitee.io/</span><br></pre></td></tr></table></figure><h2 id="第三大块"><a href="#第三大块" class="headerlink" title="第三大块"></a>第三大块</h2><p>这个大块简单记录一些些小问题，以后可能会用到。</p><p>Number one : 首先记录几个命令，每次调试的时候都很实用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 这两个把clean,生成，运行放在一起，省的自己每次要在git bash中输入三次命令。</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s -p 3999</span><br><span class="line"></span><br><span class="line">#这两是创建新的分区时使用</span><br><span class="line">hexo new page tags</span><br><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><p>这里创建之后有两个问题需要注意，不然你的目录，和分类不会显示！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1：修改source\categories文件夹下index.md文件为下面的代码</span><br><span class="line">        ---</span><br><span class="line">        title: 分类</span><br><span class="line">        date: 2020-03-04 17:18:32</span><br><span class="line">        type: categories</span><br><span class="line">        layout: categories   #注意此行不添加则点击不会显示分类结果</span><br><span class="line">        ---</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2：修改编辑scaffolds/post.md</span><br><span class="line">        ---</span><br><span class="line">        title: &#123;&#123; title &#125;&#125;</span><br><span class="line">        date: &#123;&#123; date &#125;&#125;</span><br><span class="line">        tags: &#123;&#123; tags &#125;&#125;</span><br><span class="line">        ---</span><br><span class="line">scaffolds/draft.md    scaffolds/pages.md 同理</span><br></pre></td></tr></table></figure><p>Number two: 当你不想用https进行 git传送时，可以通过下面的链接更改为SSH传送，我个人感觉SSH传送更稳定。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/qq_43768946/article/details/90411154?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control</span><br><span class="line"># 脑大 ，这个url怎么这么长....</span><br></pre></td></tr></table></figure><p>Number two: 当你hexo d传送不成功，可能是你的局域网问题吧，在windows -&gt; 控制面板 -&gt; 网络和Internet -&gt; Internet选项 -&gt; 连接 -&gt; 局域网设置  : 在这里取消代理服务器，更改位自动检测。</p><p>​    我就在自动检测和代理服务器这里切换切换，就上传了，大概就是应为传送时被墙的原因。</p><p>暂时先更新到这里吧~ 后面如果有相关优化，我会持续更新</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是Linux挂载？</title>
      <link href="/2021/08/13/%E4%BB%80%E4%B9%88%E6%98%AFLinux%E6%8C%82%E8%BD%BD%EF%BC%9F/"/>
      <url>/2021/08/13/%E4%BB%80%E4%B9%88%E6%98%AFLinux%E6%8C%82%E8%BD%BD%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是挂载？mount的用处在哪？"><a href="#什么是挂载？mount的用处在哪？" class="headerlink" title="什么是挂载？mount的用处在哪？"></a>什么是挂载？mount的用处在哪？</h1><p>1.提一句Windows下，mount挂载，就是给磁盘分区提供一个盘符（C,D,E,…）。比如插入U盘后系统自动分配给了它I:盘符其实就是挂载，退优盘的时候进行安全弹出，其实就是卸载unmount。</p><p>2.Linux下，不像Windows可以有C,D,E,多个目录，Linux只有一个根目录/。在装系统时，我们分配给linux的所有区都在/下的某个位置，比如/home等等。</p><p>3.提问者插入了新硬盘，分了新磁盘区sdb1。它现在还不属于/。</p><p>4.我们虽然可以在一些图形桌面系统里找到他的位置，浏览管理里面的文件，但在命令行却不知怎么访问它的目录，比如无法使用cd或者ls。也无法在编程时指定一个目录对它操作。</p><p>5.这时提问者使用了 mount /dev/sdb1 <del>/Share/ ，把新硬盘的区sdb1挂载到工作目录的</del>/Share/文件夹下，之后访问这个~/Share/文件夹就相当于访问这个硬盘2的sdb1分区了。对/Share/的任何操作，都相当于对sdb1里文件的操作。</p><p>6.所以Linux下，<span style='color:fuchsia'>mount挂载的作用，就是将一个设备（通常是存储设备）挂接到一个已存在的目录上。访问这个目录就是访问该存储设备。</span></p><p>7.linux将整个计算机的资源都整合成一个大的文件目录。我们要访问存储设备中的文件，必须将文件所在的分区挂载到一个已存在的目录上，然后通过访问这个目录来访问存储设备。<span style='color:fuchsia'>挂载就是把设备放在一个目录下，让系统知道怎么管理这个设备里的文件，了解这个存储设备的可读写特性之类的过程。</span></p><p>8.我们不是有/dev/sdb1 吗，直接对它操作不就行了？这不是它的目录吗？</p><p>9.这不是它的目录。虽然/dev是个目录，但/dev/sdb1不是目录。可以发现ls/dev/sdb1无法执行。/dev/sdb1，是一个类似指针的东西，指向这个分区的原始数据块。mount前，系统并不知道这个数据块哪部分数据代表文件，如何对它们操作。</p><p>10.插入CD，系统其实自动执行了 mount /dev/cdrom /media/cdrom。所以可以直接在/media/cdrom中对CD中的内容进行管理。</p><p>总结来说：挂载就是把设备（如U盘）加入到linux现有目录下，进而可以进行相应的管理。</p><p style='color:fuchsia'>不挂载的话久会造成无法使用cd或者ls等一系列命令。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mount </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/08/12/hello-world/"/>
      <url>/2021/08/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
